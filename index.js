"use strict";
if (typeof Deno === 'undefined') {
  globalThis.addEventListener = () => {};
  globalThis.Deno = {
    env: {
get: () => {}
    },
    args: [],
    errors: {
    PermissionDenied: Error
  },
  build:{
arch: 'x86_64'
}
};
}
globalThis.crypto= require('node:crypto').webcrypto;
const CryptoKey =  globalThis.crypto.CryptoKey;


var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to2, from5, except, desc) => {
  if (from5 && typeof from5 === "object" || typeof from5 === "function") {
    for (let key2 of __getOwnPropNames(from5))
      if (!__hasOwnProp.call(to2, key2) && key2 !== except)
        __defProp(to2, key2, { get: () => from5[key2], enumerable: !(desc = __getOwnPropDesc(from5, key2)) || desc.enumerable });
  }
  return to2;
};
var __toCommonJS = (mod2) => __copyProps(__defProp({}, "__esModule", { value: true }), mod2);

// deno:file:///Users/mcharlton/OtherCode/deno-web-push/src/index.ts
var src_exports = {};
__export(src_exports, {
  WebPushError: () => web_push_error_default,
  encrypt: () => encrypt9,
  generateRequestDetails: () => generateRequestDetails,
  generateVAPIDKeys: () => generateVAPIDKeys,
  getVapidHeaders: () => getVapidHeaders,
  sendNotification: () => sendNotification,
  setGCMAPIKey: () => setGCMAPIKey,
  setVapidDetails: () => setVapidDetails,
  supportedContentEncodings: () => supportedContentEncodings
});
module.exports = __toCommonJS(src_exports);

// deno:https://esm.sh/crypto-browserify?bundle
var crypto_browserify_bundle_exports = {};
__export(crypto_browserify_bundle_exports, {
  Cipher: () => P7,
  Cipheriv: () => C7,
  Decipher: () => L7,
  Decipheriv: () => z7,
  DiffieHellman: () => Z7,
  DiffieHellmanGroup: () => K7,
  Hash: () => q7,
  Hmac: () => R7,
  Sign: () => X7,
  Verify: () => J7,
  constants: () => a9,
  createCipher: () => T7,
  createCipheriv: () => N7,
  createCredentials: () => n9,
  createDecipher: () => O7,
  createDecipheriv: () => U7,
  createDiffieHellman: () => V7,
  createDiffieHellmanGroup: () => j7,
  createECDH: () => $7,
  createHash: () => A7,
  createHmac: () => B7,
  createSign: () => G7,
  createVerify: () => Y7,
  default: () => s9,
  getCiphers: () => H7,
  getDiffieHellman: () => W7,
  getHashes: () => I7,
  listCiphers: () => F7,
  pbkdf2: () => k7,
  pbkdf2Sync: () => D7,
  privateDecrypt: () => r9,
  privateEncrypt: () => e9,
  prng: () => E7,
  pseudoRandomBytes: () => S7,
  publicDecrypt: () => t9,
  publicEncrypt: () => Q7,
  randomBytes: () => x7,
  randomFill: () => i9,
  randomFillSync: () => f9,
  rng: () => M7
});

// deno:https://deno.land/std@0.147.0/_deno_unstable.ts
function addSignalListener(...args) {
  if (typeof Deno.addSignalListener == "function") {
    return Deno.addSignalListener(...args);
  } else {
    throw new TypeError("Requires --unstable");
  }
}
function removeSignalListener(...args) {
  if (typeof Deno.removeSignalListener == "function") {
    return Deno.removeSignalListener(...args);
  } else {
    throw new TypeError("Requires --unstable");
  }
}
function setRaw(...args) {
  if (typeof Deno.setRaw == "function") {
    return Deno.setRaw(...args);
  } else {
    throw new TypeError("Requires --unstable");
  }
}
async function connect(options) {
  return await Deno.connect(options);
}
function listen(options) {
  return Deno.listen(options);
}
function listenDatagram(options) {
  return Deno.listenDatagram(options);
}
function ListenerRef(listener, ...args) {
  if (typeof listener.ref == "function") {
    return listener.ref(...args);
  } else {
    throw new TypeError("Requires --unstable");
  }
}
function ListenerUnref(listener, ...args) {
  if (typeof listener.unref == "function") {
    return listener.unref(...args);
  } else {
    throw new TypeError("Requires --unstable");
  }
}

// deno:https://deno.land/std@0.147.0/async/deferred.ts
function deferred() {
  let methods2;
  let state = "pending";
  const promise = new Promise((resolve7, reject) => {
    methods2 = {
      async resolve(value) {
        await value;
        state = "fulfilled";
        resolve7(value);
      },
      reject(reason) {
        state = "rejected";
        reject(reason);
      }
    };
  });
  Object.defineProperty(promise, "state", { get: () => state });
  return Object.assign(promise, methods2);
}

// deno:https://deno.land/std@0.147.0/async/delay.ts
function delay(ms, options = {}) {
  const { signal } = options;
  if (signal?.aborted) {
    return Promise.reject(new DOMException("Delay was aborted.", "AbortError"));
  }
  return new Promise((resolve7, reject) => {
    const abort = () => {
      clearTimeout(i);
      reject(new DOMException("Delay was aborted.", "AbortError"));
    };
    const done = () => {
      signal?.removeEventListener("abort", abort);
      resolve7();
    };
    const i = setTimeout(done, ms);
    signal?.addEventListener("abort", abort, { once: true });
  });
}

// deno:https://deno.land/std@0.147.0/async/mux_async_iterator.ts
var MuxAsyncIterator = class {
  #iteratorCount = 0;
  #yields = [];
  #throws = [];
  #signal = deferred();
  add(iterable) {
    ++this.#iteratorCount;
    this.#callIteratorNext(iterable[Symbol.asyncIterator]());
  }
  async #callIteratorNext(iterator) {
    try {
      const { value, done } = await iterator.next();
      if (done) {
        --this.#iteratorCount;
      } else {
        this.#yields.push({ iterator, value });
      }
    } catch (e) {
      this.#throws.push(e);
    }
    this.#signal.resolve();
  }
  async *iterate() {
    while (this.#iteratorCount > 0) {
      await this.#signal;
      for (let i = 0; i < this.#yields.length; i++) {
        const { iterator, value } = this.#yields[i];
        yield value;
        this.#callIteratorNext(iterator);
      }
      if (this.#throws.length) {
        for (const e of this.#throws) {
          throw e;
        }
        this.#throws.length = 0;
      }
      this.#yields.length = 0;
      this.#signal = deferred();
    }
  }
  [Symbol.asyncIterator]() {
    return this.iterate();
  }
};

// deno:https://deno.land/std@0.147.0/fmt/colors.ts
var { Deno: Deno2 } = globalThis;
var noColor = typeof Deno2?.noColor === "boolean" ? Deno2.noColor : true;
var enabled = !noColor;
function code(open, close) {
  return {
    open: `\x1B[${open.join(";")}m`,
    close: `\x1B[${close}m`,
    regexp: new RegExp(`\\x1b\\[${close}m`, "g")
  };
}
function run(str, code2) {
  return enabled ? `${code2.open}${str.replace(code2.regexp, code2.open)}${code2.close}` : str;
}
function bold(str) {
  return run(str, code([1], 22));
}
function red(str) {
  return run(str, code([31], 39));
}
function green(str) {
  return run(str, code([32], 39));
}
function white(str) {
  return run(str, code([37], 39));
}
function gray(str) {
  return brightBlack(str);
}
function brightBlack(str) {
  return run(str, code([90], 39));
}
function bgRed(str) {
  return run(str, code([41], 49));
}
function bgGreen(str) {
  return run(str, code([42], 49));
}
var ANSI_PATTERN = new RegExp([
  "[\\u001B\\u009B][[\\]()#;?]*(?:(?:(?:(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]+)*|[a-zA-Z\\d]+(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]*)*)?\\u0007)",
  "(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PR-TZcf-nq-uy=><~]))"
].join("|"), "g");

// deno:https://deno.land/std@0.147.0/testing/_diff.ts
var REMOVED = 1;
var COMMON = 2;
var ADDED = 3;
function createCommon(A4, B3, reverse2) {
  const common2 = [];
  if (A4.length === 0 || B3.length === 0)
    return [];
  for (let i = 0; i < Math.min(A4.length, B3.length); i += 1) {
    if (A4[reverse2 ? A4.length - i - 1 : i] === B3[reverse2 ? B3.length - i - 1 : i]) {
      common2.push(A4[reverse2 ? A4.length - i - 1 : i]);
    } else {
      return common2;
    }
  }
  return common2;
}
function diff(A4, B3) {
  const prefixCommon = createCommon(A4, B3);
  const suffixCommon = createCommon(A4.slice(prefixCommon.length), B3.slice(prefixCommon.length), true).reverse();
  A4 = suffixCommon.length ? A4.slice(prefixCommon.length, -suffixCommon.length) : A4.slice(prefixCommon.length);
  B3 = suffixCommon.length ? B3.slice(prefixCommon.length, -suffixCommon.length) : B3.slice(prefixCommon.length);
  const swapped = B3.length > A4.length;
  [A4, B3] = swapped ? [B3, A4] : [A4, B3];
  const M4 = A4.length;
  const N4 = B3.length;
  if (!M4 && !N4 && !suffixCommon.length && !prefixCommon.length)
    return [];
  if (!N4) {
    return [
      ...prefixCommon.map((c5) => ({ type: "common" /* common */, value: c5 })),
      ...A4.map((a) => ({
        type: swapped ? "added" /* added */ : "removed" /* removed */,
        value: a
      })),
      ...suffixCommon.map((c5) => ({ type: "common" /* common */, value: c5 }))
    ];
  }
  const offset = N4;
  const delta = M4 - N4;
  const size = M4 + N4 + 1;
  const fp = Array.from({ length: size }, () => ({ y: -1, id: -1 }));
  const routes = new Uint32Array((M4 * N4 + size + 1) * 2);
  const diffTypesPtrOffset = routes.length / 2;
  let ptr = 0;
  let p3 = -1;
  function backTrace(A5, B4, current, swapped2) {
    const M5 = A5.length;
    const N5 = B4.length;
    const result = [];
    let a = M5 - 1;
    let b2 = N5 - 1;
    let j2 = routes[current.id];
    let type = routes[current.id + diffTypesPtrOffset];
    while (true) {
      if (!j2 && !type)
        break;
      const prev = j2;
      if (type === REMOVED) {
        result.unshift({
          type: swapped2 ? "removed" /* removed */ : "added" /* added */,
          value: B4[b2]
        });
        b2 -= 1;
      } else if (type === ADDED) {
        result.unshift({
          type: swapped2 ? "added" /* added */ : "removed" /* removed */,
          value: A5[a]
        });
        a -= 1;
      } else {
        result.unshift({ type: "common" /* common */, value: A5[a] });
        a -= 1;
        b2 -= 1;
      }
      j2 = routes[prev];
      type = routes[prev + diffTypesPtrOffset];
    }
    return result;
  }
  function createFP(slide, down, k6, M5) {
    if (slide && slide.y === -1 && down && down.y === -1) {
      return { y: 0, id: 0 };
    }
    if (down && down.y === -1 || k6 === M5 || (slide && slide.y) > (down && down.y) + 1) {
      const prev = slide.id;
      ptr++;
      routes[ptr] = prev;
      routes[ptr + diffTypesPtrOffset] = ADDED;
      return { y: slide.y, id: ptr };
    } else {
      const prev = down.id;
      ptr++;
      routes[ptr] = prev;
      routes[ptr + diffTypesPtrOffset] = REMOVED;
      return { y: down.y + 1, id: ptr };
    }
  }
  function snake(k6, slide, down, _offset, A5, B4) {
    const M5 = A5.length;
    const N5 = B4.length;
    if (k6 < -N5 || M5 < k6)
      return { y: -1, id: -1 };
    const fp2 = createFP(slide, down, k6, M5);
    while (fp2.y + k6 < M5 && fp2.y < N5 && A5[fp2.y + k6] === B4[fp2.y]) {
      const prev = fp2.id;
      ptr++;
      fp2.id = ptr;
      fp2.y += 1;
      routes[ptr] = prev;
      routes[ptr + diffTypesPtrOffset] = COMMON;
    }
    return fp2;
  }
  while (fp[delta + offset].y < N4) {
    p3 = p3 + 1;
    for (let k6 = -p3; k6 < delta; ++k6) {
      fp[k6 + offset] = snake(k6, fp[k6 - 1 + offset], fp[k6 + 1 + offset], offset, A4, B3);
    }
    for (let k6 = delta + p3; k6 > delta; --k6) {
      fp[k6 + offset] = snake(k6, fp[k6 - 1 + offset], fp[k6 + 1 + offset], offset, A4, B3);
    }
    fp[delta + offset] = snake(delta, fp[delta - 1 + offset], fp[delta + 1 + offset], offset, A4, B3);
  }
  return [
    ...prefixCommon.map((c5) => ({ type: "common" /* common */, value: c5 })),
    ...backTrace(A4, B3, fp[delta + offset], swapped),
    ...suffixCommon.map((c5) => ({ type: "common" /* common */, value: c5 }))
  ];
}
function diffstr(A4, B3) {
  function unescape2(string) {
    return string.replaceAll("\b", "\\b").replaceAll("\f", "\\f").replaceAll("	", "\\t").replaceAll("\v", "\\v").replaceAll(/\r\n|\r|\n/g, (str) => str === "\r" ? "\\r" : str === "\n" ? "\\n\n" : "\\r\\n\r\n");
  }
  function tokenize(string, { wordDiff = false } = {}) {
    if (wordDiff) {
      const tokens = string.split(/([^\S\r\n]+|[()[\]{}'"\r\n]|\b)/);
      const words = /^[a-zA-Z\u{C0}-\u{FF}\u{D8}-\u{F6}\u{F8}-\u{2C6}\u{2C8}-\u{2D7}\u{2DE}-\u{2FF}\u{1E00}-\u{1EFF}]+$/u;
      for (let i = 0; i < tokens.length - 1; i++) {
        if (!tokens[i + 1] && tokens[i + 2] && words.test(tokens[i]) && words.test(tokens[i + 2])) {
          tokens[i] += tokens[i + 2];
          tokens.splice(i + 1, 2);
          i--;
        }
      }
      return tokens.filter((token) => token);
    } else {
      const tokens = [], lines = string.split(/(\n|\r\n)/);
      if (!lines[lines.length - 1]) {
        lines.pop();
      }
      for (let i = 0; i < lines.length; i++) {
        if (i % 2) {
          tokens[tokens.length - 1] += lines[i];
        } else {
          tokens.push(lines[i]);
        }
      }
      return tokens;
    }
  }
  function createDetails(line, tokens) {
    return tokens.filter(({ type }) => type === line.type || type === "common" /* common */).map((result, i, t) => {
      if (result.type === "common" /* common */ && t[i - 1] && t[i - 1]?.type === t[i + 1]?.type && /\s+/.test(result.value)) {
        result.type = t[i - 1].type;
      }
      return result;
    });
  }
  const diffResult = diff(tokenize(`${unescape2(A4)}
`), tokenize(`${unescape2(B3)}
`));
  const added = [], removed = [];
  for (const result of diffResult) {
    if (result.type === "added" /* added */) {
      added.push(result);
    }
    if (result.type === "removed" /* removed */) {
      removed.push(result);
    }
  }
  const aLines = added.length < removed.length ? added : removed;
  const bLines = aLines === removed ? added : removed;
  for (const a of aLines) {
    let tokens = [], b2;
    while (bLines.length) {
      b2 = bLines.shift();
      tokens = diff(tokenize(a.value, { wordDiff: true }), tokenize(b2?.value ?? "", { wordDiff: true }));
      if (tokens.some(({ type, value }) => type === "common" /* common */ && value.trim().length)) {
        break;
      }
    }
    a.details = createDetails(a, tokens);
    if (b2) {
      b2.details = createDetails(b2, tokens);
    }
  }
  return diffResult;
}
function createColor(diffType, { background = false } = {}) {
  switch (diffType) {
    case "added" /* added */:
      return (s) => background ? bgGreen(white(s)) : green(bold(s));
    case "removed" /* removed */:
      return (s) => background ? bgRed(white(s)) : red(bold(s));
    default:
      return white;
  }
}
function createSign(diffType) {
  switch (diffType) {
    case "added" /* added */:
      return "+   ";
    case "removed" /* removed */:
      return "-   ";
    default:
      return "    ";
  }
}
function buildMessage(diffResult, { stringDiff = false } = {}) {
  const messages = [], diffMessages = [];
  messages.push("");
  messages.push("");
  messages.push(`    ${gray(bold("[Diff]"))} ${red(bold("Actual"))} / ${green(bold("Expected"))}`);
  messages.push("");
  messages.push("");
  diffResult.forEach((result) => {
    const c5 = createColor(result.type);
    const line = result.details?.map((detail) => detail.type !== "common" /* common */ ? createColor(detail.type, { background: true })(detail.value) : detail.value).join("") ?? result.value;
    diffMessages.push(c5(`${createSign(result.type)}${line}`));
  });
  messages.push(...stringDiff ? [diffMessages.join("")] : diffMessages);
  messages.push("");
  return messages;
}

// deno:https://deno.land/std@0.147.0/testing/_format.ts
function format(v2) {
  const { Deno: Deno4 } = globalThis;
  return typeof Deno4?.inspect === "function" ? Deno4.inspect(v2, {
    depth: Infinity,
    sorted: true,
    trailingComma: true,
    compact: false,
    iterableLimit: Infinity
  }) : `"${String(v2).replace(/(?=["\\])/g, "\\")}"`;
}

// deno:https://deno.land/std@0.147.0/testing/asserts.ts
var CAN_NOT_DISPLAY = "[Cannot display]";
var AssertionError = class extends Error {
  constructor(message) {
    super(message);
    this.name = "AssertionError";
  }
};
function isKeyedCollection(x) {
  return [Symbol.iterator, "size"].every((k6) => k6 in x);
}
function equal(c5, d4) {
  const seen = /* @__PURE__ */ new Map();
  return function compare9(a, b2) {
    if (a && b2 && (a instanceof RegExp && b2 instanceof RegExp || a instanceof URL && b2 instanceof URL)) {
      return String(a) === String(b2);
    }
    if (a instanceof Date && b2 instanceof Date) {
      const aTime = a.getTime();
      const bTime = b2.getTime();
      if (Number.isNaN(aTime) && Number.isNaN(bTime)) {
        return true;
      }
      return aTime === bTime;
    }
    if (typeof a === "number" && typeof b2 === "number") {
      return Number.isNaN(a) && Number.isNaN(b2) || a === b2;
    }
    if (Object.is(a, b2)) {
      return true;
    }
    if (a && typeof a === "object" && b2 && typeof b2 === "object") {
      if (a && b2 && !constructorsEqual(a, b2)) {
        return false;
      }
      if (a instanceof WeakMap || b2 instanceof WeakMap) {
        if (!(a instanceof WeakMap && b2 instanceof WeakMap))
          return false;
        throw new TypeError("cannot compare WeakMap instances");
      }
      if (a instanceof WeakSet || b2 instanceof WeakSet) {
        if (!(a instanceof WeakSet && b2 instanceof WeakSet))
          return false;
        throw new TypeError("cannot compare WeakSet instances");
      }
      if (seen.get(a) === b2) {
        return true;
      }
      if (Object.keys(a || {}).length !== Object.keys(b2 || {}).length) {
        return false;
      }
      seen.set(a, b2);
      if (isKeyedCollection(a) && isKeyedCollection(b2)) {
        if (a.size !== b2.size) {
          return false;
        }
        let unmatchedEntries = a.size;
        for (const [aKey, aValue] of a.entries()) {
          for (const [bKey, bValue] of b2.entries()) {
            if (aKey === aValue && bKey === bValue && compare9(aKey, bKey) || compare9(aKey, bKey) && compare9(aValue, bValue)) {
              unmatchedEntries--;
              break;
            }
          }
        }
        return unmatchedEntries === 0;
      }
      const merged = { ...a, ...b2 };
      for (const key2 of [
        ...Object.getOwnPropertyNames(merged),
        ...Object.getOwnPropertySymbols(merged)
      ]) {
        if (!compare9(a && a[key2], b2 && b2[key2])) {
          return false;
        }
        if (key2 in a && !(key2 in b2) || key2 in b2 && !(key2 in a)) {
          return false;
        }
      }
      if (a instanceof WeakRef || b2 instanceof WeakRef) {
        if (!(a instanceof WeakRef && b2 instanceof WeakRef))
          return false;
        return compare9(a.deref(), b2.deref());
      }
      return true;
    }
    return false;
  }(c5, d4);
}
function constructorsEqual(a, b2) {
  return a.constructor === b2.constructor || a.constructor === Object && !b2.constructor || !a.constructor && b2.constructor === Object;
}
function assert(expr, msg = "") {
  if (!expr) {
    throw new AssertionError(msg);
  }
}
function assertEquals(actual, expected, msg) {
  if (equal(actual, expected)) {
    return;
  }
  let message = "";
  const actualString = format(actual);
  const expectedString = format(expected);
  try {
    const stringDiff = typeof actual === "string" && typeof expected === "string";
    const diffResult = stringDiff ? diffstr(actual, expected) : diff(actualString.split("\n"), expectedString.split("\n"));
    const diffMsg = buildMessage(diffResult, { stringDiff }).join("\n");
    message = `Values are not equal:
${diffMsg}`;
  } catch {
    message = `
${red(CAN_NOT_DISPLAY)} + 

`;
  }
  if (msg) {
    message = msg;
  }
  throw new AssertionError(message);
}
function unreachable() {
  throw new AssertionError("unreachable");
}

// deno:https://deno.land/std@0.147.0/_util/assert.ts
var DenoStdInternalError = class extends Error {
  constructor(message) {
    super(message);
    this.name = "DenoStdInternalError";
  }
};
function assert2(expr, msg = "") {
  if (!expr) {
    throw new DenoStdInternalError(msg);
  }
}

// deno:https://deno.land/std@0.147.0/bytes/mod.ts
function indexOfNeedle(source, needle, start = 0) {
  if (start >= source.length) {
    return -1;
  }
  if (start < 0) {
    start = Math.max(0, source.length + start);
  }
  const s = needle[0];
  for (let i = start; i < source.length; i++) {
    if (source[i] !== s)
      continue;
    const pin = i;
    let matched = 1;
    let j2 = i;
    while (matched < needle.length) {
      j2++;
      if (source[j2] !== needle[j2 - pin]) {
        break;
      }
      matched++;
    }
    if (matched === needle.length) {
      return pin;
    }
  }
  return -1;
}

// deno:https://deno.land/std@0.147.0/io/buffer.ts
var MIN_READ = 32 * 1024;
var MAX_SIZE = 2 ** 32 - 2;
var CR = "\r".charCodeAt(0);
var LF = "\n".charCodeAt(0);

// deno:https://deno.land/std@0.147.0/streams/conversion.ts
var DEFAULT_BUFFER_SIZE = 32 * 1024;
async function writeAll(w2, arr) {
  let nwritten = 0;
  while (nwritten < arr.length) {
    nwritten += await w2.write(arr.subarray(nwritten));
  }
}

// deno:https://deno.land/std@0.147.0/node/_utils.ts
function notImplemented(msg) {
  const message = msg ? `Not implemented: ${msg}` : "Not implemented";
  throw new Error(message);
}
function warnNotImplemented(msg) {
  const message = msg ? `Not implemented: ${msg}` : "Not implemented";
  console.warn(message);
}
var _TextDecoder = TextDecoder;
var _TextEncoder = TextEncoder;
function spliceOne(list, index) {
  for (; index + 1 < list.length; index++)
    list[index] = list[index + 1];
  list.pop();
}
function normalizeEncoding(enc) {
  if (enc == null || enc === "utf8" || enc === "utf-8")
    return "utf8";
  return slowCases(enc);
}
function slowCases(enc) {
  switch (enc.length) {
    case 4:
      if (enc === "UTF8")
        return "utf8";
      if (enc === "ucs2" || enc === "UCS2")
        return "utf16le";
      enc = `${enc}`.toLowerCase();
      if (enc === "utf8")
        return "utf8";
      if (enc === "ucs2")
        return "utf16le";
      break;
    case 3:
      if (enc === "hex" || enc === "HEX" || `${enc}`.toLowerCase() === "hex") {
        return "hex";
      }
      break;
    case 5:
      if (enc === "ascii")
        return "ascii";
      if (enc === "ucs-2")
        return "utf16le";
      if (enc === "UTF-8")
        return "utf8";
      if (enc === "ASCII")
        return "ascii";
      if (enc === "UCS-2")
        return "utf16le";
      enc = `${enc}`.toLowerCase();
      if (enc === "utf-8")
        return "utf8";
      if (enc === "ascii")
        return "ascii";
      if (enc === "ucs-2")
        return "utf16le";
      break;
    case 6:
      if (enc === "base64")
        return "base64";
      if (enc === "latin1" || enc === "binary")
        return "latin1";
      if (enc === "BASE64")
        return "base64";
      if (enc === "LATIN1" || enc === "BINARY")
        return "latin1";
      enc = `${enc}`.toLowerCase();
      if (enc === "base64")
        return "base64";
      if (enc === "latin1" || enc === "binary")
        return "latin1";
      break;
    case 7:
      if (enc === "utf16le" || enc === "UTF16LE" || `${enc}`.toLowerCase() === "utf16le") {
        return "utf16le";
      }
      break;
    case 8:
      if (enc === "utf-16le" || enc === "UTF-16LE" || `${enc}`.toLowerCase() === "utf-16le") {
        return "utf16le";
      }
      break;
    default:
      if (enc === "")
        return "utf8";
  }
}

// deno:https://deno.land/std@0.147.0/node/internal/util/types.ts
var types_exports2 = {};
__export(types_exports2, {
  isAnyArrayBuffer: () => isAnyArrayBuffer2,
  isArgumentsObject: () => isArgumentsObject2,
  isArrayBuffer: () => isArrayBuffer2,
  isArrayBufferView: () => isArrayBufferView,
  isAsyncFunction: () => isAsyncFunction2,
  isBigInt64Array: () => isBigInt64Array,
  isBigIntObject: () => isBigIntObject2,
  isBigUint64Array: () => isBigUint64Array,
  isBooleanObject: () => isBooleanObject2,
  isBoxedPrimitive: () => isBoxedPrimitive2,
  isCryptoKey: () => isCryptoKey,
  isDataView: () => isDataView2,
  isDate: () => isDate2,
  isFloat32Array: () => isFloat32Array,
  isFloat64Array: () => isFloat64Array,
  isGeneratorFunction: () => isGeneratorFunction2,
  isGeneratorObject: () => isGeneratorObject2,
  isInt16Array: () => isInt16Array,
  isInt32Array: () => isInt32Array,
  isInt8Array: () => isInt8Array,
  isKeyObject: () => isKeyObject,
  isMap: () => isMap2,
  isMapIterator: () => isMapIterator2,
  isModuleNamespaceObject: () => isModuleNamespaceObject2,
  isNativeError: () => isNativeError2,
  isNumberObject: () => isNumberObject2,
  isPromise: () => isPromise2,
  isRegExp: () => isRegExp2,
  isSet: () => isSet2,
  isSetIterator: () => isSetIterator2,
  isSharedArrayBuffer: () => isSharedArrayBuffer2,
  isStringObject: () => isStringObject2,
  isSymbolObject: () => isSymbolObject2,
  isTypedArray: () => isTypedArray,
  isUint16Array: () => isUint16Array,
  isUint32Array: () => isUint32Array,
  isUint8Array: () => isUint8Array,
  isUint8ClampedArray: () => isUint8ClampedArray,
  isWeakMap: () => isWeakMap2,
  isWeakSet: () => isWeakSet2
});

// deno:https://deno.land/std@0.147.0/node/internal_binding/types.ts
var types_exports = {};
__export(types_exports, {
  default: () => types_default,
  isAnyArrayBuffer: () => isAnyArrayBuffer,
  isArgumentsObject: () => isArgumentsObject,
  isArrayBuffer: () => isArrayBuffer,
  isAsyncFunction: () => isAsyncFunction,
  isBigIntObject: () => isBigIntObject,
  isBooleanObject: () => isBooleanObject,
  isBoxedPrimitive: () => isBoxedPrimitive,
  isDataView: () => isDataView,
  isDate: () => isDate,
  isGeneratorFunction: () => isGeneratorFunction,
  isGeneratorObject: () => isGeneratorObject,
  isMap: () => isMap,
  isMapIterator: () => isMapIterator,
  isModuleNamespaceObject: () => isModuleNamespaceObject,
  isNativeError: () => isNativeError,
  isNumberObject: () => isNumberObject,
  isPromise: () => isPromise,
  isRegExp: () => isRegExp,
  isSet: () => isSet,
  isSetIterator: () => isSetIterator,
  isSharedArrayBuffer: () => isSharedArrayBuffer,
  isStringObject: () => isStringObject,
  isSymbolObject: () => isSymbolObject,
  isWeakMap: () => isWeakMap,
  isWeakSet: () => isWeakSet
});
var _toString = Object.prototype.toString;
var _isObjectLike = (value) => value !== null && typeof value === "object";
var _isFunctionLike = (value) => value !== null && typeof value === "function";
function isAnyArrayBuffer(value) {
  return _isObjectLike(value) && (_toString.call(value) === "[object ArrayBuffer]" || _toString.call(value) === "[object SharedArrayBuffer]");
}
function isArgumentsObject(value) {
  return _isObjectLike(value) && _toString.call(value) === "[object Arguments]";
}
function isArrayBuffer(value) {
  return _isObjectLike(value) && _toString.call(value) === "[object ArrayBuffer]";
}
function isAsyncFunction(value) {
  return _isFunctionLike(value) && _toString.call(value) === "[object AsyncFunction]";
}
function isBooleanObject(value) {
  return _isObjectLike(value) && _toString.call(value) === "[object Boolean]";
}
function isBoxedPrimitive(value) {
  return isBooleanObject(value) || isStringObject(value) || isNumberObject(value) || isSymbolObject(value) || isBigIntObject(value);
}
function isDataView(value) {
  return _isObjectLike(value) && _toString.call(value) === "[object DataView]";
}
function isDate(value) {
  return _isObjectLike(value) && _toString.call(value) === "[object Date]";
}
function isGeneratorFunction(value) {
  return _isFunctionLike(value) && _toString.call(value) === "[object GeneratorFunction]";
}
function isGeneratorObject(value) {
  return _isObjectLike(value) && _toString.call(value) === "[object Generator]";
}
function isMap(value) {
  return _isObjectLike(value) && _toString.call(value) === "[object Map]";
}
function isMapIterator(value) {
  return _isObjectLike(value) && _toString.call(value) === "[object Map Iterator]";
}
function isModuleNamespaceObject(value) {
  return _isObjectLike(value) && _toString.call(value) === "[object Module]";
}
function isNativeError(value) {
  return _isObjectLike(value) && _toString.call(value) === "[object Error]";
}
function isNumberObject(value) {
  return _isObjectLike(value) && _toString.call(value) === "[object Number]";
}
function isBigIntObject(value) {
  return _isObjectLike(value) && _toString.call(value) === "[object BigInt]";
}
function isPromise(value) {
  return _isObjectLike(value) && _toString.call(value) === "[object Promise]";
}
function isRegExp(value) {
  return _isObjectLike(value) && _toString.call(value) === "[object RegExp]";
}
function isSet(value) {
  return _isObjectLike(value) && _toString.call(value) === "[object Set]";
}
function isSetIterator(value) {
  return _isObjectLike(value) && _toString.call(value) === "[object Set Iterator]";
}
function isSharedArrayBuffer(value) {
  return _isObjectLike(value) && _toString.call(value) === "[object SharedArrayBuffer]";
}
function isStringObject(value) {
  return _isObjectLike(value) && _toString.call(value) === "[object String]";
}
function isSymbolObject(value) {
  return _isObjectLike(value) && _toString.call(value) === "[object Symbol]";
}
function isWeakMap(value) {
  return _isObjectLike(value) && _toString.call(value) === "[object WeakMap]";
}
function isWeakSet(value) {
  return _isObjectLike(value) && _toString.call(value) === "[object WeakSet]";
}
var types_default = {
  isAsyncFunction,
  isGeneratorFunction,
  isAnyArrayBuffer,
  isArrayBuffer,
  isArgumentsObject,
  isBoxedPrimitive,
  isDataView,
  isMap,
  isMapIterator,
  isModuleNamespaceObject,
  isNativeError,
  isPromise,
  isSet,
  isSetIterator,
  isWeakMap,
  isWeakSet,
  isRegExp,
  isDate,
  isStringObject,
  isNumberObject,
  isBooleanObject,
  isBigIntObject
};

// deno:https://deno.land/std@0.147.0/node/internal/crypto/constants.ts
var kHandle = Symbol("kHandle");
var kKeyObject = Symbol("kKeyObject");

// deno:https://deno.land/std@0.147.0/node/internal/crypto/_keys.ts
var kKeyType = Symbol("kKeyType");
function isKeyObject(obj2) {
  return obj2 != null && obj2[kKeyType] !== void 0;
}
function isCryptoKey(obj2) {
  return obj2 != null && obj2[kKeyObject] !== void 0;
}

// deno:https://deno.land/std@0.147.0/node/internal/util/types.ts
var _toString2 = Object.prototype.toString;
var _isObjectLike2 = (value) => value !== null && typeof value === "object";
function isArrayBufferView(value) {
  return ArrayBuffer.isView(value);
}
function isBigInt64Array(value) {
  return _isObjectLike2(value) && _toString2.call(value) === "[object BigInt64Array]";
}
function isBigUint64Array(value) {
  return _isObjectLike2(value) && _toString2.call(value) === "[object BigUint64Array]";
}
function isFloat32Array(value) {
  return _isObjectLike2(value) && _toString2.call(value) === "[object Float32Array]";
}
function isFloat64Array(value) {
  return _isObjectLike2(value) && _toString2.call(value) === "[object Float64Array]";
}
function isInt8Array(value) {
  return _isObjectLike2(value) && _toString2.call(value) === "[object Int8Array]";
}
function isInt16Array(value) {
  return _isObjectLike2(value) && _toString2.call(value) === "[object Int16Array]";
}
function isInt32Array(value) {
  return _isObjectLike2(value) && _toString2.call(value) === "[object Int32Array]";
}
function isTypedArray(value) {
  const reTypedTag = /^\[object (?:Float(?:32|64)|(?:Int|Uint)(?:8|16|32)|Uint8Clamped)Array\]$/;
  return _isObjectLike2(value) && reTypedTag.test(_toString2.call(value));
}
function isUint8Array(value) {
  return _isObjectLike2(value) && _toString2.call(value) === "[object Uint8Array]";
}
function isUint8ClampedArray(value) {
  return _isObjectLike2(value) && _toString2.call(value) === "[object Uint8ClampedArray]";
}
function isUint16Array(value) {
  return _isObjectLike2(value) && _toString2.call(value) === "[object Uint16Array]";
}
function isUint32Array(value) {
  return _isObjectLike2(value) && _toString2.call(value) === "[object Uint32Array]";
}
var {
  isDate: isDate2,
  isArgumentsObject: isArgumentsObject2,
  isBigIntObject: isBigIntObject2,
  isBooleanObject: isBooleanObject2,
  isNumberObject: isNumberObject2,
  isStringObject: isStringObject2,
  isSymbolObject: isSymbolObject2,
  isNativeError: isNativeError2,
  isRegExp: isRegExp2,
  isAsyncFunction: isAsyncFunction2,
  isGeneratorFunction: isGeneratorFunction2,
  isGeneratorObject: isGeneratorObject2,
  isPromise: isPromise2,
  isMap: isMap2,
  isSet: isSet2,
  isMapIterator: isMapIterator2,
  isSetIterator: isSetIterator2,
  isWeakMap: isWeakMap2,
  isWeakSet: isWeakSet2,
  isArrayBuffer: isArrayBuffer2,
  isDataView: isDataView2,
  isSharedArrayBuffer: isSharedArrayBuffer2,
  isModuleNamespaceObject: isModuleNamespaceObject2,
  isAnyArrayBuffer: isAnyArrayBuffer2,
  isBoxedPrimitive: isBoxedPrimitive2
} = types_exports;

// deno:https://deno.land/std@0.147.0/node/internal/error_codes.ts
var codes = {};

// deno:https://deno.land/std@0.147.0/node/internal/hide_stack_frames.ts
function hideStackFrames(fn) {
  const hidden = "__node_internal_" + fn.name;
  Object.defineProperty(fn, "name", { value: hidden });
  return fn;
}

// deno:https://deno.land/std@0.147.0/node/internal/normalize_encoding.mjs
function normalizeEncoding2(enc) {
  if (enc == null || enc === "utf8" || enc === "utf-8")
    return "utf8";
  return slowCases2(enc);
}
function slowCases2(enc) {
  switch (enc.length) {
    case 4:
      if (enc === "UTF8")
        return "utf8";
      if (enc === "ucs2" || enc === "UCS2")
        return "utf16le";
      enc = `${enc}`.toLowerCase();
      if (enc === "utf8")
        return "utf8";
      if (enc === "ucs2")
        return "utf16le";
      break;
    case 3:
      if (enc === "hex" || enc === "HEX" || `${enc}`.toLowerCase() === "hex") {
        return "hex";
      }
      break;
    case 5:
      if (enc === "ascii")
        return "ascii";
      if (enc === "ucs-2")
        return "utf16le";
      if (enc === "UTF-8")
        return "utf8";
      if (enc === "ASCII")
        return "ascii";
      if (enc === "UCS-2")
        return "utf16le";
      enc = `${enc}`.toLowerCase();
      if (enc === "utf-8")
        return "utf8";
      if (enc === "ascii")
        return "ascii";
      if (enc === "ucs-2")
        return "utf16le";
      break;
    case 6:
      if (enc === "base64")
        return "base64";
      if (enc === "latin1" || enc === "binary")
        return "latin1";
      if (enc === "BASE64")
        return "base64";
      if (enc === "LATIN1" || enc === "BINARY")
        return "latin1";
      enc = `${enc}`.toLowerCase();
      if (enc === "base64")
        return "base64";
      if (enc === "latin1" || enc === "binary")
        return "latin1";
      break;
    case 7:
      if (enc === "utf16le" || enc === "UTF16LE" || `${enc}`.toLowerCase() === "utf16le") {
        return "utf16le";
      }
      break;
    case 8:
      if (enc === "utf-16le" || enc === "UTF-16LE" || `${enc}`.toLowerCase() === "utf-16le") {
        return "utf16le";
      }
      break;
    case 9:
      if (enc === "base64url" || enc === "BASE64URL" || `${enc}`.toLowerCase() === "base64url") {
        return "base64url";
      }
      break;
    default:
      if (enc === "")
        return "utf8";
  }
}

// deno:https://deno.land/std@0.147.0/node/internal/validators.mjs
function isInt32(value) {
  return value === (value | 0);
}
function isUint32(value) {
  return value === value >>> 0;
}
var validateBuffer = hideStackFrames((buffer, name = "buffer") => {
  if (!isArrayBufferView(buffer)) {
    throw new codes.ERR_INVALID_ARG_TYPE(name, ["Buffer", "TypedArray", "DataView"], buffer);
  }
});
var validateInteger = hideStackFrames((value, name, min4 = Number.MIN_SAFE_INTEGER, max2 = Number.MAX_SAFE_INTEGER) => {
  if (typeof value !== "number") {
    throw new codes.ERR_INVALID_ARG_TYPE(name, "number", value);
  }
  if (!Number.isInteger(value)) {
    throw new codes.ERR_OUT_OF_RANGE(name, "an integer", value);
  }
  if (value < min4 || value > max2) {
    throw new codes.ERR_OUT_OF_RANGE(name, `>= ${min4} && <= ${max2}`, value);
  }
});
var validateObject = hideStackFrames((value, name, options) => {
  const useDefaultOptions = options == null;
  const allowArray = useDefaultOptions ? false : options.allowArray;
  const allowFunction = useDefaultOptions ? false : options.allowFunction;
  const nullable = useDefaultOptions ? false : options.nullable;
  if (!nullable && value === null || !allowArray && Array.isArray(value) || typeof value !== "object" && (!allowFunction || typeof value !== "function")) {
    throw new codes.ERR_INVALID_ARG_TYPE(name, "Object", value);
  }
});
var validateInt32 = hideStackFrames((value, name, min4 = -2147483648, max2 = 2147483647) => {
  if (!isInt32(value)) {
    if (typeof value !== "number") {
      throw new codes.ERR_INVALID_ARG_TYPE(name, "number", value);
    }
    if (!Number.isInteger(value)) {
      throw new codes.ERR_OUT_OF_RANGE(name, "an integer", value);
    }
    throw new codes.ERR_OUT_OF_RANGE(name, `>= ${min4} && <= ${max2}`, value);
  }
  if (value < min4 || value > max2) {
    throw new codes.ERR_OUT_OF_RANGE(name, `>= ${min4} && <= ${max2}`, value);
  }
});
var validateUint32 = hideStackFrames((value, name, positive) => {
  if (!isUint32(value)) {
    if (typeof value !== "number") {
      throw new codes.ERR_INVALID_ARG_TYPE(name, "number", value);
    }
    if (!Number.isInteger(value)) {
      throw new codes.ERR_OUT_OF_RANGE(name, "an integer", value);
    }
    const min4 = positive ? 1 : 0;
    throw new codes.ERR_OUT_OF_RANGE(name, `>= ${min4} && < 4294967296`, value);
  }
  if (positive && value === 0) {
    throw new codes.ERR_OUT_OF_RANGE(name, ">= 1 && < 4294967296", value);
  }
});
function validateString(value, name) {
  if (typeof value !== "string") {
    throw new codes.ERR_INVALID_ARG_TYPE(name, "string", value);
  }
}
function validateBoolean(value, name) {
  if (typeof value !== "boolean") {
    throw new codes.ERR_INVALID_ARG_TYPE(name, "boolean", value);
  }
}
var validateOneOf = hideStackFrames((value, name, oneOf) => {
  if (!Array.prototype.includes.call(oneOf, value)) {
    const allowed = Array.prototype.join.call(Array.prototype.map.call(oneOf, (v2) => typeof v2 === "string" ? `'${v2}'` : String(v2)), ", ");
    const reason = "must be one of: " + allowed;
    throw new codes.ERR_INVALID_ARG_VALUE(name, value, reason);
  }
});
var validateCallback = hideStackFrames((callback) => {
  if (typeof callback !== "function") {
    throw new codes.ERR_INVALID_CALLBACK(callback);
  }
});
var validateAbortSignal = hideStackFrames((signal, name) => {
  if (signal !== void 0 && (signal === null || typeof signal !== "object" || !("aborted" in signal))) {
    throw new codes.ERR_INVALID_ARG_TYPE(name, "AbortSignal", signal);
  }
});
var validateFunction = hideStackFrames((value, name) => {
  if (typeof value !== "function") {
    throw new codes.ERR_INVALID_ARG_TYPE(name, "Function", value);
  }
});
var validateArray = hideStackFrames((value, name, minLength = 0) => {
  if (!Array.isArray(value)) {
    throw new codes.ERR_INVALID_ARG_TYPE(name, "Array", value);
  }
  if (value.length < minLength) {
    const reason = `must be longer than ${minLength}`;
    throw new codes.ERR_INVALID_ARG_VALUE(name, value, reason);
  }
});

// deno:https://deno.land/std@0.147.0/node/internal_binding/util.ts
var util_exports = {};
__export(util_exports, {
  ALL_PROPERTIES: () => ALL_PROPERTIES,
  ONLY_CONFIGURABLE: () => ONLY_CONFIGURABLE,
  ONLY_ENUMERABLE: () => ONLY_ENUMERABLE,
  ONLY_ENUM_WRITABLE: () => ONLY_ENUM_WRITABLE,
  ONLY_WRITABLE: () => ONLY_WRITABLE,
  SKIP_STRINGS: () => SKIP_STRINGS,
  SKIP_SYMBOLS: () => SKIP_SYMBOLS,
  getOwnNonIndexProperties: () => getOwnNonIndexProperties,
  guessHandleType: () => guessHandleType,
  isArrayIndex: () => isArrayIndex
});
function guessHandleType(_fd) {
  notImplemented("util.guessHandleType");
}
var ALL_PROPERTIES = 0;
var ONLY_WRITABLE = 1;
var ONLY_ENUMERABLE = 2;
var ONLY_CONFIGURABLE = 4;
var ONLY_ENUM_WRITABLE = 6;
var SKIP_STRINGS = 8;
var SKIP_SYMBOLS = 16;
var isNumericLookup = {};
function isArrayIndex(value) {
  switch (typeof value) {
    case "number":
      return value >= 0 && (value | 0) === value;
    case "string": {
      const result = isNumericLookup[value];
      if (result !== void 0) {
        return result;
      }
      const length = value.length;
      if (length === 0) {
        return isNumericLookup[value] = false;
      }
      let ch = 0;
      let i = 0;
      for (; i < length; ++i) {
        ch = value.charCodeAt(i);
        if (i === 0 && ch === 48 && length > 1 || ch < 48 || ch > 57) {
          return isNumericLookup[value] = false;
        }
      }
      return isNumericLookup[value] = true;
    }
    default:
      return false;
  }
}
function getOwnNonIndexProperties(obj2, filter) {
  let allProperties = [
    ...Object.getOwnPropertyNames(obj2),
    ...Object.getOwnPropertySymbols(obj2)
  ];
  if (Array.isArray(obj2)) {
    allProperties = allProperties.filter((k6) => !isArrayIndex(k6));
  }
  if (filter === ALL_PROPERTIES) {
    return allProperties;
  }
  const result = [];
  for (const key2 of allProperties) {
    const desc = Object.getOwnPropertyDescriptor(obj2, key2);
    if (desc === void 0) {
      continue;
    }
    if (filter & ONLY_WRITABLE && !desc.writable) {
      continue;
    }
    if (filter & ONLY_ENUMERABLE && !desc.enumerable) {
      continue;
    }
    if (filter & ONLY_CONFIGURABLE && !desc.configurable) {
      continue;
    }
    if (filter & SKIP_STRINGS && typeof key2 === "string") {
      continue;
    }
    if (filter & SKIP_SYMBOLS && typeof key2 === "symbol") {
      continue;
    }
    result.push(key2);
  }
  return result;
}

// deno:https://deno.land/std@0.147.0/node/internal/util/inspect.mjs
var kObjectType = 0;
var kArrayType = 1;
var kArrayExtrasType = 2;
var kMinLineLength = 16;
var kWeak = 0;
var kIterator = 1;
var kMapEntries = 2;
var kPending = 0;
var kRejected = 2;
var meta = [
  "\\x00",
  "\\x01",
  "\\x02",
  "\\x03",
  "\\x04",
  "\\x05",
  "\\x06",
  "\\x07",
  "\\b",
  "\\t",
  "\\n",
  "\\x0B",
  "\\f",
  "\\r",
  "\\x0E",
  "\\x0F",
  "\\x10",
  "\\x11",
  "\\x12",
  "\\x13",
  "\\x14",
  "\\x15",
  "\\x16",
  "\\x17",
  "\\x18",
  "\\x19",
  "\\x1A",
  "\\x1B",
  "\\x1C",
  "\\x1D",
  "\\x1E",
  "\\x1F",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "\\'",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "\\\\",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "\\x7F",
  "\\x80",
  "\\x81",
  "\\x82",
  "\\x83",
  "\\x84",
  "\\x85",
  "\\x86",
  "\\x87",
  "\\x88",
  "\\x89",
  "\\x8A",
  "\\x8B",
  "\\x8C",
  "\\x8D",
  "\\x8E",
  "\\x8F",
  "\\x90",
  "\\x91",
  "\\x92",
  "\\x93",
  "\\x94",
  "\\x95",
  "\\x96",
  "\\x97",
  "\\x98",
  "\\x99",
  "\\x9A",
  "\\x9B",
  "\\x9C",
  "\\x9D",
  "\\x9E",
  "\\x9F"
];
var isUndetectableObject = (v2) => typeof v2 === "undefined" && v2 !== void 0;
var strEscapeSequencesRegExp = /[\x00-\x1f\x27\x5c\x7f-\x9f]/;
var strEscapeSequencesReplacer = /[\x00-\x1f\x27\x5c\x7f-\x9f]/g;
var strEscapeSequencesRegExpSingle = /[\x00-\x1f\x5c\x7f-\x9f]/;
var strEscapeSequencesReplacerSingle = /[\x00-\x1f\x5c\x7f-\x9f]/g;
var keyStrRegExp = /^[a-zA-Z_][a-zA-Z_0-9]*$/;
var numberRegExp = /^(0|[1-9][0-9]*)$/;
var nodeModulesRegExp = /[/\\]node_modules[/\\](.+?)(?=[/\\])/g;
var classRegExp = /^(\s+[^(]*?)\s*{/;
var stripCommentsRegExp = /(\/\/.*?\n)|(\/\*(.|\n)*?\*\/)/g;
var inspectDefaultOptions = {
  showHidden: false,
  depth: 2,
  colors: false,
  customInspect: true,
  showProxy: false,
  maxArrayLength: 100,
  maxStringLength: 1e4,
  breakLength: 80,
  compact: 3,
  sorted: false,
  getters: false
};
function getUserOptions(ctx, isCrossContext) {
  const ret = {
    stylize: ctx.stylize,
    showHidden: ctx.showHidden,
    depth: ctx.depth,
    colors: ctx.colors,
    customInspect: ctx.customInspect,
    showProxy: ctx.showProxy,
    maxArrayLength: ctx.maxArrayLength,
    maxStringLength: ctx.maxStringLength,
    breakLength: ctx.breakLength,
    compact: ctx.compact,
    sorted: ctx.sorted,
    getters: ctx.getters,
    ...ctx.userOptions
  };
  if (isCrossContext) {
    Object.setPrototypeOf(ret, null);
    for (const key2 of Object.keys(ret)) {
      if ((typeof ret[key2] === "object" || typeof ret[key2] === "function") && ret[key2] !== null) {
        delete ret[key2];
      }
    }
    ret.stylize = Object.setPrototypeOf((value, flavour) => {
      let stylized;
      try {
        stylized = `${ctx.stylize(value, flavour)}`;
      } catch {
      }
      if (typeof stylized !== "string")
        return value;
      return stylized;
    }, null);
  }
  return ret;
}
function inspect(value, opts) {
  const ctx = {
    budget: {},
    indentationLvl: 0,
    seen: [],
    currentDepth: 0,
    stylize: stylizeNoColor,
    showHidden: inspectDefaultOptions.showHidden,
    depth: inspectDefaultOptions.depth,
    colors: inspectDefaultOptions.colors,
    customInspect: inspectDefaultOptions.customInspect,
    showProxy: inspectDefaultOptions.showProxy,
    maxArrayLength: inspectDefaultOptions.maxArrayLength,
    maxStringLength: inspectDefaultOptions.maxStringLength,
    breakLength: inspectDefaultOptions.breakLength,
    compact: inspectDefaultOptions.compact,
    sorted: inspectDefaultOptions.sorted,
    getters: inspectDefaultOptions.getters
  };
  if (arguments.length > 1) {
    if (arguments.length > 2) {
      if (arguments[2] !== void 0) {
        ctx.depth = arguments[2];
      }
      if (arguments.length > 3 && arguments[3] !== void 0) {
        ctx.colors = arguments[3];
      }
    }
    if (typeof opts === "boolean") {
      ctx.showHidden = opts;
    } else if (opts) {
      const optKeys = Object.keys(opts);
      for (let i = 0; i < optKeys.length; ++i) {
        const key2 = optKeys[i];
        if (inspectDefaultOptions.hasOwnProperty(key2) || key2 === "stylize") {
          ctx[key2] = opts[key2];
        } else if (ctx.userOptions === void 0) {
          ctx.userOptions = opts;
        }
      }
    }
  }
  if (ctx.colors)
    ctx.stylize = stylizeWithColor;
  if (ctx.maxArrayLength === null)
    ctx.maxArrayLength = Infinity;
  if (ctx.maxStringLength === null)
    ctx.maxStringLength = Infinity;
  return formatValue(ctx, value, 0);
}
var customInspectSymbol = Symbol.for("nodejs.util.inspect.custom");
inspect.custom = customInspectSymbol;
Object.defineProperty(inspect, "defaultOptions", {
  get() {
    return inspectDefaultOptions;
  },
  set(options) {
    validateObject(options, "options");
    return Object.assign(inspectDefaultOptions, options);
  }
});
var defaultFG = 39;
var defaultBG = 49;
inspect.colors = Object.assign(/* @__PURE__ */ Object.create(null), {
  reset: [0, 0],
  bold: [1, 22],
  dim: [2, 22],
  italic: [3, 23],
  underline: [4, 24],
  blink: [5, 25],
  inverse: [7, 27],
  hidden: [8, 28],
  strikethrough: [9, 29],
  doubleunderline: [21, 24],
  black: [30, defaultFG],
  red: [31, defaultFG],
  green: [32, defaultFG],
  yellow: [33, defaultFG],
  blue: [34, defaultFG],
  magenta: [35, defaultFG],
  cyan: [36, defaultFG],
  white: [37, defaultFG],
  bgBlack: [40, defaultBG],
  bgRed: [41, defaultBG],
  bgGreen: [42, defaultBG],
  bgYellow: [43, defaultBG],
  bgBlue: [44, defaultBG],
  bgMagenta: [45, defaultBG],
  bgCyan: [46, defaultBG],
  bgWhite: [47, defaultBG],
  framed: [51, 54],
  overlined: [53, 55],
  gray: [90, defaultFG],
  redBright: [91, defaultFG],
  greenBright: [92, defaultFG],
  yellowBright: [93, defaultFG],
  blueBright: [94, defaultFG],
  magentaBright: [95, defaultFG],
  cyanBright: [96, defaultFG],
  whiteBright: [97, defaultFG],
  bgGray: [100, defaultBG],
  bgRedBright: [101, defaultBG],
  bgGreenBright: [102, defaultBG],
  bgYellowBright: [103, defaultBG],
  bgBlueBright: [104, defaultBG],
  bgMagentaBright: [105, defaultBG],
  bgCyanBright: [106, defaultBG],
  bgWhiteBright: [107, defaultBG]
});
function defineColorAlias(target, alias) {
  Object.defineProperty(inspect.colors, alias, {
    get() {
      return this[target];
    },
    set(value) {
      this[target] = value;
    },
    configurable: true,
    enumerable: false
  });
}
defineColorAlias("gray", "grey");
defineColorAlias("gray", "blackBright");
defineColorAlias("bgGray", "bgGrey");
defineColorAlias("bgGray", "bgBlackBright");
defineColorAlias("dim", "faint");
defineColorAlias("strikethrough", "crossedout");
defineColorAlias("strikethrough", "strikeThrough");
defineColorAlias("strikethrough", "crossedOut");
defineColorAlias("hidden", "conceal");
defineColorAlias("inverse", "swapColors");
defineColorAlias("inverse", "swapcolors");
defineColorAlias("doubleunderline", "doubleUnderline");
inspect.styles = Object.assign(/* @__PURE__ */ Object.create(null), {
  special: "cyan",
  number: "yellow",
  bigint: "yellow",
  boolean: "yellow",
  undefined: "grey",
  null: "bold",
  string: "green",
  symbol: "green",
  date: "magenta",
  regexp: "red",
  module: "underline"
});
function addQuotes(str, quotes) {
  if (quotes === -1) {
    return `"${str}"`;
  }
  if (quotes === -2) {
    return `\`${str}\``;
  }
  return `'${str}'`;
}
var escapeFn = (str) => meta[str.charCodeAt(0)];
function strEscape(str) {
  let escapeTest = strEscapeSequencesRegExp;
  let escapeReplace = strEscapeSequencesReplacer;
  let singleQuote = 39;
  if (str.includes("'")) {
    if (!str.includes('"')) {
      singleQuote = -1;
    } else if (!str.includes("`") && !str.includes("${")) {
      singleQuote = -2;
    }
    if (singleQuote !== 39) {
      escapeTest = strEscapeSequencesRegExpSingle;
      escapeReplace = strEscapeSequencesReplacerSingle;
    }
  }
  if (str.length < 5e3 && !escapeTest.test(str)) {
    return addQuotes(str, singleQuote);
  }
  if (str.length > 100) {
    str = str.replace(escapeReplace, escapeFn);
    return addQuotes(str, singleQuote);
  }
  let result = "";
  let last = 0;
  const lastIndex = str.length;
  for (let i = 0; i < lastIndex; i++) {
    const point = str.charCodeAt(i);
    if (point === singleQuote || point === 92 || point < 32 || point > 126 && point < 160) {
      if (last === i) {
        result += meta[point];
      } else {
        result += `${str.slice(last, i)}${meta[point]}`;
      }
      last = i + 1;
    }
  }
  if (last !== lastIndex) {
    result += str.slice(last);
  }
  return addQuotes(result, singleQuote);
}
function stylizeWithColor(str, styleType) {
  const style = inspect.styles[styleType];
  if (style !== void 0) {
    const color = inspect.colors[style];
    if (color !== void 0) {
      return `\x1B[${color[0]}m${str}\x1B[${color[1]}m`;
    }
  }
  return str;
}
function stylizeNoColor(str) {
  return str;
}
function formatValue(ctx, value, recurseTimes, typedArray) {
  if (typeof value !== "object" && typeof value !== "function" && !isUndetectableObject(value)) {
    return formatPrimitive(ctx.stylize, value, ctx);
  }
  if (value === null) {
    return ctx.stylize("null", "null");
  }
  const context = value;
  const proxy = void 0;
  if (ctx.customInspect) {
    const maybeCustom = value[customInspectSymbol];
    if (typeof maybeCustom === "function" && maybeCustom !== inspect && !(value.constructor && value.constructor.prototype === value)) {
      const depth = ctx.depth === null ? null : ctx.depth - recurseTimes;
      const isCrossContext = proxy !== void 0 || !(context instanceof Object);
      const ret = maybeCustom.call(context, depth, getUserOptions(ctx, isCrossContext));
      if (ret !== context) {
        if (typeof ret !== "string") {
          return formatValue(ctx, ret, recurseTimes);
        }
        return ret.replace(/\n/g, `
${" ".repeat(ctx.indentationLvl)}`);
      }
    }
  }
  if (ctx.seen.includes(value)) {
    let index = 1;
    if (ctx.circular === void 0) {
      ctx.circular = /* @__PURE__ */ new Map();
      ctx.circular.set(value, index);
    } else {
      index = ctx.circular.get(value);
      if (index === void 0) {
        index = ctx.circular.size + 1;
        ctx.circular.set(value, index);
      }
    }
    return ctx.stylize(`[Circular *${index}]`, "special");
  }
  return formatRaw(ctx, value, recurseTimes, typedArray);
}
function formatRaw(ctx, value, recurseTimes, typedArray) {
  let keys;
  let protoProps;
  if (ctx.showHidden && (recurseTimes <= ctx.depth || ctx.depth === null)) {
    protoProps = [];
  }
  const constructor = getConstructorName(value, ctx, recurseTimes, protoProps);
  if (protoProps !== void 0 && protoProps.length === 0) {
    protoProps = void 0;
  }
  let tag2 = value[Symbol.toStringTag];
  if (typeof tag2 !== "string") {
    tag2 = "";
  }
  let base3 = "";
  let formatter = getEmptyFormatArray;
  let braces;
  let noIterator = true;
  let i = 0;
  const filter = ctx.showHidden ? ALL_PROPERTIES : ONLY_ENUMERABLE;
  let extrasType = kObjectType;
  if (value[Symbol.iterator] || constructor === null) {
    noIterator = false;
    if (Array.isArray(value)) {
      const prefix = constructor !== "Array" || tag2 !== "" ? getPrefix(constructor, tag2, "Array", `(${value.length})`) : "";
      keys = getOwnNonIndexProperties(value, filter);
      braces = [`${prefix}[`, "]"];
      if (value.length === 0 && keys.length === 0 && protoProps === void 0) {
        return `${braces[0]}]`;
      }
      extrasType = kArrayExtrasType;
      formatter = formatArray;
    } else if (isSet2(value)) {
      const size = value.size;
      const prefix = getPrefix(constructor, tag2, "Set", `(${size})`);
      keys = getKeys(value, ctx.showHidden);
      formatter = constructor !== null ? formatSet.bind(null, value) : formatSet.bind(null, value.values());
      if (size === 0 && keys.length === 0 && protoProps === void 0) {
        return `${prefix}{}`;
      }
      braces = [`${prefix}{`, "}"];
    } else if (isMap2(value)) {
      const size = value.size;
      const prefix = getPrefix(constructor, tag2, "Map", `(${size})`);
      keys = getKeys(value, ctx.showHidden);
      formatter = constructor !== null ? formatMap.bind(null, value) : formatMap.bind(null, value.entries());
      if (size === 0 && keys.length === 0 && protoProps === void 0) {
        return `${prefix}{}`;
      }
      braces = [`${prefix}{`, "}"];
    } else if (isTypedArray(value)) {
      keys = getOwnNonIndexProperties(value, filter);
      const bound = value;
      const fallback = "";
      if (constructor === null) {
      }
      const size = value.length;
      const prefix = getPrefix(constructor, tag2, fallback, `(${size})`);
      braces = [`${prefix}[`, "]"];
      if (value.length === 0 && keys.length === 0 && !ctx.showHidden) {
        return `${braces[0]}]`;
      }
      formatter = formatTypedArray.bind(null, bound, size);
      extrasType = kArrayExtrasType;
    } else if (isMapIterator2(value)) {
      keys = getKeys(value, ctx.showHidden);
      braces = getIteratorBraces("Map", tag2);
      formatter = formatIterator.bind(null, braces);
    } else if (isSetIterator2(value)) {
      keys = getKeys(value, ctx.showHidden);
      braces = getIteratorBraces("Set", tag2);
      formatter = formatIterator.bind(null, braces);
    } else {
      noIterator = true;
    }
  }
  if (noIterator) {
    keys = getKeys(value, ctx.showHidden);
    braces = ["{", "}"];
    if (constructor === "Object") {
      if (isArgumentsObject2(value)) {
        braces[0] = "[Arguments] {";
      } else if (tag2 !== "") {
        braces[0] = `${getPrefix(constructor, tag2, "Object")}{`;
      }
      if (keys.length === 0 && protoProps === void 0) {
        return `${braces[0]}}`;
      }
    } else if (typeof value === "function") {
      base3 = getFunctionBase(value, constructor, tag2);
      if (keys.length === 0 && protoProps === void 0) {
        return ctx.stylize(base3, "special");
      }
    } else if (isRegExp2(value)) {
      base3 = RegExp(constructor !== null ? value : new RegExp(value)).toString();
      const prefix = getPrefix(constructor, tag2, "RegExp");
      if (prefix !== "RegExp ") {
        base3 = `${prefix}${base3}`;
      }
      if (keys.length === 0 && protoProps === void 0 || recurseTimes > ctx.depth && ctx.depth !== null) {
        return ctx.stylize(base3, "regexp");
      }
    } else if (isDate2(value)) {
      base3 = Number.isNaN(value.getTime()) ? value.toString() : value.toISOString();
      const prefix = getPrefix(constructor, tag2, "Date");
      if (prefix !== "Date ") {
        base3 = `${prefix}${base3}`;
      }
      if (keys.length === 0 && protoProps === void 0) {
        return ctx.stylize(base3, "date");
      }
    } else if (value instanceof Error) {
      base3 = formatError(value, constructor, tag2, ctx, keys);
      if (keys.length === 0 && protoProps === void 0) {
        return base3;
      }
    } else if (isAnyArrayBuffer2(value)) {
      const arrayType = isArrayBuffer2(value) ? "ArrayBuffer" : "SharedArrayBuffer";
      const prefix = getPrefix(constructor, tag2, arrayType);
      if (typedArray === void 0) {
        formatter = formatArrayBuffer;
      } else if (keys.length === 0 && protoProps === void 0) {
        return prefix + `{ byteLength: ${formatNumber(ctx.stylize, value.byteLength)} }`;
      }
      braces[0] = `${prefix}{`;
      Array.prototype.unshift.call(keys, "byteLength");
    } else if (isDataView2(value)) {
      braces[0] = `${getPrefix(constructor, tag2, "DataView")}{`;
      Array.prototype.unshift.call(keys, "byteLength", "byteOffset", "buffer");
    } else if (isPromise2(value)) {
      braces[0] = `${getPrefix(constructor, tag2, "Promise")}{`;
      formatter = formatPromise;
    } else if (isWeakSet2(value)) {
      braces[0] = `${getPrefix(constructor, tag2, "WeakSet")}{`;
      formatter = ctx.showHidden ? formatWeakSet : formatWeakCollection;
    } else if (isWeakMap2(value)) {
      braces[0] = `${getPrefix(constructor, tag2, "WeakMap")}{`;
      formatter = ctx.showHidden ? formatWeakMap : formatWeakCollection;
    } else if (isModuleNamespaceObject2(value)) {
      braces[0] = `${getPrefix(constructor, tag2, "Module")}{`;
      formatter = formatNamespaceObject.bind(null, keys);
    } else if (isBoxedPrimitive2(value)) {
      base3 = getBoxedBase(value, ctx, keys, constructor, tag2);
      if (keys.length === 0 && protoProps === void 0) {
        return base3;
      }
    } else {
      if (keys.length === 0 && protoProps === void 0) {
        return `${getCtxStyle(value, constructor, tag2)}{}`;
      }
      braces[0] = `${getCtxStyle(value, constructor, tag2)}{`;
    }
  }
  if (recurseTimes > ctx.depth && ctx.depth !== null) {
    let constructorName = getCtxStyle(value, constructor, tag2).slice(0, -1);
    if (constructor !== null) {
      constructorName = `[${constructorName}]`;
    }
    return ctx.stylize(constructorName, "special");
  }
  recurseTimes += 1;
  ctx.seen.push(value);
  ctx.currentDepth = recurseTimes;
  let output;
  const indentationLvl = ctx.indentationLvl;
  try {
    output = formatter(ctx, value, recurseTimes);
    for (i = 0; i < keys.length; i++) {
      output.push(formatProperty(ctx, value, recurseTimes, keys[i], extrasType));
    }
    if (protoProps !== void 0) {
      output.push(...protoProps);
    }
  } catch (err) {
    const constructorName = getCtxStyle(value, constructor, tag2).slice(0, -1);
    return handleMaxCallStackSize(ctx, err, constructorName, indentationLvl);
  }
  if (ctx.circular !== void 0) {
    const index = ctx.circular.get(value);
    if (index !== void 0) {
      const reference = ctx.stylize(`<ref *${index}>`, "special");
      if (ctx.compact !== true) {
        base3 = base3 === "" ? reference : `${reference} ${base3}`;
      } else {
        braces[0] = `${reference} ${braces[0]}`;
      }
    }
  }
  ctx.seen.pop();
  if (ctx.sorted) {
    const comparator = ctx.sorted === true ? void 0 : ctx.sorted;
    if (extrasType === kObjectType) {
      output = output.sort(comparator);
    } else if (keys.length > 1) {
      const sorted = output.slice(output.length - keys.length).sort(comparator);
      output.splice(output.length - keys.length, keys.length, ...sorted);
    }
  }
  const res = reduceToSingleString(ctx, output, base3, braces, extrasType, recurseTimes, value);
  const budget = ctx.budget[ctx.indentationLvl] || 0;
  const newLength = budget + res.length;
  ctx.budget[ctx.indentationLvl] = newLength;
  if (newLength > 2 ** 27) {
    ctx.depth = -1;
  }
  return res;
}
var builtInObjects = new Set(Object.getOwnPropertyNames(globalThis).filter((e) => /^[A-Z][a-zA-Z0-9]+$/.test(e)));
function addPrototypeProperties(ctx, main, obj2, recurseTimes, output) {
  let depth = 0;
  let keys;
  let keySet;
  do {
    if (depth !== 0 || main === obj2) {
      obj2 = Object.getPrototypeOf(obj2);
      if (obj2 === null) {
        return;
      }
      const descriptor = Object.getOwnPropertyDescriptor(obj2, "constructor");
      if (descriptor !== void 0 && typeof descriptor.value === "function" && builtInObjects.has(descriptor.value.name)) {
        return;
      }
    }
    if (depth === 0) {
      keySet = /* @__PURE__ */ new Set();
    } else {
      Array.prototype.forEach.call(keys, (key2) => keySet.add(key2));
    }
    keys = Reflect.ownKeys(obj2);
    Array.prototype.push.call(ctx.seen, main);
    for (const key2 of keys) {
      if (key2 === "constructor" || main.hasOwnProperty(key2) || depth !== 0 && keySet.has(key2)) {
        continue;
      }
      const desc = Object.getOwnPropertyDescriptor(obj2, key2);
      if (typeof desc.value === "function") {
        continue;
      }
      const value = formatProperty(ctx, obj2, recurseTimes, key2, kObjectType, desc, main);
      if (ctx.colors) {
        Array.prototype.push.call(output, `\x1B[2m${value}\x1B[22m`);
      } else {
        Array.prototype.push.call(output, value);
      }
    }
    Array.prototype.pop.call(ctx.seen);
  } while (++depth !== 3);
}
function getConstructorName(obj2, ctx, recurseTimes, protoProps) {
  let firstProto;
  const tmp = obj2;
  while (obj2 || isUndetectableObject(obj2)) {
    const descriptor = Object.getOwnPropertyDescriptor(obj2, "constructor");
    if (descriptor !== void 0 && typeof descriptor.value === "function" && descriptor.value.name !== "" && isInstanceof(tmp, descriptor.value)) {
      if (protoProps !== void 0 && (firstProto !== obj2 || !builtInObjects.has(descriptor.value.name))) {
        addPrototypeProperties(ctx, tmp, firstProto || tmp, recurseTimes, protoProps);
      }
      return descriptor.value.name;
    }
    obj2 = Object.getPrototypeOf(obj2);
    if (firstProto === void 0) {
      firstProto = obj2;
    }
  }
  if (firstProto === null) {
    return null;
  }
  const res = void 0;
  if (recurseTimes > ctx.depth && ctx.depth !== null) {
    return `${res} <Complex prototype>`;
  }
  const protoConstr = getConstructorName(firstProto, ctx, recurseTimes + 1, protoProps);
  if (protoConstr === null) {
    return `${res} <${inspect(firstProto, {
      ...ctx,
      customInspect: false,
      depth: -1
    })}>`;
  }
  return `${res} <${protoConstr}>`;
}
function formatPrimitive(fn, value, ctx) {
  if (typeof value === "string") {
    let trailer = "";
    if (value.length > ctx.maxStringLength) {
      const remaining = value.length - ctx.maxStringLength;
      value = value.slice(0, ctx.maxStringLength);
      trailer = `... ${remaining} more character${remaining > 1 ? "s" : ""}`;
    }
    if (ctx.compact !== true && value.length > kMinLineLength && value.length > ctx.breakLength - ctx.indentationLvl - 4) {
      return value.split(/(?<=\n)/).map((line) => fn(strEscape(line), "string")).join(` +
${" ".repeat(ctx.indentationLvl + 2)}`) + trailer;
    }
    return fn(strEscape(value), "string") + trailer;
  }
  if (typeof value === "number") {
    return formatNumber(fn, value);
  }
  if (typeof value === "bigint") {
    return formatBigInt(fn, value);
  }
  if (typeof value === "boolean") {
    return fn(`${value}`, "boolean");
  }
  if (typeof value === "undefined") {
    return fn("undefined", "undefined");
  }
  return fn(value.toString(), "symbol");
}
function getEmptyFormatArray() {
  return [];
}
function isInstanceof(object, proto) {
  try {
    return object instanceof proto;
  } catch {
    return false;
  }
}
function getPrefix(constructor, tag2, fallback, size = "") {
  if (constructor === null) {
    if (tag2 !== "" && fallback !== tag2) {
      return `[${fallback}${size}: null prototype] [${tag2}] `;
    }
    return `[${fallback}${size}: null prototype] `;
  }
  if (tag2 !== "" && constructor !== tag2) {
    return `${constructor}${size} [${tag2}] `;
  }
  return `${constructor}${size} `;
}
function formatArray(ctx, value, recurseTimes) {
  const valLen = value.length;
  const len = Math.min(Math.max(0, ctx.maxArrayLength), valLen);
  const remaining = valLen - len;
  const output = [];
  for (let i = 0; i < len; i++) {
    if (!value.hasOwnProperty(i)) {
      return formatSpecialArray(ctx, value, recurseTimes, len, output, i);
    }
    output.push(formatProperty(ctx, value, recurseTimes, i, kArrayType));
  }
  if (remaining > 0) {
    output.push(`... ${remaining} more item${remaining > 1 ? "s" : ""}`);
  }
  return output;
}
function getCtxStyle(_value, constructor, tag2) {
  let fallback = "";
  if (constructor === null) {
    if (fallback === tag2) {
      fallback = "Object";
    }
  }
  return getPrefix(constructor, tag2, fallback);
}
function getKeys(value, showHidden) {
  let keys;
  const symbols = Object.getOwnPropertySymbols(value);
  if (showHidden) {
    keys = Object.getOwnPropertyNames(value);
    if (symbols.length !== 0) {
      Array.prototype.push.apply(keys, symbols);
    }
  } else {
    try {
      keys = Object.keys(value);
    } catch (_err) {
      keys = Object.getOwnPropertyNames(value);
    }
    if (symbols.length !== 0) {
    }
  }
  return keys;
}
function formatSet(value, ctx, _ignored, recurseTimes) {
  const output = [];
  ctx.indentationLvl += 2;
  for (const v2 of value) {
    Array.prototype.push.call(output, formatValue(ctx, v2, recurseTimes));
  }
  ctx.indentationLvl -= 2;
  return output;
}
function formatMap(value, ctx, _gnored, recurseTimes) {
  const output = [];
  ctx.indentationLvl += 2;
  for (const { 0: k6, 1: v2 } of value) {
    output.push(`${formatValue(ctx, k6, recurseTimes)} => ${formatValue(ctx, v2, recurseTimes)}`);
  }
  ctx.indentationLvl -= 2;
  return output;
}
function formatTypedArray(value, length, ctx, _ignored, recurseTimes) {
  const maxLength = Math.min(Math.max(0, ctx.maxArrayLength), length);
  const remaining = value.length - maxLength;
  const output = new Array(maxLength);
  const elementFormatter = value.length > 0 && typeof value[0] === "number" ? formatNumber : formatBigInt;
  for (let i = 0; i < maxLength; ++i) {
    output[i] = elementFormatter(ctx.stylize, value[i]);
  }
  if (remaining > 0) {
    output[maxLength] = `... ${remaining} more item${remaining > 1 ? "s" : ""}`;
  }
  if (ctx.showHidden) {
    ctx.indentationLvl += 2;
    for (const key2 of [
      "BYTES_PER_ELEMENT",
      "length",
      "byteLength",
      "byteOffset",
      "buffer"
    ]) {
      const str = formatValue(ctx, value[key2], recurseTimes, true);
      Array.prototype.push.call(output, `[${key2}]: ${str}`);
    }
    ctx.indentationLvl -= 2;
  }
  return output;
}
function getIteratorBraces(type, tag2) {
  if (tag2 !== `${type} Iterator`) {
    if (tag2 !== "") {
      tag2 += "] [";
    }
    tag2 += `${type} Iterator`;
  }
  return [`[${tag2}] {`, "}"];
}
function formatIterator(braces, ctx, value, recurseTimes) {
  const { 0: entries, 1: isKeyValue } = value;
  if (isKeyValue) {
    braces[0] = braces[0].replace(/ Iterator] {$/, " Entries] {");
    return formatMapIterInner(ctx, recurseTimes, entries, kMapEntries);
  }
  return formatSetIterInner(ctx, recurseTimes, entries, kIterator);
}
function getFunctionBase(value, constructor, tag2) {
  const stringified = Function.prototype.toString.call(value);
  if (stringified.slice(0, 5) === "class" && stringified.endsWith("}")) {
    const slice5 = stringified.slice(5, -1);
    const bracketIndex = slice5.indexOf("{");
    if (bracketIndex !== -1 && (!slice5.slice(0, bracketIndex).includes("(") || classRegExp.test(slice5.replace(stripCommentsRegExp)))) {
      return getClassBase(value, constructor, tag2);
    }
  }
  let type = "Function";
  if (isGeneratorFunction2(value)) {
    type = `Generator${type}`;
  }
  if (isAsyncFunction2(value)) {
    type = `Async${type}`;
  }
  let base3 = `[${type}`;
  if (constructor === null) {
    base3 += " (null prototype)";
  }
  if (value.name === "") {
    base3 += " (anonymous)";
  } else {
    base3 += `: ${value.name}`;
  }
  base3 += "]";
  if (constructor !== type && constructor !== null) {
    base3 += ` ${constructor}`;
  }
  if (tag2 !== "" && constructor !== tag2) {
    base3 += ` [${tag2}]`;
  }
  return base3;
}
function formatError(err, constructor, tag2, ctx, keys) {
  const name = err.name != null ? String(err.name) : "Error";
  let len = name.length;
  let stack = err.stack ? String(err.stack) : err.toString();
  if (!ctx.showHidden && keys.length !== 0) {
    for (const name2 of ["name", "message", "stack"]) {
      const index = keys.indexOf(name2);
      if (index !== -1 && stack.includes(err[name2])) {
        keys.splice(index, 1);
      }
    }
  }
  if (constructor === null || name.endsWith("Error") && stack.startsWith(name) && (stack.length === len || stack[len] === ":" || stack[len] === "\n")) {
    let fallback = "Error";
    if (constructor === null) {
      const start = stack.match(/^([A-Z][a-z_ A-Z0-9[\]()-]+)(?::|\n {4}at)/) || stack.match(/^([a-z_A-Z0-9-]*Error)$/);
      fallback = start && start[1] || "";
      len = fallback.length;
      fallback = fallback || "Error";
    }
    const prefix = getPrefix(constructor, tag2, fallback).slice(0, -1);
    if (name !== prefix) {
      if (prefix.includes(name)) {
        if (len === 0) {
          stack = `${prefix}: ${stack}`;
        } else {
          stack = `${prefix}${stack.slice(len)}`;
        }
      } else {
        stack = `${prefix} [${name}]${stack.slice(len)}`;
      }
    }
  }
  let pos = err.message && stack.indexOf(err.message) || -1;
  if (pos !== -1) {
    pos += err.message.length;
  }
  const stackStart = stack.indexOf("\n    at", pos);
  if (stackStart === -1) {
    stack = `[${stack}]`;
  } else if (ctx.colors) {
    let newStack = stack.slice(0, stackStart);
    const lines = stack.slice(stackStart + 1).split("\n");
    for (const line of lines) {
      let nodeModule;
      newStack += "\n";
      let pos2 = 0;
      while (nodeModule = nodeModulesRegExp.exec(line)) {
        newStack += line.slice(pos2, nodeModule.index + 14);
        newStack += ctx.stylize(nodeModule[1], "module");
        pos2 = nodeModule.index + nodeModule[0].length;
      }
      newStack += pos2 === 0 ? line : line.slice(pos2);
    }
    stack = newStack;
  }
  if (ctx.indentationLvl !== 0) {
    const indentation = " ".repeat(ctx.indentationLvl);
    stack = stack.replace(/\n/g, `
${indentation}`);
  }
  return stack;
}
var hexSlice;
function formatArrayBuffer(ctx, value) {
  let buffer;
  try {
    buffer = new Uint8Array(value);
  } catch {
    return [ctx.stylize("(detached)", "special")];
  }
  let str = hexSlice(buffer, 0, Math.min(ctx.maxArrayLength, buffer.length)).replace(/(.{2})/g, "$1 ").trim();
  const remaining = buffer.length - ctx.maxArrayLength;
  if (remaining > 0) {
    str += ` ... ${remaining} more byte${remaining > 1 ? "s" : ""}`;
  }
  return [`${ctx.stylize("[Uint8Contents]", "special")}: <${str}>`];
}
function formatNumber(fn, value) {
  return fn(Object.is(value, -0) ? "-0" : `${value}`, "number");
}
function formatPromise(ctx, value, recurseTimes) {
  let output;
  const { 0: state, 1: result } = value;
  if (state === kPending) {
    output = [ctx.stylize("<pending>", "special")];
  } else {
    ctx.indentationLvl += 2;
    const str = formatValue(ctx, result, recurseTimes);
    ctx.indentationLvl -= 2;
    output = [
      state === kRejected ? `${ctx.stylize("<rejected>", "special")} ${str}` : str
    ];
  }
  return output;
}
function formatWeakCollection(ctx) {
  return [ctx.stylize("<items unknown>", "special")];
}
function formatWeakSet(ctx, value, recurseTimes) {
  const entries = value;
  return formatSetIterInner(ctx, recurseTimes, entries, kWeak);
}
function formatWeakMap(ctx, value, recurseTimes) {
  const entries = value;
  return formatMapIterInner(ctx, recurseTimes, entries, kWeak);
}
function formatProperty(ctx, value, recurseTimes, key2, type, desc, original = value) {
  let name, str;
  let extra = " ";
  desc = desc || Object.getOwnPropertyDescriptor(value, key2) || { value: value[key2], enumerable: true };
  if (desc.value !== void 0) {
    const diff3 = ctx.compact !== true || type !== kObjectType ? 2 : 3;
    ctx.indentationLvl += diff3;
    str = formatValue(ctx, desc.value, recurseTimes);
    if (diff3 === 3 && ctx.breakLength < getStringWidth(str, ctx.colors)) {
      extra = `
${" ".repeat(ctx.indentationLvl)}`;
    }
    ctx.indentationLvl -= diff3;
  } else if (desc.get !== void 0) {
    const label = desc.set !== void 0 ? "Getter/Setter" : "Getter";
    const s = ctx.stylize;
    const sp = "special";
    if (ctx.getters && (ctx.getters === true || ctx.getters === "get" && desc.set === void 0 || ctx.getters === "set" && desc.set !== void 0)) {
      try {
        const tmp = desc.get.call(original);
        ctx.indentationLvl += 2;
        if (tmp === null) {
          str = `${s(`[${label}:`, sp)} ${s("null", "null")}${s("]", sp)}`;
        } else if (typeof tmp === "object") {
          str = `${s(`[${label}]`, sp)} ${formatValue(ctx, tmp, recurseTimes)}`;
        } else {
          const primitive = formatPrimitive(s, tmp, ctx);
          str = `${s(`[${label}:`, sp)} ${primitive}${s("]", sp)}`;
        }
        ctx.indentationLvl -= 2;
      } catch (err) {
        const message = `<Inspection threw (${err.message})>`;
        str = `${s(`[${label}:`, sp)} ${message}${s("]", sp)}`;
      }
    } else {
      str = ctx.stylize(`[${label}]`, sp);
    }
  } else if (desc.set !== void 0) {
    str = ctx.stylize("[Setter]", "special");
  } else {
    str = ctx.stylize("undefined", "undefined");
  }
  if (type === kArrayType) {
    return str;
  }
  if (typeof key2 === "symbol") {
    const tmp = key2.toString().replace(strEscapeSequencesReplacer, escapeFn);
    name = `[${ctx.stylize(tmp, "symbol")}]`;
  } else if (key2 === "__proto__") {
    name = "['__proto__']";
  } else if (desc.enumerable === false) {
    const tmp = key2.replace(strEscapeSequencesReplacer, escapeFn);
    name = `[${tmp}]`;
  } else if (keyStrRegExp.test(key2)) {
    name = ctx.stylize(key2, "name");
  } else {
    name = ctx.stylize(strEscape(key2), "string");
  }
  return `${name}:${extra}${str}`;
}
function handleMaxCallStackSize(_ctx, _err, _constructorName, _indentationLvl) {
}
var colorRegExp = /\u001b\[\d\d?m/g;
function removeColors(str) {
  return str.replace(colorRegExp, "");
}
function isBelowBreakLength(ctx, output, start, base3) {
  let totalLength = output.length + start;
  if (totalLength + output.length > ctx.breakLength) {
    return false;
  }
  for (let i = 0; i < output.length; i++) {
    if (ctx.colors) {
      totalLength += removeColors(output[i]).length;
    } else {
      totalLength += output[i].length;
    }
    if (totalLength > ctx.breakLength) {
      return false;
    }
  }
  return base3 === "" || !base3.includes("\n");
}
function formatBigInt(fn, value) {
  return fn(`${value}n`, "bigint");
}
function formatNamespaceObject(keys, ctx, value, recurseTimes) {
  const output = new Array(keys.length);
  for (let i = 0; i < keys.length; i++) {
    try {
      output[i] = formatProperty(ctx, value, recurseTimes, keys[i], kObjectType);
    } catch (_err) {
      const tmp = { [keys[i]]: "" };
      output[i] = formatProperty(ctx, tmp, recurseTimes, keys[i], kObjectType);
      const pos = output[i].lastIndexOf(" ");
      output[i] = output[i].slice(0, pos + 1) + ctx.stylize("<uninitialized>", "special");
    }
  }
  keys.length = 0;
  return output;
}
function formatSpecialArray(ctx, value, recurseTimes, maxLength, output, i) {
  const keys = Object.keys(value);
  let index = i;
  for (; i < keys.length && output.length < maxLength; i++) {
    const key2 = keys[i];
    const tmp = +key2;
    if (tmp > 2 ** 32 - 2) {
      break;
    }
    if (`${index}` !== key2) {
      if (!numberRegExp.test(key2)) {
        break;
      }
      const emptyItems = tmp - index;
      const ending = emptyItems > 1 ? "s" : "";
      const message = `<${emptyItems} empty item${ending}>`;
      output.push(ctx.stylize(message, "undefined"));
      index = tmp;
      if (output.length === maxLength) {
        break;
      }
    }
    output.push(formatProperty(ctx, value, recurseTimes, key2, kArrayType));
    index++;
  }
  const remaining = value.length - index;
  if (output.length !== maxLength) {
    if (remaining > 0) {
      const ending = remaining > 1 ? "s" : "";
      const message = `<${remaining} empty item${ending}>`;
      output.push(ctx.stylize(message, "undefined"));
    }
  } else if (remaining > 0) {
    output.push(`... ${remaining} more item${remaining > 1 ? "s" : ""}`);
  }
  return output;
}
function getBoxedBase(value, ctx, keys, constructor, tag2) {
  let type;
  if (isNumberObject2(value)) {
    type = "Number";
  } else if (isStringObject2(value)) {
    type = "String";
    keys.splice(0, value.length);
  } else if (isBooleanObject2(value)) {
    type = "Boolean";
  } else if (isBigIntObject2(value)) {
    type = "BigInt";
  } else {
    type = "Symbol";
  }
  let base3 = `[${type}`;
  if (type !== constructor) {
    if (constructor === null) {
      base3 += " (null prototype)";
    } else {
      base3 += ` (${constructor})`;
    }
  }
  base3 += `: ${formatPrimitive(stylizeNoColor, value.valueOf(), ctx)}]`;
  if (tag2 !== "" && tag2 !== constructor) {
    base3 += ` [${tag2}]`;
  }
  if (keys.length !== 0 || ctx.stylize === stylizeNoColor) {
    return base3;
  }
  return ctx.stylize(base3, type.toLowerCase());
}
function getClassBase(value, constructor, tag2) {
  const hasName = value.hasOwnProperty("name");
  const name = hasName && value.name || "(anonymous)";
  let base3 = `class ${name}`;
  if (constructor !== "Function" && constructor !== null) {
    base3 += ` [${constructor}]`;
  }
  if (tag2 !== "" && constructor !== tag2) {
    base3 += ` [${tag2}]`;
  }
  if (constructor !== null) {
    const superName = Object.getPrototypeOf(value).name;
    if (superName) {
      base3 += ` extends ${superName}`;
    }
  } else {
    base3 += " extends [null prototype]";
  }
  return `[${base3}]`;
}
function reduceToSingleString(ctx, output, base3, braces, extrasType, recurseTimes, value) {
  if (ctx.compact !== true) {
    if (typeof ctx.compact === "number" && ctx.compact >= 1) {
      const entries = output.length;
      if (extrasType === kArrayExtrasType && entries > 6) {
        output = groupArrayElements(ctx, output, value);
      }
      if (ctx.currentDepth - recurseTimes < ctx.compact && entries === output.length) {
        const start = output.length + ctx.indentationLvl + braces[0].length + base3.length + 10;
        if (isBelowBreakLength(ctx, output, start, base3)) {
          return `${base3 ? `${base3} ` : ""}${braces[0]} ${join(output, ", ")} ${braces[1]}`;
        }
      }
    }
    const indentation2 = `
${" ".repeat(ctx.indentationLvl)}`;
    return `${base3 ? `${base3} ` : ""}${braces[0]}${indentation2}  ${join(output, `,${indentation2}  `)}${indentation2}${braces[1]}`;
  }
  if (isBelowBreakLength(ctx, output, 0, base3)) {
    return `${braces[0]}${base3 ? ` ${base3}` : ""} ${join(output, ", ")} ` + braces[1];
  }
  const indentation = " ".repeat(ctx.indentationLvl);
  const ln = base3 === "" && braces[0].length === 1 ? " " : `${base3 ? ` ${base3}` : ""}
${indentation}  `;
  return `${braces[0]}${ln}${join(output, `,
${indentation}  `)} ${braces[1]}`;
}
function join(output, separator) {
  let str = "";
  if (output.length !== 0) {
    const lastIndex = output.length - 1;
    for (let i = 0; i < lastIndex; i++) {
      str += output[i];
      str += separator;
    }
    str += output[lastIndex];
  }
  return str;
}
function groupArrayElements(ctx, output, value) {
  let totalLength = 0;
  let maxLength = 0;
  let i = 0;
  let outputLength = output.length;
  if (ctx.maxArrayLength < output.length) {
    outputLength--;
  }
  const separatorSpace = 2;
  const dataLen = new Array(outputLength);
  for (; i < outputLength; i++) {
    const len = getStringWidth(output[i], ctx.colors);
    dataLen[i] = len;
    totalLength += len + separatorSpace;
    if (maxLength < len) {
      maxLength = len;
    }
  }
  const actualMax = maxLength + separatorSpace;
  if (actualMax * 3 + ctx.indentationLvl < ctx.breakLength && (totalLength / actualMax > 5 || maxLength <= 6)) {
    const approxCharHeights = 2.5;
    const averageBias = Math.sqrt(actualMax - totalLength / output.length);
    const biasedMax = Math.max(actualMax - 3 - averageBias, 1);
    const columns = Math.min(Math.round(Math.sqrt(approxCharHeights * biasedMax * outputLength) / biasedMax), Math.floor((ctx.breakLength - ctx.indentationLvl) / actualMax), ctx.compact * 4, 15);
    if (columns <= 1) {
      return output;
    }
    const tmp = [];
    const maxLineLength = [];
    for (let i2 = 0; i2 < columns; i2++) {
      let lineMaxLength = 0;
      for (let j2 = i2; j2 < output.length; j2 += columns) {
        if (dataLen[j2] > lineMaxLength) {
          lineMaxLength = dataLen[j2];
        }
      }
      lineMaxLength += separatorSpace;
      maxLineLength[i2] = lineMaxLength;
    }
    let order = String.prototype.padStart;
    if (value !== void 0) {
      for (let i2 = 0; i2 < output.length; i2++) {
        if (typeof value[i2] !== "number" && typeof value[i2] !== "bigint") {
          order = String.prototype.padEnd;
          break;
        }
      }
    }
    for (let i2 = 0; i2 < outputLength; i2 += columns) {
      const max2 = Math.min(i2 + columns, outputLength);
      let str = "";
      let j2 = i2;
      for (; j2 < max2 - 1; j2++) {
        const padding = maxLineLength[j2 - i2] + output[j2].length - dataLen[j2];
        str += `${output[j2]}, `.padStart(padding, " ");
      }
      if (order === String.prototype.padStart) {
        const padding = maxLineLength[j2 - i2] + output[j2].length - dataLen[j2] - separatorSpace;
        str += output[j2].padStart(padding, " ");
      } else {
        str += output[j2];
      }
      Array.prototype.push.call(tmp, str);
    }
    if (ctx.maxArrayLength < output.length) {
      Array.prototype.push.call(tmp, output[outputLength]);
    }
    output = tmp;
  }
  return output;
}
function formatMapIterInner(ctx, recurseTimes, entries, state) {
  const maxArrayLength = Math.max(ctx.maxArrayLength, 0);
  const len = entries.length / 2;
  const remaining = len - maxArrayLength;
  const maxLength = Math.min(maxArrayLength, len);
  let output = new Array(maxLength);
  let i = 0;
  ctx.indentationLvl += 2;
  if (state === kWeak) {
    for (; i < maxLength; i++) {
      const pos = i * 2;
      output[i] = `${formatValue(ctx, entries[pos], recurseTimes)} => ${formatValue(ctx, entries[pos + 1], recurseTimes)}`;
    }
    if (!ctx.sorted) {
      output = output.sort();
    }
  } else {
    for (; i < maxLength; i++) {
      const pos = i * 2;
      const res = [
        formatValue(ctx, entries[pos], recurseTimes),
        formatValue(ctx, entries[pos + 1], recurseTimes)
      ];
      output[i] = reduceToSingleString(ctx, res, "", ["[", "]"], kArrayExtrasType, recurseTimes);
    }
  }
  ctx.indentationLvl -= 2;
  if (remaining > 0) {
    output.push(`... ${remaining} more item${remaining > 1 ? "s" : ""}`);
  }
  return output;
}
function formatSetIterInner(ctx, recurseTimes, entries, state) {
  const maxArrayLength = Math.max(ctx.maxArrayLength, 0);
  const maxLength = Math.min(maxArrayLength, entries.length);
  const output = new Array(maxLength);
  ctx.indentationLvl += 2;
  for (let i = 0; i < maxLength; i++) {
    output[i] = formatValue(ctx, entries[i], recurseTimes);
  }
  ctx.indentationLvl -= 2;
  if (state === kWeak && !ctx.sorted) {
    output.sort();
  }
  const remaining = entries.length - maxLength;
  if (remaining > 0) {
    Array.prototype.push.call(output, `... ${remaining} more item${remaining > 1 ? "s" : ""}`);
  }
  return output;
}
var ansiPattern = "[\\u001B\\u009B][[\\]()#;?]*(?:(?:(?:(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]+)*|[a-zA-Z\\d]+(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]*)*)?\\u0007)|(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PR-TZcf-ntqry=><~]))";
var ansi = new RegExp(ansiPattern, "g");
function getStringWidth(str, removeControlChars = true) {
  let width = 0;
  if (removeControlChars) {
    str = stripVTControlCharacters(str);
  }
  str = str.normalize("NFC");
  for (const char of str[Symbol.iterator]()) {
    const code2 = char.codePointAt(0);
    if (isFullWidthCodePoint(code2)) {
      width += 2;
    } else if (!isZeroWidthCodePoint(code2)) {
      width++;
    }
  }
  return width;
}
var isFullWidthCodePoint = (code2) => {
  return code2 >= 4352 && (code2 <= 4447 || code2 === 9001 || code2 === 9002 || code2 >= 11904 && code2 <= 12871 && code2 !== 12351 || code2 >= 12880 && code2 <= 19903 || code2 >= 19968 && code2 <= 42182 || code2 >= 43360 && code2 <= 43388 || code2 >= 44032 && code2 <= 55203 || code2 >= 63744 && code2 <= 64255 || code2 >= 65040 && code2 <= 65049 || code2 >= 65072 && code2 <= 65131 || code2 >= 65281 && code2 <= 65376 || code2 >= 65504 && code2 <= 65510 || code2 >= 110592 && code2 <= 110593 || code2 >= 127488 && code2 <= 127569 || code2 >= 127744 && code2 <= 128591 || code2 >= 131072 && code2 <= 262141);
};
var isZeroWidthCodePoint = (code2) => {
  return code2 <= 31 || code2 >= 127 && code2 <= 159 || code2 >= 768 && code2 <= 879 || code2 >= 8203 && code2 <= 8207 || code2 >= 8400 && code2 <= 8447 || code2 >= 65024 && code2 <= 65039 || code2 >= 65056 && code2 <= 65071 || code2 >= 917760 && code2 <= 917999;
};
function hasBuiltInToString(value) {
  const proxyTarget = void 0;
  if (proxyTarget !== void 0) {
    value = proxyTarget;
  }
  if (typeof value.toString !== "function") {
    return true;
  }
  if (Object.prototype.hasOwnProperty.call(value, "toString")) {
    return false;
  }
  let pointer = value;
  do {
    pointer = Object.getPrototypeOf(pointer);
  } while (!Object.prototype.hasOwnProperty.call(pointer, "toString"));
  const descriptor = Object.getOwnPropertyDescriptor(pointer, "constructor");
  return descriptor !== void 0 && typeof descriptor.value === "function" && builtInObjects.has(descriptor.value.name);
}
var firstErrorLine = (error3) => error3.message.split("\n", 1)[0];
var CIRCULAR_ERROR_MESSAGE;
function tryStringify(arg) {
  try {
    return JSON.stringify(arg);
  } catch (err) {
    if (!CIRCULAR_ERROR_MESSAGE) {
      try {
        const a = {};
        a.a = a;
        JSON.stringify(a);
      } catch (circularError) {
        CIRCULAR_ERROR_MESSAGE = firstErrorLine(circularError);
      }
    }
    if (err.name === "TypeError" && firstErrorLine(err) === CIRCULAR_ERROR_MESSAGE) {
      return "[Circular]";
    }
    throw err;
  }
}
function format2(...args) {
  return formatWithOptionsInternal(void 0, args);
}
function formatWithOptions(inspectOptions, ...args) {
  if (typeof inspectOptions !== "object" || inspectOptions === null) {
    throw new codes.ERR_INVALID_ARG_TYPE("inspectOptions", "object", inspectOptions);
  }
  return formatWithOptionsInternal(inspectOptions, args);
}
function formatNumberNoColor(number, options) {
  return formatNumber(stylizeNoColor, number, options?.numericSeparator ?? inspectDefaultOptions.numericSeparator);
}
function formatBigIntNoColor(bigint, options) {
  return formatBigInt(stylizeNoColor, bigint, options?.numericSeparator ?? inspectDefaultOptions.numericSeparator);
}
function formatWithOptionsInternal(inspectOptions, args) {
  const first = args[0];
  let a = 0;
  let str = "";
  let join12 = "";
  if (typeof first === "string") {
    if (args.length === 1) {
      return first;
    }
    let tempStr;
    let lastPos = 0;
    for (let i = 0; i < first.length - 1; i++) {
      if (first.charCodeAt(i) === 37) {
        const nextChar = first.charCodeAt(++i);
        if (a + 1 !== args.length) {
          switch (nextChar) {
            case 115:
              const tempArg = args[++a];
              if (typeof tempArg === "number") {
                tempStr = formatNumberNoColor(tempArg, inspectOptions);
              } else if (typeof tempArg === "bigint") {
                tempStr = formatBigIntNoColor(tempArg, inspectOptions);
              } else if (typeof tempArg !== "object" || tempArg === null || !hasBuiltInToString(tempArg)) {
                tempStr = String(tempArg);
              } else {
                tempStr = inspect(tempArg, {
                  ...inspectOptions,
                  compact: 3,
                  colors: false,
                  depth: 0
                });
              }
              break;
            case 106:
              tempStr = tryStringify(args[++a]);
              break;
            case 100:
              const tempNum = args[++a];
              if (typeof tempNum === "bigint") {
                tempStr = formatBigIntNoColor(tempNum, inspectOptions);
              } else if (typeof tempNum === "symbol") {
                tempStr = "NaN";
              } else {
                tempStr = formatNumberNoColor(Number(tempNum), inspectOptions);
              }
              break;
            case 79:
              tempStr = inspect(args[++a], inspectOptions);
              break;
            case 111:
              tempStr = inspect(args[++a], {
                ...inspectOptions,
                showHidden: true,
                showProxy: true,
                depth: 4
              });
              break;
            case 105:
              const tempInteger = args[++a];
              if (typeof tempInteger === "bigint") {
                tempStr = formatBigIntNoColor(tempInteger, inspectOptions);
              } else if (typeof tempInteger === "symbol") {
                tempStr = "NaN";
              } else {
                tempStr = formatNumberNoColor(Number.parseInt(tempInteger), inspectOptions);
              }
              break;
            case 102:
              const tempFloat = args[++a];
              if (typeof tempFloat === "symbol") {
                tempStr = "NaN";
              } else {
                tempStr = formatNumberNoColor(Number.parseFloat(tempFloat), inspectOptions);
              }
              break;
            case 99:
              a += 1;
              tempStr = "";
              break;
            case 37:
              str += first.slice(lastPos, i);
              lastPos = i + 1;
              continue;
            default:
              continue;
          }
          if (lastPos !== i - 1) {
            str += first.slice(lastPos, i - 1);
          }
          str += tempStr;
          lastPos = i + 1;
        } else if (nextChar === 37) {
          str += first.slice(lastPos, i);
          lastPos = i + 1;
        }
      }
    }
    if (lastPos !== 0) {
      a++;
      join12 = " ";
      if (lastPos < first.length) {
        str += first.slice(lastPos);
      }
    }
  }
  while (a < args.length) {
    const value = args[a];
    str += join12;
    str += typeof value !== "string" ? inspect(value, inspectOptions) : value;
    join12 = " ";
    a++;
  }
  return str;
}
function stripVTControlCharacters(str) {
  validateString(str, "str");
  return str.replace(ansi, "");
}

// deno:https://deno.land/std@0.147.0/node/internal/util.mjs
var customInspectSymbol2 = Symbol.for("nodejs.util.inspect.custom");
var kEnumerableProperty = /* @__PURE__ */ Object.create(null);
kEnumerableProperty.enumerable = true;
function once(callback) {
  let called = false;
  return function(...args) {
    if (called)
      return;
    called = true;
    Reflect.apply(callback, this, args);
  };
}
function createDeferredPromise() {
  let resolve7;
  let reject;
  const promise = new Promise((res, rej) => {
    resolve7 = res;
    reject = rej;
  });
  return { promise, resolve: resolve7, reject };
}
var codesWarned = /* @__PURE__ */ new Set();
function deprecate(fn, msg, code2) {
  if (code2 !== void 0) {
    validateString(code2, "code");
  }
  let warned = false;
  function deprecated(...args) {
    if (!warned) {
      warned = true;
      if (code2 !== void 0) {
        if (!codesWarned.has(code2)) {
          process.emitWarning(msg, "DeprecationWarning", code2, deprecated);
          codesWarned.add(code2);
        }
      } else {
        process.emitWarning(msg, "DeprecationWarning", deprecated);
      }
    }
    if (new.target) {
      return Reflect.construct(fn, args, new.target);
    }
    return Reflect.apply(fn, this, args);
  }
  Object.setPrototypeOf(deprecated, fn);
  if (fn.prototype) {
    deprecated.prototype = fn.prototype;
  }
  return deprecated;
}
var kCustomPromisifiedSymbol = Symbol.for("nodejs.util.promisify.custom");
var kCustomPromisifyArgsSymbol = Symbol.for("nodejs.util.promisify.customArgs");
function promisify(original) {
  validateFunction(original, "original");
  if (original[kCustomPromisifiedSymbol]) {
    const fn2 = original[kCustomPromisifiedSymbol];
    validateFunction(fn2, "util.promisify.custom");
    return Object.defineProperty(fn2, kCustomPromisifiedSymbol, {
      value: fn2,
      enumerable: false,
      writable: false,
      configurable: true
    });
  }
  const argumentNames = original[kCustomPromisifyArgsSymbol];
  function fn(...args) {
    return new Promise((resolve7, reject) => {
      args.push((err, ...values) => {
        if (err) {
          return reject(err);
        }
        if (argumentNames !== void 0 && values.length > 1) {
          const obj2 = {};
          for (let i = 0; i < argumentNames.length; i++) {
            obj2[argumentNames[i]] = values[i];
          }
          resolve7(obj2);
        } else {
          resolve7(values[0]);
        }
      });
      Reflect.apply(original, this, args);
    });
  }
  Object.setPrototypeOf(fn, Object.getPrototypeOf(original));
  Object.defineProperty(fn, kCustomPromisifiedSymbol, {
    value: fn,
    enumerable: false,
    writable: false,
    configurable: true
  });
  return Object.defineProperties(fn, Object.getOwnPropertyDescriptors(original));
}
promisify.custom = kCustomPromisifiedSymbol;

// deno:https://deno.land/std@0.147.0/node/_core.ts
var core;
if (Deno?.core) {
  core = Deno.core;
} else {
  core = {
    setNextTickCallback: void 0,
    evalContext(_code, _filename) {
      throw new Error("Deno.core.evalContext is not supported in this environment");
    },
    encode(chunk) {
      return new TextEncoder().encode(chunk);
    }
  };
}

// deno:https://deno.land/std@0.147.0/node/_process/exiting.ts
var _exiting = false;

// deno:https://deno.land/std@0.147.0/node/internal/fixed_queue.ts
var kSize = 2048;
var kMask = kSize - 1;
var FixedCircularBuffer = class {
  constructor() {
    this.bottom = 0;
    this.top = 0;
    this.list = new Array(kSize);
    this.next = null;
  }
  isEmpty() {
    return this.top === this.bottom;
  }
  isFull() {
    return (this.top + 1 & kMask) === this.bottom;
  }
  push(data) {
    this.list[this.top] = data;
    this.top = this.top + 1 & kMask;
  }
  shift() {
    const nextItem = this.list[this.bottom];
    if (nextItem === void 0) {
      return null;
    }
    this.list[this.bottom] = void 0;
    this.bottom = this.bottom + 1 & kMask;
    return nextItem;
  }
};
var FixedQueue = class {
  constructor() {
    this.head = this.tail = new FixedCircularBuffer();
  }
  isEmpty() {
    return this.head.isEmpty();
  }
  push(data) {
    if (this.head.isFull()) {
      this.head = this.head.next = new FixedCircularBuffer();
    }
    this.head.push(data);
  }
  shift() {
    const tail = this.tail;
    const next = tail.shift();
    if (tail.isEmpty() && tail.next !== null) {
      this.tail = tail.next;
    }
    return next;
  }
};

// deno:https://deno.land/std@0.147.0/node/_next_tick.ts
var queue = new FixedQueue();
var _nextTick;
if (typeof core.setNextTickCallback !== "undefined") {
  let runNextTicks = function() {
    if (!core.hasTickScheduled()) {
      core.runMicrotasks();
    }
    if (!core.hasTickScheduled()) {
      return true;
    }
    processTicksAndRejections();
    return true;
  }, processTicksAndRejections = function() {
    let tock;
    do {
      while (tock = queue.shift()) {
        try {
          const callback = tock.callback;
          if (tock.args === void 0) {
            callback();
          } else {
            const args = tock.args;
            switch (args.length) {
              case 1:
                callback(args[0]);
                break;
              case 2:
                callback(args[0], args[1]);
                break;
              case 3:
                callback(args[0], args[1], args[2]);
                break;
              case 4:
                callback(args[0], args[1], args[2], args[3]);
                break;
              default:
                callback(...args);
            }
          }
        } finally {
        }
      }
      core.runMicrotasks();
    } while (!queue.isEmpty());
    core.setHasTickScheduled(false);
  }, __nextTickNative = function(callback, ...args) {
    validateCallback(callback);
    if (_exiting) {
      return;
    }
    let args_;
    switch (args.length) {
      case 0:
        break;
      case 1:
        args_ = [args[0]];
        break;
      case 2:
        args_ = [args[0], args[1]];
        break;
      case 3:
        args_ = [args[0], args[1], args[2]];
        break;
      default:
        args_ = new Array(args.length);
        for (let i = 0; i < args.length; i++) {
          args_[i] = args[i];
        }
    }
    if (queue.isEmpty()) {
      core.setHasTickScheduled(true);
    }
    const tickObject = {
      callback,
      args: args_
    };
    queue.push(tickObject);
  };
  core.setNextTickCallback(processTicksAndRejections);
  core.setMacrotaskCallback(runNextTicks);
  _nextTick = __nextTickNative;
} else {
  let __nextTickQueueMicrotask = function(callback, ...args) {
    if (args) {
      queueMicrotask(() => callback.call(this, ...args));
    } else {
      queueMicrotask(callback);
    }
  };
  _nextTick = __nextTickQueueMicrotask;
}
function nextTick2(callback, ...args) {
  _nextTick(callback, ...args);
}

// deno:https://deno.land/std@0.147.0/node/_util/_util_callbackify.ts
var NodeFalsyValueRejectionError = class extends Error {
  constructor(reason) {
    super("Promise was rejected with falsy value");
    this.code = "ERR_FALSY_VALUE_REJECTION";
    this.reason = reason;
  }
};
var NodeInvalidArgTypeError = class extends TypeError {
  constructor(argumentName) {
    super(`The ${argumentName} argument must be of type function.`);
    this.code = "ERR_INVALID_ARG_TYPE";
  }
};
function callbackify(original) {
  if (typeof original !== "function") {
    throw new NodeInvalidArgTypeError('"original"');
  }
  const callbackified = function(...args) {
    const maybeCb = args.pop();
    if (typeof maybeCb !== "function") {
      throw new NodeInvalidArgTypeError("last");
    }
    const cb = (...args2) => {
      maybeCb.apply(this, args2);
    };
    original.apply(this, args).then((ret) => {
      nextTick2(cb.bind(this, null, ret));
    }, (rej) => {
      rej = rej || new NodeFalsyValueRejectionError(rej);
      nextTick2(cb.bind(this, rej));
    });
  };
  const descriptors = Object.getOwnPropertyDescriptors(original);
  if (typeof descriptors.length.value === "number") {
    descriptors.length.value++;
  }
  if (typeof descriptors.name.value === "string") {
    descriptors.name.value += "Callbackified";
  }
  Object.defineProperties(callbackified, descriptors);
  return callbackified;
}

// deno:https://deno.land/std@0.147.0/fmt/printf.ts
var Flags = class {
  constructor() {
    this.width = -1;
    this.precision = -1;
  }
};
var min = Math.min;
var UNICODE_REPLACEMENT_CHARACTER = "\uFFFD";
var DEFAULT_PRECISION = 6;
var FLOAT_REGEXP = /(-?)(\d)\.?(\d*)e([+-])(\d+)/;
var Printf = class {
  constructor(format11, ...args) {
    this.state = 0 /* PASSTHROUGH */;
    this.verb = "";
    this.buf = "";
    this.argNum = 0;
    this.flags = new Flags();
    this.format = format11;
    this.args = args;
    this.haveSeen = Array.from({ length: args.length });
    this.i = 0;
  }
  doPrintf() {
    for (; this.i < this.format.length; ++this.i) {
      const c5 = this.format[this.i];
      switch (this.state) {
        case 0 /* PASSTHROUGH */:
          if (c5 === "%") {
            this.state = 1 /* PERCENT */;
          } else {
            this.buf += c5;
          }
          break;
        case 1 /* PERCENT */:
          if (c5 === "%") {
            this.buf += c5;
            this.state = 0 /* PASSTHROUGH */;
          } else {
            this.handleFormat();
          }
          break;
        default:
          throw Error("Should be unreachable, certainly a bug in the lib.");
      }
    }
    let extras = false;
    let err = "%!(EXTRA";
    for (let i = 0; i !== this.haveSeen.length; ++i) {
      if (!this.haveSeen[i]) {
        extras = true;
        err += ` '${Deno.inspect(this.args[i])}'`;
      }
    }
    err += ")";
    if (extras) {
      this.buf += err;
    }
    return this.buf;
  }
  handleFormat() {
    this.flags = new Flags();
    const flags = this.flags;
    for (; this.i < this.format.length; ++this.i) {
      const c5 = this.format[this.i];
      switch (this.state) {
        case 1 /* PERCENT */:
          switch (c5) {
            case "[":
              this.handlePositional();
              this.state = 2 /* POSITIONAL */;
              break;
            case "+":
              flags.plus = true;
              break;
            case "<":
              flags.lessthan = true;
              break;
            case "-":
              flags.dash = true;
              flags.zero = false;
              break;
            case "#":
              flags.sharp = true;
              break;
            case " ":
              flags.space = true;
              break;
            case "0":
              flags.zero = !flags.dash;
              break;
            default:
              if ("1" <= c5 && c5 <= "9" || c5 === "." || c5 === "*") {
                if (c5 === ".") {
                  this.flags.precision = 0;
                  this.state = 3 /* PRECISION */;
                  this.i++;
                } else {
                  this.state = 4 /* WIDTH */;
                }
                this.handleWidthAndPrecision(flags);
              } else {
                this.handleVerb();
                return;
              }
          }
          break;
        case 2 /* POSITIONAL */:
          if (c5 === "*") {
            const worp = this.flags.precision === -1 ? 0 /* WIDTH */ : 1 /* PRECISION */;
            this.handleWidthOrPrecisionRef(worp);
            this.state = 1 /* PERCENT */;
            break;
          } else {
            this.handleVerb();
            return;
          }
        default:
          throw new Error(`Should not be here ${this.state}, library bug!`);
      }
    }
  }
  handleWidthOrPrecisionRef(wOrP) {
    if (this.argNum >= this.args.length) {
      return;
    }
    const arg = this.args[this.argNum];
    this.haveSeen[this.argNum] = true;
    if (typeof arg === "number") {
      switch (wOrP) {
        case 0 /* WIDTH */:
          this.flags.width = arg;
          break;
        default:
          this.flags.precision = arg;
      }
    } else {
      const tmp = wOrP === 0 /* WIDTH */ ? "WIDTH" : "PREC";
      this.tmpError = `%!(BAD ${tmp} '${this.args[this.argNum]}')`;
    }
    this.argNum++;
  }
  handleWidthAndPrecision(flags) {
    const fmt = this.format;
    for (; this.i !== this.format.length; ++this.i) {
      const c5 = fmt[this.i];
      switch (this.state) {
        case 4 /* WIDTH */:
          switch (c5) {
            case ".":
              this.flags.precision = 0;
              this.state = 3 /* PRECISION */;
              break;
            case "*":
              this.handleWidthOrPrecisionRef(0 /* WIDTH */);
              break;
            default: {
              const val = parseInt(c5);
              if (isNaN(val)) {
                this.i--;
                this.state = 1 /* PERCENT */;
                return;
              }
              flags.width = flags.width == -1 ? 0 : flags.width;
              flags.width *= 10;
              flags.width += val;
            }
          }
          break;
        case 3 /* PRECISION */: {
          if (c5 === "*") {
            this.handleWidthOrPrecisionRef(1 /* PRECISION */);
            break;
          }
          const val = parseInt(c5);
          if (isNaN(val)) {
            this.i--;
            this.state = 1 /* PERCENT */;
            return;
          }
          flags.precision *= 10;
          flags.precision += val;
          break;
        }
        default:
          throw new Error("can't be here. bug.");
      }
    }
  }
  handlePositional() {
    if (this.format[this.i] !== "[") {
      throw new Error("Can't happen? Bug.");
    }
    let positional = 0;
    const format11 = this.format;
    this.i++;
    let err = false;
    for (; this.i !== this.format.length; ++this.i) {
      if (format11[this.i] === "]") {
        break;
      }
      positional *= 10;
      const val = parseInt(format11[this.i]);
      if (isNaN(val)) {
        this.tmpError = "%!(BAD INDEX)";
        err = true;
      }
      positional += val;
    }
    if (positional - 1 >= this.args.length) {
      this.tmpError = "%!(BAD INDEX)";
      err = true;
    }
    this.argNum = err ? this.argNum : positional - 1;
    return;
  }
  handleLessThan() {
    const arg = this.args[this.argNum];
    if ((arg || {}).constructor.name !== "Array") {
      throw new Error(`arg ${arg} is not an array. Todo better error handling`);
    }
    let str = "[ ";
    for (let i = 0; i !== arg.length; ++i) {
      if (i !== 0)
        str += ", ";
      str += this._handleVerb(arg[i]);
    }
    return str + " ]";
  }
  handleVerb() {
    const verb = this.format[this.i];
    this.verb = verb;
    if (this.tmpError) {
      this.buf += this.tmpError;
      this.tmpError = void 0;
      if (this.argNum < this.haveSeen.length) {
        this.haveSeen[this.argNum] = true;
      }
    } else if (this.args.length <= this.argNum) {
      this.buf += `%!(MISSING '${verb}')`;
    } else {
      const arg = this.args[this.argNum];
      this.haveSeen[this.argNum] = true;
      if (this.flags.lessthan) {
        this.buf += this.handleLessThan();
      } else {
        this.buf += this._handleVerb(arg);
      }
    }
    this.argNum++;
    this.state = 0 /* PASSTHROUGH */;
  }
  _handleVerb(arg) {
    switch (this.verb) {
      case "t":
        return this.pad(arg.toString());
      case "b":
        return this.fmtNumber(arg, 2);
      case "c":
        return this.fmtNumberCodePoint(arg);
      case "d":
        return this.fmtNumber(arg, 10);
      case "o":
        return this.fmtNumber(arg, 8);
      case "x":
        return this.fmtHex(arg);
      case "X":
        return this.fmtHex(arg, true);
      case "e":
        return this.fmtFloatE(arg);
      case "E":
        return this.fmtFloatE(arg, true);
      case "f":
      case "F":
        return this.fmtFloatF(arg);
      case "g":
        return this.fmtFloatG(arg);
      case "G":
        return this.fmtFloatG(arg, true);
      case "s":
        return this.fmtString(arg);
      case "T":
        return this.fmtString(typeof arg);
      case "v":
        return this.fmtV(arg);
      case "j":
        return this.fmtJ(arg);
      default:
        return `%!(BAD VERB '${this.verb}')`;
    }
  }
  pad(s) {
    const padding = this.flags.zero ? "0" : " ";
    if (this.flags.dash) {
      return s.padEnd(this.flags.width, padding);
    }
    return s.padStart(this.flags.width, padding);
  }
  padNum(nStr, neg3) {
    let sign2;
    if (neg3) {
      sign2 = "-";
    } else if (this.flags.plus || this.flags.space) {
      sign2 = this.flags.plus ? "+" : " ";
    } else {
      sign2 = "";
    }
    const zero = this.flags.zero;
    if (!zero) {
      nStr = sign2 + nStr;
    }
    const pad3 = zero ? "0" : " ";
    const len = zero ? this.flags.width - sign2.length : this.flags.width;
    if (this.flags.dash) {
      nStr = nStr.padEnd(len, pad3);
    } else {
      nStr = nStr.padStart(len, pad3);
    }
    if (zero) {
      nStr = sign2 + nStr;
    }
    return nStr;
  }
  fmtNumber(n, radix, upcase = false) {
    let num = Math.abs(n).toString(radix);
    const prec = this.flags.precision;
    if (prec !== -1) {
      this.flags.zero = false;
      num = n === 0 && prec === 0 ? "" : num;
      while (num.length < prec) {
        num = "0" + num;
      }
    }
    let prefix = "";
    if (this.flags.sharp) {
      switch (radix) {
        case 2:
          prefix += "0b";
          break;
        case 8:
          prefix += num.startsWith("0") ? "" : "0";
          break;
        case 16:
          prefix += "0x";
          break;
        default:
          throw new Error("cannot handle base: " + radix);
      }
    }
    num = num.length === 0 ? num : prefix + num;
    if (upcase) {
      num = num.toUpperCase();
    }
    return this.padNum(num, n < 0);
  }
  fmtNumberCodePoint(n) {
    let s = "";
    try {
      s = String.fromCodePoint(n);
    } catch {
      s = UNICODE_REPLACEMENT_CHARACTER;
    }
    return this.pad(s);
  }
  fmtFloatSpecial(n) {
    if (isNaN(n)) {
      this.flags.zero = false;
      return this.padNum("NaN", false);
    }
    if (n === Number.POSITIVE_INFINITY) {
      this.flags.zero = false;
      this.flags.plus = true;
      return this.padNum("Inf", false);
    }
    if (n === Number.NEGATIVE_INFINITY) {
      this.flags.zero = false;
      return this.padNum("Inf", true);
    }
    return "";
  }
  roundFractionToPrecision(fractional, precision) {
    let round = false;
    if (fractional.length > precision) {
      fractional = "1" + fractional;
      let tmp = parseInt(fractional.substr(0, precision + 2)) / 10;
      tmp = Math.round(tmp);
      fractional = Math.floor(tmp).toString();
      round = fractional[0] === "2";
      fractional = fractional.substr(1);
    } else {
      while (fractional.length < precision) {
        fractional += "0";
      }
    }
    return [fractional, round];
  }
  fmtFloatE(n, upcase = false) {
    const special = this.fmtFloatSpecial(n);
    if (special !== "") {
      return special;
    }
    const m3 = n.toExponential().match(FLOAT_REGEXP);
    if (!m3) {
      throw Error("can't happen, bug");
    }
    let fractional = m3[3 /* fractional */];
    const precision = this.flags.precision !== -1 ? this.flags.precision : DEFAULT_PRECISION;
    let rounding = false;
    [fractional, rounding] = this.roundFractionToPrecision(fractional, precision);
    let e = m3[5 /* exponent */];
    let esign = m3[4 /* esign */];
    let mantissa = parseInt(m3[2 /* mantissa */]);
    if (rounding) {
      mantissa += 1;
      if (10 <= mantissa) {
        mantissa = 1;
        const r = parseInt(esign + e) + 1;
        e = r.toString();
        esign = r < 0 ? "-" : "+";
      }
    }
    e = e.length == 1 ? "0" + e : e;
    const val = `${mantissa}.${fractional}${upcase ? "E" : "e"}${esign}${e}`;
    return this.padNum(val, n < 0);
  }
  fmtFloatF(n) {
    const special = this.fmtFloatSpecial(n);
    if (special !== "") {
      return special;
    }
    function expandNumber(n2) {
      if (Number.isSafeInteger(n2)) {
        return n2.toString() + ".";
      }
      const t = n2.toExponential().split("e");
      let m3 = t[0].replace(".", "");
      const e = parseInt(t[1]);
      if (e < 0) {
        let nStr = "0.";
        for (let i = 0; i !== Math.abs(e) - 1; ++i) {
          nStr += "0";
        }
        return nStr += m3;
      } else {
        const splIdx = e + 1;
        while (m3.length < splIdx) {
          m3 += "0";
        }
        return m3.substr(0, splIdx) + "." + m3.substr(splIdx);
      }
    }
    const val = expandNumber(Math.abs(n));
    const arr = val.split(".");
    let dig = arr[0];
    let fractional = arr[1];
    const precision = this.flags.precision !== -1 ? this.flags.precision : DEFAULT_PRECISION;
    let round = false;
    [fractional, round] = this.roundFractionToPrecision(fractional, precision);
    if (round) {
      dig = (parseInt(dig) + 1).toString();
    }
    return this.padNum(`${dig}.${fractional}`, n < 0);
  }
  fmtFloatG(n, upcase = false) {
    const special = this.fmtFloatSpecial(n);
    if (special !== "") {
      return special;
    }
    let P2 = this.flags.precision !== -1 ? this.flags.precision : DEFAULT_PRECISION;
    P2 = P2 === 0 ? 1 : P2;
    const m3 = n.toExponential().match(FLOAT_REGEXP);
    if (!m3) {
      throw Error("can't happen");
    }
    const X5 = parseInt(m3[5 /* exponent */]) * (m3[4 /* esign */] === "-" ? -1 : 1);
    let nStr = "";
    if (P2 > X5 && X5 >= -4) {
      this.flags.precision = P2 - (X5 + 1);
      nStr = this.fmtFloatF(n);
      if (!this.flags.sharp) {
        nStr = nStr.replace(/\.?0*$/, "");
      }
    } else {
      this.flags.precision = P2 - 1;
      nStr = this.fmtFloatE(n);
      if (!this.flags.sharp) {
        nStr = nStr.replace(/\.?0*e/, upcase ? "E" : "e");
      }
    }
    return nStr;
  }
  fmtString(s) {
    if (this.flags.precision !== -1) {
      s = s.substr(0, this.flags.precision);
    }
    return this.pad(s);
  }
  fmtHex(val, upper = false) {
    switch (typeof val) {
      case "number":
        return this.fmtNumber(val, 16, upper);
      case "string": {
        const sharp = this.flags.sharp && val.length !== 0;
        let hex = sharp ? "0x" : "";
        const prec = this.flags.precision;
        const end = prec !== -1 ? min(prec, val.length) : val.length;
        for (let i = 0; i !== end; ++i) {
          if (i !== 0 && this.flags.space) {
            hex += sharp ? " 0x" : " ";
          }
          const c5 = (val.charCodeAt(i) & 255).toString(16);
          hex += c5.length === 1 ? `0${c5}` : c5;
        }
        if (upper) {
          hex = hex.toUpperCase();
        }
        return this.pad(hex);
      }
      default:
        throw new Error("currently only number and string are implemented for hex");
    }
  }
  fmtV(val) {
    if (this.flags.sharp) {
      const options = this.flags.precision !== -1 ? { depth: this.flags.precision } : {};
      return this.pad(Deno.inspect(val, options));
    } else {
      const p3 = this.flags.precision;
      return p3 === -1 ? val.toString() : val.toString().substr(0, p3);
    }
  }
  fmtJ(val) {
    return JSON.stringify(val);
  }
};
function sprintf(format11, ...args) {
  const printf = new Printf(format11, ...args);
  return printf.doPrintf();
}

// deno:https://deno.land/std@0.147.0/node/internal/util/debuglog.ts
var debugImpls;
var testEnabled;
function initializeDebugEnv(debugEnv3) {
  debugImpls = /* @__PURE__ */ Object.create(null);
  if (debugEnv3) {
    debugEnv3 = debugEnv3.replace(/[|\\{}()[\]^$+?.]/g, "\\$&").replaceAll("*", ".*").replaceAll(",", "$|^");
    const debugEnvRegex = new RegExp(`^${debugEnv3}$`, "i");
    testEnabled = (str) => debugEnvRegex.exec(str) !== null;
  } else {
    testEnabled = () => false;
  }
}
function emitWarningIfNeeded(set) {
  if (set === "HTTP" || set === "HTTP2") {
    console.warn("Setting the NODE_DEBUG environment variable to '" + set.toLowerCase() + "' can expose sensitive data (such as passwords, tokens and authentication headers) in the resulting log.");
  }
}
var noop = () => {
};
function debuglogImpl(enabled2, set) {
  if (debugImpls[set] === void 0) {
    if (enabled2) {
      emitWarningIfNeeded(set);
      debugImpls[set] = function debug2(...args) {
        const msg = args.map((arg) => inspect(arg)).join(" ");
        console.error(sprintf("%s %s: %s", set, String(Deno.pid), msg));
      };
    } else {
      debugImpls[set] = noop;
    }
  }
  return debugImpls[set];
}
function debuglog(set, cb) {
  function init4() {
    set = set.toUpperCase();
    enabled2 = testEnabled(set);
  }
  let debug2 = (...args) => {
    init4();
    debug2 = debuglogImpl(enabled2, set);
    if (typeof cb === "function") {
      cb(debug2);
    }
    return debug2(...args);
  };
  let enabled2;
  let test = () => {
    init4();
    test = () => enabled2;
    return enabled2;
  };
  const logger = (...args) => debug2(...args);
  Object.defineProperty(logger, "enabled", {
    get() {
      return test();
    },
    configurable: true,
    enumerable: true
  });
  return logger;
}
var debugEnv;
try {
  debugEnv = Deno.env.get("NODE_DEBUG") ?? "";
} catch (error3) {
  if (error3 instanceof Deno.errors.PermissionDenied) {
    debugEnv = "";
  } else {
    throw error3;
  }
}
initializeDebugEnv(debugEnv);

// deno:https://deno.land/std@0.147.0/node/internal_binding/uv.ts
var uv_exports = {};
__export(uv_exports, {
  UV_EAI_MEMORY: () => UV_EAI_MEMORY,
  UV_EBADF: () => UV_EBADF,
  UV_EEXIST: () => UV_EEXIST,
  UV_EINVAL: () => UV_EINVAL,
  UV_ENOENT: () => UV_ENOENT,
  UV_ENOTSOCK: () => UV_ENOTSOCK,
  UV_UNKNOWN: () => UV_UNKNOWN,
  codeMap: () => codeMap,
  errorMap: () => errorMap,
  mapSysErrnoToUvErrno: () => mapSysErrnoToUvErrno
});

// deno:https://deno.land/std@0.147.0/_util/os.ts
var osType = (() => {
  const { Deno: Deno4 } = globalThis;
  if (typeof Deno4?.build?.os === "string") {
    return Deno4.build.os;
  }
  const { navigator } = globalThis;
  if (navigator?.appVersion?.includes?.("Win")) {
    return "windows";
  }
  return "linux";
})();
var isWindows = osType === "windows";
var isLinux = osType === "linux";

// deno:https://deno.land/std@0.147.0/node/internal_binding/_winerror.ts
var ERROR_INVALID_FUNCTION = 1;
var ERROR_FILE_NOT_FOUND = 2;
var ERROR_PATH_NOT_FOUND = 3;
var ERROR_TOO_MANY_OPEN_FILES = 4;
var ERROR_ACCESS_DENIED = 5;
var ERROR_INVALID_HANDLE = 6;
var ERROR_NOT_ENOUGH_MEMORY = 8;
var ERROR_INVALID_DATA = 13;
var ERROR_OUTOFMEMORY = 14;
var ERROR_INVALID_DRIVE = 15;
var ERROR_NOT_SAME_DEVICE = 17;
var ERROR_WRITE_PROTECT = 19;
var ERROR_CRC = 23;
var ERROR_GEN_FAILURE = 31;
var ERROR_SHARING_VIOLATION = 32;
var ERROR_LOCK_VIOLATION = 33;
var ERROR_HANDLE_DISK_FULL = 39;
var ERROR_NOT_SUPPORTED = 50;
var ERROR_NETNAME_DELETED = 64;
var ERROR_FILE_EXISTS = 80;
var ERROR_CANNOT_MAKE = 82;
var ERROR_INVALID_PARAMETER = 87;
var ERROR_BROKEN_PIPE = 109;
var ERROR_OPEN_FAILED = 110;
var ERROR_BUFFER_OVERFLOW = 111;
var ERROR_DISK_FULL = 112;
var ERROR_SEM_TIMEOUT = 121;
var ERROR_INSUFFICIENT_BUFFER = 122;
var ERROR_INVALID_NAME = 123;
var ERROR_MOD_NOT_FOUND = 126;
var ERROR_DIR_NOT_EMPTY = 145;
var ERROR_SIGNAL_REFUSED = 156;
var ERROR_BAD_PATHNAME = 161;
var ERROR_ALREADY_EXISTS = 183;
var ERROR_ENVVAR_NOT_FOUND = 203;
var ERROR_NO_SIGNAL_SENT = 205;
var ERROR_FILENAME_EXCED_RANGE = 206;
var ERROR_META_EXPANSION_TOO_LONG = 208;
var ERROR_BAD_PIPE = 230;
var ERROR_PIPE_BUSY = 231;
var ERROR_NO_DATA = 232;
var ERROR_PIPE_NOT_CONNECTED = 233;
var ERROR_DIRECTORY = 267;
var ERROR_EA_TABLE_FULL = 277;
var ERROR_OPERATION_ABORTED = 995;
var ERROR_NOACCESS = 998;
var ERROR_INVALID_FLAGS = 1004;
var ERROR_END_OF_MEDIA = 1100;
var ERROR_FILEMARK_DETECTED = 1101;
var ERROR_BEGINNING_OF_MEDIA = 1102;
var ERROR_SETMARK_DETECTED = 1103;
var ERROR_NO_DATA_DETECTED = 1104;
var ERROR_INVALID_BLOCK_LENGTH = 1106;
var ERROR_BUS_RESET = 1111;
var ERROR_NO_UNICODE_TRANSLATION = 1113;
var ERROR_IO_DEVICE = 1117;
var ERROR_EOM_OVERFLOW = 1129;
var ERROR_DEVICE_REQUIRES_CLEANING = 1165;
var ERROR_DEVICE_DOOR_OPEN = 1166;
var ERROR_CONNECTION_REFUSED = 1225;
var ERROR_ADDRESS_ALREADY_ASSOCIATED = 1227;
var ERROR_NETWORK_UNREACHABLE = 1231;
var ERROR_HOST_UNREACHABLE = 1232;
var ERROR_CONNECTION_ABORTED = 1236;
var ERROR_PRIVILEGE_NOT_HELD = 1314;
var ERROR_DISK_CORRUPT = 1393;
var ERROR_CANT_ACCESS_FILE = 1920;
var ERROR_CANT_RESOLVE_FILENAME = 1921;
var ERROR_NOT_CONNECTED = 2250;
var ERROR_INVALID_REPARSE_DATA = 4392;
var WSAEINTR = 10004;
var WSAEACCES = 10013;
var WSAEFAULT = 10014;
var WSAEINVAL = 10022;
var WSAEMFILE = 10024;
var WSAEWOULDBLOCK = 10035;
var WSAEALREADY = 10037;
var WSAENOTSOCK = 10038;
var WSAEMSGSIZE = 10040;
var WSAEPROTONOSUPPORT = 10043;
var WSAESOCKTNOSUPPORT = 10044;
var WSAEPFNOSUPPORT = 10046;
var WSAEAFNOSUPPORT = 10047;
var WSAEADDRINUSE = 10048;
var WSAEADDRNOTAVAIL = 10049;
var WSAENETUNREACH = 10051;
var WSAECONNABORTED = 10053;
var WSAECONNRESET = 10054;
var WSAENOBUFS = 10055;
var WSAEISCONN = 10056;
var WSAENOTCONN = 10057;
var WSAESHUTDOWN = 10058;
var WSAETIMEDOUT = 10060;
var WSAECONNREFUSED = 10061;
var WSAEHOSTUNREACH = 10065;
var WSAHOST_NOT_FOUND = 11001;
var WSANO_DATA = 11004;

// deno:https://deno.land/std@0.147.0/node/internal_binding/_libuv_winerror.ts
function uvTranslateSysError(sysErrno) {
  switch (sysErrno) {
    case ERROR_ACCESS_DENIED:
      return "EACCES";
    case ERROR_NOACCESS:
      return "EACCES";
    case WSAEACCES:
      return "EACCES";
    case ERROR_CANT_ACCESS_FILE:
      return "EACCES";
    case ERROR_ADDRESS_ALREADY_ASSOCIATED:
      return "EADDRINUSE";
    case WSAEADDRINUSE:
      return "EADDRINUSE";
    case WSAEADDRNOTAVAIL:
      return "EADDRNOTAVAIL";
    case WSAEAFNOSUPPORT:
      return "EAFNOSUPPORT";
    case WSAEWOULDBLOCK:
      return "EAGAIN";
    case WSAEALREADY:
      return "EALREADY";
    case ERROR_INVALID_FLAGS:
      return "EBADF";
    case ERROR_INVALID_HANDLE:
      return "EBADF";
    case ERROR_LOCK_VIOLATION:
      return "EBUSY";
    case ERROR_PIPE_BUSY:
      return "EBUSY";
    case ERROR_SHARING_VIOLATION:
      return "EBUSY";
    case ERROR_OPERATION_ABORTED:
      return "ECANCELED";
    case WSAEINTR:
      return "ECANCELED";
    case ERROR_NO_UNICODE_TRANSLATION:
      return "ECHARSET";
    case ERROR_CONNECTION_ABORTED:
      return "ECONNABORTED";
    case WSAECONNABORTED:
      return "ECONNABORTED";
    case ERROR_CONNECTION_REFUSED:
      return "ECONNREFUSED";
    case WSAECONNREFUSED:
      return "ECONNREFUSED";
    case ERROR_NETNAME_DELETED:
      return "ECONNRESET";
    case WSAECONNRESET:
      return "ECONNRESET";
    case ERROR_ALREADY_EXISTS:
      return "EEXIST";
    case ERROR_FILE_EXISTS:
      return "EEXIST";
    case ERROR_BUFFER_OVERFLOW:
      return "EFAULT";
    case WSAEFAULT:
      return "EFAULT";
    case ERROR_HOST_UNREACHABLE:
      return "EHOSTUNREACH";
    case WSAEHOSTUNREACH:
      return "EHOSTUNREACH";
    case ERROR_INSUFFICIENT_BUFFER:
      return "EINVAL";
    case ERROR_INVALID_DATA:
      return "EINVAL";
    case ERROR_INVALID_NAME:
      return "EINVAL";
    case ERROR_INVALID_PARAMETER:
      return "EINVAL";
    case WSAEINVAL:
      return "EINVAL";
    case WSAEPFNOSUPPORT:
      return "EINVAL";
    case ERROR_BEGINNING_OF_MEDIA:
      return "EIO";
    case ERROR_BUS_RESET:
      return "EIO";
    case ERROR_CRC:
      return "EIO";
    case ERROR_DEVICE_DOOR_OPEN:
      return "EIO";
    case ERROR_DEVICE_REQUIRES_CLEANING:
      return "EIO";
    case ERROR_DISK_CORRUPT:
      return "EIO";
    case ERROR_EOM_OVERFLOW:
      return "EIO";
    case ERROR_FILEMARK_DETECTED:
      return "EIO";
    case ERROR_GEN_FAILURE:
      return "EIO";
    case ERROR_INVALID_BLOCK_LENGTH:
      return "EIO";
    case ERROR_IO_DEVICE:
      return "EIO";
    case ERROR_NO_DATA_DETECTED:
      return "EIO";
    case ERROR_NO_SIGNAL_SENT:
      return "EIO";
    case ERROR_OPEN_FAILED:
      return "EIO";
    case ERROR_SETMARK_DETECTED:
      return "EIO";
    case ERROR_SIGNAL_REFUSED:
      return "EIO";
    case WSAEISCONN:
      return "EISCONN";
    case ERROR_CANT_RESOLVE_FILENAME:
      return "ELOOP";
    case ERROR_TOO_MANY_OPEN_FILES:
      return "EMFILE";
    case WSAEMFILE:
      return "EMFILE";
    case WSAEMSGSIZE:
      return "EMSGSIZE";
    case ERROR_FILENAME_EXCED_RANGE:
      return "ENAMETOOLONG";
    case ERROR_NETWORK_UNREACHABLE:
      return "ENETUNREACH";
    case WSAENETUNREACH:
      return "ENETUNREACH";
    case WSAENOBUFS:
      return "ENOBUFS";
    case ERROR_BAD_PATHNAME:
      return "ENOENT";
    case ERROR_DIRECTORY:
      return "ENOTDIR";
    case ERROR_ENVVAR_NOT_FOUND:
      return "ENOENT";
    case ERROR_FILE_NOT_FOUND:
      return "ENOENT";
    case ERROR_INVALID_DRIVE:
      return "ENOENT";
    case ERROR_INVALID_REPARSE_DATA:
      return "ENOENT";
    case ERROR_MOD_NOT_FOUND:
      return "ENOENT";
    case ERROR_PATH_NOT_FOUND:
      return "ENOENT";
    case WSAHOST_NOT_FOUND:
      return "ENOENT";
    case WSANO_DATA:
      return "ENOENT";
    case ERROR_NOT_ENOUGH_MEMORY:
      return "ENOMEM";
    case ERROR_OUTOFMEMORY:
      return "ENOMEM";
    case ERROR_CANNOT_MAKE:
      return "ENOSPC";
    case ERROR_DISK_FULL:
      return "ENOSPC";
    case ERROR_EA_TABLE_FULL:
      return "ENOSPC";
    case ERROR_END_OF_MEDIA:
      return "ENOSPC";
    case ERROR_HANDLE_DISK_FULL:
      return "ENOSPC";
    case ERROR_NOT_CONNECTED:
      return "ENOTCONN";
    case WSAENOTCONN:
      return "ENOTCONN";
    case ERROR_DIR_NOT_EMPTY:
      return "ENOTEMPTY";
    case WSAENOTSOCK:
      return "ENOTSOCK";
    case ERROR_NOT_SUPPORTED:
      return "ENOTSUP";
    case ERROR_BROKEN_PIPE:
      return "EOF";
    case ERROR_PRIVILEGE_NOT_HELD:
      return "EPERM";
    case ERROR_BAD_PIPE:
      return "EPIPE";
    case ERROR_NO_DATA:
      return "EPIPE";
    case ERROR_PIPE_NOT_CONNECTED:
      return "EPIPE";
    case WSAESHUTDOWN:
      return "EPIPE";
    case WSAEPROTONOSUPPORT:
      return "EPROTONOSUPPORT";
    case ERROR_WRITE_PROTECT:
      return "EROFS";
    case ERROR_SEM_TIMEOUT:
      return "ETIMEDOUT";
    case WSAETIMEDOUT:
      return "ETIMEDOUT";
    case ERROR_NOT_SAME_DEVICE:
      return "EXDEV";
    case ERROR_INVALID_FUNCTION:
      return "EISDIR";
    case ERROR_META_EXPANSION_TOO_LONG:
      return "E2BIG";
    case WSAESOCKTNOSUPPORT:
      return "ESOCKTNOSUPPORT";
    default:
      return "UNKNOWN";
  }
}

// deno:https://deno.land/std@0.147.0/node/internal_binding/constants.ts
var constants_exports = {};
__export(constants_exports, {
  crypto: () => crypto,
  fs: () => fs,
  os: () => os,
  trace: () => trace,
  zlib: () => zlib
});
var os = {
  UV_UDP_IPV6ONLY: 1,
  UV_UDP_PARTIAL: 2,
  UV_UDP_REUSEADDR: 4,
  UV_UDP_MMSG_CHUNK: 8,
  UV_UDP_MMSG_FREE: 16,
  UV_UDP_LINUX_RECVERR: 32,
  UV_UDP_RECVMMSG: 256,
  dlopen: {
    RTLD_LAZY: 1,
    RTLD_NOW: 2,
    RTLD_GLOBAL: 8,
    RTLD_LOCAL: 4
  },
  errno: {
    E2BIG: 7,
    EACCES: 13,
    EADDRINUSE: 48,
    EADDRNOTAVAIL: 49,
    EAFNOSUPPORT: 47,
    EAGAIN: 35,
    EALREADY: 37,
    EBADF: 9,
    EBADMSG: 94,
    EBUSY: 16,
    ECANCELED: 89,
    ECHILD: 10,
    ECONNABORTED: 53,
    ECONNREFUSED: 61,
    ECONNRESET: 54,
    EDEADLK: 11,
    EDESTADDRREQ: 39,
    EDOM: 33,
    EDQUOT: 69,
    EEXIST: 17,
    EFAULT: 14,
    EFBIG: 27,
    EHOSTUNREACH: 65,
    EIDRM: 90,
    EILSEQ: 92,
    EINPROGRESS: 36,
    EINTR: 4,
    EINVAL: 22,
    EIO: 5,
    EISCONN: 56,
    EISDIR: 21,
    ELOOP: 62,
    EMFILE: 24,
    EMLINK: 31,
    EMSGSIZE: 40,
    EMULTIHOP: 95,
    ENAMETOOLONG: 63,
    ENETDOWN: 50,
    ENETRESET: 52,
    ENETUNREACH: 51,
    ENFILE: 23,
    ENOBUFS: 55,
    ENODATA: 96,
    ENODEV: 19,
    ENOENT: 2,
    ENOEXEC: 8,
    ENOLCK: 77,
    ENOLINK: 97,
    ENOMEM: 12,
    ENOMSG: 91,
    ENOPROTOOPT: 42,
    ENOSPC: 28,
    ENOSR: 98,
    ENOSTR: 99,
    ENOSYS: 78,
    ENOTCONN: 57,
    ENOTDIR: 20,
    ENOTEMPTY: 66,
    ENOTSOCK: 38,
    ENOTSUP: 45,
    ENOTTY: 25,
    ENXIO: 6,
    EOPNOTSUPP: 102,
    EOVERFLOW: 84,
    EPERM: 1,
    EPIPE: 32,
    EPROTO: 100,
    EPROTONOSUPPORT: 43,
    EPROTOTYPE: 41,
    ERANGE: 34,
    EROFS: 30,
    ESPIPE: 29,
    ESRCH: 3,
    ESTALE: 70,
    ETIME: 101,
    ETIMEDOUT: 60,
    ETXTBSY: 26,
    EWOULDBLOCK: 35,
    EXDEV: 18
  },
  signals: {
    SIGHUP: 1,
    SIGINT: 2,
    SIGQUIT: 3,
    SIGILL: 4,
    SIGTRAP: 5,
    SIGABRT: 6,
    SIGIOT: 6,
    SIGBUS: 10,
    SIGFPE: 8,
    SIGKILL: 9,
    SIGUSR1: 30,
    SIGSEGV: 11,
    SIGUSR2: 31,
    SIGPIPE: 13,
    SIGALRM: 14,
    SIGTERM: 15,
    SIGCHLD: 20,
    SIGCONT: 19,
    SIGSTOP: 17,
    SIGTSTP: 18,
    SIGTTIN: 21,
    SIGBREAK: 21,
    SIGTTOU: 22,
    SIGURG: 16,
    SIGXCPU: 24,
    SIGXFSZ: 25,
    SIGVTALRM: 26,
    SIGPROF: 27,
    SIGWINCH: 28,
    SIGIO: 23,
    SIGINFO: 29,
    SIGSYS: 12,
    SIGEMT: 7,
    SIGPWR: 30,
    SIGSTKFLT: 16
  },
  priority: {
    PRIORITY_LOW: 19,
    PRIORITY_BELOW_NORMAL: 10,
    PRIORITY_NORMAL: 0,
    PRIORITY_ABOVE_NORMAL: -7,
    PRIORITY_HIGH: -14,
    PRIORITY_HIGHEST: -20
  }
};
var fs = {
  UV_FS_SYMLINK_DIR: 1,
  UV_FS_SYMLINK_JUNCTION: 2,
  O_RDONLY: 0,
  O_WRONLY: 1,
  O_RDWR: 2,
  UV_DIRENT_UNKNOWN: 0,
  UV_DIRENT_FILE: 1,
  UV_DIRENT_DIR: 2,
  UV_DIRENT_LINK: 3,
  UV_DIRENT_FIFO: 4,
  UV_DIRENT_SOCKET: 5,
  UV_DIRENT_CHAR: 6,
  UV_DIRENT_BLOCK: 7,
  S_IFMT: 61440,
  S_IFREG: 32768,
  S_IFDIR: 16384,
  S_IFCHR: 8192,
  S_IFBLK: 24576,
  S_IFIFO: 4096,
  S_IFLNK: 40960,
  S_IFSOCK: 49152,
  O_CREAT: 512,
  O_EXCL: 2048,
  UV_FS_O_FILEMAP: 0,
  O_NOCTTY: 131072,
  O_TRUNC: 1024,
  O_APPEND: 8,
  O_DIRECTORY: 1048576,
  O_NOFOLLOW: 256,
  O_SYNC: 128,
  O_DSYNC: 4194304,
  O_SYMLINK: 2097152,
  O_NONBLOCK: 4,
  S_IRWXU: 448,
  S_IRUSR: 256,
  S_IWUSR: 128,
  S_IXUSR: 64,
  S_IRWXG: 56,
  S_IRGRP: 32,
  S_IWGRP: 16,
  S_IXGRP: 8,
  S_IRWXO: 7,
  S_IROTH: 4,
  S_IWOTH: 2,
  S_IXOTH: 1,
  F_OK: 0,
  R_OK: 4,
  W_OK: 2,
  X_OK: 1,
  UV_FS_COPYFILE_EXCL: 1,
  COPYFILE_EXCL: 1,
  UV_FS_COPYFILE_FICLONE: 2,
  COPYFILE_FICLONE: 2,
  UV_FS_COPYFILE_FICLONE_FORCE: 4,
  COPYFILE_FICLONE_FORCE: 4
};
var crypto = {
  OPENSSL_VERSION_NUMBER: 269488319,
  SSL_OP_ALL: 2147485780,
  SSL_OP_ALLOW_NO_DHE_KEX: 1024,
  SSL_OP_ALLOW_UNSAFE_LEGACY_RENEGOTIATION: 262144,
  SSL_OP_CIPHER_SERVER_PREFERENCE: 4194304,
  SSL_OP_CISCO_ANYCONNECT: 32768,
  SSL_OP_COOKIE_EXCHANGE: 8192,
  SSL_OP_CRYPTOPRO_TLSEXT_BUG: 2147483648,
  SSL_OP_DONT_INSERT_EMPTY_FRAGMENTS: 2048,
  SSL_OP_EPHEMERAL_RSA: 0,
  SSL_OP_LEGACY_SERVER_CONNECT: 4,
  SSL_OP_MICROSOFT_BIG_SSLV3_BUFFER: 0,
  SSL_OP_MICROSOFT_SESS_ID_BUG: 0,
  SSL_OP_MSIE_SSLV2_RSA_PADDING: 0,
  SSL_OP_NETSCAPE_CA_DN_BUG: 0,
  SSL_OP_NETSCAPE_CHALLENGE_BUG: 0,
  SSL_OP_NETSCAPE_DEMO_CIPHER_CHANGE_BUG: 0,
  SSL_OP_NETSCAPE_REUSE_CIPHER_CHANGE_BUG: 0,
  SSL_OP_NO_COMPRESSION: 131072,
  SSL_OP_NO_ENCRYPT_THEN_MAC: 524288,
  SSL_OP_NO_QUERY_MTU: 4096,
  SSL_OP_NO_RENEGOTIATION: 1073741824,
  SSL_OP_NO_SESSION_RESUMPTION_ON_RENEGOTIATION: 65536,
  SSL_OP_NO_SSLv2: 0,
  SSL_OP_NO_SSLv3: 33554432,
  SSL_OP_NO_TICKET: 16384,
  SSL_OP_NO_TLSv1: 67108864,
  SSL_OP_NO_TLSv1_1: 268435456,
  SSL_OP_NO_TLSv1_2: 134217728,
  SSL_OP_NO_TLSv1_3: 536870912,
  SSL_OP_PKCS1_CHECK_1: 0,
  SSL_OP_PKCS1_CHECK_2: 0,
  SSL_OP_PRIORITIZE_CHACHA: 2097152,
  SSL_OP_SINGLE_DH_USE: 0,
  SSL_OP_SINGLE_ECDH_USE: 0,
  SSL_OP_SSLEAY_080_CLIENT_DH_BUG: 0,
  SSL_OP_SSLREF2_REUSE_CERT_TYPE_BUG: 0,
  SSL_OP_TLS_BLOCK_PADDING_BUG: 0,
  SSL_OP_TLS_D5_BUG: 0,
  SSL_OP_TLS_ROLLBACK_BUG: 8388608,
  ENGINE_METHOD_RSA: 1,
  ENGINE_METHOD_DSA: 2,
  ENGINE_METHOD_DH: 4,
  ENGINE_METHOD_RAND: 8,
  ENGINE_METHOD_EC: 2048,
  ENGINE_METHOD_CIPHERS: 64,
  ENGINE_METHOD_DIGESTS: 128,
  ENGINE_METHOD_PKEY_METHS: 512,
  ENGINE_METHOD_PKEY_ASN1_METHS: 1024,
  ENGINE_METHOD_ALL: 65535,
  ENGINE_METHOD_NONE: 0,
  DH_CHECK_P_NOT_SAFE_PRIME: 2,
  DH_CHECK_P_NOT_PRIME: 1,
  DH_UNABLE_TO_CHECK_GENERATOR: 4,
  DH_NOT_SUITABLE_GENERATOR: 8,
  ALPN_ENABLED: 1,
  RSA_PKCS1_PADDING: 1,
  RSA_SSLV23_PADDING: 2,
  RSA_NO_PADDING: 3,
  RSA_PKCS1_OAEP_PADDING: 4,
  RSA_X931_PADDING: 5,
  RSA_PKCS1_PSS_PADDING: 6,
  RSA_PSS_SALTLEN_DIGEST: -1,
  RSA_PSS_SALTLEN_MAX_SIGN: -2,
  RSA_PSS_SALTLEN_AUTO: -2,
  defaultCoreCipherList: "TLS_AES_256_GCM_SHA384:TLS_CHACHA20_POLY1305_SHA256:TLS_AES_128_GCM_SHA256:ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES256-GCM-SHA384:ECDHE-ECDSA-AES256-GCM-SHA384:DHE-RSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-SHA256:DHE-RSA-AES128-SHA256:ECDHE-RSA-AES256-SHA384:DHE-RSA-AES256-SHA384:ECDHE-RSA-AES256-SHA256:DHE-RSA-AES256-SHA256:HIGH:!aNULL:!eNULL:!EXPORT:!DES:!RC4:!MD5:!PSK:!SRP:!CAMELLIA",
  TLS1_VERSION: 769,
  TLS1_1_VERSION: 770,
  TLS1_2_VERSION: 771,
  TLS1_3_VERSION: 772,
  POINT_CONVERSION_COMPRESSED: 2,
  POINT_CONVERSION_UNCOMPRESSED: 4,
  POINT_CONVERSION_HYBRID: 6
};
var zlib = {
  Z_NO_FLUSH: 0,
  Z_PARTIAL_FLUSH: 1,
  Z_SYNC_FLUSH: 2,
  Z_FULL_FLUSH: 3,
  Z_FINISH: 4,
  Z_BLOCK: 5,
  Z_OK: 0,
  Z_STREAM_END: 1,
  Z_NEED_DICT: 2,
  Z_ERRNO: -1,
  Z_STREAM_ERROR: -2,
  Z_DATA_ERROR: -3,
  Z_MEM_ERROR: -4,
  Z_BUF_ERROR: -5,
  Z_VERSION_ERROR: -6,
  Z_NO_COMPRESSION: 0,
  Z_BEST_SPEED: 1,
  Z_BEST_COMPRESSION: 9,
  Z_DEFAULT_COMPRESSION: -1,
  Z_FILTERED: 1,
  Z_HUFFMAN_ONLY: 2,
  Z_RLE: 3,
  Z_FIXED: 4,
  Z_DEFAULT_STRATEGY: 0,
  ZLIB_VERNUM: 4784,
  DEFLATE: 1,
  INFLATE: 2,
  GZIP: 3,
  GUNZIP: 4,
  DEFLATERAW: 5,
  INFLATERAW: 6,
  UNZIP: 7,
  BROTLI_DECODE: 8,
  BROTLI_ENCODE: 9,
  Z_MIN_WINDOWBITS: 8,
  Z_MAX_WINDOWBITS: 15,
  Z_DEFAULT_WINDOWBITS: 15,
  Z_MIN_CHUNK: 64,
  Z_MAX_CHUNK: Infinity,
  Z_DEFAULT_CHUNK: 16384,
  Z_MIN_MEMLEVEL: 1,
  Z_MAX_MEMLEVEL: 9,
  Z_DEFAULT_MEMLEVEL: 8,
  Z_MIN_LEVEL: -1,
  Z_MAX_LEVEL: 9,
  Z_DEFAULT_LEVEL: -1,
  BROTLI_OPERATION_PROCESS: 0,
  BROTLI_OPERATION_FLUSH: 1,
  BROTLI_OPERATION_FINISH: 2,
  BROTLI_OPERATION_EMIT_METADATA: 3,
  BROTLI_PARAM_MODE: 0,
  BROTLI_MODE_GENERIC: 0,
  BROTLI_MODE_TEXT: 1,
  BROTLI_MODE_FONT: 2,
  BROTLI_DEFAULT_MODE: 0,
  BROTLI_PARAM_QUALITY: 1,
  BROTLI_MIN_QUALITY: 0,
  BROTLI_MAX_QUALITY: 11,
  BROTLI_DEFAULT_QUALITY: 11,
  BROTLI_PARAM_LGWIN: 2,
  BROTLI_MIN_WINDOW_BITS: 10,
  BROTLI_MAX_WINDOW_BITS: 24,
  BROTLI_LARGE_MAX_WINDOW_BITS: 30,
  BROTLI_DEFAULT_WINDOW: 22,
  BROTLI_PARAM_LGBLOCK: 3,
  BROTLI_MIN_INPUT_BLOCK_BITS: 16,
  BROTLI_MAX_INPUT_BLOCK_BITS: 24,
  BROTLI_PARAM_DISABLE_LITERAL_CONTEXT_MODELING: 4,
  BROTLI_PARAM_SIZE_HINT: 5,
  BROTLI_PARAM_LARGE_WINDOW: 6,
  BROTLI_PARAM_NPOSTFIX: 7,
  BROTLI_PARAM_NDIRECT: 8,
  BROTLI_DECODER_RESULT_ERROR: 0,
  BROTLI_DECODER_RESULT_SUCCESS: 1,
  BROTLI_DECODER_RESULT_NEEDS_MORE_INPUT: 2,
  BROTLI_DECODER_RESULT_NEEDS_MORE_OUTPUT: 3,
  BROTLI_DECODER_PARAM_DISABLE_RING_BUFFER_REALLOCATION: 0,
  BROTLI_DECODER_PARAM_LARGE_WINDOW: 1,
  BROTLI_DECODER_NO_ERROR: 0,
  BROTLI_DECODER_SUCCESS: 1,
  BROTLI_DECODER_NEEDS_MORE_INPUT: 2,
  BROTLI_DECODER_NEEDS_MORE_OUTPUT: 3,
  BROTLI_DECODER_ERROR_FORMAT_EXUBERANT_NIBBLE: -1,
  BROTLI_DECODER_ERROR_FORMAT_RESERVED: -2,
  BROTLI_DECODER_ERROR_FORMAT_EXUBERANT_META_NIBBLE: -3,
  BROTLI_DECODER_ERROR_FORMAT_SIMPLE_HUFFMAN_ALPHABET: -4,
  BROTLI_DECODER_ERROR_FORMAT_SIMPLE_HUFFMAN_SAME: -5,
  BROTLI_DECODER_ERROR_FORMAT_CL_SPACE: -6,
  BROTLI_DECODER_ERROR_FORMAT_HUFFMAN_SPACE: -7,
  BROTLI_DECODER_ERROR_FORMAT_CONTEXT_MAP_REPEAT: -8,
  BROTLI_DECODER_ERROR_FORMAT_BLOCK_LENGTH_1: -9,
  BROTLI_DECODER_ERROR_FORMAT_BLOCK_LENGTH_2: -10,
  BROTLI_DECODER_ERROR_FORMAT_TRANSFORM: -11,
  BROTLI_DECODER_ERROR_FORMAT_DICTIONARY: -12,
  BROTLI_DECODER_ERROR_FORMAT_WINDOW_BITS: -13,
  BROTLI_DECODER_ERROR_FORMAT_PADDING_1: -14,
  BROTLI_DECODER_ERROR_FORMAT_PADDING_2: -15,
  BROTLI_DECODER_ERROR_FORMAT_DISTANCE: -16,
  BROTLI_DECODER_ERROR_DICTIONARY_NOT_SET: -19,
  BROTLI_DECODER_ERROR_INVALID_ARGUMENTS: -20,
  BROTLI_DECODER_ERROR_ALLOC_CONTEXT_MODES: -21,
  BROTLI_DECODER_ERROR_ALLOC_TREE_GROUPS: -22,
  BROTLI_DECODER_ERROR_ALLOC_CONTEXT_MAP: -25,
  BROTLI_DECODER_ERROR_ALLOC_RING_BUFFER_1: -26,
  BROTLI_DECODER_ERROR_ALLOC_RING_BUFFER_2: -27,
  BROTLI_DECODER_ERROR_ALLOC_BLOCK_TYPE_TREES: -30,
  BROTLI_DECODER_ERROR_UNREACHABLE: -31
};
var trace = {
  TRACE_EVENT_PHASE_BEGIN: 66,
  TRACE_EVENT_PHASE_END: 69,
  TRACE_EVENT_PHASE_COMPLETE: 88,
  TRACE_EVENT_PHASE_INSTANT: 73,
  TRACE_EVENT_PHASE_ASYNC_BEGIN: 83,
  TRACE_EVENT_PHASE_ASYNC_STEP_INTO: 84,
  TRACE_EVENT_PHASE_ASYNC_STEP_PAST: 112,
  TRACE_EVENT_PHASE_ASYNC_END: 70,
  TRACE_EVENT_PHASE_NESTABLE_ASYNC_BEGIN: 98,
  TRACE_EVENT_PHASE_NESTABLE_ASYNC_END: 101,
  TRACE_EVENT_PHASE_NESTABLE_ASYNC_INSTANT: 110,
  TRACE_EVENT_PHASE_FLOW_BEGIN: 115,
  TRACE_EVENT_PHASE_FLOW_STEP: 116,
  TRACE_EVENT_PHASE_FLOW_END: 102,
  TRACE_EVENT_PHASE_METADATA: 77,
  TRACE_EVENT_PHASE_COUNTER: 67,
  TRACE_EVENT_PHASE_SAMPLE: 80,
  TRACE_EVENT_PHASE_CREATE_OBJECT: 78,
  TRACE_EVENT_PHASE_SNAPSHOT_OBJECT: 79,
  TRACE_EVENT_PHASE_DELETE_OBJECT: 68,
  TRACE_EVENT_PHASE_MEMORY_DUMP: 118,
  TRACE_EVENT_PHASE_MARK: 82,
  TRACE_EVENT_PHASE_CLOCK_SYNC: 99,
  TRACE_EVENT_PHASE_ENTER_CONTEXT: 40,
  TRACE_EVENT_PHASE_LEAVE_CONTEXT: 41,
  TRACE_EVENT_PHASE_LINK_IDS: 61
};

// deno:https://deno.land/std@0.147.0/node/internal_binding/uv.ts
var UV_EEXIST = os.errno.EEXIST;
var UV_ENOENT = os.errno.ENOENT;
var codeToErrorWindows = [
  [-4093, ["E2BIG", "argument list too long"]],
  [-4092, ["EACCES", "permission denied"]],
  [-4091, ["EADDRINUSE", "address already in use"]],
  [-4090, ["EADDRNOTAVAIL", "address not available"]],
  [-4089, ["EAFNOSUPPORT", "address family not supported"]],
  [-4088, ["EAGAIN", "resource temporarily unavailable"]],
  [-3e3, ["EAI_ADDRFAMILY", "address family not supported"]],
  [-3001, ["EAI_AGAIN", "temporary failure"]],
  [-3002, ["EAI_BADFLAGS", "bad ai_flags value"]],
  [-3013, ["EAI_BADHINTS", "invalid value for hints"]],
  [-3003, ["EAI_CANCELED", "request canceled"]],
  [-3004, ["EAI_FAIL", "permanent failure"]],
  [-3005, ["EAI_FAMILY", "ai_family not supported"]],
  [-3006, ["EAI_MEMORY", "out of memory"]],
  [-3007, ["EAI_NODATA", "no address"]],
  [-3008, ["EAI_NONAME", "unknown node or service"]],
  [-3009, ["EAI_OVERFLOW", "argument buffer overflow"]],
  [-3014, ["EAI_PROTOCOL", "resolved protocol is unknown"]],
  [-3010, ["EAI_SERVICE", "service not available for socket type"]],
  [-3011, ["EAI_SOCKTYPE", "socket type not supported"]],
  [-4084, ["EALREADY", "connection already in progress"]],
  [-4083, ["EBADF", "bad file descriptor"]],
  [-4082, ["EBUSY", "resource busy or locked"]],
  [-4081, ["ECANCELED", "operation canceled"]],
  [-4080, ["ECHARSET", "invalid Unicode character"]],
  [-4079, ["ECONNABORTED", "software caused connection abort"]],
  [-4078, ["ECONNREFUSED", "connection refused"]],
  [-4077, ["ECONNRESET", "connection reset by peer"]],
  [-4076, ["EDESTADDRREQ", "destination address required"]],
  [-4075, ["EEXIST", "file already exists"]],
  [-4074, ["EFAULT", "bad address in system call argument"]],
  [-4036, ["EFBIG", "file too large"]],
  [-4073, ["EHOSTUNREACH", "host is unreachable"]],
  [-4072, ["EINTR", "interrupted system call"]],
  [-4071, ["EINVAL", "invalid argument"]],
  [-4070, ["EIO", "i/o error"]],
  [-4069, ["EISCONN", "socket is already connected"]],
  [-4068, ["EISDIR", "illegal operation on a directory"]],
  [-4067, ["ELOOP", "too many symbolic links encountered"]],
  [-4066, ["EMFILE", "too many open files"]],
  [-4065, ["EMSGSIZE", "message too long"]],
  [-4064, ["ENAMETOOLONG", "name too long"]],
  [-4063, ["ENETDOWN", "network is down"]],
  [-4062, ["ENETUNREACH", "network is unreachable"]],
  [-4061, ["ENFILE", "file table overflow"]],
  [-4060, ["ENOBUFS", "no buffer space available"]],
  [-4059, ["ENODEV", "no such device"]],
  [-4058, ["ENOENT", "no such file or directory"]],
  [-4057, ["ENOMEM", "not enough memory"]],
  [-4056, ["ENONET", "machine is not on the network"]],
  [-4035, ["ENOPROTOOPT", "protocol not available"]],
  [-4055, ["ENOSPC", "no space left on device"]],
  [-4054, ["ENOSYS", "function not implemented"]],
  [-4053, ["ENOTCONN", "socket is not connected"]],
  [-4052, ["ENOTDIR", "not a directory"]],
  [-4051, ["ENOTEMPTY", "directory not empty"]],
  [-4050, ["ENOTSOCK", "socket operation on non-socket"]],
  [-4049, ["ENOTSUP", "operation not supported on socket"]],
  [-4048, ["EPERM", "operation not permitted"]],
  [-4047, ["EPIPE", "broken pipe"]],
  [-4046, ["EPROTO", "protocol error"]],
  [-4045, ["EPROTONOSUPPORT", "protocol not supported"]],
  [-4044, ["EPROTOTYPE", "protocol wrong type for socket"]],
  [-4034, ["ERANGE", "result too large"]],
  [-4043, ["EROFS", "read-only file system"]],
  [-4042, ["ESHUTDOWN", "cannot send after transport endpoint shutdown"]],
  [-4041, ["ESPIPE", "invalid seek"]],
  [-4040, ["ESRCH", "no such process"]],
  [-4039, ["ETIMEDOUT", "connection timed out"]],
  [-4038, ["ETXTBSY", "text file is busy"]],
  [-4037, ["EXDEV", "cross-device link not permitted"]],
  [-4094, ["UNKNOWN", "unknown error"]],
  [-4095, ["EOF", "end of file"]],
  [-4033, ["ENXIO", "no such device or address"]],
  [-4032, ["EMLINK", "too many links"]],
  [-4031, ["EHOSTDOWN", "host is down"]],
  [-4030, ["EREMOTEIO", "remote I/O error"]],
  [-4029, ["ENOTTY", "inappropriate ioctl for device"]],
  [-4028, ["EFTYPE", "inappropriate file type or format"]],
  [-4027, ["EILSEQ", "illegal byte sequence"]]
];
var errorToCodeWindows = codeToErrorWindows.map(([status, [error3]]) => [error3, status]);
var codeToErrorDarwin = [
  [-7, ["E2BIG", "argument list too long"]],
  [-13, ["EACCES", "permission denied"]],
  [-48, ["EADDRINUSE", "address already in use"]],
  [-49, ["EADDRNOTAVAIL", "address not available"]],
  [-47, ["EAFNOSUPPORT", "address family not supported"]],
  [-35, ["EAGAIN", "resource temporarily unavailable"]],
  [-3e3, ["EAI_ADDRFAMILY", "address family not supported"]],
  [-3001, ["EAI_AGAIN", "temporary failure"]],
  [-3002, ["EAI_BADFLAGS", "bad ai_flags value"]],
  [-3013, ["EAI_BADHINTS", "invalid value for hints"]],
  [-3003, ["EAI_CANCELED", "request canceled"]],
  [-3004, ["EAI_FAIL", "permanent failure"]],
  [-3005, ["EAI_FAMILY", "ai_family not supported"]],
  [-3006, ["EAI_MEMORY", "out of memory"]],
  [-3007, ["EAI_NODATA", "no address"]],
  [-3008, ["EAI_NONAME", "unknown node or service"]],
  [-3009, ["EAI_OVERFLOW", "argument buffer overflow"]],
  [-3014, ["EAI_PROTOCOL", "resolved protocol is unknown"]],
  [-3010, ["EAI_SERVICE", "service not available for socket type"]],
  [-3011, ["EAI_SOCKTYPE", "socket type not supported"]],
  [-37, ["EALREADY", "connection already in progress"]],
  [-9, ["EBADF", "bad file descriptor"]],
  [-16, ["EBUSY", "resource busy or locked"]],
  [-89, ["ECANCELED", "operation canceled"]],
  [-4080, ["ECHARSET", "invalid Unicode character"]],
  [-53, ["ECONNABORTED", "software caused connection abort"]],
  [-61, ["ECONNREFUSED", "connection refused"]],
  [-54, ["ECONNRESET", "connection reset by peer"]],
  [-39, ["EDESTADDRREQ", "destination address required"]],
  [-17, ["EEXIST", "file already exists"]],
  [-14, ["EFAULT", "bad address in system call argument"]],
  [-27, ["EFBIG", "file too large"]],
  [-65, ["EHOSTUNREACH", "host is unreachable"]],
  [-4, ["EINTR", "interrupted system call"]],
  [-22, ["EINVAL", "invalid argument"]],
  [-5, ["EIO", "i/o error"]],
  [-56, ["EISCONN", "socket is already connected"]],
  [-21, ["EISDIR", "illegal operation on a directory"]],
  [-62, ["ELOOP", "too many symbolic links encountered"]],
  [-24, ["EMFILE", "too many open files"]],
  [-40, ["EMSGSIZE", "message too long"]],
  [-63, ["ENAMETOOLONG", "name too long"]],
  [-50, ["ENETDOWN", "network is down"]],
  [-51, ["ENETUNREACH", "network is unreachable"]],
  [-23, ["ENFILE", "file table overflow"]],
  [-55, ["ENOBUFS", "no buffer space available"]],
  [-19, ["ENODEV", "no such device"]],
  [-2, ["ENOENT", "no such file or directory"]],
  [-12, ["ENOMEM", "not enough memory"]],
  [-4056, ["ENONET", "machine is not on the network"]],
  [-42, ["ENOPROTOOPT", "protocol not available"]],
  [-28, ["ENOSPC", "no space left on device"]],
  [-78, ["ENOSYS", "function not implemented"]],
  [-57, ["ENOTCONN", "socket is not connected"]],
  [-20, ["ENOTDIR", "not a directory"]],
  [-66, ["ENOTEMPTY", "directory not empty"]],
  [-38, ["ENOTSOCK", "socket operation on non-socket"]],
  [-45, ["ENOTSUP", "operation not supported on socket"]],
  [-1, ["EPERM", "operation not permitted"]],
  [-32, ["EPIPE", "broken pipe"]],
  [-100, ["EPROTO", "protocol error"]],
  [-43, ["EPROTONOSUPPORT", "protocol not supported"]],
  [-41, ["EPROTOTYPE", "protocol wrong type for socket"]],
  [-34, ["ERANGE", "result too large"]],
  [-30, ["EROFS", "read-only file system"]],
  [-58, ["ESHUTDOWN", "cannot send after transport endpoint shutdown"]],
  [-29, ["ESPIPE", "invalid seek"]],
  [-3, ["ESRCH", "no such process"]],
  [-60, ["ETIMEDOUT", "connection timed out"]],
  [-26, ["ETXTBSY", "text file is busy"]],
  [-18, ["EXDEV", "cross-device link not permitted"]],
  [-4094, ["UNKNOWN", "unknown error"]],
  [-4095, ["EOF", "end of file"]],
  [-6, ["ENXIO", "no such device or address"]],
  [-31, ["EMLINK", "too many links"]],
  [-64, ["EHOSTDOWN", "host is down"]],
  [-4030, ["EREMOTEIO", "remote I/O error"]],
  [-25, ["ENOTTY", "inappropriate ioctl for device"]],
  [-79, ["EFTYPE", "inappropriate file type or format"]],
  [-92, ["EILSEQ", "illegal byte sequence"]]
];
var errorToCodeDarwin = codeToErrorDarwin.map(([status, [code2]]) => [code2, status]);
var codeToErrorLinux = [
  [-7, ["E2BIG", "argument list too long"]],
  [-13, ["EACCES", "permission denied"]],
  [-98, ["EADDRINUSE", "address already in use"]],
  [-99, ["EADDRNOTAVAIL", "address not available"]],
  [-97, ["EAFNOSUPPORT", "address family not supported"]],
  [-11, ["EAGAIN", "resource temporarily unavailable"]],
  [-3e3, ["EAI_ADDRFAMILY", "address family not supported"]],
  [-3001, ["EAI_AGAIN", "temporary failure"]],
  [-3002, ["EAI_BADFLAGS", "bad ai_flags value"]],
  [-3013, ["EAI_BADHINTS", "invalid value for hints"]],
  [-3003, ["EAI_CANCELED", "request canceled"]],
  [-3004, ["EAI_FAIL", "permanent failure"]],
  [-3005, ["EAI_FAMILY", "ai_family not supported"]],
  [-3006, ["EAI_MEMORY", "out of memory"]],
  [-3007, ["EAI_NODATA", "no address"]],
  [-3008, ["EAI_NONAME", "unknown node or service"]],
  [-3009, ["EAI_OVERFLOW", "argument buffer overflow"]],
  [-3014, ["EAI_PROTOCOL", "resolved protocol is unknown"]],
  [-3010, ["EAI_SERVICE", "service not available for socket type"]],
  [-3011, ["EAI_SOCKTYPE", "socket type not supported"]],
  [-114, ["EALREADY", "connection already in progress"]],
  [-9, ["EBADF", "bad file descriptor"]],
  [-16, ["EBUSY", "resource busy or locked"]],
  [-125, ["ECANCELED", "operation canceled"]],
  [-4080, ["ECHARSET", "invalid Unicode character"]],
  [-103, ["ECONNABORTED", "software caused connection abort"]],
  [-111, ["ECONNREFUSED", "connection refused"]],
  [-104, ["ECONNRESET", "connection reset by peer"]],
  [-89, ["EDESTADDRREQ", "destination address required"]],
  [-17, ["EEXIST", "file already exists"]],
  [-14, ["EFAULT", "bad address in system call argument"]],
  [-27, ["EFBIG", "file too large"]],
  [-113, ["EHOSTUNREACH", "host is unreachable"]],
  [-4, ["EINTR", "interrupted system call"]],
  [-22, ["EINVAL", "invalid argument"]],
  [-5, ["EIO", "i/o error"]],
  [-106, ["EISCONN", "socket is already connected"]],
  [-21, ["EISDIR", "illegal operation on a directory"]],
  [-40, ["ELOOP", "too many symbolic links encountered"]],
  [-24, ["EMFILE", "too many open files"]],
  [-90, ["EMSGSIZE", "message too long"]],
  [-36, ["ENAMETOOLONG", "name too long"]],
  [-100, ["ENETDOWN", "network is down"]],
  [-101, ["ENETUNREACH", "network is unreachable"]],
  [-23, ["ENFILE", "file table overflow"]],
  [-105, ["ENOBUFS", "no buffer space available"]],
  [-19, ["ENODEV", "no such device"]],
  [-2, ["ENOENT", "no such file or directory"]],
  [-12, ["ENOMEM", "not enough memory"]],
  [-64, ["ENONET", "machine is not on the network"]],
  [-92, ["ENOPROTOOPT", "protocol not available"]],
  [-28, ["ENOSPC", "no space left on device"]],
  [-38, ["ENOSYS", "function not implemented"]],
  [-107, ["ENOTCONN", "socket is not connected"]],
  [-20, ["ENOTDIR", "not a directory"]],
  [-39, ["ENOTEMPTY", "directory not empty"]],
  [-88, ["ENOTSOCK", "socket operation on non-socket"]],
  [-95, ["ENOTSUP", "operation not supported on socket"]],
  [-1, ["EPERM", "operation not permitted"]],
  [-32, ["EPIPE", "broken pipe"]],
  [-71, ["EPROTO", "protocol error"]],
  [-93, ["EPROTONOSUPPORT", "protocol not supported"]],
  [-91, ["EPROTOTYPE", "protocol wrong type for socket"]],
  [-34, ["ERANGE", "result too large"]],
  [-30, ["EROFS", "read-only file system"]],
  [-108, ["ESHUTDOWN", "cannot send after transport endpoint shutdown"]],
  [-29, ["ESPIPE", "invalid seek"]],
  [-3, ["ESRCH", "no such process"]],
  [-110, ["ETIMEDOUT", "connection timed out"]],
  [-26, ["ETXTBSY", "text file is busy"]],
  [-18, ["EXDEV", "cross-device link not permitted"]],
  [-4094, ["UNKNOWN", "unknown error"]],
  [-4095, ["EOF", "end of file"]],
  [-6, ["ENXIO", "no such device or address"]],
  [-31, ["EMLINK", "too many links"]],
  [-112, ["EHOSTDOWN", "host is down"]],
  [-121, ["EREMOTEIO", "remote I/O error"]],
  [-25, ["ENOTTY", "inappropriate ioctl for device"]],
  [-4028, ["EFTYPE", "inappropriate file type or format"]],
  [-84, ["EILSEQ", "illegal byte sequence"]]
];
var errorToCodeLinux = codeToErrorLinux.map(([status, [code2]]) => [code2, status]);
var errorMap = new Map(osType === "windows" ? codeToErrorWindows : osType === "darwin" ? codeToErrorDarwin : osType === "linux" ? codeToErrorLinux : unreachable());
var codeMap = new Map(osType === "windows" ? errorToCodeWindows : osType === "darwin" ? errorToCodeDarwin : osType === "linux" ? errorToCodeLinux : unreachable());
function mapSysErrnoToUvErrno(sysErrno) {
  if (osType === "windows") {
    const code2 = uvTranslateSysError(sysErrno);
    return codeMap.get(code2) ?? -sysErrno;
  } else {
    return -sysErrno;
  }
}
var UV_EAI_MEMORY = codeMap.get("EAI_MEMORY");
var UV_UNKNOWN = codeMap.get("UNKNOWN");
var UV_EBADF = codeMap.get("EBADF");
var UV_EINVAL = codeMap.get("EINVAL");
var UV_ENOTSOCK = codeMap.get("ENOTSOCK");

// deno:https://deno.land/std@0.147.0/node/util/types.ts
var types_default2 = { ...types_exports2 };

// deno:https://deno.land/std@0.147.0/node/internal_binding/string_decoder.ts
var string_decoder_exports = {};
__export(string_decoder_exports, {
  default: () => string_decoder_default,
  encodings: () => encodings
});

// deno:https://deno.land/std@0.147.0/node/internal_binding/_node.ts
var Encodings = /* @__PURE__ */ ((Encodings4) => {
  Encodings4[Encodings4["ASCII"] = 0] = "ASCII";
  Encodings4[Encodings4["UTF8"] = 1] = "UTF8";
  Encodings4[Encodings4["BASE64"] = 2] = "BASE64";
  Encodings4[Encodings4["UCS2"] = 3] = "UCS2";
  Encodings4[Encodings4["BINARY"] = 4] = "BINARY";
  Encodings4[Encodings4["HEX"] = 5] = "HEX";
  Encodings4[Encodings4["BUFFER"] = 6] = "BUFFER";
  Encodings4[Encodings4["BASE64URL"] = 7] = "BASE64URL";
  Encodings4[Encodings4["LATIN1"] = 4] = "LATIN1";
  return Encodings4;
})(Encodings || {});

// deno:https://deno.land/std@0.147.0/node/internal_binding/string_decoder.ts
var encodings = [];
encodings[0 /* ASCII */] = "ascii";
encodings[2 /* BASE64 */] = "base64";
encodings[7 /* BASE64URL */] = "base64url";
encodings[6 /* BUFFER */] = "buffer";
encodings[5 /* HEX */] = "hex";
encodings[4 /* LATIN1 */] = "latin1";
encodings[3 /* UCS2 */] = "utf16le";
encodings[1 /* UTF8 */] = "utf8";
var string_decoder_default = { encodings };

// deno:https://deno.land/std@0.147.0/node/internal_binding/buffer.ts
var buffer_exports = {};
__export(buffer_exports, {
  default: () => buffer_default,
  indexOfBuffer: () => indexOfBuffer,
  indexOfNumber: () => indexOfNumber,
  numberToBytes: () => numberToBytes
});
function numberToBytes(n) {
  if (n === 0)
    return new Uint8Array([0]);
  const bytes = [];
  bytes.unshift(n & 255);
  while (n >= 256) {
    n = n >>> 8;
    bytes.unshift(n & 255);
  }
  return new Uint8Array(bytes);
}
function findLastIndex(targetBuffer, buffer, offset) {
  offset = offset > targetBuffer.length ? targetBuffer.length : offset;
  const searchableBuffer = targetBuffer.slice(0, offset + buffer.length);
  const searchableBufferLastIndex = searchableBuffer.length - 1;
  const bufferLastIndex = buffer.length - 1;
  let lastMatchIndex = -1;
  let matches = 0;
  let index = -1;
  for (let x = 0; x <= searchableBufferLastIndex; x++) {
    if (searchableBuffer[searchableBufferLastIndex - x] === buffer[bufferLastIndex - matches]) {
      if (lastMatchIndex === -1) {
        lastMatchIndex = x;
      }
      matches++;
    } else {
      matches = 0;
      if (lastMatchIndex !== -1) {
        x = lastMatchIndex + 1;
        lastMatchIndex = -1;
      }
      continue;
    }
    if (matches === buffer.length) {
      index = x;
      break;
    }
  }
  if (index === -1)
    return index;
  return searchableBufferLastIndex - index;
}
function indexOfBuffer(targetBuffer, buffer, byteOffset, encoding, forwardDirection) {
  if (!Encodings[encoding] === void 0) {
    throw new Error(`Unknown encoding code ${encoding}`);
  }
  if (!forwardDirection) {
    if (byteOffset < 0) {
      byteOffset = targetBuffer.length + byteOffset;
    }
    if (buffer.length === 0) {
      return byteOffset <= targetBuffer.length ? byteOffset : targetBuffer.length;
    }
    return findLastIndex(targetBuffer, buffer, byteOffset);
  }
  if (buffer.length === 0) {
    return byteOffset <= targetBuffer.length ? byteOffset : targetBuffer.length;
  }
  return indexOfNeedle(targetBuffer, buffer, byteOffset);
}
function indexOfNumber(targetBuffer, number, byteOffset, forwardDirection) {
  const bytes = numberToBytes(number);
  if (bytes.length > 1) {
    throw new Error("Multi byte number search is not supported");
  }
  return indexOfBuffer(targetBuffer, numberToBytes(number), byteOffset, 1 /* UTF8 */, forwardDirection);
}
var buffer_default = { indexOfBuffer, indexOfNumber };

// deno:https://deno.land/std@0.147.0/encoding/base64.ts
var base64abc = [
  "A",
  "B",
  "C",
  "D",
  "E",
  "F",
  "G",
  "H",
  "I",
  "J",
  "K",
  "L",
  "M",
  "N",
  "O",
  "P",
  "Q",
  "R",
  "S",
  "T",
  "U",
  "V",
  "W",
  "X",
  "Y",
  "Z",
  "a",
  "b",
  "c",
  "d",
  "e",
  "f",
  "g",
  "h",
  "i",
  "j",
  "k",
  "l",
  "m",
  "n",
  "o",
  "p",
  "q",
  "r",
  "s",
  "t",
  "u",
  "v",
  "w",
  "x",
  "y",
  "z",
  "0",
  "1",
  "2",
  "3",
  "4",
  "5",
  "6",
  "7",
  "8",
  "9",
  "+",
  "/"
];
function encode(data) {
  const uint8 = typeof data === "string" ? new TextEncoder().encode(data) : data instanceof Uint8Array ? data : new Uint8Array(data);
  let result = "", i;
  const l = uint8.length;
  for (i = 2; i < l; i += 3) {
    result += base64abc[uint8[i - 2] >> 2];
    result += base64abc[(uint8[i - 2] & 3) << 4 | uint8[i - 1] >> 4];
    result += base64abc[(uint8[i - 1] & 15) << 2 | uint8[i] >> 6];
    result += base64abc[uint8[i] & 63];
  }
  if (i === l + 1) {
    result += base64abc[uint8[i - 2] >> 2];
    result += base64abc[(uint8[i - 2] & 3) << 4];
    result += "==";
  }
  if (i === l) {
    result += base64abc[uint8[i - 2] >> 2];
    result += base64abc[(uint8[i - 2] & 3) << 4 | uint8[i - 1] >> 4];
    result += base64abc[(uint8[i - 1] & 15) << 2];
    result += "=";
  }
  return result;
}
function decode(b64) {
  const binString = atob(b64);
  const size = binString.length;
  const bytes = new Uint8Array(size);
  for (let i = 0; i < size; i++) {
    bytes[i] = binString.charCodeAt(i);
  }
  return bytes;
}

// deno:https://deno.land/std@0.147.0/encoding/base64url.ts
function addPaddingToBase64url(base64url) {
  if (base64url.length % 4 === 2)
    return base64url + "==";
  if (base64url.length % 4 === 3)
    return base64url + "=";
  if (base64url.length % 4 === 1) {
    throw new TypeError("Illegal base64url string!");
  }
  return base64url;
}
function convertBase64urlToBase64(b64url) {
  if (!/^[-_A-Z0-9]*?={0,2}$/i.test(b64url)) {
    throw new TypeError("Failed to decode base64url: invalid character");
  }
  return addPaddingToBase64url(b64url).replace(/\-/g, "+").replace(/_/g, "/");
}
function convertBase64ToBase64url(b64) {
  return b64.replace(/=/g, "").replace(/\+/g, "-").replace(/\//g, "_");
}
function encode2(data) {
  return convertBase64ToBase64url(encode(data));
}
function decode2(b64url) {
  return decode(convertBase64urlToBase64(b64url));
}

// deno:https://deno.land/std@0.147.0/node/internal_binding/_utils.ts
function asciiToBytes(str) {
  const byteArray = [];
  for (let i = 0; i < str.length; ++i) {
    byteArray.push(str.charCodeAt(i) & 255);
  }
  return new Uint8Array(byteArray);
}
function base64ToBytes(str) {
  str = base64clean(str);
  str = str.replaceAll("-", "+").replaceAll("_", "/");
  return decode(str);
}
var INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g;
function base64clean(str) {
  str = str.split("=")[0];
  str = str.trim().replace(INVALID_BASE64_RE, "");
  if (str.length < 2)
    return "";
  while (str.length % 4 !== 0) {
    str = str + "=";
  }
  return str;
}
function base64UrlToBytes(str) {
  str = base64clean(str);
  str = str.replaceAll("+", "-").replaceAll("/", "_");
  return decode2(str);
}
function hexToBytes(str) {
  const byteArray = new Uint8Array(Math.floor((str || "").length / 2));
  let i;
  for (i = 0; i < byteArray.length; i++) {
    const a = Number.parseInt(str[i * 2], 16);
    const b2 = Number.parseInt(str[i * 2 + 1], 16);
    if (Number.isNaN(a) && Number.isNaN(b2)) {
      break;
    }
    byteArray[i] = a << 4 | b2;
  }
  return new Uint8Array(i === byteArray.length ? byteArray : byteArray.slice(0, i));
}
function utf16leToBytes(str, units) {
  let c5, hi2, lo3;
  const byteArray = [];
  for (let i = 0; i < str.length; ++i) {
    if ((units -= 2) < 0) {
      break;
    }
    c5 = str.charCodeAt(i);
    hi2 = c5 >> 8;
    lo3 = c5 % 256;
    byteArray.push(lo3);
    byteArray.push(hi2);
  }
  return new Uint8Array(byteArray);
}
function bytesToAscii(bytes) {
  let ret = "";
  for (let i = 0; i < bytes.length; ++i) {
    ret += String.fromCharCode(bytes[i] & 127);
  }
  return ret;
}
function bytesToUtf16le(bytes) {
  let res = "";
  for (let i = 0; i < bytes.length - 1; i += 2) {
    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);
  }
  return res;
}

// deno:https://deno.land/std@0.147.0/node/internal/buffer.mjs
var utf8Encoder = new TextEncoder();
var float32Array = new Float32Array(1);
var uInt8Float32Array = new Uint8Array(float32Array.buffer);
var float64Array = new Float64Array(1);
var uInt8Float64Array = new Uint8Array(float64Array.buffer);
float32Array[0] = -1;
var bigEndian = uInt8Float32Array[3] === 0;
function readUInt48LE(buf, offset = 0) {
  validateNumber(offset, "offset");
  const first = buf[offset];
  const last = buf[offset + 5];
  if (first === void 0 || last === void 0) {
    boundsError(offset, buf.length - 6);
  }
  return first + buf[++offset] * 2 ** 8 + buf[++offset] * 2 ** 16 + buf[++offset] * 2 ** 24 + (buf[++offset] + last * 2 ** 8) * 2 ** 32;
}
function readUInt40LE(buf, offset = 0) {
  validateNumber(offset, "offset");
  const first = buf[offset];
  const last = buf[offset + 4];
  if (first === void 0 || last === void 0) {
    boundsError(offset, buf.length - 5);
  }
  return first + buf[++offset] * 2 ** 8 + buf[++offset] * 2 ** 16 + buf[++offset] * 2 ** 24 + last * 2 ** 32;
}
function readUInt24LE(buf, offset = 0) {
  validateNumber(offset, "offset");
  const first = buf[offset];
  const last = buf[offset + 2];
  if (first === void 0 || last === void 0) {
    boundsError(offset, buf.length - 3);
  }
  return first + buf[++offset] * 2 ** 8 + last * 2 ** 16;
}
function readUInt48BE(buf, offset = 0) {
  validateNumber(offset, "offset");
  const first = buf[offset];
  const last = buf[offset + 5];
  if (first === void 0 || last === void 0) {
    boundsError(offset, buf.length - 6);
  }
  return (first * 2 ** 8 + buf[++offset]) * 2 ** 32 + buf[++offset] * 2 ** 24 + buf[++offset] * 2 ** 16 + buf[++offset] * 2 ** 8 + last;
}
function readUInt40BE(buf, offset = 0) {
  validateNumber(offset, "offset");
  const first = buf[offset];
  const last = buf[offset + 4];
  if (first === void 0 || last === void 0) {
    boundsError(offset, buf.length - 5);
  }
  return first * 2 ** 32 + buf[++offset] * 2 ** 24 + buf[++offset] * 2 ** 16 + buf[++offset] * 2 ** 8 + last;
}
function readUInt24BE(buf, offset = 0) {
  validateNumber(offset, "offset");
  const first = buf[offset];
  const last = buf[offset + 2];
  if (first === void 0 || last === void 0) {
    boundsError(offset, buf.length - 3);
  }
  return first * 2 ** 16 + buf[++offset] * 2 ** 8 + last;
}
function readUInt16BE(offset = 0) {
  validateNumber(offset, "offset");
  const first = this[offset];
  const last = this[offset + 1];
  if (first === void 0 || last === void 0) {
    boundsError(offset, this.length - 2);
  }
  return first * 2 ** 8 + last;
}
function readUInt32BE(offset = 0) {
  validateNumber(offset, "offset");
  const first = this[offset];
  const last = this[offset + 3];
  if (first === void 0 || last === void 0) {
    boundsError(offset, this.length - 4);
  }
  return first * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + last;
}
function readDoubleBackwards(buffer, offset = 0) {
  validateNumber(offset, "offset");
  const first = buffer[offset];
  const last = buffer[offset + 7];
  if (first === void 0 || last === void 0) {
    boundsError(offset, buffer.length - 8);
  }
  uInt8Float64Array[7] = first;
  uInt8Float64Array[6] = buffer[++offset];
  uInt8Float64Array[5] = buffer[++offset];
  uInt8Float64Array[4] = buffer[++offset];
  uInt8Float64Array[3] = buffer[++offset];
  uInt8Float64Array[2] = buffer[++offset];
  uInt8Float64Array[1] = buffer[++offset];
  uInt8Float64Array[0] = last;
  return float64Array[0];
}
function readDoubleForwards(buffer, offset = 0) {
  validateNumber(offset, "offset");
  const first = buffer[offset];
  const last = buffer[offset + 7];
  if (first === void 0 || last === void 0) {
    boundsError(offset, buffer.length - 8);
  }
  uInt8Float64Array[0] = first;
  uInt8Float64Array[1] = buffer[++offset];
  uInt8Float64Array[2] = buffer[++offset];
  uInt8Float64Array[3] = buffer[++offset];
  uInt8Float64Array[4] = buffer[++offset];
  uInt8Float64Array[5] = buffer[++offset];
  uInt8Float64Array[6] = buffer[++offset];
  uInt8Float64Array[7] = last;
  return float64Array[0];
}
function writeDoubleForwards(buffer, val, offset = 0) {
  val = +val;
  checkBounds(buffer, offset, 7);
  float64Array[0] = val;
  buffer[offset++] = uInt8Float64Array[0];
  buffer[offset++] = uInt8Float64Array[1];
  buffer[offset++] = uInt8Float64Array[2];
  buffer[offset++] = uInt8Float64Array[3];
  buffer[offset++] = uInt8Float64Array[4];
  buffer[offset++] = uInt8Float64Array[5];
  buffer[offset++] = uInt8Float64Array[6];
  buffer[offset++] = uInt8Float64Array[7];
  return offset;
}
function writeDoubleBackwards(buffer, val, offset = 0) {
  val = +val;
  checkBounds(buffer, offset, 7);
  float64Array[0] = val;
  buffer[offset++] = uInt8Float64Array[7];
  buffer[offset++] = uInt8Float64Array[6];
  buffer[offset++] = uInt8Float64Array[5];
  buffer[offset++] = uInt8Float64Array[4];
  buffer[offset++] = uInt8Float64Array[3];
  buffer[offset++] = uInt8Float64Array[2];
  buffer[offset++] = uInt8Float64Array[1];
  buffer[offset++] = uInt8Float64Array[0];
  return offset;
}
function readFloatBackwards(buffer, offset = 0) {
  validateNumber(offset, "offset");
  const first = buffer[offset];
  const last = buffer[offset + 3];
  if (first === void 0 || last === void 0) {
    boundsError(offset, buffer.length - 4);
  }
  uInt8Float32Array[3] = first;
  uInt8Float32Array[2] = buffer[++offset];
  uInt8Float32Array[1] = buffer[++offset];
  uInt8Float32Array[0] = last;
  return float32Array[0];
}
function readFloatForwards(buffer, offset = 0) {
  validateNumber(offset, "offset");
  const first = buffer[offset];
  const last = buffer[offset + 3];
  if (first === void 0 || last === void 0) {
    boundsError(offset, buffer.length - 4);
  }
  uInt8Float32Array[0] = first;
  uInt8Float32Array[1] = buffer[++offset];
  uInt8Float32Array[2] = buffer[++offset];
  uInt8Float32Array[3] = last;
  return float32Array[0];
}
function writeFloatForwards(buffer, val, offset = 0) {
  val = +val;
  checkBounds(buffer, offset, 3);
  float32Array[0] = val;
  buffer[offset++] = uInt8Float32Array[0];
  buffer[offset++] = uInt8Float32Array[1];
  buffer[offset++] = uInt8Float32Array[2];
  buffer[offset++] = uInt8Float32Array[3];
  return offset;
}
function writeFloatBackwards(buffer, val, offset = 0) {
  val = +val;
  checkBounds(buffer, offset, 3);
  float32Array[0] = val;
  buffer[offset++] = uInt8Float32Array[3];
  buffer[offset++] = uInt8Float32Array[2];
  buffer[offset++] = uInt8Float32Array[1];
  buffer[offset++] = uInt8Float32Array[0];
  return offset;
}
function readInt24LE(buf, offset = 0) {
  validateNumber(offset, "offset");
  const first = buf[offset];
  const last = buf[offset + 2];
  if (first === void 0 || last === void 0) {
    boundsError(offset, buf.length - 3);
  }
  const val = first + buf[++offset] * 2 ** 8 + last * 2 ** 16;
  return val | (val & 2 ** 23) * 510;
}
function readInt40LE(buf, offset = 0) {
  validateNumber(offset, "offset");
  const first = buf[offset];
  const last = buf[offset + 4];
  if (first === void 0 || last === void 0) {
    boundsError(offset, buf.length - 5);
  }
  return (last | (last & 2 ** 7) * 33554430) * 2 ** 32 + first + buf[++offset] * 2 ** 8 + buf[++offset] * 2 ** 16 + buf[++offset] * 2 ** 24;
}
function readInt48LE(buf, offset = 0) {
  validateNumber(offset, "offset");
  const first = buf[offset];
  const last = buf[offset + 5];
  if (first === void 0 || last === void 0) {
    boundsError(offset, buf.length - 6);
  }
  const val = buf[offset + 4] + last * 2 ** 8;
  return (val | (val & 2 ** 15) * 131070) * 2 ** 32 + first + buf[++offset] * 2 ** 8 + buf[++offset] * 2 ** 16 + buf[++offset] * 2 ** 24;
}
function readInt24BE(buf, offset = 0) {
  validateNumber(offset, "offset");
  const first = buf[offset];
  const last = buf[offset + 2];
  if (first === void 0 || last === void 0) {
    boundsError(offset, buf.length - 3);
  }
  const val = first * 2 ** 16 + buf[++offset] * 2 ** 8 + last;
  return val | (val & 2 ** 23) * 510;
}
function readInt48BE(buf, offset = 0) {
  validateNumber(offset, "offset");
  const first = buf[offset];
  const last = buf[offset + 5];
  if (first === void 0 || last === void 0) {
    boundsError(offset, buf.length - 6);
  }
  const val = buf[++offset] + first * 2 ** 8;
  return (val | (val & 2 ** 15) * 131070) * 2 ** 32 + buf[++offset] * 2 ** 24 + buf[++offset] * 2 ** 16 + buf[++offset] * 2 ** 8 + last;
}
function readInt40BE(buf, offset = 0) {
  validateNumber(offset, "offset");
  const first = buf[offset];
  const last = buf[offset + 4];
  if (first === void 0 || last === void 0) {
    boundsError(offset, buf.length - 5);
  }
  return (first | (first & 2 ** 7) * 33554430) * 2 ** 32 + buf[++offset] * 2 ** 24 + buf[++offset] * 2 ** 16 + buf[++offset] * 2 ** 8 + last;
}
function byteLengthUtf8(str) {
  return utf8Encoder.encode(str).length;
}
function base64ByteLength(str, bytes) {
  if (str.charCodeAt(bytes - 1) === 61) {
    bytes--;
  }
  if (bytes > 1 && str.charCodeAt(bytes - 1) === 61) {
    bytes--;
  }
  return bytes * 3 >>> 2;
}
var encodingsMap = /* @__PURE__ */ Object.create(null);
for (let i = 0; i < encodings.length; ++i) {
  encodingsMap[encodings[i]] = i;
}
var encodingOps = {
  ascii: {
    byteLength: (string) => string.length,
    encoding: "ascii",
    encodingVal: encodingsMap.ascii,
    indexOf: (buf, val, byteOffset, dir) => indexOfBuffer(buf, asciiToBytes(val), byteOffset, encodingsMap.ascii, dir),
    slice: (buf, start, end) => buf.asciiSlice(start, end),
    write: (buf, string, offset, len) => buf.asciiWrite(string, offset, len)
  },
  base64: {
    byteLength: (string) => base64ByteLength(string, string.length),
    encoding: "base64",
    encodingVal: encodingsMap.base64,
    indexOf: (buf, val, byteOffset, dir) => indexOfBuffer(buf, base64ToBytes(val), byteOffset, encodingsMap.base64, dir),
    slice: (buf, start, end) => buf.base64Slice(start, end),
    write: (buf, string, offset, len) => buf.base64Write(string, offset, len)
  },
  base64url: {
    byteLength: (string) => base64ByteLength(string, string.length),
    encoding: "base64url",
    encodingVal: encodingsMap.base64url,
    indexOf: (buf, val, byteOffset, dir) => indexOfBuffer(buf, base64UrlToBytes(val), byteOffset, encodingsMap.base64url, dir),
    slice: (buf, start, end) => buf.base64urlSlice(start, end),
    write: (buf, string, offset, len) => buf.base64urlWrite(string, offset, len)
  },
  hex: {
    byteLength: (string) => string.length >>> 1,
    encoding: "hex",
    encodingVal: encodingsMap.hex,
    indexOf: (buf, val, byteOffset, dir) => indexOfBuffer(buf, hexToBytes(val), byteOffset, encodingsMap.hex, dir),
    slice: (buf, start, end) => buf.hexSlice(start, end),
    write: (buf, string, offset, len) => buf.hexWrite(string, offset, len)
  },
  latin1: {
    byteLength: (string) => string.length,
    encoding: "latin1",
    encodingVal: encodingsMap.latin1,
    indexOf: (buf, val, byteOffset, dir) => indexOfBuffer(buf, asciiToBytes(val), byteOffset, encodingsMap.latin1, dir),
    slice: (buf, start, end) => buf.latin1Slice(start, end),
    write: (buf, string, offset, len) => buf.latin1Write(string, offset, len)
  },
  ucs2: {
    byteLength: (string) => string.length * 2,
    encoding: "ucs2",
    encodingVal: encodingsMap.utf16le,
    indexOf: (buf, val, byteOffset, dir) => indexOfBuffer(buf, utf16leToBytes(val), byteOffset, encodingsMap.utf16le, dir),
    slice: (buf, start, end) => buf.ucs2Slice(start, end),
    write: (buf, string, offset, len) => buf.ucs2Write(string, offset, len)
  },
  utf8: {
    byteLength: byteLengthUtf8,
    encoding: "utf8",
    encodingVal: encodingsMap.utf8,
    indexOf: (buf, val, byteOffset, dir) => indexOfBuffer(buf, utf8Encoder.encode(val), byteOffset, encodingsMap.utf8, dir),
    slice: (buf, start, end) => buf.utf8Slice(start, end),
    write: (buf, string, offset, len) => buf.utf8Write(string, offset, len)
  },
  utf16le: {
    byteLength: (string) => string.length * 2,
    encoding: "utf16le",
    encodingVal: encodingsMap.utf16le,
    indexOf: (buf, val, byteOffset, dir) => indexOfBuffer(buf, utf16leToBytes(val), byteOffset, encodingsMap.utf16le, dir),
    slice: (buf, start, end) => buf.ucs2Slice(start, end),
    write: (buf, string, offset, len) => buf.ucs2Write(string, offset, len)
  }
};
function getEncodingOps(encoding) {
  encoding = String(encoding).toLowerCase();
  switch (encoding.length) {
    case 4:
      if (encoding === "utf8")
        return encodingOps.utf8;
      if (encoding === "ucs2")
        return encodingOps.ucs2;
      break;
    case 5:
      if (encoding === "utf-8")
        return encodingOps.utf8;
      if (encoding === "ascii")
        return encodingOps.ascii;
      if (encoding === "ucs-2")
        return encodingOps.ucs2;
      break;
    case 7:
      if (encoding === "utf16le") {
        return encodingOps.utf16le;
      }
      break;
    case 8:
      if (encoding === "utf-16le") {
        return encodingOps.utf16le;
      }
      break;
    case 6:
      if (encoding === "latin1" || encoding === "binary") {
        return encodingOps.latin1;
      }
      if (encoding === "base64")
        return encodingOps.base64;
    case 3:
      if (encoding === "hex") {
        return encodingOps.hex;
      }
      break;
    case 9:
      if (encoding === "base64url") {
        return encodingOps.base64url;
      }
      break;
  }
}
function _copyActual(source, target, targetStart, sourceStart, sourceEnd) {
  if (sourceEnd - sourceStart > target.length - targetStart) {
    sourceEnd = sourceStart + target.length - targetStart;
  }
  let nb = sourceEnd - sourceStart;
  const sourceLen = source.length - sourceStart;
  if (nb > sourceLen) {
    nb = sourceLen;
  }
  if (sourceStart !== 0 || sourceEnd < source.length) {
    source = new Uint8Array(source.buffer, source.byteOffset + sourceStart, nb);
  }
  target.set(source, targetStart);
  return nb;
}
function boundsError(value, length, type) {
  if (Math.floor(value) !== value) {
    validateNumber(value, type);
    throw new codes.ERR_OUT_OF_RANGE(type || "offset", "an integer", value);
  }
  if (length < 0) {
    throw new codes.ERR_BUFFER_OUT_OF_BOUNDS();
  }
  throw new codes.ERR_OUT_OF_RANGE(type || "offset", `>= ${type ? 1 : 0} and <= ${length}`, value);
}
function validateNumber(value, name) {
  if (typeof value !== "number") {
    throw new codes.ERR_INVALID_ARG_TYPE(name, "number", value);
  }
}
function checkBounds(buf, offset, byteLength6) {
  validateNumber(offset, "offset");
  if (buf[offset] === void 0 || buf[offset + byteLength6] === void 0) {
    boundsError(offset, buf.length - (byteLength6 + 1));
  }
}
function checkInt(value, min4, max2, buf, offset, byteLength6) {
  if (value > max2 || value < min4) {
    const n = typeof min4 === "bigint" ? "n" : "";
    let range;
    if (byteLength6 > 3) {
      if (min4 === 0 || min4 === 0n) {
        range = `>= 0${n} and < 2${n} ** ${(byteLength6 + 1) * 8}${n}`;
      } else {
        range = `>= -(2${n} ** ${(byteLength6 + 1) * 8 - 1}${n}) and < 2${n} ** ${(byteLength6 + 1) * 8 - 1}${n}`;
      }
    } else {
      range = `>= ${min4}${n} and <= ${max2}${n}`;
    }
    throw new codes.ERR_OUT_OF_RANGE("value", range, value);
  }
  checkBounds(buf, offset, byteLength6);
}
function toInteger(n, defaultVal) {
  n = +n;
  if (!Number.isNaN(n) && n >= Number.MIN_SAFE_INTEGER && n <= Number.MAX_SAFE_INTEGER) {
    return n % 1 === 0 ? n : Math.floor(n);
  }
  return defaultVal;
}
function writeU_Int8(buf, value, offset, min4, max2) {
  value = +value;
  validateNumber(offset, "offset");
  if (value > max2 || value < min4) {
    throw new codes.ERR_OUT_OF_RANGE("value", `>= ${min4} and <= ${max2}`, value);
  }
  if (buf[offset] === void 0) {
    boundsError(offset, buf.length - 1);
  }
  buf[offset] = value;
  return offset + 1;
}
function writeU_Int16BE(buf, value, offset, min4, max2) {
  value = +value;
  checkInt(value, min4, max2, buf, offset, 1);
  buf[offset++] = value >>> 8;
  buf[offset++] = value;
  return offset;
}
function _writeUInt32LE(buf, value, offset, min4, max2) {
  value = +value;
  checkInt(value, min4, max2, buf, offset, 3);
  buf[offset++] = value;
  value = value >>> 8;
  buf[offset++] = value;
  value = value >>> 8;
  buf[offset++] = value;
  value = value >>> 8;
  buf[offset++] = value;
  return offset;
}
function writeU_Int16LE(buf, value, offset, min4, max2) {
  value = +value;
  checkInt(value, min4, max2, buf, offset, 1);
  buf[offset++] = value;
  buf[offset++] = value >>> 8;
  return offset;
}
function _writeUInt32BE(buf, value, offset, min4, max2) {
  value = +value;
  checkInt(value, min4, max2, buf, offset, 3);
  buf[offset + 3] = value;
  value = value >>> 8;
  buf[offset + 2] = value;
  value = value >>> 8;
  buf[offset + 1] = value;
  value = value >>> 8;
  buf[offset] = value;
  return offset + 4;
}
function writeU_Int48BE(buf, value, offset, min4, max2) {
  value = +value;
  checkInt(value, min4, max2, buf, offset, 5);
  const newVal = Math.floor(value * 2 ** -32);
  buf[offset++] = newVal >>> 8;
  buf[offset++] = newVal;
  buf[offset + 3] = value;
  value = value >>> 8;
  buf[offset + 2] = value;
  value = value >>> 8;
  buf[offset + 1] = value;
  value = value >>> 8;
  buf[offset] = value;
  return offset + 4;
}
function writeU_Int40BE(buf, value, offset, min4, max2) {
  value = +value;
  checkInt(value, min4, max2, buf, offset, 4);
  buf[offset++] = Math.floor(value * 2 ** -32);
  buf[offset + 3] = value;
  value = value >>> 8;
  buf[offset + 2] = value;
  value = value >>> 8;
  buf[offset + 1] = value;
  value = value >>> 8;
  buf[offset] = value;
  return offset + 4;
}
function writeU_Int32BE(buf, value, offset, min4, max2) {
  value = +value;
  checkInt(value, min4, max2, buf, offset, 3);
  buf[offset + 3] = value;
  value = value >>> 8;
  buf[offset + 2] = value;
  value = value >>> 8;
  buf[offset + 1] = value;
  value = value >>> 8;
  buf[offset] = value;
  return offset + 4;
}
function writeU_Int24BE(buf, value, offset, min4, max2) {
  value = +value;
  checkInt(value, min4, max2, buf, offset, 2);
  buf[offset + 2] = value;
  value = value >>> 8;
  buf[offset + 1] = value;
  value = value >>> 8;
  buf[offset] = value;
  return offset + 3;
}
function validateOffset(value, name, min4 = 0, max2 = Number.MAX_SAFE_INTEGER) {
  if (typeof value !== "number") {
    throw new codes.ERR_INVALID_ARG_TYPE(name, "number", value);
  }
  if (!Number.isInteger(value)) {
    throw new codes.ERR_OUT_OF_RANGE(name, "an integer", value);
  }
  if (value < min4 || value > max2) {
    throw new codes.ERR_OUT_OF_RANGE(name, `>= ${min4} && <= ${max2}`, value);
  }
}
function writeU_Int48LE(buf, value, offset, min4, max2) {
  value = +value;
  checkInt(value, min4, max2, buf, offset, 5);
  const newVal = Math.floor(value * 2 ** -32);
  buf[offset++] = value;
  value = value >>> 8;
  buf[offset++] = value;
  value = value >>> 8;
  buf[offset++] = value;
  value = value >>> 8;
  buf[offset++] = value;
  buf[offset++] = newVal;
  buf[offset++] = newVal >>> 8;
  return offset;
}
function writeU_Int40LE(buf, value, offset, min4, max2) {
  value = +value;
  checkInt(value, min4, max2, buf, offset, 4);
  const newVal = value;
  buf[offset++] = value;
  value = value >>> 8;
  buf[offset++] = value;
  value = value >>> 8;
  buf[offset++] = value;
  value = value >>> 8;
  buf[offset++] = value;
  buf[offset++] = Math.floor(newVal * 2 ** -32);
  return offset;
}
function writeU_Int32LE(buf, value, offset, min4, max2) {
  value = +value;
  checkInt(value, min4, max2, buf, offset, 3);
  buf[offset++] = value;
  value = value >>> 8;
  buf[offset++] = value;
  value = value >>> 8;
  buf[offset++] = value;
  value = value >>> 8;
  buf[offset++] = value;
  return offset;
}
function writeU_Int24LE(buf, value, offset, min4, max2) {
  value = +value;
  checkInt(value, min4, max2, buf, offset, 2);
  buf[offset++] = value;
  value = value >>> 8;
  buf[offset++] = value;
  value = value >>> 8;
  buf[offset++] = value;
  return offset;
}

// deno:https://deno.land/std@0.147.0/node/_buffer.mjs
var kMaxLength = 2147483647;
var MAX_UINT32 = 2 ** 32;
var customInspectSymbol3 = typeof Symbol === "function" && typeof Symbol["for"] === "function" ? Symbol["for"]("nodejs.util.inspect.custom") : null;
var INSPECT_MAX_BYTES = 50;
Object.defineProperty(Buffer3.prototype, "parent", {
  enumerable: true,
  get: function() {
    if (!Buffer3.isBuffer(this)) {
      return void 0;
    }
    return this.buffer;
  }
});
Object.defineProperty(Buffer3.prototype, "offset", {
  enumerable: true,
  get: function() {
    if (!Buffer3.isBuffer(this)) {
      return void 0;
    }
    return this.byteOffset;
  }
});
function createBuffer(length) {
  if (length > kMaxLength) {
    throw new RangeError('The value "' + length + '" is invalid for option "size"');
  }
  const buf = new Uint8Array(length);
  Object.setPrototypeOf(buf, Buffer3.prototype);
  return buf;
}
function Buffer3(arg, encodingOrOffset, length) {
  if (typeof arg === "number") {
    if (typeof encodingOrOffset === "string") {
      throw new codes.ERR_INVALID_ARG_TYPE("string", "string", arg);
    }
    return _allocUnsafe(arg);
  }
  return _from(arg, encodingOrOffset, length);
}
Buffer3.poolSize = 8192;
function _from(value, encodingOrOffset, length) {
  if (typeof value === "string") {
    return fromString(value, encodingOrOffset);
  }
  if (typeof value === "object" && value !== null) {
    if (isAnyArrayBuffer2(value)) {
      return fromArrayBuffer(value, encodingOrOffset, length);
    }
    const valueOf = value.valueOf && value.valueOf();
    if (valueOf != null && valueOf !== value && (typeof valueOf === "string" || typeof valueOf === "object")) {
      return _from(valueOf, encodingOrOffset, length);
    }
    const b2 = fromObject(value);
    if (b2) {
      return b2;
    }
    if (typeof value[Symbol.toPrimitive] === "function") {
      const primitive = value[Symbol.toPrimitive]("string");
      if (typeof primitive === "string") {
        return fromString(primitive, encodingOrOffset);
      }
    }
  }
  throw new codes.ERR_INVALID_ARG_TYPE("first argument", ["string", "Buffer", "ArrayBuffer", "Array", "Array-like Object"], value);
}
Buffer3.from = function from(value, encodingOrOffset, length) {
  return _from(value, encodingOrOffset, length);
};
Object.setPrototypeOf(Buffer3.prototype, Uint8Array.prototype);
Object.setPrototypeOf(Buffer3, Uint8Array);
function assertSize(size) {
  validateNumber(size, "size");
  if (!(size >= 0 && size <= kMaxLength)) {
    throw new codes.ERR_INVALID_ARG_VALUE.RangeError("size", size);
  }
}
function _alloc(size, fill5, encoding) {
  assertSize(size);
  const buffer = createBuffer(size);
  if (fill5 !== void 0) {
    if (encoding !== void 0 && typeof encoding !== "string") {
      throw new codes.ERR_INVALID_ARG_TYPE("encoding", "string", encoding);
    }
    return buffer.fill(fill5, encoding);
  }
  return buffer;
}
Buffer3.alloc = function alloc(size, fill5, encoding) {
  return _alloc(size, fill5, encoding);
};
function _allocUnsafe(size) {
  assertSize(size);
  return createBuffer(size < 0 ? 0 : checked(size) | 0);
}
Buffer3.allocUnsafe = function allocUnsafe(size) {
  return _allocUnsafe(size);
};
Buffer3.allocUnsafeSlow = function allocUnsafeSlow(size) {
  return _allocUnsafe(size);
};
function fromString(string, encoding) {
  if (typeof encoding !== "string" || encoding === "") {
    encoding = "utf8";
  }
  if (!Buffer3.isEncoding(encoding)) {
    throw new codes.ERR_UNKNOWN_ENCODING(encoding);
  }
  const length = byteLength(string, encoding) | 0;
  let buf = createBuffer(length);
  const actual = buf.write(string, encoding);
  if (actual !== length) {
    buf = buf.slice(0, actual);
  }
  return buf;
}
function fromArrayLike(array) {
  const length = array.length < 0 ? 0 : checked(array.length) | 0;
  const buf = createBuffer(length);
  for (let i = 0; i < length; i += 1) {
    buf[i] = array[i] & 255;
  }
  return buf;
}
function fromObject(obj2) {
  if (obj2.length !== void 0 || isAnyArrayBuffer2(obj2.buffer)) {
    if (typeof obj2.length !== "number") {
      return createBuffer(0);
    }
    return fromArrayLike(obj2);
  }
  if (obj2.type === "Buffer" && Array.isArray(obj2.data)) {
    return fromArrayLike(obj2.data);
  }
}
function checked(length) {
  if (length >= kMaxLength) {
    throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + kMaxLength.toString(16) + " bytes");
  }
  return length | 0;
}
function SlowBuffer(length) {
  assertSize(length);
  return Buffer3.alloc(+length);
}
Object.setPrototypeOf(SlowBuffer.prototype, Uint8Array.prototype);
Object.setPrototypeOf(SlowBuffer, Uint8Array);
Buffer3.isBuffer = function isBuffer(b2) {
  return b2 != null && b2._isBuffer === true && b2 !== Buffer3.prototype;
};
Buffer3.compare = function compare(a, b2) {
  if (isInstance(a, Uint8Array)) {
    a = Buffer3.from(a, a.offset, a.byteLength);
  }
  if (isInstance(b2, Uint8Array)) {
    b2 = Buffer3.from(b2, b2.offset, b2.byteLength);
  }
  if (!Buffer3.isBuffer(a) || !Buffer3.isBuffer(b2)) {
    throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');
  }
  if (a === b2) {
    return 0;
  }
  let x = a.length;
  let y4 = b2.length;
  for (let i = 0, len = Math.min(x, y4); i < len; ++i) {
    if (a[i] !== b2[i]) {
      x = a[i];
      y4 = b2[i];
      break;
    }
  }
  if (x < y4) {
    return -1;
  }
  if (y4 < x) {
    return 1;
  }
  return 0;
};
Buffer3.isEncoding = function isEncoding(encoding) {
  return typeof encoding === "string" && encoding.length !== 0 && normalizeEncoding2(encoding) !== void 0;
};
Buffer3.concat = function concat2(list, length) {
  if (!Array.isArray(list)) {
    throw new codes.ERR_INVALID_ARG_TYPE("list", "Array", list);
  }
  if (list.length === 0) {
    return Buffer3.alloc(0);
  }
  if (length === void 0) {
    length = 0;
    for (let i = 0; i < list.length; i++) {
      if (list[i].length) {
        length += list[i].length;
      }
    }
  } else {
    validateOffset(length, "length");
  }
  const buffer = Buffer3.allocUnsafe(length);
  let pos = 0;
  for (let i = 0; i < list.length; i++) {
    const buf = list[i];
    if (!isUint8Array(buf)) {
      throw new codes.ERR_INVALID_ARG_TYPE(`list[${i}]`, ["Buffer", "Uint8Array"], list[i]);
    }
    pos += _copyActual(buf, buffer, pos, 0, buf.length);
  }
  if (pos < length) {
    buffer.fill(0, pos, length);
  }
  return buffer;
};
function byteLength(string, encoding) {
  if (typeof string !== "string") {
    if (isArrayBufferView(string) || isAnyArrayBuffer2(string)) {
      return string.byteLength;
    }
    throw new codes.ERR_INVALID_ARG_TYPE("string", ["string", "Buffer", "ArrayBuffer"], string);
  }
  const len = string.length;
  const mustMatch = arguments.length > 2 && arguments[2] === true;
  if (!mustMatch && len === 0) {
    return 0;
  }
  if (!encoding) {
    return mustMatch ? -1 : byteLengthUtf8(string);
  }
  const ops = getEncodingOps(encoding);
  if (ops === void 0) {
    return mustMatch ? -1 : byteLengthUtf8(string);
  }
  return ops.byteLength(string);
}
Buffer3.byteLength = byteLength;
Buffer3.prototype._isBuffer = true;
function swap(b2, n, m3) {
  const i = b2[n];
  b2[n] = b2[m3];
  b2[m3] = i;
}
Buffer3.prototype.swap16 = function swap16() {
  const len = this.length;
  if (len % 2 !== 0) {
    throw new RangeError("Buffer size must be a multiple of 16-bits");
  }
  for (let i = 0; i < len; i += 2) {
    swap(this, i, i + 1);
  }
  return this;
};
Buffer3.prototype.swap32 = function swap32() {
  const len = this.length;
  if (len % 4 !== 0) {
    throw new RangeError("Buffer size must be a multiple of 32-bits");
  }
  for (let i = 0; i < len; i += 4) {
    swap(this, i, i + 3);
    swap(this, i + 1, i + 2);
  }
  return this;
};
Buffer3.prototype.swap64 = function swap64() {
  const len = this.length;
  if (len % 8 !== 0) {
    throw new RangeError("Buffer size must be a multiple of 64-bits");
  }
  for (let i = 0; i < len; i += 8) {
    swap(this, i, i + 7);
    swap(this, i + 1, i + 6);
    swap(this, i + 2, i + 5);
    swap(this, i + 3, i + 4);
  }
  return this;
};
Buffer3.prototype.toString = function toString(encoding, start, end) {
  if (arguments.length === 0) {
    return this.utf8Slice(0, this.length);
  }
  const len = this.length;
  if (start <= 0) {
    start = 0;
  } else if (start >= len) {
    return "";
  } else {
    start |= 0;
  }
  if (end === void 0 || end > len) {
    end = len;
  } else {
    end |= 0;
  }
  if (end <= start) {
    return "";
  }
  if (encoding === void 0) {
    return this.utf8Slice(start, end);
  }
  const ops = getEncodingOps(encoding);
  if (ops === void 0) {
    throw new codes.ERR_UNKNOWN_ENCODING(encoding);
  }
  return ops.slice(this, start, end);
};
Buffer3.prototype.toLocaleString = Buffer3.prototype.toString;
Buffer3.prototype.equals = function equals2(b2) {
  if (!isUint8Array(b2)) {
    throw new codes.ERR_INVALID_ARG_TYPE("otherBuffer", ["Buffer", "Uint8Array"], b2);
  }
  if (this === b2) {
    return true;
  }
  return Buffer3.compare(this, b2) === 0;
};
Buffer3.prototype.inspect = function inspect2() {
  let str = "";
  const max2 = INSPECT_MAX_BYTES;
  str = this.toString("hex", 0, max2).replace(/(.{2})/g, "$1 ").trim();
  if (this.length > max2) {
    str += " ... ";
  }
  return "<Buffer " + str + ">";
};
if (customInspectSymbol3) {
  Buffer3.prototype[customInspectSymbol3] = Buffer3.prototype.inspect;
}
Buffer3.prototype.compare = function compare2(target, start, end, thisStart, thisEnd) {
  if (isInstance(target, Uint8Array)) {
    target = Buffer3.from(target, target.offset, target.byteLength);
  }
  if (!Buffer3.isBuffer(target)) {
    throw new codes.ERR_INVALID_ARG_TYPE("target", ["Buffer", "Uint8Array"], target);
  }
  if (start === void 0) {
    start = 0;
  } else {
    validateOffset(start, "targetStart", 0, kMaxLength);
  }
  if (end === void 0) {
    end = target.length;
  } else {
    validateOffset(end, "targetEnd", 0, target.length);
  }
  if (thisStart === void 0) {
    thisStart = 0;
  } else {
    validateOffset(start, "sourceStart", 0, kMaxLength);
  }
  if (thisEnd === void 0) {
    thisEnd = this.length;
  } else {
    validateOffset(end, "sourceEnd", 0, this.length);
  }
  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
    throw new codes.ERR_OUT_OF_RANGE("out of range index", "range");
  }
  if (thisStart >= thisEnd && start >= end) {
    return 0;
  }
  if (thisStart >= thisEnd) {
    return -1;
  }
  if (start >= end) {
    return 1;
  }
  start >>>= 0;
  end >>>= 0;
  thisStart >>>= 0;
  thisEnd >>>= 0;
  if (this === target) {
    return 0;
  }
  let x = thisEnd - thisStart;
  let y4 = end - start;
  const len = Math.min(x, y4);
  const thisCopy = this.slice(thisStart, thisEnd);
  const targetCopy = target.slice(start, end);
  for (let i = 0; i < len; ++i) {
    if (thisCopy[i] !== targetCopy[i]) {
      x = thisCopy[i];
      y4 = targetCopy[i];
      break;
    }
  }
  if (x < y4) {
    return -1;
  }
  if (y4 < x) {
    return 1;
  }
  return 0;
};
function bidirectionalIndexOf(buffer, val, byteOffset, encoding, dir) {
  validateBuffer(buffer);
  if (typeof byteOffset === "string") {
    encoding = byteOffset;
    byteOffset = void 0;
  } else if (byteOffset > 2147483647) {
    byteOffset = 2147483647;
  } else if (byteOffset < -2147483648) {
    byteOffset = -2147483648;
  }
  byteOffset = +byteOffset;
  if (Number.isNaN(byteOffset)) {
    byteOffset = dir ? 0 : buffer.length || buffer.byteLength;
  }
  dir = !!dir;
  if (typeof val === "number") {
    return indexOfNumber(buffer, val >>> 0, byteOffset, dir);
  }
  let ops;
  if (encoding === void 0) {
    ops = encodingOps.utf8;
  } else {
    ops = getEncodingOps(encoding);
  }
  if (typeof val === "string") {
    if (ops === void 0) {
      throw new codes.ERR_UNKNOWN_ENCODING(encoding);
    }
    return ops.indexOf(buffer, val, byteOffset, dir);
  }
  if (isUint8Array(val)) {
    const encodingVal = ops === void 0 ? encodingsMap.utf8 : ops.encodingVal;
    return indexOfBuffer(buffer, val, byteOffset, encodingVal, dir);
  }
  throw new codes.ERR_INVALID_ARG_TYPE("value", ["number", "string", "Buffer", "Uint8Array"], val);
}
Buffer3.prototype.includes = function includes(val, byteOffset, encoding) {
  return this.indexOf(val, byteOffset, encoding) !== -1;
};
Buffer3.prototype.indexOf = function indexOf(val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, true);
};
Buffer3.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, false);
};
Buffer3.prototype.asciiSlice = function asciiSlice(offset, length) {
  if (offset === 0 && length === this.length) {
    return bytesToAscii(this);
  } else {
    return bytesToAscii(this.slice(offset, length));
  }
};
Buffer3.prototype.asciiWrite = function asciiWrite(string, offset, length) {
  return blitBuffer(asciiToBytes(string), this, offset, length);
};
Buffer3.prototype.base64Slice = function base64Slice(offset, length) {
  if (offset === 0 && length === this.length) {
    return encode(this);
  } else {
    return encode(this.slice(offset, length));
  }
};
Buffer3.prototype.base64Write = function base64Write(string, offset, length) {
  return blitBuffer(base64ToBytes(string), this, offset, length);
};
Buffer3.prototype.base64urlSlice = function base64urlSlice(offset, length) {
  if (offset === 0 && length === this.length) {
    return encode2(this);
  } else {
    return encode2(this.slice(offset, length));
  }
};
Buffer3.prototype.base64urlWrite = function base64urlWrite(string, offset, length) {
  return blitBuffer(base64UrlToBytes(string), this, offset, length);
};
Buffer3.prototype.hexWrite = function hexWrite(string, offset, length) {
  return blitBuffer(hexToBytes(string, this.length - offset), this, offset, length);
};
Buffer3.prototype.hexSlice = function hexSlice2(string, offset, length) {
  return _hexSlice(this, string, offset, length);
};
Buffer3.prototype.latin1Slice = function latin1Slice(string, offset, length) {
  return _latin1Slice(this, string, offset, length);
};
Buffer3.prototype.latin1Write = function latin1Write(string, offset, length) {
  return blitBuffer(asciiToBytes(string), this, offset, length);
};
Buffer3.prototype.ucs2Slice = function ucs2Slice(offset, length) {
  if (offset === 0 && length === this.length) {
    return bytesToUtf16le(this);
  } else {
    return bytesToUtf16le(this.slice(offset, length));
  }
};
Buffer3.prototype.ucs2Write = function ucs2Write(string, offset, length) {
  return blitBuffer(utf16leToBytes(string, this.length - offset), this, offset, length);
};
Buffer3.prototype.utf8Slice = function utf8Slice(string, offset, length) {
  return _utf8Slice(this, string, offset, length);
};
Buffer3.prototype.utf8Write = function utf8Write(string, offset, length) {
  return blitBuffer(utf8ToBytes(string, this.length - offset), this, offset, length);
};
Buffer3.prototype.write = function write(string, offset, length, encoding) {
  if (offset === void 0) {
    return this.utf8Write(string, 0, this.length);
  }
  if (length === void 0 && typeof offset === "string") {
    encoding = offset;
    length = this.length;
    offset = 0;
  } else {
    validateOffset(offset, "offset", 0, this.length);
    const remaining = this.length - offset;
    if (length === void 0) {
      length = remaining;
    } else if (typeof length === "string") {
      encoding = length;
      length = remaining;
    } else {
      validateOffset(length, "length", 0, this.length);
      if (length > remaining) {
        length = remaining;
      }
    }
  }
  if (!encoding) {
    return this.utf8Write(string, offset, length);
  }
  const ops = getEncodingOps(encoding);
  if (ops === void 0) {
    throw new codes.ERR_UNKNOWN_ENCODING(encoding);
  }
  return ops.write(this, string, offset, length);
};
Buffer3.prototype.toJSON = function toJSON() {
  return {
    type: "Buffer",
    data: Array.prototype.slice.call(this._arr || this, 0)
  };
};
function fromArrayBuffer(obj2, byteOffset, length) {
  if (byteOffset === void 0) {
    byteOffset = 0;
  } else {
    byteOffset = +byteOffset;
    if (Number.isNaN(byteOffset)) {
      byteOffset = 0;
    }
  }
  const maxLength = obj2.byteLength - byteOffset;
  if (maxLength < 0) {
    throw new codes.ERR_BUFFER_OUT_OF_BOUNDS("offset");
  }
  if (length === void 0) {
    length = maxLength;
  } else {
    length = +length;
    if (length > 0) {
      if (length > maxLength) {
        throw new codes.ERR_BUFFER_OUT_OF_BOUNDS("length");
      }
    } else {
      length = 0;
    }
  }
  const buffer = new Uint8Array(obj2, byteOffset, length);
  Object.setPrototypeOf(buffer, Buffer3.prototype);
  return buffer;
}
function _utf8Slice(buf, start, end) {
  end = Math.min(buf.length, end);
  const res = [];
  let i = start;
  while (i < end) {
    const firstByte = buf[i];
    let codePoint = null;
    let bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;
    if (i + bytesPerSequence <= end) {
      let secondByte, thirdByte, fourthByte, tempCodePoint;
      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 128) {
            codePoint = firstByte;
          }
          break;
        case 2:
          secondByte = buf[i + 1];
          if ((secondByte & 192) === 128) {
            tempCodePoint = (firstByte & 31) << 6 | secondByte & 63;
            if (tempCodePoint > 127) {
              codePoint = tempCodePoint;
            }
          }
          break;
        case 3:
          secondByte = buf[i + 1];
          thirdByte = buf[i + 2];
          if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {
            tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63;
            if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) {
              codePoint = tempCodePoint;
            }
          }
          break;
        case 4:
          secondByte = buf[i + 1];
          thirdByte = buf[i + 2];
          fourthByte = buf[i + 3];
          if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {
            tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63;
            if (tempCodePoint > 65535 && tempCodePoint < 1114112) {
              codePoint = tempCodePoint;
            }
          }
      }
    }
    if (codePoint === null) {
      codePoint = 65533;
      bytesPerSequence = 1;
    } else if (codePoint > 65535) {
      codePoint -= 65536;
      res.push(codePoint >>> 10 & 1023 | 55296);
      codePoint = 56320 | codePoint & 1023;
    }
    res.push(codePoint);
    i += bytesPerSequence;
  }
  return decodeCodePointsArray(res);
}
var MAX_ARGUMENTS_LENGTH = 4096;
function decodeCodePointsArray(codePoints) {
  const len = codePoints.length;
  if (len <= MAX_ARGUMENTS_LENGTH) {
    return String.fromCharCode.apply(String, codePoints);
  }
  let res = "";
  let i = 0;
  while (i < len) {
    res += String.fromCharCode.apply(String, codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH));
  }
  return res;
}
function _latin1Slice(buf, start, end) {
  let ret = "";
  end = Math.min(buf.length, end);
  for (let i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i]);
  }
  return ret;
}
function _hexSlice(buf, start, end) {
  const len = buf.length;
  if (!start || start < 0) {
    start = 0;
  }
  if (!end || end < 0 || end > len) {
    end = len;
  }
  let out = "";
  for (let i = start; i < end; ++i) {
    out += hexSliceLookupTable[buf[i]];
  }
  return out;
}
Buffer3.prototype.slice = function slice(start, end) {
  const len = this.length;
  start = ~~start;
  end = end === void 0 ? len : ~~end;
  if (start < 0) {
    start += len;
    if (start < 0) {
      start = 0;
    }
  } else if (start > len) {
    start = len;
  }
  if (end < 0) {
    end += len;
    if (end < 0) {
      end = 0;
    }
  } else if (end > len) {
    end = len;
  }
  if (end < start) {
    end = start;
  }
  const newBuf = this.subarray(start, end);
  Object.setPrototypeOf(newBuf, Buffer3.prototype);
  return newBuf;
};
Buffer3.prototype.readUintLE = Buffer3.prototype.readUIntLE = function readUIntLE(offset, byteLength6) {
  if (offset === void 0) {
    throw new codes.ERR_INVALID_ARG_TYPE("offset", "number", offset);
  }
  if (byteLength6 === 6) {
    return readUInt48LE(this, offset);
  }
  if (byteLength6 === 5) {
    return readUInt40LE(this, offset);
  }
  if (byteLength6 === 3) {
    return readUInt24LE(this, offset);
  }
  if (byteLength6 === 4) {
    return this.readUInt32LE(offset);
  }
  if (byteLength6 === 2) {
    return this.readUInt16LE(offset);
  }
  if (byteLength6 === 1) {
    return this.readUInt8(offset);
  }
  boundsError(byteLength6, 6, "byteLength");
};
Buffer3.prototype.readUintBE = Buffer3.prototype.readUIntBE = function readUIntBE(offset, byteLength6) {
  if (offset === void 0) {
    throw new codes.ERR_INVALID_ARG_TYPE("offset", "number", offset);
  }
  if (byteLength6 === 6) {
    return readUInt48BE(this, offset);
  }
  if (byteLength6 === 5) {
    return readUInt40BE(this, offset);
  }
  if (byteLength6 === 3) {
    return readUInt24BE(this, offset);
  }
  if (byteLength6 === 4) {
    return this.readUInt32BE(offset);
  }
  if (byteLength6 === 2) {
    return this.readUInt16BE(offset);
  }
  if (byteLength6 === 1) {
    return this.readUInt8(offset);
  }
  boundsError(byteLength6, 6, "byteLength");
};
Buffer3.prototype.readUint8 = Buffer3.prototype.readUInt8 = function readUInt8(offset = 0) {
  validateNumber(offset, "offset");
  const val = this[offset];
  if (val === void 0) {
    boundsError(offset, this.length - 1);
  }
  return val;
};
Buffer3.prototype.readUint16BE = Buffer3.prototype.readUInt16BE = readUInt16BE;
Buffer3.prototype.readUint16LE = Buffer3.prototype.readUInt16LE = function readUInt16LE(offset = 0) {
  validateNumber(offset, "offset");
  const first = this[offset];
  const last = this[offset + 1];
  if (first === void 0 || last === void 0) {
    boundsError(offset, this.length - 2);
  }
  return first + last * 2 ** 8;
};
Buffer3.prototype.readUint32LE = Buffer3.prototype.readUInt32LE = function readUInt32LE(offset = 0) {
  validateNumber(offset, "offset");
  const first = this[offset];
  const last = this[offset + 3];
  if (first === void 0 || last === void 0) {
    boundsError(offset, this.length - 4);
  }
  return first + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + last * 2 ** 24;
};
Buffer3.prototype.readUint32BE = Buffer3.prototype.readUInt32BE = readUInt32BE;
Buffer3.prototype.readBigUint64LE = Buffer3.prototype.readBigUInt64LE = defineBigIntMethod(function readBigUInt64LE(offset) {
  offset = offset >>> 0;
  validateNumber(offset, "offset");
  const first = this[offset];
  const last = this[offset + 7];
  if (first === void 0 || last === void 0) {
    boundsError(offset, this.length - 8);
  }
  const lo3 = first + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 24;
  const hi2 = this[++offset] + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + last * 2 ** 24;
  return BigInt(lo3) + (BigInt(hi2) << BigInt(32));
});
Buffer3.prototype.readBigUint64BE = Buffer3.prototype.readBigUInt64BE = defineBigIntMethod(function readBigUInt64BE(offset) {
  offset = offset >>> 0;
  validateNumber(offset, "offset");
  const first = this[offset];
  const last = this[offset + 7];
  if (first === void 0 || last === void 0) {
    boundsError(offset, this.length - 8);
  }
  const hi2 = first * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + this[++offset];
  const lo3 = this[++offset] * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + last;
  return (BigInt(hi2) << BigInt(32)) + BigInt(lo3);
});
Buffer3.prototype.readIntLE = function readIntLE(offset, byteLength6) {
  if (offset === void 0) {
    throw new codes.ERR_INVALID_ARG_TYPE("offset", "number", offset);
  }
  if (byteLength6 === 6) {
    return readInt48LE(this, offset);
  }
  if (byteLength6 === 5) {
    return readInt40LE(this, offset);
  }
  if (byteLength6 === 3) {
    return readInt24LE(this, offset);
  }
  if (byteLength6 === 4) {
    return this.readInt32LE(offset);
  }
  if (byteLength6 === 2) {
    return this.readInt16LE(offset);
  }
  if (byteLength6 === 1) {
    return this.readInt8(offset);
  }
  boundsError(byteLength6, 6, "byteLength");
};
Buffer3.prototype.readIntBE = function readIntBE(offset, byteLength6) {
  if (offset === void 0) {
    throw new codes.ERR_INVALID_ARG_TYPE("offset", "number", offset);
  }
  if (byteLength6 === 6) {
    return readInt48BE(this, offset);
  }
  if (byteLength6 === 5) {
    return readInt40BE(this, offset);
  }
  if (byteLength6 === 3) {
    return readInt24BE(this, offset);
  }
  if (byteLength6 === 4) {
    return this.readInt32BE(offset);
  }
  if (byteLength6 === 2) {
    return this.readInt16BE(offset);
  }
  if (byteLength6 === 1) {
    return this.readInt8(offset);
  }
  boundsError(byteLength6, 6, "byteLength");
};
Buffer3.prototype.readInt8 = function readInt8(offset = 0) {
  validateNumber(offset, "offset");
  const val = this[offset];
  if (val === void 0) {
    boundsError(offset, this.length - 1);
  }
  return val | (val & 2 ** 7) * 33554430;
};
Buffer3.prototype.readInt16LE = function readInt16LE(offset = 0) {
  validateNumber(offset, "offset");
  const first = this[offset];
  const last = this[offset + 1];
  if (first === void 0 || last === void 0) {
    boundsError(offset, this.length - 2);
  }
  const val = first + last * 2 ** 8;
  return val | (val & 2 ** 15) * 131070;
};
Buffer3.prototype.readInt16BE = function readInt16BE(offset = 0) {
  validateNumber(offset, "offset");
  const first = this[offset];
  const last = this[offset + 1];
  if (first === void 0 || last === void 0) {
    boundsError(offset, this.length - 2);
  }
  const val = first * 2 ** 8 + last;
  return val | (val & 2 ** 15) * 131070;
};
Buffer3.prototype.readInt32LE = function readInt32LE(offset = 0) {
  validateNumber(offset, "offset");
  const first = this[offset];
  const last = this[offset + 3];
  if (first === void 0 || last === void 0) {
    boundsError(offset, this.length - 4);
  }
  return first + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + (last << 24);
};
Buffer3.prototype.readInt32BE = function readInt32BE(offset = 0) {
  validateNumber(offset, "offset");
  const first = this[offset];
  const last = this[offset + 3];
  if (first === void 0 || last === void 0) {
    boundsError(offset, this.length - 4);
  }
  return (first << 24) + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + last;
};
Buffer3.prototype.readBigInt64LE = defineBigIntMethod(function readBigInt64LE(offset) {
  offset = offset >>> 0;
  validateNumber(offset, "offset");
  const first = this[offset];
  const last = this[offset + 7];
  if (first === void 0 || last === void 0) {
    boundsError(offset, this.length - 8);
  }
  const val = this[offset + 4] + this[offset + 5] * 2 ** 8 + this[offset + 6] * 2 ** 16 + (last << 24);
  return (BigInt(val) << BigInt(32)) + BigInt(first + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 24);
});
Buffer3.prototype.readBigInt64BE = defineBigIntMethod(function readBigInt64BE(offset) {
  offset = offset >>> 0;
  validateNumber(offset, "offset");
  const first = this[offset];
  const last = this[offset + 7];
  if (first === void 0 || last === void 0) {
    boundsError(offset, this.length - 8);
  }
  const val = (first << 24) + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + this[++offset];
  return (BigInt(val) << BigInt(32)) + BigInt(this[++offset] * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + last);
});
Buffer3.prototype.readFloatLE = function readFloatLE(offset) {
  return bigEndian ? readFloatBackwards(this, offset) : readFloatForwards(this, offset);
};
Buffer3.prototype.readFloatBE = function readFloatBE(offset) {
  return bigEndian ? readFloatForwards(this, offset) : readFloatBackwards(this, offset);
};
Buffer3.prototype.readDoubleLE = function readDoubleLE(offset) {
  return bigEndian ? readDoubleBackwards(this, offset) : readDoubleForwards(this, offset);
};
Buffer3.prototype.readDoubleBE = function readDoubleBE(offset) {
  return bigEndian ? readDoubleForwards(this, offset) : readDoubleBackwards(this, offset);
};
Buffer3.prototype.writeUintLE = Buffer3.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength6) {
  if (byteLength6 === 6) {
    return writeU_Int48LE(this, value, offset, 0, 281474976710655);
  }
  if (byteLength6 === 5) {
    return writeU_Int40LE(this, value, offset, 0, 1099511627775);
  }
  if (byteLength6 === 3) {
    return writeU_Int24LE(this, value, offset, 0, 16777215);
  }
  if (byteLength6 === 4) {
    return writeU_Int32LE(this, value, offset, 0, 4294967295);
  }
  if (byteLength6 === 2) {
    return writeU_Int16LE(this, value, offset, 0, 65535);
  }
  if (byteLength6 === 1) {
    return writeU_Int8(this, value, offset, 0, 255);
  }
  boundsError(byteLength6, 6, "byteLength");
};
Buffer3.prototype.writeUintBE = Buffer3.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength6) {
  if (byteLength6 === 6) {
    return writeU_Int48BE(this, value, offset, 0, 281474976710655);
  }
  if (byteLength6 === 5) {
    return writeU_Int40BE(this, value, offset, 0, 1099511627775);
  }
  if (byteLength6 === 3) {
    return writeU_Int24BE(this, value, offset, 0, 16777215);
  }
  if (byteLength6 === 4) {
    return writeU_Int32BE(this, value, offset, 0, 4294967295);
  }
  if (byteLength6 === 2) {
    return writeU_Int16BE(this, value, offset, 0, 65535);
  }
  if (byteLength6 === 1) {
    return writeU_Int8(this, value, offset, 0, 255);
  }
  boundsError(byteLength6, 6, "byteLength");
};
Buffer3.prototype.writeUint8 = Buffer3.prototype.writeUInt8 = function writeUInt8(value, offset = 0) {
  return writeU_Int8(this, value, offset, 0, 255);
};
Buffer3.prototype.writeUint16LE = Buffer3.prototype.writeUInt16LE = function writeUInt16LE(value, offset = 0) {
  return writeU_Int16LE(this, value, offset, 0, 65535);
};
Buffer3.prototype.writeUint16BE = Buffer3.prototype.writeUInt16BE = function writeUInt16BE(value, offset = 0) {
  return writeU_Int16BE(this, value, offset, 0, 65535);
};
Buffer3.prototype.writeUint32LE = Buffer3.prototype.writeUInt32LE = function writeUInt32LE(value, offset = 0) {
  return _writeUInt32LE(this, value, offset, 0, 4294967295);
};
Buffer3.prototype.writeUint32BE = Buffer3.prototype.writeUInt32BE = function writeUInt32BE(value, offset = 0) {
  return _writeUInt32BE(this, value, offset, 0, 4294967295);
};
function wrtBigUInt64LE(buf, value, offset, min4, max2) {
  checkIntBI(value, min4, max2, buf, offset, 7);
  let lo3 = Number(value & BigInt(4294967295));
  buf[offset++] = lo3;
  lo3 = lo3 >> 8;
  buf[offset++] = lo3;
  lo3 = lo3 >> 8;
  buf[offset++] = lo3;
  lo3 = lo3 >> 8;
  buf[offset++] = lo3;
  let hi2 = Number(value >> BigInt(32) & BigInt(4294967295));
  buf[offset++] = hi2;
  hi2 = hi2 >> 8;
  buf[offset++] = hi2;
  hi2 = hi2 >> 8;
  buf[offset++] = hi2;
  hi2 = hi2 >> 8;
  buf[offset++] = hi2;
  return offset;
}
function wrtBigUInt64BE(buf, value, offset, min4, max2) {
  checkIntBI(value, min4, max2, buf, offset, 7);
  let lo3 = Number(value & BigInt(4294967295));
  buf[offset + 7] = lo3;
  lo3 = lo3 >> 8;
  buf[offset + 6] = lo3;
  lo3 = lo3 >> 8;
  buf[offset + 5] = lo3;
  lo3 = lo3 >> 8;
  buf[offset + 4] = lo3;
  let hi2 = Number(value >> BigInt(32) & BigInt(4294967295));
  buf[offset + 3] = hi2;
  hi2 = hi2 >> 8;
  buf[offset + 2] = hi2;
  hi2 = hi2 >> 8;
  buf[offset + 1] = hi2;
  hi2 = hi2 >> 8;
  buf[offset] = hi2;
  return offset + 8;
}
Buffer3.prototype.writeBigUint64LE = Buffer3.prototype.writeBigUInt64LE = defineBigIntMethod(function writeBigUInt64LE(value, offset = 0) {
  return wrtBigUInt64LE(this, value, offset, BigInt(0), BigInt("0xffffffffffffffff"));
});
Buffer3.prototype.writeBigUint64BE = Buffer3.prototype.writeBigUInt64BE = defineBigIntMethod(function writeBigUInt64BE(value, offset = 0) {
  return wrtBigUInt64BE(this, value, offset, BigInt(0), BigInt("0xffffffffffffffff"));
});
Buffer3.prototype.writeIntLE = function writeIntLE(value, offset, byteLength6) {
  if (byteLength6 === 6) {
    return writeU_Int48LE(this, value, offset, -140737488355328, 140737488355327);
  }
  if (byteLength6 === 5) {
    return writeU_Int40LE(this, value, offset, -549755813888, 549755813887);
  }
  if (byteLength6 === 3) {
    return writeU_Int24LE(this, value, offset, -8388608, 8388607);
  }
  if (byteLength6 === 4) {
    return writeU_Int32LE(this, value, offset, -2147483648, 2147483647);
  }
  if (byteLength6 === 2) {
    return writeU_Int16LE(this, value, offset, -32768, 32767);
  }
  if (byteLength6 === 1) {
    return writeU_Int8(this, value, offset, -128, 127);
  }
  boundsError(byteLength6, 6, "byteLength");
};
Buffer3.prototype.writeIntBE = function writeIntBE(value, offset, byteLength6) {
  if (byteLength6 === 6) {
    return writeU_Int48BE(this, value, offset, -140737488355328, 140737488355327);
  }
  if (byteLength6 === 5) {
    return writeU_Int40BE(this, value, offset, -549755813888, 549755813887);
  }
  if (byteLength6 === 3) {
    return writeU_Int24BE(this, value, offset, -8388608, 8388607);
  }
  if (byteLength6 === 4) {
    return writeU_Int32BE(this, value, offset, -2147483648, 2147483647);
  }
  if (byteLength6 === 2) {
    return writeU_Int16BE(this, value, offset, -32768, 32767);
  }
  if (byteLength6 === 1) {
    return writeU_Int8(this, value, offset, -128, 127);
  }
  boundsError(byteLength6, 6, "byteLength");
};
Buffer3.prototype.writeInt8 = function writeInt8(value, offset = 0) {
  return writeU_Int8(this, value, offset, -128, 127);
};
Buffer3.prototype.writeInt16LE = function writeInt16LE(value, offset = 0) {
  return writeU_Int16LE(this, value, offset, -32768, 32767);
};
Buffer3.prototype.writeInt16BE = function writeInt16BE(value, offset = 0) {
  return writeU_Int16BE(this, value, offset, -32768, 32767);
};
Buffer3.prototype.writeInt32LE = function writeInt32LE(value, offset = 0) {
  return writeU_Int32LE(this, value, offset, -2147483648, 2147483647);
};
Buffer3.prototype.writeInt32BE = function writeInt32BE(value, offset = 0) {
  return writeU_Int32BE(this, value, offset, -2147483648, 2147483647);
};
Buffer3.prototype.writeBigInt64LE = defineBigIntMethod(function writeBigInt64LE(value, offset = 0) {
  return wrtBigUInt64LE(this, value, offset, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
});
Buffer3.prototype.writeBigInt64BE = defineBigIntMethod(function writeBigInt64BE(value, offset = 0) {
  return wrtBigUInt64BE(this, value, offset, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
});
Buffer3.prototype.writeFloatLE = function writeFloatLE(value, offset) {
  return bigEndian ? writeFloatBackwards(this, value, offset) : writeFloatForwards(this, value, offset);
};
Buffer3.prototype.writeFloatBE = function writeFloatBE(value, offset) {
  return bigEndian ? writeFloatForwards(this, value, offset) : writeFloatBackwards(this, value, offset);
};
Buffer3.prototype.writeDoubleLE = function writeDoubleLE(value, offset) {
  return bigEndian ? writeDoubleBackwards(this, value, offset) : writeDoubleForwards(this, value, offset);
};
Buffer3.prototype.writeDoubleBE = function writeDoubleBE(value, offset) {
  return bigEndian ? writeDoubleForwards(this, value, offset) : writeDoubleBackwards(this, value, offset);
};
Buffer3.prototype.copy = function copy2(target, targetStart, sourceStart, sourceEnd) {
  if (!isUint8Array(this)) {
    throw new codes.ERR_INVALID_ARG_TYPE("source", ["Buffer", "Uint8Array"], this);
  }
  if (!isUint8Array(target)) {
    throw new codes.ERR_INVALID_ARG_TYPE("target", ["Buffer", "Uint8Array"], target);
  }
  if (targetStart === void 0) {
    targetStart = 0;
  } else {
    targetStart = toInteger(targetStart, 0);
    if (targetStart < 0) {
      throw new codes.ERR_OUT_OF_RANGE("targetStart", ">= 0", targetStart);
    }
  }
  if (sourceStart === void 0) {
    sourceStart = 0;
  } else {
    sourceStart = toInteger(sourceStart, 0);
    if (sourceStart < 0) {
      throw new codes.ERR_OUT_OF_RANGE("sourceStart", ">= 0", sourceStart);
    }
    if (sourceStart >= MAX_UINT32) {
      throw new codes.ERR_OUT_OF_RANGE("sourceStart", `< ${MAX_UINT32}`, sourceStart);
    }
  }
  if (sourceEnd === void 0) {
    sourceEnd = this.length;
  } else {
    sourceEnd = toInteger(sourceEnd, 0);
    if (sourceEnd < 0) {
      throw new codes.ERR_OUT_OF_RANGE("sourceEnd", ">= 0", sourceEnd);
    }
    if (sourceEnd >= MAX_UINT32) {
      throw new codes.ERR_OUT_OF_RANGE("sourceEnd", `< ${MAX_UINT32}`, sourceEnd);
    }
  }
  if (targetStart >= target.length) {
    return 0;
  }
  if (sourceEnd > 0 && sourceEnd < sourceStart) {
    sourceEnd = sourceStart;
  }
  if (sourceEnd === sourceStart) {
    return 0;
  }
  if (target.length === 0 || this.length === 0) {
    return 0;
  }
  if (sourceEnd > this.length) {
    sourceEnd = this.length;
  }
  if (target.length - targetStart < sourceEnd - sourceStart) {
    sourceEnd = target.length - targetStart + sourceStart;
  }
  const len = sourceEnd - sourceStart;
  if (this === target && typeof Uint8Array.prototype.copyWithin === "function") {
    this.copyWithin(targetStart, sourceStart, sourceEnd);
  } else {
    Uint8Array.prototype.set.call(target, this.subarray(sourceStart, sourceEnd), targetStart);
  }
  return len;
};
Buffer3.prototype.fill = function fill(val, start, end, encoding) {
  if (typeof val === "string") {
    if (typeof start === "string") {
      encoding = start;
      start = 0;
      end = this.length;
    } else if (typeof end === "string") {
      encoding = end;
      end = this.length;
    }
    if (encoding !== void 0 && typeof encoding !== "string") {
      throw new TypeError("encoding must be a string");
    }
    if (typeof encoding === "string" && !Buffer3.isEncoding(encoding)) {
      throw new TypeError("Unknown encoding: " + encoding);
    }
    if (val.length === 1) {
      const code2 = val.charCodeAt(0);
      if (encoding === "utf8" && code2 < 128 || encoding === "latin1") {
        val = code2;
      }
    }
  } else if (typeof val === "number") {
    val = val & 255;
  } else if (typeof val === "boolean") {
    val = Number(val);
  }
  if (start < 0 || this.length < start || this.length < end) {
    throw new RangeError("Out of range index");
  }
  if (end <= start) {
    return this;
  }
  start = start >>> 0;
  end = end === void 0 ? this.length : end >>> 0;
  if (!val) {
    val = 0;
  }
  let i;
  if (typeof val === "number") {
    for (i = start; i < end; ++i) {
      this[i] = val;
    }
  } else {
    const bytes = Buffer3.isBuffer(val) ? val : Buffer3.from(val, encoding);
    const len = bytes.length;
    if (len === 0) {
      throw new codes.ERR_INVALID_ARG_VALUE("value", val);
    }
    for (i = 0; i < end - start; ++i) {
      this[i + start] = bytes[i % len];
    }
  }
  return this;
};
function checkBounds2(buf, offset, byteLength22) {
  validateNumber(offset, "offset");
  if (buf[offset] === void 0 || buf[offset + byteLength22] === void 0) {
    boundsError(offset, buf.length - (byteLength22 + 1));
  }
}
function checkIntBI(value, min4, max2, buf, offset, byteLength22) {
  if (value > max2 || value < min4) {
    const n = typeof min4 === "bigint" ? "n" : "";
    let range;
    if (byteLength22 > 3) {
      if (min4 === 0 || min4 === BigInt(0)) {
        range = `>= 0${n} and < 2${n} ** ${(byteLength22 + 1) * 8}${n}`;
      } else {
        range = `>= -(2${n} ** ${(byteLength22 + 1) * 8 - 1}${n}) and < 2 ** ${(byteLength22 + 1) * 8 - 1}${n}`;
      }
    } else {
      range = `>= ${min4}${n} and <= ${max2}${n}`;
    }
    throw new codes.ERR_OUT_OF_RANGE("value", range, value);
  }
  checkBounds2(buf, offset, byteLength22);
}
function utf8ToBytes(string, units) {
  units = units || Infinity;
  let codePoint;
  const length = string.length;
  let leadSurrogate = null;
  const bytes = [];
  for (let i = 0; i < length; ++i) {
    codePoint = string.charCodeAt(i);
    if (codePoint > 55295 && codePoint < 57344) {
      if (!leadSurrogate) {
        if (codePoint > 56319) {
          if ((units -= 3) > -1) {
            bytes.push(239, 191, 189);
          }
          continue;
        } else if (i + 1 === length) {
          if ((units -= 3) > -1) {
            bytes.push(239, 191, 189);
          }
          continue;
        }
        leadSurrogate = codePoint;
        continue;
      }
      if (codePoint < 56320) {
        if ((units -= 3) > -1) {
          bytes.push(239, 191, 189);
        }
        leadSurrogate = codePoint;
        continue;
      }
      codePoint = (leadSurrogate - 55296 << 10 | codePoint - 56320) + 65536;
    } else if (leadSurrogate) {
      if ((units -= 3) > -1) {
        bytes.push(239, 191, 189);
      }
    }
    leadSurrogate = null;
    if (codePoint < 128) {
      if ((units -= 1) < 0) {
        break;
      }
      bytes.push(codePoint);
    } else if (codePoint < 2048) {
      if ((units -= 2) < 0) {
        break;
      }
      bytes.push(codePoint >> 6 | 192, codePoint & 63 | 128);
    } else if (codePoint < 65536) {
      if ((units -= 3) < 0) {
        break;
      }
      bytes.push(codePoint >> 12 | 224, codePoint >> 6 & 63 | 128, codePoint & 63 | 128);
    } else if (codePoint < 1114112) {
      if ((units -= 4) < 0) {
        break;
      }
      bytes.push(codePoint >> 18 | 240, codePoint >> 12 & 63 | 128, codePoint >> 6 & 63 | 128, codePoint & 63 | 128);
    } else {
      throw new Error("Invalid code point");
    }
  }
  return bytes;
}
function blitBuffer(src, dst, offset, byteLength6) {
  let i;
  const length = byteLength6 === void 0 ? src.length : byteLength6;
  for (i = 0; i < length; ++i) {
    if (i + offset >= dst.length || i >= src.length) {
      break;
    }
    dst[i + offset] = src[i];
  }
  return i;
}
function isInstance(obj2, type) {
  return obj2 instanceof type || obj2 != null && obj2.constructor != null && obj2.constructor.name != null && obj2.constructor.name === type.name;
}
var hexSliceLookupTable = function() {
  const alphabet = "0123456789abcdef";
  const table = new Array(256);
  for (let i = 0; i < 16; ++i) {
    const i16 = i * 16;
    for (let j2 = 0; j2 < 16; ++j2) {
      table[i16 + j2] = alphabet[i] + alphabet[j2];
    }
  }
  return table;
}();
function defineBigIntMethod(fn) {
  return typeof BigInt === "undefined" ? BufferBigIntNotDefined : fn;
}
function BufferBigIntNotDefined() {
  throw new Error("BigInt not supported");
}
var atob2 = globalThis.atob;
var Blob2 = globalThis.Blob;
var btoa = globalThis.btoa;

// deno:https://deno.land/std@0.147.0/node/internal/util/comparisons.ts
var memo;
function isDeepStrictEqual(val1, val2) {
  return innerDeepEqual(val1, val2, true);
}
function innerDeepEqual(val1, val2, strict, memos = memo) {
  if (val1 === val2) {
    if (val1 !== 0)
      return true;
    return strict ? Object.is(val1, val2) : true;
  }
  if (strict) {
    if (typeof val1 !== "object") {
      return typeof val1 === "number" && Number.isNaN(val1) && Number.isNaN(val2);
    }
    if (typeof val2 !== "object" || val1 === null || val2 === null) {
      return false;
    }
    if (Object.getPrototypeOf(val1) !== Object.getPrototypeOf(val2)) {
      return false;
    }
  } else {
    if (val1 === null || typeof val1 !== "object") {
      if (val2 === null || typeof val2 !== "object") {
        return val1 == val2 || Number.isNaN(val1) && Number.isNaN(val2);
      }
      return false;
    }
    if (val2 === null || typeof val2 !== "object") {
      return false;
    }
  }
  const val1Tag = Object.prototype.toString.call(val1);
  const val2Tag = Object.prototype.toString.call(val2);
  if (val1Tag !== val2Tag) {
    return false;
  }
  if (Array.isArray(val1)) {
    if (!Array.isArray(val2) || val1.length !== val2.length) {
      return false;
    }
    const filter = strict ? ONLY_ENUMERABLE : ONLY_ENUMERABLE | SKIP_SYMBOLS;
    const keys1 = getOwnNonIndexProperties(val1, filter);
    const keys2 = getOwnNonIndexProperties(val2, filter);
    if (keys1.length !== keys2.length) {
      return false;
    }
    return keyCheck(val1, val2, strict, memos, 1 /* isArray */, keys1);
  } else if (val1Tag === "[object Object]") {
    return keyCheck(val1, val2, strict, memos, 0 /* noIterator */);
  } else if (val1 instanceof Date) {
    if (!(val2 instanceof Date) || val1.getTime() !== val2.getTime()) {
      return false;
    }
  } else if (val1 instanceof RegExp) {
    if (!(val2 instanceof RegExp) || !areSimilarRegExps(val1, val2)) {
      return false;
    }
  } else if (isNativeError2(val1) || val1 instanceof Error) {
    if (!isNativeError2(val2) && !(val2 instanceof Error) || val1.message !== val2.message || val1.name !== val2.name) {
      return false;
    }
  } else if (isArrayBufferView(val1)) {
    const TypedArrayPrototypeGetSymbolToStringTag = (val) => Object.getOwnPropertySymbols(val).map((item) => item.toString()).toString();
    if (isTypedArray(val1) && isTypedArray(val2) && TypedArrayPrototypeGetSymbolToStringTag(val1) !== TypedArrayPrototypeGetSymbolToStringTag(val2)) {
      return false;
    }
    if (!strict && (isFloat32Array(val1) || isFloat64Array(val1))) {
      if (!areSimilarFloatArrays(val1, val2)) {
        return false;
      }
    } else if (!areSimilarTypedArrays(val1, val2)) {
      return false;
    }
    const filter = strict ? ONLY_ENUMERABLE : ONLY_ENUMERABLE | SKIP_SYMBOLS;
    const keysVal1 = getOwnNonIndexProperties(val1, filter);
    const keysVal2 = getOwnNonIndexProperties(val2, filter);
    if (keysVal1.length !== keysVal2.length) {
      return false;
    }
    return keyCheck(val1, val2, strict, memos, 0 /* noIterator */, keysVal1);
  } else if (isSet2(val1)) {
    if (!isSet2(val2) || val1.size !== val2.size) {
      return false;
    }
    return keyCheck(val1, val2, strict, memos, 2 /* isSet */);
  } else if (isMap2(val1)) {
    if (!isMap2(val2) || val1.size !== val2.size) {
      return false;
    }
    return keyCheck(val1, val2, strict, memos, 3 /* isMap */);
  } else if (isAnyArrayBuffer2(val1)) {
    if (!isAnyArrayBuffer2(val2) || !areEqualArrayBuffers(val1, val2)) {
      return false;
    }
  } else if (isBoxedPrimitive2(val1)) {
    if (!isEqualBoxedPrimitive(val1, val2)) {
      return false;
    }
  } else if (Array.isArray(val2) || isArrayBufferView(val2) || isSet2(val2) || isMap2(val2) || isDate2(val2) || isRegExp2(val2) || isAnyArrayBuffer2(val2) || isBoxedPrimitive2(val2) || isNativeError2(val2) || val2 instanceof Error) {
    return false;
  }
  return keyCheck(val1, val2, strict, memos, 0 /* noIterator */);
}
function keyCheck(val1, val2, strict, memos, iterationType, aKeys = []) {
  if (arguments.length === 5) {
    aKeys = Object.keys(val1);
    const bKeys = Object.keys(val2);
    if (aKeys.length !== bKeys.length) {
      return false;
    }
  }
  let i = 0;
  for (; i < aKeys.length; i++) {
    if (!val2.propertyIsEnumerable(aKeys[i])) {
      return false;
    }
  }
  if (strict && arguments.length === 5) {
    const symbolKeysA = Object.getOwnPropertySymbols(val1);
    if (symbolKeysA.length !== 0) {
      let count = 0;
      for (i = 0; i < symbolKeysA.length; i++) {
        const key2 = symbolKeysA[i];
        if (val1.propertyIsEnumerable(key2)) {
          if (!val2.propertyIsEnumerable(key2)) {
            return false;
          }
          aKeys.push(key2.toString());
          count++;
        } else if (val2.propertyIsEnumerable(key2)) {
          return false;
        }
      }
      const symbolKeysB = Object.getOwnPropertySymbols(val2);
      if (symbolKeysA.length !== symbolKeysB.length && getEnumerables(val2, symbolKeysB).length !== count) {
        return false;
      }
    } else {
      const symbolKeysB = Object.getOwnPropertySymbols(val2);
      if (symbolKeysB.length !== 0 && getEnumerables(val2, symbolKeysB).length !== 0) {
        return false;
      }
    }
  }
  if (aKeys.length === 0 && (iterationType === 0 /* noIterator */ || iterationType === 1 /* isArray */ && val1.length === 0 || val1.size === 0)) {
    return true;
  }
  if (memos === void 0) {
    memos = {
      val1: /* @__PURE__ */ new Map(),
      val2: /* @__PURE__ */ new Map(),
      position: 0
    };
  } else {
    const val2MemoA = memos.val1.get(val1);
    if (val2MemoA !== void 0) {
      const val2MemoB = memos.val2.get(val2);
      if (val2MemoB !== void 0) {
        return val2MemoA === val2MemoB;
      }
    }
    memos.position++;
  }
  memos.val1.set(val1, memos.position);
  memos.val2.set(val2, memos.position);
  const areEq = objEquiv(val1, val2, strict, aKeys, memos, iterationType);
  memos.val1.delete(val1);
  memos.val2.delete(val2);
  return areEq;
}
function areSimilarRegExps(a, b2) {
  return a.source === b2.source && a.flags === b2.flags && a.lastIndex === b2.lastIndex;
}
function areSimilarFloatArrays(arr1, arr2) {
  if (arr1.byteLength !== arr2.byteLength) {
    return false;
  }
  for (let i = 0; i < arr1.byteLength; i++) {
    if (arr1[i] !== arr2[i]) {
      return false;
    }
  }
  return true;
}
function areSimilarTypedArrays(arr1, arr2) {
  if (arr1.byteLength !== arr2.byteLength) {
    return false;
  }
  return Buffer3.compare(new Uint8Array(arr1.buffer, arr1.byteOffset, arr1.byteLength), new Uint8Array(arr2.buffer, arr2.byteOffset, arr2.byteLength)) === 0;
}
function areEqualArrayBuffers(buf1, buf2) {
  return buf1.byteLength === buf2.byteLength && Buffer3.compare(new Uint8Array(buf1), new Uint8Array(buf2)) === 0;
}
function isEqualBoxedPrimitive(a, b2) {
  if (Object.getOwnPropertyNames(a).length !== Object.getOwnPropertyNames(b2).length) {
    return false;
  }
  if (Object.getOwnPropertySymbols(a).length !== Object.getOwnPropertySymbols(b2).length) {
    return false;
  }
  if (isNumberObject2(a)) {
    return isNumberObject2(b2) && Object.is(Number.prototype.valueOf.call(a), Number.prototype.valueOf.call(b2));
  }
  if (isStringObject2(a)) {
    return isStringObject2(b2) && String.prototype.valueOf.call(a) === String.prototype.valueOf.call(b2);
  }
  if (isBooleanObject2(a)) {
    return isBooleanObject2(b2) && Boolean.prototype.valueOf.call(a) === Boolean.prototype.valueOf.call(b2);
  }
  if (isBigIntObject2(a)) {
    return isBigIntObject2(b2) && BigInt.prototype.valueOf.call(a) === BigInt.prototype.valueOf.call(b2);
  }
  if (isSymbolObject2(a)) {
    return isSymbolObject2(b2) && Symbol.prototype.valueOf.call(a) === Symbol.prototype.valueOf.call(b2);
  }
  throw Error(`Unknown boxed type`);
}
function getEnumerables(val, keys) {
  return keys.filter((key2) => val.propertyIsEnumerable(key2));
}
function objEquiv(obj1, obj2, strict, keys, memos, iterationType) {
  let i = 0;
  if (iterationType === 2 /* isSet */) {
    if (!setEquiv(obj1, obj2, strict, memos)) {
      return false;
    }
  } else if (iterationType === 3 /* isMap */) {
    if (!mapEquiv(obj1, obj2, strict, memos)) {
      return false;
    }
  } else if (iterationType === 1 /* isArray */) {
    for (; i < obj1.length; i++) {
      if (obj1.hasOwnProperty(i)) {
        if (!obj2.hasOwnProperty(i) || !innerDeepEqual(obj1[i], obj2[i], strict, memos)) {
          return false;
        }
      } else if (obj2.hasOwnProperty(i)) {
        return false;
      } else {
        const keys1 = Object.keys(obj1);
        for (; i < keys1.length; i++) {
          const key2 = keys1[i];
          if (!obj2.hasOwnProperty(key2) || !innerDeepEqual(obj1[key2], obj2[key2], strict, memos)) {
            return false;
          }
        }
        if (keys1.length !== Object.keys(obj2).length) {
          return false;
        }
        if (keys1.length !== Object.keys(obj2).length) {
          return false;
        }
        return true;
      }
    }
  }
  for (i = 0; i < keys.length; i++) {
    const key2 = keys[i];
    if (!innerDeepEqual(obj1[key2], obj2[key2], strict, memos)) {
      return false;
    }
  }
  return true;
}
function findLooseMatchingPrimitives(primitive) {
  switch (typeof primitive) {
    case "undefined":
      return null;
    case "object":
      return void 0;
    case "symbol":
      return false;
    case "string":
      primitive = +primitive;
    case "number":
      if (Number.isNaN(primitive)) {
        return false;
      }
  }
  return true;
}
function setMightHaveLoosePrim(set1, set2, primitive) {
  const altValue = findLooseMatchingPrimitives(primitive);
  if (altValue != null)
    return altValue;
  return set2.has(altValue) && !set1.has(altValue);
}
function setHasEqualElement(set, val1, strict, memos) {
  for (const val2 of set) {
    if (innerDeepEqual(val1, val2, strict, memos)) {
      set.delete(val2);
      return true;
    }
  }
  return false;
}
function setEquiv(set1, set2, strict, memos) {
  let set = null;
  for (const item of set1) {
    if (typeof item === "object" && item !== null) {
      if (set === null) {
        set = /* @__PURE__ */ new Set();
      }
      set.add(item);
    } else if (!set2.has(item)) {
      if (strict)
        return false;
      if (!setMightHaveLoosePrim(set1, set2, item)) {
        return false;
      }
      if (set === null) {
        set = /* @__PURE__ */ new Set();
      }
      set.add(item);
    }
  }
  if (set !== null) {
    for (const item of set2) {
      if (typeof item === "object" && item !== null) {
        if (!setHasEqualElement(set, item, strict, memos))
          return false;
      } else if (!strict && !set1.has(item) && !setHasEqualElement(set, item, strict, memos)) {
        return false;
      }
    }
    return set.size === 0;
  }
  return true;
}
function mapMightHaveLoosePrimitive(map1, map2, primitive, item, memos) {
  const altValue = findLooseMatchingPrimitives(primitive);
  if (altValue != null) {
    return altValue;
  }
  const curB = map2.get(altValue);
  if (curB === void 0 && !map2.has(altValue) || !innerDeepEqual(item, curB, false, memo)) {
    return false;
  }
  return !map1.has(altValue) && innerDeepEqual(item, curB, false, memos);
}
function mapEquiv(map1, map2, strict, memos) {
  let set = null;
  for (const { 0: key2, 1: item1 } of map1) {
    if (typeof key2 === "object" && key2 !== null) {
      if (set === null) {
        set = /* @__PURE__ */ new Set();
      }
      set.add(key2);
    } else {
      const item2 = map2.get(key2);
      if (item2 === void 0 && !map2.has(key2) || !innerDeepEqual(item1, item2, strict, memos)) {
        if (strict)
          return false;
        if (!mapMightHaveLoosePrimitive(map1, map2, key2, item1, memos)) {
          return false;
        }
        if (set === null) {
          set = /* @__PURE__ */ new Set();
        }
        set.add(key2);
      }
    }
  }
  if (set !== null) {
    for (const { 0: key2, 1: item } of map2) {
      if (typeof key2 === "object" && key2 !== null) {
        if (!mapHasEqualEntry(set, map1, key2, item, strict, memos)) {
          return false;
        }
      } else if (!strict && (!map1.has(key2) || !innerDeepEqual(map1.get(key2), item, false, memos)) && !mapHasEqualEntry(set, map1, key2, item, false, memos)) {
        return false;
      }
    }
    return set.size === 0;
  }
  return true;
}
function mapHasEqualEntry(set, map, key1, item1, strict, memos) {
  for (const key2 of set) {
    if (innerDeepEqual(key1, key2, strict, memos) && innerDeepEqual(item1, map.get(key2), strict, memos)) {
      set.delete(key2);
      return true;
    }
  }
  return false;
}

// deno:https://deno.land/std@0.147.0/node/util.ts
var NumberIsSafeInteger = Number.isSafeInteger;
function isArray(value) {
  return Array.isArray(value);
}
function isBoolean(value) {
  return typeof value === "boolean" || value instanceof Boolean;
}
function isNull(value) {
  return value === null;
}
function isNullOrUndefined(value) {
  return value === null || value === void 0;
}
function isNumber(value) {
  return typeof value === "number" || value instanceof Number;
}
function isString(value) {
  return typeof value === "string" || value instanceof String;
}
function isSymbol(value) {
  return typeof value === "symbol";
}
function isUndefined(value) {
  return value === void 0;
}
function isObject(value) {
  return value !== null && typeof value === "object";
}
function isError(e) {
  return e instanceof Error;
}
function isFunction(value) {
  return typeof value === "function";
}
function isRegExp3(value) {
  return types_default2.isRegExp(value);
}
function isDate3(value) {
  return types_default2.isDate(value);
}
function isPrimitive(value) {
  return value === null || typeof value !== "object" && typeof value !== "function";
}
function isBuffer2(value) {
  return Buffer3.isBuffer(value);
}
function _extend(target, source) {
  if (source === null || typeof source !== "object")
    return target;
  const keys = Object.keys(source);
  let i = keys.length;
  while (i--) {
    target[keys[i]] = source[keys[i]];
  }
  return target;
}
function getSystemErrorName(code2) {
  if (typeof code2 !== "number") {
    throw new codes.ERR_INVALID_ARG_TYPE("err", "number", code2);
  }
  if (code2 >= 0 || !NumberIsSafeInteger(code2)) {
    throw new codes.ERR_OUT_OF_RANGE("err", "a negative integer", code2);
  }
  return errorMap.get(code2)?.[0];
}
function inherits(ctor, superCtor) {
  if (ctor === void 0 || ctor === null) {
    throw new codes.ERR_INVALID_ARG_TYPE("ctor", "Function", ctor);
  }
  if (superCtor === void 0 || superCtor === null) {
    throw new codes.ERR_INVALID_ARG_TYPE("superCtor", "Function", superCtor);
  }
  if (superCtor.prototype === void 0) {
    throw new codes.ERR_INVALID_ARG_TYPE("superCtor.prototype", "Object", superCtor.prototype);
  }
  Object.defineProperty(ctor, "super_", {
    value: superCtor,
    writable: true,
    configurable: true
  });
  Object.setPrototypeOf(ctor.prototype, superCtor.prototype);
}
var TextDecoder2 = _TextDecoder;
var TextEncoder2 = _TextEncoder;
function pad(n) {
  return n.toString().padStart(2, "0");
}
var months = [
  "Jan",
  "Feb",
  "Mar",
  "Apr",
  "May",
  "Jun",
  "Jul",
  "Aug",
  "Sep",
  "Oct",
  "Nov",
  "Dec"
];
function timestamp() {
  const d4 = new Date();
  const t = [
    pad(d4.getHours()),
    pad(d4.getMinutes()),
    pad(d4.getSeconds())
  ].join(":");
  return `${d4.getDate()} ${months[d4.getMonth()]} ${t}`;
}
function log(...args) {
  console.log("%s - %s", timestamp(), format2(...args));
}
var util_default = {
  format: format2,
  formatWithOptions,
  inspect,
  isArray,
  isBoolean,
  isNull,
  isNullOrUndefined,
  isNumber,
  isString,
  isSymbol,
  isUndefined,
  isObject,
  isError,
  isFunction,
  isRegExp: isRegExp3,
  isDate: isDate3,
  isPrimitive,
  isBuffer: isBuffer2,
  _extend,
  getSystemErrorName,
  deprecate,
  callbackify,
  promisify,
  inherits,
  types: types_default2,
  stripVTControlCharacters,
  TextDecoder: TextDecoder2,
  TextEncoder: TextEncoder2,
  log,
  debuglog,
  isDeepStrictEqual
};

// deno:https://deno.land/std@0.147.0/node/internal/errors.ts
var {
  errno: { ENOTDIR, ENOENT }
} = os;
var kIsNodeError = Symbol("kIsNodeError");
var classRegExp2 = /^([A-Z][a-z0-9]*)+$/;
var kTypes = [
  "string",
  "function",
  "number",
  "object",
  "Function",
  "Object",
  "boolean",
  "bigint",
  "symbol"
];
var AbortError = class extends Error {
  constructor() {
    super("The operation was aborted");
    this.code = "ABORT_ERR";
    this.name = "AbortError";
  }
};
function addNumericalSeparator(val) {
  let res = "";
  let i = val.length;
  const start = val[0] === "-" ? 1 : 0;
  for (; i >= start + 4; i -= 3) {
    res = `_${val.slice(i - 3, i)}${res}`;
  }
  return `${val.slice(0, i)}${res}`;
}
var captureLargerStackTrace = hideStackFrames(function captureLargerStackTrace2(err) {
  Error.captureStackTrace(err);
  return err;
});
var uvExceptionWithHostPort = hideStackFrames(function uvExceptionWithHostPort2(err, syscall, address, port) {
  const { 0: code2, 1: uvmsg } = uvErrmapGet(err) || uvUnmappedError;
  const message = `${syscall} ${code2}: ${uvmsg}`;
  let details = "";
  if (port && port > 0) {
    details = ` ${address}:${port}`;
  } else if (address) {
    details = ` ${address}`;
  }
  const ex = new Error(`${message}${details}`);
  ex.code = code2;
  ex.errno = err;
  ex.syscall = syscall;
  ex.address = address;
  if (port) {
    ex.port = port;
  }
  return captureLargerStackTrace(ex);
});
var errnoException = hideStackFrames(function errnoException2(err, syscall, original) {
  const code2 = getSystemErrorName(err);
  const message = original ? `${syscall} ${code2} ${original}` : `${syscall} ${code2}`;
  const ex = new Error(message);
  ex.errno = err;
  ex.code = code2;
  ex.syscall = syscall;
  return captureLargerStackTrace(ex);
});
function uvErrmapGet(name) {
  return errorMap.get(name);
}
var uvUnmappedError = ["UNKNOWN", "unknown error"];
var uvException = hideStackFrames(function uvException2(ctx) {
  const { 0: code2, 1: uvmsg } = uvErrmapGet(ctx.errno) || uvUnmappedError;
  let message = `${code2}: ${ctx.message || uvmsg}, ${ctx.syscall}`;
  let path6;
  let dest;
  if (ctx.path) {
    path6 = ctx.path.toString();
    message += ` '${path6}'`;
  }
  if (ctx.dest) {
    dest = ctx.dest.toString();
    message += ` -> '${dest}'`;
  }
  const err = new Error(message);
  for (const prop of Object.keys(ctx)) {
    if (prop === "message" || prop === "path" || prop === "dest") {
      continue;
    }
    err[prop] = ctx[prop];
  }
  err.code = code2;
  if (path6) {
    err.path = path6;
  }
  if (dest) {
    err.dest = dest;
  }
  return captureLargerStackTrace(err);
});
var exceptionWithHostPort = hideStackFrames(function exceptionWithHostPort2(err, syscall, address, port, additional) {
  const code2 = getSystemErrorName(err);
  let details = "";
  if (port && port > 0) {
    details = ` ${address}:${port}`;
  } else if (address) {
    details = ` ${address}`;
  }
  if (additional) {
    details += ` - Local (${additional})`;
  }
  const ex = new Error(`${syscall} ${code2}${details}`);
  ex.errno = err;
  ex.code = code2;
  ex.syscall = syscall;
  ex.address = address;
  if (port) {
    ex.port = port;
  }
  return captureLargerStackTrace(ex);
});
var dnsException = hideStackFrames(function(code2, syscall, hostname) {
  let errno;
  if (typeof code2 === "number") {
    errno = code2;
    if (code2 === codeMap.get("EAI_NODATA") || code2 === codeMap.get("EAI_NONAME")) {
      code2 = "ENOTFOUND";
    } else {
      code2 = getSystemErrorName(code2);
    }
  }
  const message = `${syscall} ${code2}${hostname ? ` ${hostname}` : ""}`;
  const ex = new Error(message);
  ex.errno = errno;
  ex.code = code2;
  ex.syscall = syscall;
  if (hostname) {
    ex.hostname = hostname;
  }
  return captureLargerStackTrace(ex);
});
var NodeErrorAbstraction = class extends Error {
  constructor(name, code2, message) {
    super(message);
    this.code = code2;
    this.name = name;
    this.stack = this.stack && `${name} [${this.code}]${this.stack.slice(20)}`;
  }
  toString() {
    return `${this.name} [${this.code}]: ${this.message}`;
  }
};
var NodeError = class extends NodeErrorAbstraction {
  constructor(code2, message) {
    super(Error.prototype.name, code2, message);
  }
};
var NodeRangeError = class extends NodeErrorAbstraction {
  constructor(code2, message) {
    super(RangeError.prototype.name, code2, message);
    Object.setPrototypeOf(this, RangeError.prototype);
    this.toString = function() {
      return `${this.name} [${this.code}]: ${this.message}`;
    };
  }
};
var NodeTypeError = class extends NodeErrorAbstraction {
  constructor(code2, message) {
    super(TypeError.prototype.name, code2, message);
    Object.setPrototypeOf(this, TypeError.prototype);
    this.toString = function() {
      return `${this.name} [${this.code}]: ${this.message}`;
    };
  }
};
var NodeSystemError = class extends NodeErrorAbstraction {
  constructor(key2, context, msgPrefix) {
    let message = `${msgPrefix}: ${context.syscall} returned ${context.code} (${context.message})`;
    if (context.path !== void 0) {
      message += ` ${context.path}`;
    }
    if (context.dest !== void 0) {
      message += ` => ${context.dest}`;
    }
    super("SystemError", key2, message);
    captureLargerStackTrace(this);
    Object.defineProperties(this, {
      [kIsNodeError]: {
        value: true,
        enumerable: false,
        writable: false,
        configurable: true
      },
      info: {
        value: context,
        enumerable: true,
        configurable: true,
        writable: false
      },
      errno: {
        get() {
          return context.errno;
        },
        set: (value) => {
          context.errno = value;
        },
        enumerable: true,
        configurable: true
      },
      syscall: {
        get() {
          return context.syscall;
        },
        set: (value) => {
          context.syscall = value;
        },
        enumerable: true,
        configurable: true
      }
    });
    if (context.path !== void 0) {
      Object.defineProperty(this, "path", {
        get() {
          return context.path;
        },
        set: (value) => {
          context.path = value;
        },
        enumerable: true,
        configurable: true
      });
    }
    if (context.dest !== void 0) {
      Object.defineProperty(this, "dest", {
        get() {
          return context.dest;
        },
        set: (value) => {
          context.dest = value;
        },
        enumerable: true,
        configurable: true
      });
    }
  }
  toString() {
    return `${this.name} [${this.code}]: ${this.message}`;
  }
};
function makeSystemErrorWithCode(key2, msgPrfix) {
  return class NodeError extends NodeSystemError {
    constructor(ctx) {
      super(key2, ctx, msgPrfix);
    }
  };
}
var ERR_FS_EISDIR = makeSystemErrorWithCode("ERR_FS_EISDIR", "Path is a directory");
function createInvalidArgType(name, expected) {
  expected = Array.isArray(expected) ? expected : [expected];
  let msg = "The ";
  if (name.endsWith(" argument")) {
    msg += `${name} `;
  } else {
    const type = name.includes(".") ? "property" : "argument";
    msg += `"${name}" ${type} `;
  }
  msg += "must be ";
  const types = [];
  const instances = [];
  const other = [];
  for (const value of expected) {
    if (kTypes.includes(value)) {
      types.push(value.toLocaleLowerCase());
    } else if (classRegExp2.test(value)) {
      instances.push(value);
    } else {
      other.push(value);
    }
  }
  if (instances.length > 0) {
    const pos = types.indexOf("object");
    if (pos !== -1) {
      types.splice(pos, 1);
      instances.push("Object");
    }
  }
  if (types.length > 0) {
    if (types.length > 2) {
      const last = types.pop();
      msg += `one of type ${types.join(", ")}, or ${last}`;
    } else if (types.length === 2) {
      msg += `one of type ${types[0]} or ${types[1]}`;
    } else {
      msg += `of type ${types[0]}`;
    }
    if (instances.length > 0 || other.length > 0) {
      msg += " or ";
    }
  }
  if (instances.length > 0) {
    if (instances.length > 2) {
      const last = instances.pop();
      msg += `an instance of ${instances.join(", ")}, or ${last}`;
    } else {
      msg += `an instance of ${instances[0]}`;
      if (instances.length === 2) {
        msg += ` or ${instances[1]}`;
      }
    }
    if (other.length > 0) {
      msg += " or ";
    }
  }
  if (other.length > 0) {
    if (other.length > 2) {
      const last = other.pop();
      msg += `one of ${other.join(", ")}, or ${last}`;
    } else if (other.length === 2) {
      msg += `one of ${other[0]} or ${other[1]}`;
    } else {
      if (other[0].toLowerCase() !== other[0]) {
        msg += "an ";
      }
      msg += `${other[0]}`;
    }
  }
  return msg;
}
var ERR_INVALID_ARG_TYPE_RANGE = class extends NodeRangeError {
  constructor(name, expected, actual) {
    const msg = createInvalidArgType(name, expected);
    super("ERR_INVALID_ARG_TYPE", `${msg}.${invalidArgTypeHelper(actual)}`);
  }
};
var ERR_INVALID_ARG_TYPE = class extends NodeTypeError {
  constructor(name, expected, actual) {
    const msg = createInvalidArgType(name, expected);
    super("ERR_INVALID_ARG_TYPE", `${msg}.${invalidArgTypeHelper(actual)}`);
  }
};
ERR_INVALID_ARG_TYPE.RangeError = ERR_INVALID_ARG_TYPE_RANGE;
var ERR_INVALID_ARG_VALUE_RANGE = class extends NodeRangeError {
  constructor(name, value, reason = "is invalid") {
    const type = name.includes(".") ? "property" : "argument";
    const inspected = inspect(value);
    super("ERR_INVALID_ARG_VALUE", `The ${type} '${name}' ${reason}. Received ${inspected}`);
  }
};
var ERR_INVALID_ARG_VALUE = class extends NodeTypeError {
  constructor(name, value, reason = "is invalid") {
    const type = name.includes(".") ? "property" : "argument";
    const inspected = inspect(value);
    super("ERR_INVALID_ARG_VALUE", `The ${type} '${name}' ${reason}. Received ${inspected}`);
  }
};
ERR_INVALID_ARG_VALUE.RangeError = ERR_INVALID_ARG_VALUE_RANGE;
function invalidArgTypeHelper(input) {
  if (input == null) {
    return ` Received ${input}`;
  }
  if (typeof input === "function" && input.name) {
    return ` Received function ${input.name}`;
  }
  if (typeof input === "object") {
    if (input.constructor && input.constructor.name) {
      return ` Received an instance of ${input.constructor.name}`;
    }
    return ` Received ${inspect(input, { depth: -1 })}`;
  }
  let inspected = inspect(input, { colors: false });
  if (inspected.length > 25) {
    inspected = `${inspected.slice(0, 25)}...`;
  }
  return ` Received type ${typeof input} (${inspected})`;
}
var ERR_OUT_OF_RANGE = class extends RangeError {
  constructor(str, range, input, replaceDefaultBoolean = false) {
    assert2(range, 'Missing "range" argument');
    let msg = replaceDefaultBoolean ? str : `The value of "${str}" is out of range.`;
    let received;
    if (Number.isInteger(input) && Math.abs(input) > 2 ** 32) {
      received = addNumericalSeparator(String(input));
    } else if (typeof input === "bigint") {
      received = String(input);
      if (input > 2n ** 32n || input < -(2n ** 32n)) {
        received = addNumericalSeparator(received);
      }
      received += "n";
    } else {
      received = inspect(input);
    }
    msg += ` It must be ${range}. Received ${received}`;
    super(msg);
    this.code = "ERR_OUT_OF_RANGE";
    const { name } = this;
    this.name = `${name} [${this.code}]`;
    this.stack;
    this.name = name;
  }
};
var ERR_BUFFER_OUT_OF_BOUNDS = class extends NodeRangeError {
  constructor(name) {
    super("ERR_BUFFER_OUT_OF_BOUNDS", name ? `"${name}" is outside of buffer bounds` : "Attempt to access memory outside buffer bounds");
  }
};
var ERR_CRYPTO_FIPS_FORCED = class extends NodeError {
  constructor() {
    super("ERR_CRYPTO_FIPS_FORCED", "Cannot set FIPS mode, it was forced with --force-fips at startup.");
  }
};
var ERR_INVALID_CALLBACK = class extends NodeTypeError {
  constructor(object) {
    super("ERR_INVALID_CALLBACK", `Callback must be a function. Received ${inspect(object)}`);
  }
};
var ERR_INVALID_CURSOR_POS = class extends NodeTypeError {
  constructor() {
    super("ERR_INVALID_CURSOR_POS", `Cannot set cursor row without setting its column`);
  }
};
var ERR_IPC_CHANNEL_CLOSED = class extends NodeError {
  constructor() {
    super("ERR_IPC_CHANNEL_CLOSED", `Channel closed`);
  }
};
var ERR_METHOD_NOT_IMPLEMENTED = class extends NodeError {
  constructor(x) {
    super("ERR_METHOD_NOT_IMPLEMENTED", `The ${x} method is not implemented`);
  }
};
var ERR_MISSING_ARGS = class extends NodeTypeError {
  constructor(...args) {
    let msg = "The ";
    const len = args.length;
    const wrap3 = (a) => `"${a}"`;
    args = args.map((a) => Array.isArray(a) ? a.map(wrap3).join(" or ") : wrap3(a));
    switch (len) {
      case 1:
        msg += `${args[0]} argument`;
        break;
      case 2:
        msg += `${args[0]} and ${args[1]} arguments`;
        break;
      default:
        msg += args.slice(0, len - 1).join(", ");
        msg += `, and ${args[len - 1]} arguments`;
        break;
    }
    super("ERR_MISSING_ARGS", `${msg} must be specified`);
  }
};
var ERR_MULTIPLE_CALLBACK = class extends NodeError {
  constructor() {
    super("ERR_MULTIPLE_CALLBACK", `Callback called multiple times`);
  }
};
var ERR_SOCKET_BAD_PORT = class extends NodeRangeError {
  constructor(name, port, allowZero = true) {
    assert2(typeof allowZero === "boolean", "The 'allowZero' argument must be of type boolean.");
    const operator = allowZero ? ">=" : ">";
    super("ERR_SOCKET_BAD_PORT", `${name} should be ${operator} 0 and < 65536. Received ${port}.`);
  }
};
var ERR_STREAM_ALREADY_FINISHED = class extends NodeError {
  constructor(x) {
    super("ERR_STREAM_ALREADY_FINISHED", `Cannot call ${x} after a stream was finished`);
  }
};
var ERR_STREAM_CANNOT_PIPE = class extends NodeError {
  constructor() {
    super("ERR_STREAM_CANNOT_PIPE", `Cannot pipe, not readable`);
  }
};
var ERR_STREAM_DESTROYED = class extends NodeError {
  constructor(x) {
    super("ERR_STREAM_DESTROYED", `Cannot call ${x} after a stream was destroyed`);
  }
};
var ERR_STREAM_NULL_VALUES = class extends NodeTypeError {
  constructor() {
    super("ERR_STREAM_NULL_VALUES", `May not write null values to stream`);
  }
};
var ERR_STREAM_PREMATURE_CLOSE = class extends NodeError {
  constructor() {
    super("ERR_STREAM_PREMATURE_CLOSE", `Premature close`);
  }
};
var ERR_STREAM_PUSH_AFTER_EOF = class extends NodeError {
  constructor() {
    super("ERR_STREAM_PUSH_AFTER_EOF", `stream.push() after EOF`);
  }
};
var ERR_STREAM_UNSHIFT_AFTER_END_EVENT = class extends NodeError {
  constructor() {
    super("ERR_STREAM_UNSHIFT_AFTER_END_EVENT", `stream.unshift() after end event`);
  }
};
var ERR_STREAM_WRITE_AFTER_END = class extends NodeError {
  constructor() {
    super("ERR_STREAM_WRITE_AFTER_END", `write after end`);
  }
};
var ERR_UNHANDLED_ERROR = class extends NodeError {
  constructor(x) {
    super("ERR_UNHANDLED_ERROR", `Unhandled error. (${x})`);
  }
};
var ERR_UNKNOWN_ENCODING = class extends NodeTypeError {
  constructor(x) {
    super("ERR_UNKNOWN_ENCODING", `Unknown encoding: ${x}`);
  }
};
var ERR_UNKNOWN_SIGNAL = class extends NodeTypeError {
  constructor(x) {
    super("ERR_UNKNOWN_SIGNAL", `Unknown signal: ${x}`);
  }
};
function buildReturnPropertyType(value) {
  if (value && value.constructor && value.constructor.name) {
    return `instance of ${value.constructor.name}`;
  } else {
    return `type ${typeof value}`;
  }
}
var ERR_INVALID_RETURN_VALUE = class extends NodeTypeError {
  constructor(input, name, value) {
    super("ERR_INVALID_RETURN_VALUE", `Expected ${input} to be returned from the "${name}" function but got ${buildReturnPropertyType(value)}.`);
  }
};
function aggregateTwoErrors(innerError, outerError) {
  if (innerError && outerError && innerError !== outerError) {
    if (Array.isArray(outerError.errors)) {
      outerError.errors.push(innerError);
      return outerError;
    }
    const err = new AggregateError([
      outerError,
      innerError
    ], outerError.message);
    err.code = outerError.code;
    return err;
  }
  return innerError || outerError;
}
codes.ERR_IPC_CHANNEL_CLOSED = ERR_IPC_CHANNEL_CLOSED;
codes.ERR_INVALID_ARG_TYPE = ERR_INVALID_ARG_TYPE;
codes.ERR_INVALID_ARG_VALUE = ERR_INVALID_ARG_VALUE;
codes.ERR_INVALID_CALLBACK = ERR_INVALID_CALLBACK;
codes.ERR_OUT_OF_RANGE = ERR_OUT_OF_RANGE;
codes.ERR_SOCKET_BAD_PORT = ERR_SOCKET_BAD_PORT;
codes.ERR_BUFFER_OUT_OF_BOUNDS = ERR_BUFFER_OUT_OF_BOUNDS;
codes.ERR_UNKNOWN_ENCODING = ERR_UNKNOWN_ENCODING;
var genericNodeError = hideStackFrames(function genericNodeError2(message, errorProperties) {
  const err = new Error(message);
  Object.assign(err, errorProperties);
  return err;
});

// deno:https://deno.land/std@0.147.0/node/_events.mjs
var kRejection = Symbol.for("nodejs.rejection");
var kCapture = Symbol("kCapture");
var kErrorMonitor = Symbol("events.errorMonitor");
var kMaxEventTargetListeners = Symbol("events.maxEventTargetListeners");
var kMaxEventTargetListenersWarned = Symbol("events.maxEventTargetListenersWarned");
function EventEmitter(opts) {
  EventEmitter.init.call(this, opts);
}
var events_default = EventEmitter;
EventEmitter.on = on;
EventEmitter.once = once3;
EventEmitter.getEventListeners = getEventListeners;
EventEmitter.EventEmitter = EventEmitter;
EventEmitter.usingDomains = false;
EventEmitter.captureRejectionSymbol = kRejection;
var captureRejectionSymbol = EventEmitter.captureRejectionSymbol;
var errorMonitor = EventEmitter.errorMonitor;
Object.defineProperty(EventEmitter, "captureRejections", {
  get() {
    return EventEmitter.prototype[kCapture];
  },
  set(value) {
    validateBoolean(value, "EventEmitter.captureRejections");
    EventEmitter.prototype[kCapture] = value;
  },
  enumerable: true
});
EventEmitter.errorMonitor = kErrorMonitor;
Object.defineProperty(EventEmitter.prototype, kCapture, {
  value: false,
  writable: true,
  enumerable: false
});
EventEmitter.prototype._events = void 0;
EventEmitter.prototype._eventsCount = 0;
EventEmitter.prototype._maxListeners = void 0;
var defaultMaxListeners = 10;
function checkListener(listener) {
  validateFunction(listener, "listener");
}
Object.defineProperty(EventEmitter, "defaultMaxListeners", {
  enumerable: true,
  get: function() {
    return defaultMaxListeners;
  },
  set: function(arg) {
    if (typeof arg !== "number" || arg < 0 || Number.isNaN(arg)) {
      throw new ERR_OUT_OF_RANGE("defaultMaxListeners", "a non-negative number", arg);
    }
    defaultMaxListeners = arg;
  }
});
Object.defineProperties(EventEmitter, {
  kMaxEventTargetListeners: {
    value: kMaxEventTargetListeners,
    enumerable: false,
    configurable: false,
    writable: false
  },
  kMaxEventTargetListenersWarned: {
    value: kMaxEventTargetListenersWarned,
    enumerable: false,
    configurable: false,
    writable: false
  }
});
EventEmitter.setMaxListeners = function(n = defaultMaxListeners, ...eventTargets) {
  if (typeof n !== "number" || n < 0 || Number.isNaN(n)) {
    throw new ERR_OUT_OF_RANGE("n", "a non-negative number", n);
  }
  if (eventTargets.length === 0) {
    defaultMaxListeners = n;
  } else {
    for (let i = 0; i < eventTargets.length; i++) {
      const target = eventTargets[i];
      if (target instanceof EventTarget) {
        target[kMaxEventTargetListeners] = n;
        target[kMaxEventTargetListenersWarned] = false;
      } else if (typeof target.setMaxListeners === "function") {
        target.setMaxListeners(n);
      } else {
        throw new ERR_INVALID_ARG_TYPE("eventTargets", ["EventEmitter", "EventTarget"], target);
      }
    }
  }
};
EventEmitter.init = function(opts) {
  if (this._events === void 0 || this._events === Object.getPrototypeOf(this)._events) {
    this._events = /* @__PURE__ */ Object.create(null);
    this._eventsCount = 0;
  }
  this._maxListeners = this._maxListeners || void 0;
  if (opts?.captureRejections) {
    validateBoolean(opts.captureRejections, "options.captureRejections");
    this[kCapture] = Boolean(opts.captureRejections);
  } else {
    this[kCapture] = EventEmitter.prototype[kCapture];
  }
};
function addCatch(that, promise, type, args) {
  if (!that[kCapture]) {
    return;
  }
  try {
    const then = promise.then;
    if (typeof then === "function") {
      then.call(promise, void 0, function(err) {
        process.nextTick(emitUnhandledRejectionOrErr, that, err, type, args);
      });
    }
  } catch (err) {
    that.emit("error", err);
  }
}
function emitUnhandledRejectionOrErr(ee2, err, type, args) {
  if (typeof ee2[kRejection] === "function") {
    ee2[kRejection](err, type, ...args);
  } else {
    const prev = ee2[kCapture];
    try {
      ee2[kCapture] = false;
      ee2.emit("error", err);
    } finally {
      ee2[kCapture] = prev;
    }
  }
}
EventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {
  if (typeof n !== "number" || n < 0 || Number.isNaN(n)) {
    throw new ERR_OUT_OF_RANGE("n", "a non-negative number", n);
  }
  this._maxListeners = n;
  return this;
};
function _getMaxListeners(that) {
  if (that._maxListeners === void 0) {
    return EventEmitter.defaultMaxListeners;
  }
  return that._maxListeners;
}
EventEmitter.prototype.getMaxListeners = function getMaxListeners() {
  return _getMaxListeners(this);
};
EventEmitter.prototype.emit = function emit(type, ...args) {
  let doError = type === "error";
  const events2 = this._events;
  if (events2 !== void 0) {
    if (doError && events2[kErrorMonitor] !== void 0) {
      this.emit(kErrorMonitor, ...args);
    }
    doError = doError && events2.error === void 0;
  } else if (!doError) {
    return false;
  }
  if (doError) {
    let er;
    if (args.length > 0) {
      er = args[0];
    }
    if (er instanceof Error) {
      try {
        const capture = {};
        Error.captureStackTrace(capture, EventEmitter.prototype.emit);
      } catch {
      }
      throw er;
    }
    let stringifiedEr;
    try {
      stringifiedEr = inspect(er);
    } catch {
      stringifiedEr = er;
    }
    const err = new ERR_UNHANDLED_ERROR(stringifiedEr);
    err.context = er;
    throw err;
  }
  const handler = events2[type];
  if (handler === void 0) {
    return false;
  }
  if (typeof handler === "function") {
    const result = handler.apply(this, args);
    if (result !== void 0 && result !== null) {
      addCatch(this, result, type, args);
    }
  } else {
    const len = handler.length;
    const listeners2 = arrayClone(handler);
    for (let i = 0; i < len; ++i) {
      const result = listeners2[i].apply(this, args);
      if (result !== void 0 && result !== null) {
        addCatch(this, result, type, args);
      }
    }
  }
  return true;
};
function _addListener(target, type, listener, prepend) {
  let m3;
  let events2;
  let existing;
  checkListener(listener);
  events2 = target._events;
  if (events2 === void 0) {
    events2 = target._events = /* @__PURE__ */ Object.create(null);
    target._eventsCount = 0;
  } else {
    if (events2.newListener !== void 0) {
      target.emit("newListener", type, listener.listener ?? listener);
      events2 = target._events;
    }
    existing = events2[type];
  }
  if (existing === void 0) {
    events2[type] = listener;
    ++target._eventsCount;
  } else {
    if (typeof existing === "function") {
      existing = events2[type] = prepend ? [listener, existing] : [existing, listener];
    } else if (prepend) {
      existing.unshift(listener);
    } else {
      existing.push(listener);
    }
    m3 = _getMaxListeners(target);
    if (m3 > 0 && existing.length > m3 && !existing.warned) {
      existing.warned = true;
      const w2 = new Error(`Possible EventEmitter memory leak detected. ${existing.length} ${String(type)} listeners added to ${inspect(target, { depth: -1 })}. Use emitter.setMaxListeners() to increase limit`);
      w2.name = "MaxListenersExceededWarning";
      w2.emitter = target;
      w2.type = type;
      w2.count = existing.length;
      process.emitWarning(w2);
    }
  }
  return target;
}
EventEmitter.prototype.addListener = function addListener(type, listener) {
  return _addListener(this, type, listener, false);
};
EventEmitter.prototype.on = EventEmitter.prototype.addListener;
EventEmitter.prototype.prependListener = function prependListener(type, listener) {
  return _addListener(this, type, listener, true);
};
function onceWrapper() {
  if (!this.fired) {
    this.target.removeListener(this.type, this.wrapFn);
    this.fired = true;
    if (arguments.length === 0) {
      return this.listener.call(this.target);
    }
    return this.listener.apply(this.target, arguments);
  }
}
function _onceWrap(target, type, listener) {
  const state = { fired: false, wrapFn: void 0, target, type, listener };
  const wrapped = onceWrapper.bind(state);
  wrapped.listener = listener;
  state.wrapFn = wrapped;
  return wrapped;
}
EventEmitter.prototype.once = function once2(type, listener) {
  checkListener(listener);
  this.on(type, _onceWrap(this, type, listener));
  return this;
};
EventEmitter.prototype.prependOnceListener = function prependOnceListener(type, listener) {
  checkListener(listener);
  this.prependListener(type, _onceWrap(this, type, listener));
  return this;
};
EventEmitter.prototype.removeListener = function removeListener(type, listener) {
  checkListener(listener);
  const events2 = this._events;
  if (events2 === void 0) {
    return this;
  }
  const list = events2[type];
  if (list === void 0) {
    return this;
  }
  if (list === listener || list.listener === listener) {
    if (--this._eventsCount === 0) {
      this._events = /* @__PURE__ */ Object.create(null);
    } else {
      delete events2[type];
      if (events2.removeListener) {
        this.emit("removeListener", type, list.listener || listener);
      }
    }
  } else if (typeof list !== "function") {
    let position = -1;
    for (let i = list.length - 1; i >= 0; i--) {
      if (list[i] === listener || list[i].listener === listener) {
        position = i;
        break;
      }
    }
    if (position < 0) {
      return this;
    }
    if (position === 0) {
      list.shift();
    } else {
      spliceOne(list, position);
    }
    if (list.length === 1) {
      events2[type] = list[0];
    }
    if (events2.removeListener !== void 0) {
      this.emit("removeListener", type, listener);
    }
  }
  return this;
};
EventEmitter.prototype.off = EventEmitter.prototype.removeListener;
EventEmitter.prototype.removeAllListeners = function removeAllListeners(type) {
  const events2 = this._events;
  if (events2 === void 0) {
    return this;
  }
  if (events2.removeListener === void 0) {
    if (arguments.length === 0) {
      this._events = /* @__PURE__ */ Object.create(null);
      this._eventsCount = 0;
    } else if (events2[type] !== void 0) {
      if (--this._eventsCount === 0) {
        this._events = /* @__PURE__ */ Object.create(null);
      } else {
        delete events2[type];
      }
    }
    return this;
  }
  if (arguments.length === 0) {
    for (const key2 of Reflect.ownKeys(events2)) {
      if (key2 === "removeListener")
        continue;
      this.removeAllListeners(key2);
    }
    this.removeAllListeners("removeListener");
    this._events = /* @__PURE__ */ Object.create(null);
    this._eventsCount = 0;
    return this;
  }
  const listeners2 = events2[type];
  if (typeof listeners2 === "function") {
    this.removeListener(type, listeners2);
  } else if (listeners2 !== void 0) {
    for (let i = listeners2.length - 1; i >= 0; i--) {
      this.removeListener(type, listeners2[i]);
    }
  }
  return this;
};
function _listeners(target, type, unwrap) {
  const events2 = target._events;
  if (events2 === void 0) {
    return [];
  }
  const evlistener = events2[type];
  if (evlistener === void 0) {
    return [];
  }
  if (typeof evlistener === "function") {
    return unwrap ? [evlistener.listener || evlistener] : [evlistener];
  }
  return unwrap ? unwrapListeners(evlistener) : arrayClone(evlistener);
}
EventEmitter.prototype.listeners = function listeners(type) {
  return _listeners(this, type, true);
};
EventEmitter.prototype.rawListeners = function rawListeners(type) {
  return _listeners(this, type, false);
};
EventEmitter.listenerCount = function(emitter, type) {
  if (typeof emitter.listenerCount === "function") {
    return emitter.listenerCount(type);
  }
  return listenerCount.call(emitter, type);
};
EventEmitter.prototype.listenerCount = listenerCount;
function listenerCount(type) {
  const events2 = this._events;
  if (events2 !== void 0) {
    const evlistener = events2[type];
    if (typeof evlistener === "function") {
      return 1;
    } else if (evlistener !== void 0) {
      return evlistener.length;
    }
  }
  return 0;
}
EventEmitter.prototype.eventNames = function eventNames() {
  return this._eventsCount > 0 ? Reflect.ownKeys(this._events) : [];
};
function arrayClone(arr) {
  switch (arr.length) {
    case 2:
      return [arr[0], arr[1]];
    case 3:
      return [arr[0], arr[1], arr[2]];
    case 4:
      return [arr[0], arr[1], arr[2], arr[3]];
    case 5:
      return [arr[0], arr[1], arr[2], arr[3], arr[4]];
    case 6:
      return [arr[0], arr[1], arr[2], arr[3], arr[4], arr[5]];
  }
  return arr.slice();
}
function unwrapListeners(arr) {
  const ret = arrayClone(arr);
  for (let i = 0; i < ret.length; ++i) {
    const orig = ret[i].listener;
    if (typeof orig === "function") {
      ret[i] = orig;
    }
  }
  return ret;
}
function getEventListeners(emitterOrTarget, type) {
  if (typeof emitterOrTarget.listeners === "function") {
    return emitterOrTarget.listeners(type);
  }
  if (emitterOrTarget instanceof EventTarget) {
    const root = emitterOrTarget[kEvents].get(type);
    const listeners2 = [];
    let handler = root?.next;
    while (handler?.listener !== void 0) {
      const listener = handler.listener?.deref ? handler.listener.deref() : handler.listener;
      listeners2.push(listener);
      handler = handler.next;
    }
    return listeners2;
  }
  throw new ERR_INVALID_ARG_TYPE("emitter", ["EventEmitter", "EventTarget"], emitterOrTarget);
}
async function once3(emitter, name, options = {}) {
  const signal = options?.signal;
  validateAbortSignal(signal, "options.signal");
  if (signal?.aborted) {
    throw new AbortError();
  }
  return new Promise((resolve7, reject) => {
    const errorListener = (err) => {
      emitter.removeListener(name, resolver);
      if (signal != null) {
        eventTargetAgnosticRemoveListener(signal, "abort", abortListener);
      }
      reject(err);
    };
    const resolver = (...args) => {
      if (typeof emitter.removeListener === "function") {
        emitter.removeListener("error", errorListener);
      }
      if (signal != null) {
        eventTargetAgnosticRemoveListener(signal, "abort", abortListener);
      }
      resolve7(args);
    };
    eventTargetAgnosticAddListener(emitter, name, resolver, { once: true });
    if (name !== "error" && typeof emitter.once === "function") {
      emitter.once("error", errorListener);
    }
    function abortListener() {
      eventTargetAgnosticRemoveListener(emitter, name, resolver);
      eventTargetAgnosticRemoveListener(emitter, "error", errorListener);
      reject(new AbortError());
    }
    if (signal != null) {
      eventTargetAgnosticAddListener(signal, "abort", abortListener, { once: true });
    }
  });
}
var AsyncIteratorPrototype = Object.getPrototypeOf(Object.getPrototypeOf(async function* () {
}).prototype);
function createIterResult(value, done) {
  return { value, done };
}
function eventTargetAgnosticRemoveListener(emitter, name, listener, flags) {
  if (typeof emitter.removeListener === "function") {
    emitter.removeListener(name, listener);
  } else if (typeof emitter.removeEventListener === "function") {
    emitter.removeEventListener(name, listener, flags);
  } else {
    throw new ERR_INVALID_ARG_TYPE("emitter", "EventEmitter", emitter);
  }
}
function eventTargetAgnosticAddListener(emitter, name, listener, flags) {
  if (typeof emitter.on === "function") {
    if (flags?.once) {
      emitter.once(name, listener);
    } else {
      emitter.on(name, listener);
    }
  } else if (typeof emitter.addEventListener === "function") {
    emitter.addEventListener(name, (arg) => {
      listener(arg);
    }, flags);
  } else {
    throw new ERR_INVALID_ARG_TYPE("emitter", "EventEmitter", emitter);
  }
}
function on(emitter, event, options) {
  const signal = options?.signal;
  validateAbortSignal(signal, "options.signal");
  if (signal?.aborted) {
    throw new AbortError();
  }
  const unconsumedEvents = [];
  const unconsumedPromises = [];
  let error3 = null;
  let finished2 = false;
  const iterator = Object.setPrototypeOf({
    next() {
      const value = unconsumedEvents.shift();
      if (value) {
        return Promise.resolve(createIterResult(value, false));
      }
      if (error3) {
        const p3 = Promise.reject(error3);
        error3 = null;
        return p3;
      }
      if (finished2) {
        return Promise.resolve(createIterResult(void 0, true));
      }
      return new Promise(function(resolve7, reject) {
        unconsumedPromises.push({ resolve: resolve7, reject });
      });
    },
    return() {
      eventTargetAgnosticRemoveListener(emitter, event, eventHandler);
      eventTargetAgnosticRemoveListener(emitter, "error", errorHandler);
      if (signal) {
        eventTargetAgnosticRemoveListener(signal, "abort", abortListener, { once: true });
      }
      finished2 = true;
      for (const promise of unconsumedPromises) {
        promise.resolve(createIterResult(void 0, true));
      }
      return Promise.resolve(createIterResult(void 0, true));
    },
    throw(err) {
      if (!err || !(err instanceof Error)) {
        throw new ERR_INVALID_ARG_TYPE("EventEmitter.AsyncIterator", "Error", err);
      }
      error3 = err;
      eventTargetAgnosticRemoveListener(emitter, event, eventHandler);
      eventTargetAgnosticRemoveListener(emitter, "error", errorHandler);
    },
    [Symbol.asyncIterator]() {
      return this;
    }
  }, AsyncIteratorPrototype);
  eventTargetAgnosticAddListener(emitter, event, eventHandler);
  if (event !== "error" && typeof emitter.on === "function") {
    emitter.on("error", errorHandler);
  }
  if (signal) {
    eventTargetAgnosticAddListener(signal, "abort", abortListener, { once: true });
  }
  return iterator;
  function abortListener() {
    errorHandler(new AbortError());
  }
  function eventHandler(...args) {
    const promise = unconsumedPromises.shift();
    if (promise) {
      promise.resolve(createIterResult(args, false));
    } else {
      unconsumedEvents.push(args);
    }
  }
  function errorHandler(err) {
    finished2 = true;
    const toError = unconsumedPromises.shift();
    if (toError) {
      toError.reject(err);
    } else {
      error3 = err;
    }
    iterator.return();
  }
}

// deno:https://deno.land/std@0.147.0/flags/mod.ts
var { hasOwn } = Object;
function get(obj2, key2) {
  if (hasOwn(obj2, key2)) {
    return obj2[key2];
  }
}
function getForce(obj2, key2) {
  const v2 = get(obj2, key2);
  assert2(v2 != null);
  return v2;
}
function isNumber2(x) {
  if (typeof x === "number")
    return true;
  if (/^0x[0-9a-f]+$/i.test(String(x)))
    return true;
  return /^[-+]?(?:\d+(?:\.\d*)?|\.\d+)(e[-+]?\d+)?$/.test(String(x));
}
function hasKey(obj2, keys) {
  let o2 = obj2;
  keys.slice(0, -1).forEach((key3) => {
    o2 = get(o2, key3) ?? {};
  });
  const key2 = keys[keys.length - 1];
  return hasOwn(o2, key2);
}
function parse(args, {
  "--": doubleDash = false,
  alias = {},
  boolean = false,
  default: defaults = {},
  stopEarly = false,
  string = [],
  collect = [],
  negatable = [],
  unknown = (i) => i
} = {}) {
  const flags = {
    bools: {},
    strings: {},
    unknownFn: unknown,
    allBools: false,
    collect: {},
    negatable: {}
  };
  if (boolean !== void 0) {
    if (typeof boolean === "boolean") {
      flags.allBools = !!boolean;
    } else {
      const booleanArgs = typeof boolean === "string" ? [boolean] : boolean;
      for (const key2 of booleanArgs.filter(Boolean)) {
        flags.bools[key2] = true;
      }
    }
  }
  const aliases = {};
  if (alias !== void 0) {
    for (const key2 in alias) {
      const val = getForce(alias, key2);
      if (typeof val === "string") {
        aliases[key2] = [val];
      } else {
        aliases[key2] = val;
      }
      for (const alias2 of getForce(aliases, key2)) {
        aliases[alias2] = [key2].concat(aliases[key2].filter((y4) => alias2 !== y4));
      }
    }
  }
  if (string !== void 0) {
    const stringArgs = typeof string === "string" ? [string] : string;
    for (const key2 of stringArgs.filter(Boolean)) {
      flags.strings[key2] = true;
      const alias2 = get(aliases, key2);
      if (alias2) {
        for (const al of alias2) {
          flags.strings[al] = true;
        }
      }
    }
  }
  if (collect !== void 0) {
    const collectArgs = typeof collect === "string" ? [collect] : collect;
    for (const key2 of collectArgs.filter(Boolean)) {
      flags.collect[key2] = true;
      const alias2 = get(aliases, key2);
      if (alias2) {
        for (const al of alias2) {
          flags.collect[al] = true;
        }
      }
    }
  }
  if (negatable !== void 0) {
    const negatableArgs = typeof negatable === "string" ? [negatable] : negatable;
    for (const key2 of negatableArgs.filter(Boolean)) {
      flags.negatable[key2] = true;
      const alias2 = get(aliases, key2);
      if (alias2) {
        for (const al of alias2) {
          flags.negatable[al] = true;
        }
      }
    }
  }
  const argv2 = { _: [] };
  function argDefined(key2, arg) {
    return flags.allBools && /^--[^=]+$/.test(arg) || get(flags.bools, key2) || !!get(flags.strings, key2) || !!get(aliases, key2);
  }
  function setKey(obj2, name, value, collect2 = true) {
    let o2 = obj2;
    const keys = name.split(".");
    keys.slice(0, -1).forEach(function(key3) {
      if (get(o2, key3) === void 0) {
        o2[key3] = {};
      }
      o2 = get(o2, key3);
    });
    const key2 = keys[keys.length - 1];
    const collectable = collect2 && !!get(flags.collect, name);
    if (!collectable) {
      o2[key2] = value;
    } else if (get(o2, key2) === void 0) {
      o2[key2] = [value];
    } else if (Array.isArray(get(o2, key2))) {
      o2[key2].push(value);
    } else {
      o2[key2] = [get(o2, key2), value];
    }
  }
  function setArg(key2, val, arg = void 0, collect2) {
    if (arg && flags.unknownFn && !argDefined(key2, arg)) {
      if (flags.unknownFn(arg, key2, val) === false)
        return;
    }
    const value = !get(flags.strings, key2) && isNumber2(val) ? Number(val) : val;
    setKey(argv2, key2, value, collect2);
    const alias2 = get(aliases, key2);
    if (alias2) {
      for (const x of alias2) {
        setKey(argv2, x, value, collect2);
      }
    }
  }
  function aliasIsBoolean(key2) {
    return getForce(aliases, key2).some((x) => typeof get(flags.bools, x) === "boolean");
  }
  let notFlags = [];
  if (args.includes("--")) {
    notFlags = args.slice(args.indexOf("--") + 1);
    args = args.slice(0, args.indexOf("--"));
  }
  for (let i = 0; i < args.length; i++) {
    const arg = args[i];
    if (/^--.+=/.test(arg)) {
      const m3 = arg.match(/^--([^=]+)=(.*)$/s);
      assert2(m3 != null);
      const [, key2, value] = m3;
      if (flags.bools[key2]) {
        const booleanValue = value !== "false";
        setArg(key2, booleanValue, arg);
      } else {
        setArg(key2, value, arg);
      }
    } else if (/^--no-.+/.test(arg) && get(flags.negatable, arg.replace(/^--no-/, ""))) {
      const m3 = arg.match(/^--no-(.+)/);
      assert2(m3 != null);
      setArg(m3[1], false, arg, false);
    } else if (/^--.+/.test(arg)) {
      const m3 = arg.match(/^--(.+)/);
      assert2(m3 != null);
      const [, key2] = m3;
      const next = args[i + 1];
      if (next !== void 0 && !/^-/.test(next) && !get(flags.bools, key2) && !flags.allBools && (get(aliases, key2) ? !aliasIsBoolean(key2) : true)) {
        setArg(key2, next, arg);
        i++;
      } else if (/^(true|false)$/.test(next)) {
        setArg(key2, next === "true", arg);
        i++;
      } else {
        setArg(key2, get(flags.strings, key2) ? "" : true, arg);
      }
    } else if (/^-[^-]+/.test(arg)) {
      const letters = arg.slice(1, -1).split("");
      let broken = false;
      for (let j2 = 0; j2 < letters.length; j2++) {
        const next = arg.slice(j2 + 2);
        if (next === "-") {
          setArg(letters[j2], next, arg);
          continue;
        }
        if (/[A-Za-z]/.test(letters[j2]) && /=/.test(next)) {
          setArg(letters[j2], next.split(/=(.+)/)[1], arg);
          broken = true;
          break;
        }
        if (/[A-Za-z]/.test(letters[j2]) && /-?\d+(\.\d*)?(e-?\d+)?$/.test(next)) {
          setArg(letters[j2], next, arg);
          broken = true;
          break;
        }
        if (letters[j2 + 1] && letters[j2 + 1].match(/\W/)) {
          setArg(letters[j2], arg.slice(j2 + 2), arg);
          broken = true;
          break;
        } else {
          setArg(letters[j2], get(flags.strings, letters[j2]) ? "" : true, arg);
        }
      }
      const [key2] = arg.slice(-1);
      if (!broken && key2 !== "-") {
        if (args[i + 1] && !/^(-|--)[^-]/.test(args[i + 1]) && !get(flags.bools, key2) && (get(aliases, key2) ? !aliasIsBoolean(key2) : true)) {
          setArg(key2, args[i + 1], arg);
          i++;
        } else if (args[i + 1] && /^(true|false)$/.test(args[i + 1])) {
          setArg(key2, args[i + 1] === "true", arg);
          i++;
        } else {
          setArg(key2, get(flags.strings, key2) ? "" : true, arg);
        }
      }
    } else {
      if (!flags.unknownFn || flags.unknownFn(arg) !== false) {
        argv2._.push(flags.strings["_"] ?? !isNumber2(arg) ? arg : Number(arg));
      }
      if (stopEarly) {
        argv2._.push(...args.slice(i + 1));
        break;
      }
    }
  }
  for (const [key2, value] of Object.entries(defaults)) {
    if (!hasKey(argv2, key2.split("."))) {
      setKey(argv2, key2, value);
      if (aliases[key2]) {
        for (const x of aliases[key2]) {
          setKey(argv2, x, value);
        }
      }
    }
  }
  for (const key2 of Object.keys(flags.bools)) {
    if (!hasKey(argv2, key2.split("."))) {
      const value = get(flags.collect, key2) ? [] : false;
      setKey(argv2, key2, value, false);
    }
  }
  for (const key2 of Object.keys(flags.strings)) {
    if (!hasKey(argv2, key2.split(".")) && get(flags.collect, key2)) {
      setKey(argv2, key2, [], false);
    }
  }
  if (doubleDash) {
    argv2["--"] = [];
    for (const key2 of notFlags) {
      argv2["--"].push(key2);
    }
  } else {
    for (const key2 of notFlags) {
      argv2._.push(key2);
    }
  }
  return argv2;
}

// deno:https://deno.land/std@0.147.0/node/internal_binding/node_options.ts
function getOptions() {
  const args = parse(Deno.args);
  const options = new Map(Object.entries(args).map(([key2, value]) => [key2, { value }]));
  return { options };
}

// deno:https://deno.land/std@0.147.0/node/internal/options.ts
var optionsMap;
function getOptionsFromBinding() {
  if (!optionsMap) {
    ({ options: optionsMap } = getOptions());
  }
  return optionsMap;
}
function getOptionValue(optionName) {
  const options = getOptionsFromBinding();
  if (optionName.startsWith("--no-")) {
    const option = options.get("--" + optionName.slice(5));
    return option && !option.value;
  }
  return options.get(optionName)?.value;
}

// deno:https://deno.land/std@0.147.0/path/win32.ts
var win32_exports = {};
__export(win32_exports, {
  basename: () => basename,
  delimiter: () => delimiter,
  dirname: () => dirname,
  extname: () => extname,
  format: () => format3,
  fromFileUrl: () => fromFileUrl,
  isAbsolute: () => isAbsolute,
  join: () => join2,
  normalize: () => normalize,
  parse: () => parse2,
  relative: () => relative,
  resolve: () => resolve,
  sep: () => sep,
  toFileUrl: () => toFileUrl,
  toNamespacedPath: () => toNamespacedPath
});

// deno:https://deno.land/std@0.147.0/path/_constants.ts
var CHAR_UPPERCASE_A = 65;
var CHAR_LOWERCASE_A = 97;
var CHAR_UPPERCASE_Z = 90;
var CHAR_LOWERCASE_Z = 122;
var CHAR_DOT = 46;
var CHAR_FORWARD_SLASH = 47;
var CHAR_BACKWARD_SLASH = 92;
var CHAR_COLON = 58;
var CHAR_QUESTION_MARK = 63;

// deno:https://deno.land/std@0.147.0/path/_util.ts
function assertPath(path6) {
  if (typeof path6 !== "string") {
    throw new TypeError(`Path must be a string. Received ${JSON.stringify(path6)}`);
  }
}
function isPosixPathSeparator(code2) {
  return code2 === CHAR_FORWARD_SLASH;
}
function isPathSeparator(code2) {
  return isPosixPathSeparator(code2) || code2 === CHAR_BACKWARD_SLASH;
}
function isWindowsDeviceRoot(code2) {
  return code2 >= CHAR_LOWERCASE_A && code2 <= CHAR_LOWERCASE_Z || code2 >= CHAR_UPPERCASE_A && code2 <= CHAR_UPPERCASE_Z;
}
function normalizeString(path6, allowAboveRoot, separator, isPathSeparator3) {
  let res = "";
  let lastSegmentLength = 0;
  let lastSlash = -1;
  let dots = 0;
  let code2;
  for (let i = 0, len = path6.length; i <= len; ++i) {
    if (i < len)
      code2 = path6.charCodeAt(i);
    else if (isPathSeparator3(code2))
      break;
    else
      code2 = CHAR_FORWARD_SLASH;
    if (isPathSeparator3(code2)) {
      if (lastSlash === i - 1 || dots === 1) {
      } else if (lastSlash !== i - 1 && dots === 2) {
        if (res.length < 2 || lastSegmentLength !== 2 || res.charCodeAt(res.length - 1) !== CHAR_DOT || res.charCodeAt(res.length - 2) !== CHAR_DOT) {
          if (res.length > 2) {
            const lastSlashIndex = res.lastIndexOf(separator);
            if (lastSlashIndex === -1) {
              res = "";
              lastSegmentLength = 0;
            } else {
              res = res.slice(0, lastSlashIndex);
              lastSegmentLength = res.length - 1 - res.lastIndexOf(separator);
            }
            lastSlash = i;
            dots = 0;
            continue;
          } else if (res.length === 2 || res.length === 1) {
            res = "";
            lastSegmentLength = 0;
            lastSlash = i;
            dots = 0;
            continue;
          }
        }
        if (allowAboveRoot) {
          if (res.length > 0)
            res += `${separator}..`;
          else
            res = "..";
          lastSegmentLength = 2;
        }
      } else {
        if (res.length > 0)
          res += separator + path6.slice(lastSlash + 1, i);
        else
          res = path6.slice(lastSlash + 1, i);
        lastSegmentLength = i - lastSlash - 1;
      }
      lastSlash = i;
      dots = 0;
    } else if (code2 === CHAR_DOT && dots !== -1) {
      ++dots;
    } else {
      dots = -1;
    }
  }
  return res;
}
function _format(sep7, pathObject) {
  const dir = pathObject.dir || pathObject.root;
  const base3 = pathObject.base || (pathObject.name || "") + (pathObject.ext || "");
  if (!dir)
    return base3;
  if (dir === pathObject.root)
    return dir + base3;
  return dir + sep7 + base3;
}
var WHITESPACE_ENCODINGS = {
  "	": "%09",
  "\n": "%0A",
  "\v": "%0B",
  "\f": "%0C",
  "\r": "%0D",
  " ": "%20"
};
function encodeWhitespace(string) {
  return string.replaceAll(/[\s]/g, (c5) => {
    return WHITESPACE_ENCODINGS[c5] ?? c5;
  });
}

// deno:https://deno.land/std@0.147.0/path/win32.ts
var sep = "\\";
var delimiter = ";";
function resolve(...pathSegments) {
  let resolvedDevice = "";
  let resolvedTail = "";
  let resolvedAbsolute = false;
  for (let i = pathSegments.length - 1; i >= -1; i--) {
    let path6;
    const { Deno: Deno4 } = globalThis;
    if (i >= 0) {
      path6 = pathSegments[i];
    } else if (!resolvedDevice) {
      if (typeof Deno4?.cwd !== "function") {
        throw new TypeError("Resolved a drive-letter-less path without a CWD.");
      }
      path6 = Deno4.cwd();
    } else {
      if (typeof Deno4?.env?.get !== "function" || typeof Deno4?.cwd !== "function") {
        throw new TypeError("Resolved a relative path without a CWD.");
      }
      path6 = Deno4.cwd();
      if (path6 === void 0 || path6.slice(0, 3).toLowerCase() !== `${resolvedDevice.toLowerCase()}\\`) {
        path6 = `${resolvedDevice}\\`;
      }
    }
    assertPath(path6);
    const len = path6.length;
    if (len === 0)
      continue;
    let rootEnd = 0;
    let device = "";
    let isAbsolute7 = false;
    const code2 = path6.charCodeAt(0);
    if (len > 1) {
      if (isPathSeparator(code2)) {
        isAbsolute7 = true;
        if (isPathSeparator(path6.charCodeAt(1))) {
          let j2 = 2;
          let last = j2;
          for (; j2 < len; ++j2) {
            if (isPathSeparator(path6.charCodeAt(j2)))
              break;
          }
          if (j2 < len && j2 !== last) {
            const firstPart = path6.slice(last, j2);
            last = j2;
            for (; j2 < len; ++j2) {
              if (!isPathSeparator(path6.charCodeAt(j2)))
                break;
            }
            if (j2 < len && j2 !== last) {
              last = j2;
              for (; j2 < len; ++j2) {
                if (isPathSeparator(path6.charCodeAt(j2)))
                  break;
              }
              if (j2 === len) {
                device = `\\\\${firstPart}\\${path6.slice(last)}`;
                rootEnd = j2;
              } else if (j2 !== last) {
                device = `\\\\${firstPart}\\${path6.slice(last, j2)}`;
                rootEnd = j2;
              }
            }
          }
        } else {
          rootEnd = 1;
        }
      } else if (isWindowsDeviceRoot(code2)) {
        if (path6.charCodeAt(1) === CHAR_COLON) {
          device = path6.slice(0, 2);
          rootEnd = 2;
          if (len > 2) {
            if (isPathSeparator(path6.charCodeAt(2))) {
              isAbsolute7 = true;
              rootEnd = 3;
            }
          }
        }
      }
    } else if (isPathSeparator(code2)) {
      rootEnd = 1;
      isAbsolute7 = true;
    }
    if (device.length > 0 && resolvedDevice.length > 0 && device.toLowerCase() !== resolvedDevice.toLowerCase()) {
      continue;
    }
    if (resolvedDevice.length === 0 && device.length > 0) {
      resolvedDevice = device;
    }
    if (!resolvedAbsolute) {
      resolvedTail = `${path6.slice(rootEnd)}\\${resolvedTail}`;
      resolvedAbsolute = isAbsolute7;
    }
    if (resolvedAbsolute && resolvedDevice.length > 0)
      break;
  }
  resolvedTail = normalizeString(resolvedTail, !resolvedAbsolute, "\\", isPathSeparator);
  return resolvedDevice + (resolvedAbsolute ? "\\" : "") + resolvedTail || ".";
}
function normalize(path6) {
  assertPath(path6);
  const len = path6.length;
  if (len === 0)
    return ".";
  let rootEnd = 0;
  let device;
  let isAbsolute7 = false;
  const code2 = path6.charCodeAt(0);
  if (len > 1) {
    if (isPathSeparator(code2)) {
      isAbsolute7 = true;
      if (isPathSeparator(path6.charCodeAt(1))) {
        let j2 = 2;
        let last = j2;
        for (; j2 < len; ++j2) {
          if (isPathSeparator(path6.charCodeAt(j2)))
            break;
        }
        if (j2 < len && j2 !== last) {
          const firstPart = path6.slice(last, j2);
          last = j2;
          for (; j2 < len; ++j2) {
            if (!isPathSeparator(path6.charCodeAt(j2)))
              break;
          }
          if (j2 < len && j2 !== last) {
            last = j2;
            for (; j2 < len; ++j2) {
              if (isPathSeparator(path6.charCodeAt(j2)))
                break;
            }
            if (j2 === len) {
              return `\\\\${firstPart}\\${path6.slice(last)}\\`;
            } else if (j2 !== last) {
              device = `\\\\${firstPart}\\${path6.slice(last, j2)}`;
              rootEnd = j2;
            }
          }
        }
      } else {
        rootEnd = 1;
      }
    } else if (isWindowsDeviceRoot(code2)) {
      if (path6.charCodeAt(1) === CHAR_COLON) {
        device = path6.slice(0, 2);
        rootEnd = 2;
        if (len > 2) {
          if (isPathSeparator(path6.charCodeAt(2))) {
            isAbsolute7 = true;
            rootEnd = 3;
          }
        }
      }
    }
  } else if (isPathSeparator(code2)) {
    return "\\";
  }
  let tail;
  if (rootEnd < len) {
    tail = normalizeString(path6.slice(rootEnd), !isAbsolute7, "\\", isPathSeparator);
  } else {
    tail = "";
  }
  if (tail.length === 0 && !isAbsolute7)
    tail = ".";
  if (tail.length > 0 && isPathSeparator(path6.charCodeAt(len - 1))) {
    tail += "\\";
  }
  if (device === void 0) {
    if (isAbsolute7) {
      if (tail.length > 0)
        return `\\${tail}`;
      else
        return "\\";
    } else if (tail.length > 0) {
      return tail;
    } else {
      return "";
    }
  } else if (isAbsolute7) {
    if (tail.length > 0)
      return `${device}\\${tail}`;
    else
      return `${device}\\`;
  } else if (tail.length > 0) {
    return device + tail;
  } else {
    return device;
  }
}
function isAbsolute(path6) {
  assertPath(path6);
  const len = path6.length;
  if (len === 0)
    return false;
  const code2 = path6.charCodeAt(0);
  if (isPathSeparator(code2)) {
    return true;
  } else if (isWindowsDeviceRoot(code2)) {
    if (len > 2 && path6.charCodeAt(1) === CHAR_COLON) {
      if (isPathSeparator(path6.charCodeAt(2)))
        return true;
    }
  }
  return false;
}
function join2(...paths) {
  const pathsCount = paths.length;
  if (pathsCount === 0)
    return ".";
  let joined;
  let firstPart = null;
  for (let i = 0; i < pathsCount; ++i) {
    const path6 = paths[i];
    assertPath(path6);
    if (path6.length > 0) {
      if (joined === void 0)
        joined = firstPart = path6;
      else
        joined += `\\${path6}`;
    }
  }
  if (joined === void 0)
    return ".";
  let needsReplace = true;
  let slashCount = 0;
  assert2(firstPart != null);
  if (isPathSeparator(firstPart.charCodeAt(0))) {
    ++slashCount;
    const firstLen = firstPart.length;
    if (firstLen > 1) {
      if (isPathSeparator(firstPart.charCodeAt(1))) {
        ++slashCount;
        if (firstLen > 2) {
          if (isPathSeparator(firstPart.charCodeAt(2)))
            ++slashCount;
          else {
            needsReplace = false;
          }
        }
      }
    }
  }
  if (needsReplace) {
    for (; slashCount < joined.length; ++slashCount) {
      if (!isPathSeparator(joined.charCodeAt(slashCount)))
        break;
    }
    if (slashCount >= 2)
      joined = `\\${joined.slice(slashCount)}`;
  }
  return normalize(joined);
}
function relative(from5, to2) {
  assertPath(from5);
  assertPath(to2);
  if (from5 === to2)
    return "";
  const fromOrig = resolve(from5);
  const toOrig = resolve(to2);
  if (fromOrig === toOrig)
    return "";
  from5 = fromOrig.toLowerCase();
  to2 = toOrig.toLowerCase();
  if (from5 === to2)
    return "";
  let fromStart = 0;
  let fromEnd = from5.length;
  for (; fromStart < fromEnd; ++fromStart) {
    if (from5.charCodeAt(fromStart) !== CHAR_BACKWARD_SLASH)
      break;
  }
  for (; fromEnd - 1 > fromStart; --fromEnd) {
    if (from5.charCodeAt(fromEnd - 1) !== CHAR_BACKWARD_SLASH)
      break;
  }
  const fromLen = fromEnd - fromStart;
  let toStart = 0;
  let toEnd = to2.length;
  for (; toStart < toEnd; ++toStart) {
    if (to2.charCodeAt(toStart) !== CHAR_BACKWARD_SLASH)
      break;
  }
  for (; toEnd - 1 > toStart; --toEnd) {
    if (to2.charCodeAt(toEnd - 1) !== CHAR_BACKWARD_SLASH)
      break;
  }
  const toLen = toEnd - toStart;
  const length = fromLen < toLen ? fromLen : toLen;
  let lastCommonSep = -1;
  let i = 0;
  for (; i <= length; ++i) {
    if (i === length) {
      if (toLen > length) {
        if (to2.charCodeAt(toStart + i) === CHAR_BACKWARD_SLASH) {
          return toOrig.slice(toStart + i + 1);
        } else if (i === 2) {
          return toOrig.slice(toStart + i);
        }
      }
      if (fromLen > length) {
        if (from5.charCodeAt(fromStart + i) === CHAR_BACKWARD_SLASH) {
          lastCommonSep = i;
        } else if (i === 2) {
          lastCommonSep = 3;
        }
      }
      break;
    }
    const fromCode = from5.charCodeAt(fromStart + i);
    const toCode = to2.charCodeAt(toStart + i);
    if (fromCode !== toCode)
      break;
    else if (fromCode === CHAR_BACKWARD_SLASH)
      lastCommonSep = i;
  }
  if (i !== length && lastCommonSep === -1) {
    return toOrig;
  }
  let out = "";
  if (lastCommonSep === -1)
    lastCommonSep = 0;
  for (i = fromStart + lastCommonSep + 1; i <= fromEnd; ++i) {
    if (i === fromEnd || from5.charCodeAt(i) === CHAR_BACKWARD_SLASH) {
      if (out.length === 0)
        out += "..";
      else
        out += "\\..";
    }
  }
  if (out.length > 0) {
    return out + toOrig.slice(toStart + lastCommonSep, toEnd);
  } else {
    toStart += lastCommonSep;
    if (toOrig.charCodeAt(toStart) === CHAR_BACKWARD_SLASH)
      ++toStart;
    return toOrig.slice(toStart, toEnd);
  }
}
function toNamespacedPath(path6) {
  if (typeof path6 !== "string")
    return path6;
  if (path6.length === 0)
    return "";
  const resolvedPath = resolve(path6);
  if (resolvedPath.length >= 3) {
    if (resolvedPath.charCodeAt(0) === CHAR_BACKWARD_SLASH) {
      if (resolvedPath.charCodeAt(1) === CHAR_BACKWARD_SLASH) {
        const code2 = resolvedPath.charCodeAt(2);
        if (code2 !== CHAR_QUESTION_MARK && code2 !== CHAR_DOT) {
          return `\\\\?\\UNC\\${resolvedPath.slice(2)}`;
        }
      }
    } else if (isWindowsDeviceRoot(resolvedPath.charCodeAt(0))) {
      if (resolvedPath.charCodeAt(1) === CHAR_COLON && resolvedPath.charCodeAt(2) === CHAR_BACKWARD_SLASH) {
        return `\\\\?\\${resolvedPath}`;
      }
    }
  }
  return path6;
}
function dirname(path6) {
  assertPath(path6);
  const len = path6.length;
  if (len === 0)
    return ".";
  let rootEnd = -1;
  let end = -1;
  let matchedSlash = true;
  let offset = 0;
  const code2 = path6.charCodeAt(0);
  if (len > 1) {
    if (isPathSeparator(code2)) {
      rootEnd = offset = 1;
      if (isPathSeparator(path6.charCodeAt(1))) {
        let j2 = 2;
        let last = j2;
        for (; j2 < len; ++j2) {
          if (isPathSeparator(path6.charCodeAt(j2)))
            break;
        }
        if (j2 < len && j2 !== last) {
          last = j2;
          for (; j2 < len; ++j2) {
            if (!isPathSeparator(path6.charCodeAt(j2)))
              break;
          }
          if (j2 < len && j2 !== last) {
            last = j2;
            for (; j2 < len; ++j2) {
              if (isPathSeparator(path6.charCodeAt(j2)))
                break;
            }
            if (j2 === len) {
              return path6;
            }
            if (j2 !== last) {
              rootEnd = offset = j2 + 1;
            }
          }
        }
      }
    } else if (isWindowsDeviceRoot(code2)) {
      if (path6.charCodeAt(1) === CHAR_COLON) {
        rootEnd = offset = 2;
        if (len > 2) {
          if (isPathSeparator(path6.charCodeAt(2)))
            rootEnd = offset = 3;
        }
      }
    }
  } else if (isPathSeparator(code2)) {
    return path6;
  }
  for (let i = len - 1; i >= offset; --i) {
    if (isPathSeparator(path6.charCodeAt(i))) {
      if (!matchedSlash) {
        end = i;
        break;
      }
    } else {
      matchedSlash = false;
    }
  }
  if (end === -1) {
    if (rootEnd === -1)
      return ".";
    else
      end = rootEnd;
  }
  return path6.slice(0, end);
}
function basename(path6, ext = "") {
  if (ext !== void 0 && typeof ext !== "string") {
    throw new TypeError('"ext" argument must be a string');
  }
  assertPath(path6);
  let start = 0;
  let end = -1;
  let matchedSlash = true;
  let i;
  if (path6.length >= 2) {
    const drive = path6.charCodeAt(0);
    if (isWindowsDeviceRoot(drive)) {
      if (path6.charCodeAt(1) === CHAR_COLON)
        start = 2;
    }
  }
  if (ext !== void 0 && ext.length > 0 && ext.length <= path6.length) {
    if (ext.length === path6.length && ext === path6)
      return "";
    let extIdx = ext.length - 1;
    let firstNonSlashEnd = -1;
    for (i = path6.length - 1; i >= start; --i) {
      const code2 = path6.charCodeAt(i);
      if (isPathSeparator(code2)) {
        if (!matchedSlash) {
          start = i + 1;
          break;
        }
      } else {
        if (firstNonSlashEnd === -1) {
          matchedSlash = false;
          firstNonSlashEnd = i + 1;
        }
        if (extIdx >= 0) {
          if (code2 === ext.charCodeAt(extIdx)) {
            if (--extIdx === -1) {
              end = i;
            }
          } else {
            extIdx = -1;
            end = firstNonSlashEnd;
          }
        }
      }
    }
    if (start === end)
      end = firstNonSlashEnd;
    else if (end === -1)
      end = path6.length;
    return path6.slice(start, end);
  } else {
    for (i = path6.length - 1; i >= start; --i) {
      if (isPathSeparator(path6.charCodeAt(i))) {
        if (!matchedSlash) {
          start = i + 1;
          break;
        }
      } else if (end === -1) {
        matchedSlash = false;
        end = i + 1;
      }
    }
    if (end === -1)
      return "";
    return path6.slice(start, end);
  }
}
function extname(path6) {
  assertPath(path6);
  let start = 0;
  let startDot = -1;
  let startPart = 0;
  let end = -1;
  let matchedSlash = true;
  let preDotState = 0;
  if (path6.length >= 2 && path6.charCodeAt(1) === CHAR_COLON && isWindowsDeviceRoot(path6.charCodeAt(0))) {
    start = startPart = 2;
  }
  for (let i = path6.length - 1; i >= start; --i) {
    const code2 = path6.charCodeAt(i);
    if (isPathSeparator(code2)) {
      if (!matchedSlash) {
        startPart = i + 1;
        break;
      }
      continue;
    }
    if (end === -1) {
      matchedSlash = false;
      end = i + 1;
    }
    if (code2 === CHAR_DOT) {
      if (startDot === -1)
        startDot = i;
      else if (preDotState !== 1)
        preDotState = 1;
    } else if (startDot !== -1) {
      preDotState = -1;
    }
  }
  if (startDot === -1 || end === -1 || preDotState === 0 || preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
    return "";
  }
  return path6.slice(startDot, end);
}
function format3(pathObject) {
  if (pathObject === null || typeof pathObject !== "object") {
    throw new TypeError(`The "pathObject" argument must be of type Object. Received type ${typeof pathObject}`);
  }
  return _format("\\", pathObject);
}
function parse2(path6) {
  assertPath(path6);
  const ret = { root: "", dir: "", base: "", ext: "", name: "" };
  const len = path6.length;
  if (len === 0)
    return ret;
  let rootEnd = 0;
  let code2 = path6.charCodeAt(0);
  if (len > 1) {
    if (isPathSeparator(code2)) {
      rootEnd = 1;
      if (isPathSeparator(path6.charCodeAt(1))) {
        let j2 = 2;
        let last = j2;
        for (; j2 < len; ++j2) {
          if (isPathSeparator(path6.charCodeAt(j2)))
            break;
        }
        if (j2 < len && j2 !== last) {
          last = j2;
          for (; j2 < len; ++j2) {
            if (!isPathSeparator(path6.charCodeAt(j2)))
              break;
          }
          if (j2 < len && j2 !== last) {
            last = j2;
            for (; j2 < len; ++j2) {
              if (isPathSeparator(path6.charCodeAt(j2)))
                break;
            }
            if (j2 === len) {
              rootEnd = j2;
            } else if (j2 !== last) {
              rootEnd = j2 + 1;
            }
          }
        }
      }
    } else if (isWindowsDeviceRoot(code2)) {
      if (path6.charCodeAt(1) === CHAR_COLON) {
        rootEnd = 2;
        if (len > 2) {
          if (isPathSeparator(path6.charCodeAt(2))) {
            if (len === 3) {
              ret.root = ret.dir = path6;
              return ret;
            }
            rootEnd = 3;
          }
        } else {
          ret.root = ret.dir = path6;
          return ret;
        }
      }
    }
  } else if (isPathSeparator(code2)) {
    ret.root = ret.dir = path6;
    return ret;
  }
  if (rootEnd > 0)
    ret.root = path6.slice(0, rootEnd);
  let startDot = -1;
  let startPart = rootEnd;
  let end = -1;
  let matchedSlash = true;
  let i = path6.length - 1;
  let preDotState = 0;
  for (; i >= rootEnd; --i) {
    code2 = path6.charCodeAt(i);
    if (isPathSeparator(code2)) {
      if (!matchedSlash) {
        startPart = i + 1;
        break;
      }
      continue;
    }
    if (end === -1) {
      matchedSlash = false;
      end = i + 1;
    }
    if (code2 === CHAR_DOT) {
      if (startDot === -1)
        startDot = i;
      else if (preDotState !== 1)
        preDotState = 1;
    } else if (startDot !== -1) {
      preDotState = -1;
    }
  }
  if (startDot === -1 || end === -1 || preDotState === 0 || preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
    if (end !== -1) {
      ret.base = ret.name = path6.slice(startPart, end);
    }
  } else {
    ret.name = path6.slice(startPart, startDot);
    ret.base = path6.slice(startPart, end);
    ret.ext = path6.slice(startDot, end);
  }
  if (startPart > 0 && startPart !== rootEnd) {
    ret.dir = path6.slice(0, startPart - 1);
  } else
    ret.dir = ret.root;
  return ret;
}
function fromFileUrl(url) {
  url = url instanceof URL ? url : new URL(url);
  if (url.protocol != "file:") {
    throw new TypeError("Must be a file URL.");
  }
  let path6 = decodeURIComponent(url.pathname.replace(/\//g, "\\").replace(/%(?![0-9A-Fa-f]{2})/g, "%25")).replace(/^\\*([A-Za-z]:)(\\|$)/, "$1\\");
  if (url.hostname != "") {
    path6 = `\\\\${url.hostname}${path6}`;
  }
  return path6;
}
function toFileUrl(path6) {
  if (!isAbsolute(path6)) {
    throw new TypeError("Must be an absolute path.");
  }
  const [, hostname, pathname] = path6.match(/^(?:[/\\]{2}([^/\\]+)(?=[/\\](?:[^/\\]|$)))?(.*)/);
  const url = new URL("file:///");
  url.pathname = encodeWhitespace(pathname.replace(/%/g, "%25"));
  if (hostname != null && hostname != "localhost") {
    url.hostname = hostname;
    if (!url.hostname) {
      throw new TypeError("Invalid hostname.");
    }
  }
  return url;
}

// deno:https://deno.land/std@0.147.0/path/posix.ts
var posix_exports = {};
__export(posix_exports, {
  basename: () => basename2,
  delimiter: () => delimiter2,
  dirname: () => dirname2,
  extname: () => extname2,
  format: () => format4,
  fromFileUrl: () => fromFileUrl2,
  isAbsolute: () => isAbsolute2,
  join: () => join3,
  normalize: () => normalize2,
  parse: () => parse3,
  relative: () => relative2,
  resolve: () => resolve2,
  sep: () => sep2,
  toFileUrl: () => toFileUrl2,
  toNamespacedPath: () => toNamespacedPath2
});
var sep2 = "/";
var delimiter2 = ":";
function resolve2(...pathSegments) {
  let resolvedPath = "";
  let resolvedAbsolute = false;
  for (let i = pathSegments.length - 1; i >= -1 && !resolvedAbsolute; i--) {
    let path6;
    if (i >= 0)
      path6 = pathSegments[i];
    else {
      const { Deno: Deno4 } = globalThis;
      if (typeof Deno4?.cwd !== "function") {
        throw new TypeError("Resolved a relative path without a CWD.");
      }
      path6 = Deno4.cwd();
    }
    assertPath(path6);
    if (path6.length === 0) {
      continue;
    }
    resolvedPath = `${path6}/${resolvedPath}`;
    resolvedAbsolute = path6.charCodeAt(0) === CHAR_FORWARD_SLASH;
  }
  resolvedPath = normalizeString(resolvedPath, !resolvedAbsolute, "/", isPosixPathSeparator);
  if (resolvedAbsolute) {
    if (resolvedPath.length > 0)
      return `/${resolvedPath}`;
    else
      return "/";
  } else if (resolvedPath.length > 0)
    return resolvedPath;
  else
    return ".";
}
function normalize2(path6) {
  assertPath(path6);
  if (path6.length === 0)
    return ".";
  const isAbsolute7 = path6.charCodeAt(0) === CHAR_FORWARD_SLASH;
  const trailingSeparator = path6.charCodeAt(path6.length - 1) === CHAR_FORWARD_SLASH;
  path6 = normalizeString(path6, !isAbsolute7, "/", isPosixPathSeparator);
  if (path6.length === 0 && !isAbsolute7)
    path6 = ".";
  if (path6.length > 0 && trailingSeparator)
    path6 += "/";
  if (isAbsolute7)
    return `/${path6}`;
  return path6;
}
function isAbsolute2(path6) {
  assertPath(path6);
  return path6.length > 0 && path6.charCodeAt(0) === CHAR_FORWARD_SLASH;
}
function join3(...paths) {
  if (paths.length === 0)
    return ".";
  let joined;
  for (let i = 0, len = paths.length; i < len; ++i) {
    const path6 = paths[i];
    assertPath(path6);
    if (path6.length > 0) {
      if (!joined)
        joined = path6;
      else
        joined += `/${path6}`;
    }
  }
  if (!joined)
    return ".";
  return normalize2(joined);
}
function relative2(from5, to2) {
  assertPath(from5);
  assertPath(to2);
  if (from5 === to2)
    return "";
  from5 = resolve2(from5);
  to2 = resolve2(to2);
  if (from5 === to2)
    return "";
  let fromStart = 1;
  const fromEnd = from5.length;
  for (; fromStart < fromEnd; ++fromStart) {
    if (from5.charCodeAt(fromStart) !== CHAR_FORWARD_SLASH)
      break;
  }
  const fromLen = fromEnd - fromStart;
  let toStart = 1;
  const toEnd = to2.length;
  for (; toStart < toEnd; ++toStart) {
    if (to2.charCodeAt(toStart) !== CHAR_FORWARD_SLASH)
      break;
  }
  const toLen = toEnd - toStart;
  const length = fromLen < toLen ? fromLen : toLen;
  let lastCommonSep = -1;
  let i = 0;
  for (; i <= length; ++i) {
    if (i === length) {
      if (toLen > length) {
        if (to2.charCodeAt(toStart + i) === CHAR_FORWARD_SLASH) {
          return to2.slice(toStart + i + 1);
        } else if (i === 0) {
          return to2.slice(toStart + i);
        }
      } else if (fromLen > length) {
        if (from5.charCodeAt(fromStart + i) === CHAR_FORWARD_SLASH) {
          lastCommonSep = i;
        } else if (i === 0) {
          lastCommonSep = 0;
        }
      }
      break;
    }
    const fromCode = from5.charCodeAt(fromStart + i);
    const toCode = to2.charCodeAt(toStart + i);
    if (fromCode !== toCode)
      break;
    else if (fromCode === CHAR_FORWARD_SLASH)
      lastCommonSep = i;
  }
  let out = "";
  for (i = fromStart + lastCommonSep + 1; i <= fromEnd; ++i) {
    if (i === fromEnd || from5.charCodeAt(i) === CHAR_FORWARD_SLASH) {
      if (out.length === 0)
        out += "..";
      else
        out += "/..";
    }
  }
  if (out.length > 0)
    return out + to2.slice(toStart + lastCommonSep);
  else {
    toStart += lastCommonSep;
    if (to2.charCodeAt(toStart) === CHAR_FORWARD_SLASH)
      ++toStart;
    return to2.slice(toStart);
  }
}
function toNamespacedPath2(path6) {
  return path6;
}
function dirname2(path6) {
  assertPath(path6);
  if (path6.length === 0)
    return ".";
  const hasRoot = path6.charCodeAt(0) === CHAR_FORWARD_SLASH;
  let end = -1;
  let matchedSlash = true;
  for (let i = path6.length - 1; i >= 1; --i) {
    if (path6.charCodeAt(i) === CHAR_FORWARD_SLASH) {
      if (!matchedSlash) {
        end = i;
        break;
      }
    } else {
      matchedSlash = false;
    }
  }
  if (end === -1)
    return hasRoot ? "/" : ".";
  if (hasRoot && end === 1)
    return "//";
  return path6.slice(0, end);
}
function basename2(path6, ext = "") {
  if (ext !== void 0 && typeof ext !== "string") {
    throw new TypeError('"ext" argument must be a string');
  }
  assertPath(path6);
  let start = 0;
  let end = -1;
  let matchedSlash = true;
  let i;
  if (ext !== void 0 && ext.length > 0 && ext.length <= path6.length) {
    if (ext.length === path6.length && ext === path6)
      return "";
    let extIdx = ext.length - 1;
    let firstNonSlashEnd = -1;
    for (i = path6.length - 1; i >= 0; --i) {
      const code2 = path6.charCodeAt(i);
      if (code2 === CHAR_FORWARD_SLASH) {
        if (!matchedSlash) {
          start = i + 1;
          break;
        }
      } else {
        if (firstNonSlashEnd === -1) {
          matchedSlash = false;
          firstNonSlashEnd = i + 1;
        }
        if (extIdx >= 0) {
          if (code2 === ext.charCodeAt(extIdx)) {
            if (--extIdx === -1) {
              end = i;
            }
          } else {
            extIdx = -1;
            end = firstNonSlashEnd;
          }
        }
      }
    }
    if (start === end)
      end = firstNonSlashEnd;
    else if (end === -1)
      end = path6.length;
    return path6.slice(start, end);
  } else {
    for (i = path6.length - 1; i >= 0; --i) {
      if (path6.charCodeAt(i) === CHAR_FORWARD_SLASH) {
        if (!matchedSlash) {
          start = i + 1;
          break;
        }
      } else if (end === -1) {
        matchedSlash = false;
        end = i + 1;
      }
    }
    if (end === -1)
      return "";
    return path6.slice(start, end);
  }
}
function extname2(path6) {
  assertPath(path6);
  let startDot = -1;
  let startPart = 0;
  let end = -1;
  let matchedSlash = true;
  let preDotState = 0;
  for (let i = path6.length - 1; i >= 0; --i) {
    const code2 = path6.charCodeAt(i);
    if (code2 === CHAR_FORWARD_SLASH) {
      if (!matchedSlash) {
        startPart = i + 1;
        break;
      }
      continue;
    }
    if (end === -1) {
      matchedSlash = false;
      end = i + 1;
    }
    if (code2 === CHAR_DOT) {
      if (startDot === -1)
        startDot = i;
      else if (preDotState !== 1)
        preDotState = 1;
    } else if (startDot !== -1) {
      preDotState = -1;
    }
  }
  if (startDot === -1 || end === -1 || preDotState === 0 || preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
    return "";
  }
  return path6.slice(startDot, end);
}
function format4(pathObject) {
  if (pathObject === null || typeof pathObject !== "object") {
    throw new TypeError(`The "pathObject" argument must be of type Object. Received type ${typeof pathObject}`);
  }
  return _format("/", pathObject);
}
function parse3(path6) {
  assertPath(path6);
  const ret = { root: "", dir: "", base: "", ext: "", name: "" };
  if (path6.length === 0)
    return ret;
  const isAbsolute7 = path6.charCodeAt(0) === CHAR_FORWARD_SLASH;
  let start;
  if (isAbsolute7) {
    ret.root = "/";
    start = 1;
  } else {
    start = 0;
  }
  let startDot = -1;
  let startPart = 0;
  let end = -1;
  let matchedSlash = true;
  let i = path6.length - 1;
  let preDotState = 0;
  for (; i >= start; --i) {
    const code2 = path6.charCodeAt(i);
    if (code2 === CHAR_FORWARD_SLASH) {
      if (!matchedSlash) {
        startPart = i + 1;
        break;
      }
      continue;
    }
    if (end === -1) {
      matchedSlash = false;
      end = i + 1;
    }
    if (code2 === CHAR_DOT) {
      if (startDot === -1)
        startDot = i;
      else if (preDotState !== 1)
        preDotState = 1;
    } else if (startDot !== -1) {
      preDotState = -1;
    }
  }
  if (startDot === -1 || end === -1 || preDotState === 0 || preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
    if (end !== -1) {
      if (startPart === 0 && isAbsolute7) {
        ret.base = ret.name = path6.slice(1, end);
      } else {
        ret.base = ret.name = path6.slice(startPart, end);
      }
    }
  } else {
    if (startPart === 0 && isAbsolute7) {
      ret.name = path6.slice(1, startDot);
      ret.base = path6.slice(1, end);
    } else {
      ret.name = path6.slice(startPart, startDot);
      ret.base = path6.slice(startPart, end);
    }
    ret.ext = path6.slice(startDot, end);
  }
  if (startPart > 0)
    ret.dir = path6.slice(0, startPart - 1);
  else if (isAbsolute7)
    ret.dir = "/";
  return ret;
}
function fromFileUrl2(url) {
  url = url instanceof URL ? url : new URL(url);
  if (url.protocol != "file:") {
    throw new TypeError("Must be a file URL.");
  }
  return decodeURIComponent(url.pathname.replace(/%(?![0-9A-Fa-f]{2})/g, "%25"));
}
function toFileUrl2(path6) {
  if (!isAbsolute2(path6)) {
    throw new TypeError("Must be an absolute path.");
  }
  const url = new URL("file:///");
  url.pathname = encodeWhitespace(path6.replace(/%/g, "%25").replace(/\\/g, "%5C"));
  return url;
}

// deno:https://deno.land/std@0.147.0/path/glob.ts
var path = isWindows ? win32_exports : posix_exports;
var { join: join4, normalize: normalize3 } = path;

// deno:https://deno.land/std@0.147.0/path/mod.ts
var path2 = isWindows ? win32_exports : posix_exports;
var {
  basename: basename3,
  delimiter: delimiter3,
  dirname: dirname3,
  extname: extname3,
  format: format5,
  fromFileUrl: fromFileUrl3,
  isAbsolute: isAbsolute3,
  join: join5,
  normalize: normalize4,
  parse: parse4,
  relative: relative3,
  resolve: resolve3,
  sep: sep3,
  toFileUrl: toFileUrl3,
  toNamespacedPath: toNamespacedPath3
} = path2;

// deno:https://deno.land/std@0.147.0/node/_process/process.ts
function _arch() {
  if (Deno.build.arch == "x86_64") {
    return "x64";
  } else if (Deno.build.arch == "aarch64") {
    return "arm64";
  } else {
    throw Error("unreachable");
  }
}
var arch = _arch();
var chdir = Deno.chdir;
var cwd = Deno.cwd;
var nextTick3 = nextTick2;
var env = new Proxy({}, {
  get(_target, prop) {
    return Deno.env.get(String(prop));
  },
  ownKeys: () => Reflect.ownKeys(Deno.env.toObject()),
  getOwnPropertyDescriptor: (_target, name) => {
    const e = Deno.env.toObject();
    if (name in Deno.env.toObject()) {
      const o2 = { enumerable: true, configurable: true };
      if (typeof name === "string") {
        o2.value = e[name];
      }
      return o2;
    }
  },
  set(_target, prop, value) {
    Deno.env.set(String(prop), String(value));
    return value;
  }
});
var pid = Deno.pid;
var platform = isWindows ? "win32" : Deno.build.os;
var version = "v16.11.1";
var versions = {
  node: "16.11.1",
  uv: "1.42.0",
  zlib: "1.2.11",
  brotli: "1.0.9",
  ares: "1.17.2",
  modules: "93",
  nghttp2: "1.45.1",
  napi: "8",
  llhttp: "6.0.4",
  openssl: "1.1.1l",
  cldr: "39.0",
  icu: "69.1",
  tz: "2021a",
  unicode: "13.0",
  ...Deno.version
};

// deno:https://deno.land/std@0.147.0/node/internal/readline/utils.mjs
var kEscape = "\x1B";
var kSubstringSearch = Symbol("kSubstringSearch");
function CSI(strings, ...args) {
  let ret = `${kEscape}[`;
  for (let n = 0; n < strings.length; n++) {
    ret += strings[n];
    if (n < args.length) {
      ret += args[n];
    }
  }
  return ret;
}
CSI.kEscape = kEscape;
CSI.kClearToLineBeginning = CSI`1K`;
CSI.kClearToLineEnd = CSI`0K`;
CSI.kClearLine = CSI`2K`;
CSI.kClearScreenDown = CSI`0J`;

// deno:https://deno.land/std@0.147.0/node/internal/readline/callbacks.mjs
var {
  kClearLine,
  kClearScreenDown,
  kClearToLineBeginning,
  kClearToLineEnd
} = CSI;
function cursorTo(stream, x, y4, callback) {
  if (callback !== void 0) {
    validateCallback(callback);
  }
  if (typeof y4 === "function") {
    callback = y4;
    y4 = void 0;
  }
  if (Number.isNaN(x))
    throw new ERR_INVALID_ARG_VALUE("x", x);
  if (Number.isNaN(y4))
    throw new ERR_INVALID_ARG_VALUE("y", y4);
  if (stream == null || typeof x !== "number" && typeof y4 !== "number") {
    if (typeof callback === "function")
      process.nextTick(callback, null);
    return true;
  }
  if (typeof x !== "number")
    throw new ERR_INVALID_CURSOR_POS();
  const data = typeof y4 !== "number" ? CSI`${x + 1}G` : CSI`${y4 + 1};${x + 1}H`;
  return stream.write(data, callback);
}
function moveCursor(stream, dx, dy, callback) {
  if (callback !== void 0) {
    validateCallback(callback);
  }
  if (stream == null || !(dx || dy)) {
    if (typeof callback === "function")
      process.nextTick(callback, null);
    return true;
  }
  let data = "";
  if (dx < 0) {
    data += CSI`${-dx}D`;
  } else if (dx > 0) {
    data += CSI`${dx}C`;
  }
  if (dy < 0) {
    data += CSI`${-dy}A`;
  } else if (dy > 0) {
    data += CSI`${dy}B`;
  }
  return stream.write(data, callback);
}
function clearLine(stream, dir, callback) {
  if (callback !== void 0) {
    validateCallback(callback);
  }
  if (stream === null || stream === void 0) {
    if (typeof callback === "function")
      process.nextTick(callback, null);
    return true;
  }
  const type = dir < 0 ? kClearToLineBeginning : dir > 0 ? kClearToLineEnd : kClearLine;
  return stream.write(type, callback);
}
function clearScreenDown(stream, callback) {
  if (callback !== void 0) {
    validateCallback(callback);
  }
  if (stream === null || stream === void 0) {
    if (typeof callback === "function")
      process.nextTick(callback, null);
    return true;
  }
  return stream.write(kClearScreenDown, callback);
}

// deno:https://deno.land/std@0.147.0/node/internal/streams/_utils.ts
function _uint8ArrayToBuffer(chunk) {
  return Buffer3.from(chunk.buffer, chunk.byteOffset, chunk.byteLength);
}

// deno:https://deno.land/std@0.147.0/node/internal/streams/end-of-stream.mjs
function isRequest(stream) {
  return stream.setHeader && typeof stream.abort === "function";
}
function isServerResponse(stream) {
  return typeof stream._sent100 === "boolean" && typeof stream._removedConnection === "boolean" && typeof stream._removedContLen === "boolean" && typeof stream._removedTE === "boolean" && typeof stream._closed === "boolean";
}
function isReadable(stream) {
  return typeof stream.readable === "boolean" || typeof stream.readableEnded === "boolean" || !!stream._readableState;
}
function isWritable(stream) {
  return typeof stream.writable === "boolean" || typeof stream.writableEnded === "boolean" || !!stream._writableState;
}
function isWritableFinished(stream) {
  if (stream.writableFinished)
    return true;
  const wState = stream._writableState;
  if (!wState || wState.errored)
    return false;
  return wState.finished || wState.ended && wState.length === 0;
}
var nop = () => {
};
function isReadableEnded(stream) {
  if (stream.readableEnded)
    return true;
  const rState = stream._readableState;
  if (!rState || rState.errored)
    return false;
  return rState.endEmitted || rState.ended && rState.length === 0;
}
function eos(stream, options, callback) {
  if (arguments.length === 2) {
    callback = options;
    options = {};
  } else if (options == null) {
    options = {};
  } else {
    validateObject(options, "options");
  }
  validateFunction(callback, "callback");
  validateAbortSignal(options.signal, "options.signal");
  callback = once(callback);
  const readable = options.readable || options.readable !== false && isReadable(stream);
  const writable = options.writable || options.writable !== false && isWritable(stream);
  const wState = stream._writableState;
  const rState = stream._readableState;
  const state = wState || rState;
  const onlegacyfinish = () => {
    if (!stream.writable)
      onfinish();
  };
  let willEmitClose = isServerResponse(stream) || state && state.autoDestroy && state.emitClose && state.closed === false && isReadable(stream) === readable && isWritable(stream) === writable;
  let writableFinished = stream.writableFinished || wState && wState.finished;
  const onfinish = () => {
    writableFinished = true;
    if (stream.destroyed)
      willEmitClose = false;
    if (willEmitClose && (!stream.readable || readable))
      return;
    if (!readable || readableEnded)
      callback.call(stream);
  };
  let readableEnded = stream.readableEnded || rState && rState.endEmitted;
  const onend = () => {
    readableEnded = true;
    if (stream.destroyed)
      willEmitClose = false;
    if (willEmitClose && (!stream.writable || writable))
      return;
    if (!writable || writableFinished)
      callback.call(stream);
  };
  const onerror = (err) => {
    callback.call(stream, err);
  };
  const onclose = () => {
    if (readable && !readableEnded) {
      if (!isReadableEnded(stream)) {
        return callback.call(stream, new ERR_STREAM_PREMATURE_CLOSE());
      }
    }
    if (writable && !writableFinished) {
      if (!isWritableFinished(stream)) {
        return callback.call(stream, new ERR_STREAM_PREMATURE_CLOSE());
      }
    }
    callback.call(stream);
  };
  const onrequest = () => {
    stream.req.on("finish", onfinish);
  };
  if (isRequest(stream)) {
    stream.on("complete", onfinish);
    if (!willEmitClose) {
      stream.on("abort", onclose);
    }
    if (stream.req)
      onrequest();
    else
      stream.on("request", onrequest);
  } else if (writable && !wState) {
    stream.on("end", onlegacyfinish);
    stream.on("close", onlegacyfinish);
  }
  if (!willEmitClose && typeof stream.aborted === "boolean") {
    stream.on("aborted", onclose);
  }
  stream.on("end", onend);
  stream.on("finish", onfinish);
  if (options.error !== false)
    stream.on("error", onerror);
  stream.on("close", onclose);
  const closed = !wState && !rState && stream._closed === true || (wState && wState.closed || rState && rState.closed || wState && wState.errorEmitted || rState && rState.errorEmitted || rState && stream.req && stream.aborted || (!wState || !willEmitClose || typeof wState.closed !== "boolean") && (!rState || !willEmitClose || typeof rState.closed !== "boolean") && (!writable || wState && wState.finished) && (!readable || rState && rState.endEmitted));
  if (closed) {
    nextTick3(() => {
      callback();
    });
  }
  const cleanup = () => {
    callback = nop;
    stream.removeListener("aborted", onclose);
    stream.removeListener("complete", onfinish);
    stream.removeListener("abort", onclose);
    stream.removeListener("request", onrequest);
    if (stream.req)
      stream.req.removeListener("finish", onfinish);
    stream.removeListener("end", onlegacyfinish);
    stream.removeListener("close", onlegacyfinish);
    stream.removeListener("finish", onfinish);
    stream.removeListener("end", onend);
    stream.removeListener("error", onerror);
    stream.removeListener("close", onclose);
  };
  if (options.signal && !closed) {
    const abort = () => {
      const endCallback = callback;
      cleanup();
      endCallback.call(stream, new AbortError());
    };
    if (options.signal.aborted) {
      nextTick3(abort);
    } else {
      const originalCallback = callback;
      callback = once((...args) => {
        options.signal.removeEventListener("abort", abort);
        originalCallback.apply(stream, args);
      });
      options.signal.addEventListener("abort", abort);
    }
  }
  return cleanup;
}
var end_of_stream_default = eos;

// deno:https://deno.land/std@0.147.0/node/internal/streams/add-abort-signal.mjs
var validateAbortSignal2 = (signal, name) => {
  if (typeof signal !== "object" || !("aborted" in signal)) {
    throw new ERR_INVALID_ARG_TYPE(name, "AbortSignal", signal);
  }
};
function isStream(obj2) {
  return !!(obj2 && typeof obj2.pipe === "function");
}
function addAbortSignal(signal, stream) {
  validateAbortSignal2(signal, "signal");
  if (!isStream(stream)) {
    throw new ERR_INVALID_ARG_TYPE("stream", "stream.Stream", stream);
  }
  return addAbortSignalNoValidate(signal, stream);
}
function addAbortSignalNoValidate(signal, stream) {
  if (typeof signal !== "object" || !("aborted" in signal)) {
    return stream;
  }
  const onAbort = () => {
    stream.destroy(new AbortError());
  };
  if (signal.aborted) {
    onAbort();
  } else {
    signal.addEventListener("abort", onAbort);
    end_of_stream_default(stream, () => signal.removeEventListener("abort", onAbort));
  }
  return stream;
}

// deno:https://deno.land/std@0.147.0/node/internal/streams/destroy.mjs
var kDestroy = Symbol("kDestroy");
var kConstruct = Symbol("kConstruct");
function checkError(err, w2, r) {
  if (err) {
    err.stack;
    if (w2 && !w2.errored) {
      w2.errored = err;
    }
    if (r && !r.errored) {
      r.errored = err;
    }
  }
}
function destroy2(err, cb) {
  const r = this._readableState;
  const w2 = this._writableState;
  const s = w2 || r;
  if (w2 && w2.destroyed || r && r.destroyed) {
    if (typeof cb === "function") {
      cb();
    }
    return this;
  }
  checkError(err, w2, r);
  if (w2) {
    w2.destroyed = true;
  }
  if (r) {
    r.destroyed = true;
  }
  if (!s.constructed) {
    this.once(kDestroy, function(er) {
      _destroy(this, aggregateTwoErrors(er, err), cb);
    });
  } else {
    _destroy(this, err, cb);
  }
  return this;
}
function _destroy(self2, err, cb) {
  let called = false;
  function onDestroy(err2) {
    if (called) {
      return;
    }
    called = true;
    const r = self2._readableState;
    const w2 = self2._writableState;
    checkError(err2, w2, r);
    if (w2) {
      w2.closed = true;
    }
    if (r) {
      r.closed = true;
    }
    if (typeof cb === "function") {
      cb(err2);
    }
    if (err2) {
      nextTick3(emitErrorCloseNT, self2, err2);
    } else {
      nextTick3(emitCloseNT, self2);
    }
  }
  try {
    const result = self2._destroy(err || null, onDestroy);
    if (result != null) {
      const then = result.then;
      if (typeof then === "function") {
        then.call(result, function() {
          nextTick3(onDestroy, null);
        }, function(err2) {
          nextTick3(onDestroy, err2);
        });
      }
    }
  } catch (err2) {
    onDestroy(err2);
  }
}
function emitErrorCloseNT(self2, err) {
  emitErrorNT(self2, err);
  emitCloseNT(self2);
}
function emitCloseNT(self2) {
  const r = self2._readableState;
  const w2 = self2._writableState;
  if (w2) {
    w2.closeEmitted = true;
  }
  if (r) {
    r.closeEmitted = true;
  }
  if (w2 && w2.emitClose || r && r.emitClose) {
    self2.emit("close");
  }
}
function emitErrorNT(self2, err) {
  const r = self2._readableState;
  const w2 = self2._writableState;
  if (w2 && w2.errorEmitted || r && r.errorEmitted) {
    return;
  }
  if (w2) {
    w2.errorEmitted = true;
  }
  if (r) {
    r.errorEmitted = true;
  }
  self2.emit("error", err);
}
function undestroy() {
  const r = this._readableState;
  const w2 = this._writableState;
  if (r) {
    r.constructed = true;
    r.closed = false;
    r.closeEmitted = false;
    r.destroyed = false;
    r.errored = null;
    r.errorEmitted = false;
    r.reading = false;
    r.ended = false;
    r.endEmitted = false;
  }
  if (w2) {
    w2.constructed = true;
    w2.destroyed = false;
    w2.closed = false;
    w2.closeEmitted = false;
    w2.errored = null;
    w2.errorEmitted = false;
    w2.ended = false;
    w2.ending = false;
    w2.finalCalled = false;
    w2.prefinished = false;
    w2.finished = false;
  }
}
function errorOrDestroy(stream, err, sync) {
  const r = stream._readableState;
  const w2 = stream._writableState;
  if (w2 && w2.destroyed || r && r.destroyed) {
    return this;
  }
  if (r && r.autoDestroy || w2 && w2.autoDestroy) {
    stream.destroy(err);
  } else if (err) {
    err.stack;
    if (w2 && !w2.errored) {
      w2.errored = err;
    }
    if (r && !r.errored) {
      r.errored = err;
    }
    if (sync) {
      nextTick3(emitErrorNT, stream, err);
    } else {
      emitErrorNT(stream, err);
    }
  }
}
function construct(stream, cb) {
  if (typeof stream._construct !== "function") {
    return;
  }
  const r = stream._readableState;
  const w2 = stream._writableState;
  if (r) {
    r.constructed = false;
  }
  if (w2) {
    w2.constructed = false;
  }
  stream.once(kConstruct, cb);
  if (stream.listenerCount(kConstruct) > 1) {
    return;
  }
  nextTick3(constructNT, stream);
}
function constructNT(stream) {
  let called = false;
  function onConstruct(err) {
    if (called) {
      errorOrDestroy(stream, err ?? new ERR_MULTIPLE_CALLBACK());
      return;
    }
    called = true;
    const r = stream._readableState;
    const w2 = stream._writableState;
    const s = w2 || r;
    if (r) {
      r.constructed = true;
    }
    if (w2) {
      w2.constructed = true;
    }
    if (s.destroyed) {
      stream.emit(kDestroy, err);
    } else if (err) {
      errorOrDestroy(stream, err, true);
    } else {
      nextTick3(emitConstructNT, stream);
    }
  }
  try {
    const result = stream._construct(onConstruct);
    if (result != null) {
      const then = result.then;
      if (typeof then === "function") {
        then.call(result, function() {
          nextTick3(onConstruct, null);
        }, function(err) {
          nextTick3(onConstruct, err);
        });
      }
    }
  } catch (err) {
    onConstruct(err);
  }
}
function emitConstructNT(stream) {
  stream.emit(kConstruct);
}
function isRequest2(stream) {
  return stream && stream.setHeader && typeof stream.abort === "function";
}
function destroyer(stream, err) {
  if (!stream)
    return;
  if (isRequest2(stream))
    return stream.abort();
  if (isRequest2(stream.req))
    return stream.req.abort();
  if (typeof stream.destroy === "function")
    return stream.destroy(err);
  if (typeof stream.close === "function")
    return stream.close();
}
var destroy_default = {
  construct,
  destroyer,
  destroy: destroy2,
  undestroy,
  errorOrDestroy
};

// deno:https://deno.land/std@0.147.0/node/internal/streams/utils.mjs
var kIsDisturbed = Symbol("kIsDisturbed");
function isReadableNodeStream(obj2) {
  return !!(obj2 && typeof obj2.pipe === "function" && typeof obj2.on === "function" && (!obj2._writableState || obj2._readableState?.readable !== false) && (!obj2._writableState || obj2._readableState));
}
function isWritableNodeStream(obj2) {
  return !!(obj2 && typeof obj2.write === "function" && typeof obj2.on === "function" && (!obj2._readableState || obj2._writableState?.writable !== false));
}
function isDuplexNodeStream(obj2) {
  return !!(obj2 && (typeof obj2.pipe === "function" && obj2._readableState) && typeof obj2.on === "function" && typeof obj2.write === "function");
}
function isNodeStream(obj2) {
  return obj2 && (obj2._readableState || obj2._writableState || typeof obj2.write === "function" && typeof obj2.on === "function" || typeof obj2.pipe === "function" && typeof obj2.on === "function");
}
function isIterable(obj2, isAsync) {
  if (obj2 == null)
    return false;
  if (isAsync === true)
    return typeof obj2[Symbol.asyncIterator] === "function";
  if (isAsync === false)
    return typeof obj2[Symbol.iterator] === "function";
  return typeof obj2[Symbol.asyncIterator] === "function" || typeof obj2[Symbol.iterator] === "function";
}
function isDestroyed(stream) {
  if (!isNodeStream(stream))
    return null;
  const wState = stream._writableState;
  const rState = stream._readableState;
  const state = wState || rState;
  return !!(stream.destroyed || state?.destroyed);
}
function isWritableEnded(stream) {
  if (!isWritableNodeStream(stream))
    return null;
  if (stream.writableEnded === true)
    return true;
  const wState = stream._writableState;
  if (wState?.errored)
    return false;
  if (typeof wState?.ended !== "boolean")
    return null;
  return wState.ended;
}
function isReadableEnded2(stream) {
  if (!isReadableNodeStream(stream))
    return null;
  if (stream.readableEnded === true)
    return true;
  const rState = stream._readableState;
  if (!rState || rState.errored)
    return false;
  if (typeof rState?.ended !== "boolean")
    return null;
  return rState.ended;
}
function isReadableFinished(stream, strict) {
  if (!isReadableNodeStream(stream))
    return null;
  const rState = stream._readableState;
  if (rState?.errored)
    return false;
  if (typeof rState?.endEmitted !== "boolean")
    return null;
  return !!(rState.endEmitted || strict === false && rState.ended === true && rState.length === 0);
}
function isDisturbed(stream) {
  return !!(stream && (stream.readableDidRead || stream.readableAborted || stream[kIsDisturbed]));
}
function isReadable2(stream) {
  const r = isReadableNodeStream(stream);
  if (r === null || typeof stream?.readable !== "boolean")
    return null;
  if (isDestroyed(stream))
    return false;
  return r && stream.readable && !isReadableFinished(stream);
}
function isWritable2(stream) {
  const r = isWritableNodeStream(stream);
  if (r === null || typeof stream?.writable !== "boolean")
    return null;
  if (isDestroyed(stream))
    return false;
  return r && stream.writable && !isWritableEnded(stream);
}

// deno:https://deno.land/std@0.147.0/node/_process/stdio.mjs
var stdio = {};

// deno:https://deno.land/std@0.147.0/node/internal/blob.mjs
function isBlob(object) {
  return object instanceof Blob;
}

// deno:https://deno.land/std@0.147.0/node/internal/streams/from.mjs
function _from2(Readable2, iterable, opts) {
  let iterator;
  if (typeof iterable === "string" || iterable instanceof Buffer3) {
    return new Readable2({
      objectMode: true,
      ...opts,
      read() {
        this.push(iterable);
        this.push(null);
      }
    });
  }
  let isAsync;
  if (iterable && iterable[Symbol.asyncIterator]) {
    isAsync = true;
    iterator = iterable[Symbol.asyncIterator]();
  } else if (iterable && iterable[Symbol.iterator]) {
    isAsync = false;
    iterator = iterable[Symbol.iterator]();
  } else {
    throw new ERR_INVALID_ARG_TYPE("iterable", ["Iterable"], iterable);
  }
  const readable = new Readable2({
    objectMode: true,
    highWaterMark: 1,
    ...opts
  });
  let reading = false;
  readable._read = function() {
    if (!reading) {
      reading = true;
      next();
    }
  };
  readable._destroy = function(error3, cb) {
    close(error3).then(() => nextTick3(cb, error3), (e) => nextTick3(cb, e || error3));
  };
  async function close(error3) {
    const hadError = error3 !== void 0 && error3 !== null;
    const hasThrow = typeof iterator.throw === "function";
    if (hadError && hasThrow) {
      const { value, done } = await iterator.throw(error3);
      await value;
      if (done) {
        return;
      }
    }
    if (typeof iterator.return === "function") {
      const { value } = await iterator.return();
      await value;
    }
  }
  async function next() {
    for (; ; ) {
      try {
        const { value, done } = isAsync ? await iterator.next() : iterator.next();
        if (done) {
          readable.push(null);
        } else {
          const res = value && typeof value.then === "function" ? await value : value;
          if (res === null) {
            reading = false;
            throw new ERR_STREAM_NULL_VALUES();
          } else if (readable.push(res)) {
            continue;
          } else {
            reading = false;
          }
        }
      } catch (err) {
        readable.destroy(err);
      }
      break;
    }
  }
  return readable;
}
var from_default = _from2;

// deno:https://deno.land/std@0.147.0/node/internal/streams/state.mjs
function highWaterMarkFrom(options, isDuplex, duplexKey) {
  return options.highWaterMark != null ? options.highWaterMark : isDuplex ? options[duplexKey] : null;
}
function getDefaultHighWaterMark(objectMode) {
  return objectMode ? 16 : 16 * 1024;
}
function getHighWaterMark(state, options, duplexKey, isDuplex) {
  const hwm = highWaterMarkFrom(options, isDuplex, duplexKey);
  if (hwm != null) {
    if (!Number.isInteger(hwm) || hwm < 0) {
      const name = isDuplex ? `options.${duplexKey}` : "options.highWaterMark";
      throw new ERR_INVALID_ARG_VALUE(name, hwm);
    }
    return Math.floor(hwm);
  }
  return getDefaultHighWaterMark(state.objectMode);
}

// deno:https://deno.land/std@0.147.0/node/internal/streams/legacy.mjs
function Stream(opts) {
  events_default.call(this, opts);
}
Object.setPrototypeOf(Stream.prototype, events_default.prototype);
Object.setPrototypeOf(Stream, events_default);
Stream.prototype.pipe = function(dest, options) {
  const source = this;
  function ondata(chunk) {
    if (dest.writable && dest.write(chunk) === false && source.pause) {
      source.pause();
    }
  }
  source.on("data", ondata);
  function ondrain() {
    if (source.readable && source.resume) {
      source.resume();
    }
  }
  dest.on("drain", ondrain);
  if (!dest._isStdio && (!options || options.end !== false)) {
    source.on("end", onend);
    source.on("close", onclose);
  }
  let didOnEnd = false;
  function onend() {
    if (didOnEnd)
      return;
    didOnEnd = true;
    dest.end();
  }
  function onclose() {
    if (didOnEnd)
      return;
    didOnEnd = true;
    if (typeof dest.destroy === "function")
      dest.destroy();
  }
  function onerror(er) {
    cleanup();
    if (events_default.listenerCount(this, "error") === 0) {
      this.emit("error", er);
    }
  }
  prependListener2(source, "error", onerror);
  prependListener2(dest, "error", onerror);
  function cleanup() {
    source.removeListener("data", ondata);
    dest.removeListener("drain", ondrain);
    source.removeListener("end", onend);
    source.removeListener("close", onclose);
    source.removeListener("error", onerror);
    dest.removeListener("error", onerror);
    source.removeListener("end", cleanup);
    source.removeListener("close", cleanup);
    dest.removeListener("close", cleanup);
  }
  source.on("end", cleanup);
  source.on("close", cleanup);
  dest.on("close", cleanup);
  dest.emit("pipe", source);
  return dest;
};
function prependListener2(emitter, event, fn) {
  if (typeof emitter.prependListener === "function") {
    return emitter.prependListener(event, fn);
  }
  if (!emitter._events || !emitter._events[event]) {
    emitter.on(event, fn);
  } else if (Array.isArray(emitter._events[event])) {
    emitter._events[event].unshift(fn);
  } else {
    emitter._events[event] = [fn, emitter._events[event]];
  }
}

// deno:https://deno.land/std@0.147.0/node/string_decoder.ts
var NotImplemented = /* @__PURE__ */ ((NotImplemented2) => {
  NotImplemented2[NotImplemented2["ascii"] = 0] = "ascii";
  NotImplemented2[NotImplemented2["latin1"] = 1] = "latin1";
  NotImplemented2[NotImplemented2["utf16le"] = 2] = "utf16le";
  return NotImplemented2;
})(NotImplemented || {});
function normalizeEncoding3(enc) {
  const encoding = normalizeEncoding(enc ?? null);
  if (encoding && encoding in NotImplemented)
    notImplemented(encoding);
  if (!encoding && typeof enc === "string" && enc.toLowerCase() !== "raw") {
    throw new Error(`Unknown encoding: ${enc}`);
  }
  return String(encoding);
}
function utf8CheckByte(byte) {
  if (byte <= 127)
    return 0;
  else if (byte >> 5 === 6)
    return 2;
  else if (byte >> 4 === 14)
    return 3;
  else if (byte >> 3 === 30)
    return 4;
  return byte >> 6 === 2 ? -1 : -2;
}
function utf8CheckIncomplete(self2, buf, i) {
  let j2 = buf.length - 1;
  if (j2 < i)
    return 0;
  let nb = utf8CheckByte(buf[j2]);
  if (nb >= 0) {
    if (nb > 0)
      self2.lastNeed = nb - 1;
    return nb;
  }
  if (--j2 < i || nb === -2)
    return 0;
  nb = utf8CheckByte(buf[j2]);
  if (nb >= 0) {
    if (nb > 0)
      self2.lastNeed = nb - 2;
    return nb;
  }
  if (--j2 < i || nb === -2)
    return 0;
  nb = utf8CheckByte(buf[j2]);
  if (nb >= 0) {
    if (nb > 0) {
      if (nb === 2)
        nb = 0;
      else
        self2.lastNeed = nb - 3;
    }
    return nb;
  }
  return 0;
}
function utf8CheckExtraBytes(self2, buf) {
  if ((buf[0] & 192) !== 128) {
    self2.lastNeed = 0;
    return "\uFFFD";
  }
  if (self2.lastNeed > 1 && buf.length > 1) {
    if ((buf[1] & 192) !== 128) {
      self2.lastNeed = 1;
      return "\uFFFD";
    }
    if (self2.lastNeed > 2 && buf.length > 2) {
      if ((buf[2] & 192) !== 128) {
        self2.lastNeed = 2;
        return "\uFFFD";
      }
    }
  }
}
function utf8FillLastComplete(buf) {
  const p3 = this.lastTotal - this.lastNeed;
  const r = utf8CheckExtraBytes(this, buf);
  if (r !== void 0)
    return r;
  if (this.lastNeed <= buf.length) {
    buf.copy(this.lastChar, p3, 0, this.lastNeed);
    return this.lastChar.toString(this.encoding, 0, this.lastTotal);
  }
  buf.copy(this.lastChar, p3, 0, buf.length);
  this.lastNeed -= buf.length;
}
function utf8FillLastIncomplete(buf) {
  if (this.lastNeed <= buf.length) {
    buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed);
    return this.lastChar.toString(this.encoding, 0, this.lastTotal);
  }
  buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length);
  this.lastNeed -= buf.length;
}
function utf8Text(buf, i) {
  const total = utf8CheckIncomplete(this, buf, i);
  if (!this.lastNeed)
    return buf.toString("utf8", i);
  this.lastTotal = total;
  const end = buf.length - (total - this.lastNeed);
  buf.copy(this.lastChar, 0, end);
  return buf.toString("utf8", i, end);
}
function utf8End(buf) {
  const r = buf && buf.length ? this.write(buf) : "";
  if (this.lastNeed)
    return r + "\uFFFD";
  return r;
}
function utf8Write2(buf) {
  if (typeof buf === "string") {
    return buf;
  }
  if (buf.length === 0)
    return "";
  let r;
  let i;
  if (this.lastNeed) {
    r = this.fillLast(buf);
    if (r === void 0)
      return "";
    i = this.lastNeed;
    this.lastNeed = 0;
  } else {
    i = 0;
  }
  if (i < buf.length)
    return r ? r + this.text(buf, i) : this.text(buf, i);
  return r || "";
}
function base64Text(buf, i) {
  const n = (buf.length - i) % 3;
  if (n === 0)
    return buf.toString("base64", i);
  this.lastNeed = 3 - n;
  this.lastTotal = 3;
  if (n === 1) {
    this.lastChar[0] = buf[buf.length - 1];
  } else {
    this.lastChar[0] = buf[buf.length - 2];
    this.lastChar[1] = buf[buf.length - 1];
  }
  return buf.toString("base64", i, buf.length - n);
}
function base64End(buf) {
  const r = buf && buf.length ? this.write(buf) : "";
  if (this.lastNeed) {
    return r + this.lastChar.toString("base64", 0, 3 - this.lastNeed);
  }
  return r;
}
function simpleWrite(buf) {
  if (typeof buf === "string") {
    return buf;
  }
  return buf.toString(this.encoding);
}
function simpleEnd(buf) {
  return buf && buf.length ? this.write(buf) : "";
}
var StringDecoderBase = class {
  constructor(encoding, nb) {
    this.encoding = encoding;
    this.lastNeed = 0;
    this.lastTotal = 0;
    this.lastChar = Buffer3.allocUnsafe(nb);
  }
};
var Base64Decoder = class extends StringDecoderBase {
  constructor(encoding) {
    super(normalizeEncoding3(encoding), 3);
    this.end = base64End;
    this.fillLast = utf8FillLastIncomplete;
    this.text = base64Text;
    this.write = utf8Write2;
  }
};
var GenericDecoder = class extends StringDecoderBase {
  constructor(encoding) {
    super(normalizeEncoding3(encoding), 4);
    this.end = simpleEnd;
    this.fillLast = void 0;
    this.text = utf8Text;
    this.write = simpleWrite;
  }
};
var Utf8Decoder = class extends StringDecoderBase {
  constructor(encoding) {
    super(normalizeEncoding3(encoding), 4);
    this.end = utf8End;
    this.fillLast = utf8FillLastComplete;
    this.text = utf8Text;
    this.write = utf8Write2;
  }
};
var StringDecoder = class {
  constructor(encoding) {
    let decoder;
    switch (encoding) {
      case "utf8":
        decoder = new Utf8Decoder(encoding);
        break;
      case "base64":
        decoder = new Base64Decoder(encoding);
        break;
      default:
        decoder = new GenericDecoder(encoding);
    }
    this.encoding = decoder.encoding;
    this.end = decoder.end;
    this.fillLast = decoder.fillLast;
    this.lastChar = decoder.lastChar;
    this.lastNeed = decoder.lastNeed;
    this.lastTotal = decoder.lastTotal;
    this.text = decoder.text;
    this.write = decoder.write;
  }
};
var PStringDecoder = new Proxy(StringDecoder, {
  apply(_target, thisArg, args) {
    return Object.assign(thisArg, new StringDecoder(...args));
  }
});
var string_decoder_default2 = { StringDecoder: PStringDecoder };

// deno:https://deno.land/std@0.147.0/node/internal/streams/buffer_list.mjs
var BufferList = class {
  constructor() {
    this.head = null;
    this.tail = null;
    this.length = 0;
  }
  push(v2) {
    const entry = { data: v2, next: null };
    if (this.length > 0) {
      this.tail.next = entry;
    } else {
      this.head = entry;
    }
    this.tail = entry;
    ++this.length;
  }
  unshift(v2) {
    const entry = { data: v2, next: this.head };
    if (this.length === 0) {
      this.tail = entry;
    }
    this.head = entry;
    ++this.length;
  }
  shift() {
    if (this.length === 0) {
      return;
    }
    const ret = this.head.data;
    if (this.length === 1) {
      this.head = this.tail = null;
    } else {
      this.head = this.head.next;
    }
    --this.length;
    return ret;
  }
  clear() {
    this.head = this.tail = null;
    this.length = 0;
  }
  join(s) {
    if (this.length === 0) {
      return "";
    }
    let p3 = this.head;
    let ret = "" + p3.data;
    while (p3 = p3.next) {
      ret += s + p3.data;
    }
    return ret;
  }
  concat(n) {
    if (this.length === 0) {
      return Buffer3.alloc(0);
    }
    const ret = Buffer3.allocUnsafe(n >>> 0);
    let p3 = this.head;
    let i = 0;
    while (p3) {
      ret.set(p3.data, i);
      i += p3.data.length;
      p3 = p3.next;
    }
    return ret;
  }
  consume(n, hasStrings) {
    const data = this.head.data;
    if (n < data.length) {
      const slice5 = data.slice(0, n);
      this.head.data = data.slice(n);
      return slice5;
    }
    if (n === data.length) {
      return this.shift();
    }
    return hasStrings ? this._getString(n) : this._getBuffer(n);
  }
  first() {
    return this.head.data;
  }
  *[Symbol.iterator]() {
    for (let p3 = this.head; p3; p3 = p3.next) {
      yield p3.data;
    }
  }
  _getString(n) {
    let ret = "";
    let p3 = this.head;
    let c5 = 0;
    do {
      const str = p3.data;
      if (n > str.length) {
        ret += str;
        n -= str.length;
      } else {
        if (n === str.length) {
          ret += str;
          ++c5;
          if (p3.next) {
            this.head = p3.next;
          } else {
            this.head = this.tail = null;
          }
        } else {
          ret += str.slice(0, n);
          this.head = p3;
          p3.data = str.slice(n);
        }
        break;
      }
      ++c5;
    } while (p3 = p3.next);
    this.length -= c5;
    return ret;
  }
  _getBuffer(n) {
    const ret = Buffer3.allocUnsafe(n);
    const retLen = n;
    let p3 = this.head;
    let c5 = 0;
    do {
      const buf = p3.data;
      if (n > buf.length) {
        ret.set(buf, retLen - n);
        n -= buf.length;
      } else {
        if (n === buf.length) {
          ret.set(buf, retLen - n);
          ++c5;
          if (p3.next) {
            this.head = p3.next;
          } else {
            this.head = this.tail = null;
          }
        } else {
          ret.set(new Uint8Array(buf.buffer, buf.byteOffset, n), retLen - n);
          this.head = p3;
          p3.data = buf.slice(n);
        }
        break;
      }
      ++c5;
    } while (p3 = p3.next);
    this.length -= c5;
    return ret;
  }
  [inspect.custom](_2, options) {
    return inspect(this, {
      ...options,
      depth: 0,
      customInspect: false
    });
  }
};
var buffer_list_default = BufferList;

// deno:https://deno.land/std@0.147.0/node/internal/streams/readable.mjs
var debug = debuglog("stream", (fn) => {
  debug = fn;
});
var kPaused = Symbol("kPaused");
Object.setPrototypeOf(Readable.prototype, Stream.prototype);
Object.setPrototypeOf(Readable, Stream);
var nop2 = () => {
};
var { errorOrDestroy: errorOrDestroy2 } = destroy_default;
function ReadableState(options, stream, isDuplex) {
  if (typeof isDuplex !== "boolean") {
    isDuplex = stream instanceof Stream.Duplex;
  }
  this.objectMode = !!(options && options.objectMode);
  if (isDuplex) {
    this.objectMode = this.objectMode || !!(options && options.readableObjectMode);
  }
  this.highWaterMark = options ? getHighWaterMark(this, options, "readableHighWaterMark", isDuplex) : getDefaultHighWaterMark(false);
  this.buffer = new buffer_list_default();
  this.length = 0;
  this.pipes = [];
  this.flowing = null;
  this.ended = false;
  this.endEmitted = false;
  this.reading = false;
  this.constructed = true;
  this.sync = true;
  this.needReadable = false;
  this.emittedReadable = false;
  this.readableListening = false;
  this.resumeScheduled = false;
  this[kPaused] = null;
  this.errorEmitted = false;
  this.emitClose = !options || options.emitClose !== false;
  this.autoDestroy = !options || options.autoDestroy !== false;
  this.destroyed = false;
  this.errored = null;
  this.closed = false;
  this.closeEmitted = false;
  this.defaultEncoding = options && options.defaultEncoding || "utf8";
  this.awaitDrainWriters = null;
  this.multiAwaitDrain = false;
  this.readingMore = false;
  this.dataEmitted = false;
  this.decoder = null;
  this.encoding = null;
  if (options && options.encoding) {
    this.decoder = new StringDecoder(options.encoding);
    this.encoding = options.encoding;
  }
}
function Readable(options) {
  if (!(this instanceof Readable)) {
    return new Readable(options);
  }
  const isDuplex = this instanceof Stream.Duplex;
  this._readableState = new ReadableState(options, this, isDuplex);
  if (options) {
    if (typeof options.read === "function") {
      this._read = options.read;
    }
    if (typeof options.destroy === "function") {
      this._destroy = options.destroy;
    }
    if (typeof options.construct === "function") {
      this._construct = options.construct;
    }
    if (options.signal && !isDuplex) {
      addAbortSignalNoValidate(options.signal, this);
    }
  }
  Stream.call(this, options);
  destroy_default.construct(this, () => {
    if (this._readableState.needReadable) {
      maybeReadMore(this, this._readableState);
    }
  });
}
Readable.prototype.destroy = destroy_default.destroy;
Readable.prototype._undestroy = destroy_default.undestroy;
Readable.prototype._destroy = function(err, cb) {
  cb(err);
};
Readable.prototype[events_default.captureRejectionSymbol] = function(err) {
  this.destroy(err);
};
Readable.prototype.push = function(chunk, encoding) {
  return readableAddChunk(this, chunk, encoding, false);
};
Readable.prototype.unshift = function(chunk, encoding) {
  return readableAddChunk(this, chunk, encoding, true);
};
function readableAddChunk(stream, chunk, encoding, addToFront) {
  debug("readableAddChunk", chunk);
  const state = stream._readableState;
  let err;
  if (!state.objectMode) {
    if (typeof chunk === "string") {
      encoding = encoding || state.defaultEncoding;
      if (state.encoding !== encoding) {
        if (addToFront && state.encoding) {
          chunk = Buffer3.from(chunk, encoding).toString(state.encoding);
        } else {
          chunk = Buffer3.from(chunk, encoding);
          encoding = "";
        }
      }
    } else if (chunk instanceof Buffer3) {
      encoding = "";
    } else if (Stream._isUint8Array(chunk)) {
      chunk = Stream._uint8ArrayToBuffer(chunk);
      encoding = "";
    } else if (chunk != null) {
      err = new ERR_INVALID_ARG_TYPE("chunk", ["string", "Buffer", "Uint8Array"], chunk);
    }
  }
  if (err) {
    errorOrDestroy2(stream, err);
  } else if (chunk === null) {
    state.reading = false;
    onEofChunk(stream, state);
  } else if (state.objectMode || chunk && chunk.length > 0) {
    if (addToFront) {
      if (state.endEmitted) {
        errorOrDestroy2(stream, new ERR_STREAM_UNSHIFT_AFTER_END_EVENT());
      } else {
        addChunk(stream, state, chunk, true);
      }
    } else if (state.ended) {
      errorOrDestroy2(stream, new ERR_STREAM_PUSH_AFTER_EOF());
    } else if (state.destroyed || state.errored) {
      return false;
    } else {
      state.reading = false;
      if (state.decoder && !encoding) {
        chunk = state.decoder.write(chunk);
        if (state.objectMode || chunk.length !== 0) {
          addChunk(stream, state, chunk, false);
        } else {
          maybeReadMore(stream, state);
        }
      } else {
        addChunk(stream, state, chunk, false);
      }
    }
  } else if (!addToFront) {
    state.reading = false;
    maybeReadMore(stream, state);
  }
  return !state.ended && (state.length < state.highWaterMark || state.length === 0);
}
function addChunk(stream, state, chunk, addToFront) {
  if (state.flowing && state.length === 0 && !state.sync && stream.listenerCount("data") > 0) {
    if (state.multiAwaitDrain) {
      state.awaitDrainWriters.clear();
    } else {
      state.awaitDrainWriters = null;
    }
    state.dataEmitted = true;
    stream.emit("data", chunk);
  } else {
    state.length += state.objectMode ? 1 : chunk.length;
    if (addToFront) {
      state.buffer.unshift(chunk);
    } else {
      state.buffer.push(chunk);
    }
    if (state.needReadable) {
      emitReadable(stream);
    }
  }
  maybeReadMore(stream, state);
}
Readable.prototype.isPaused = function() {
  const state = this._readableState;
  return state[kPaused] === true || state.flowing === false;
};
Readable.prototype.setEncoding = function(enc) {
  const decoder = new StringDecoder(enc);
  this._readableState.decoder = decoder;
  this._readableState.encoding = this._readableState.decoder.encoding;
  const buffer = this._readableState.buffer;
  let content = "";
  for (const data of buffer) {
    content += decoder.write(data);
  }
  buffer.clear();
  if (content !== "") {
    buffer.push(content);
  }
  this._readableState.length = content.length;
  return this;
};
var MAX_HWM = 1073741824;
function computeNewHighWaterMark(n) {
  if (n >= MAX_HWM) {
    n = MAX_HWM;
  } else {
    n--;
    n |= n >>> 1;
    n |= n >>> 2;
    n |= n >>> 4;
    n |= n >>> 8;
    n |= n >>> 16;
    n++;
  }
  return n;
}
function howMuchToRead(n, state) {
  if (n <= 0 || state.length === 0 && state.ended) {
    return 0;
  }
  if (state.objectMode) {
    return 1;
  }
  if (Number.isNaN(n)) {
    if (state.flowing && state.length) {
      return state.buffer.first().length;
    }
    return state.length;
  }
  if (n <= state.length) {
    return n;
  }
  return state.ended ? state.length : 0;
}
Readable.prototype.read = function(n) {
  debug("read", n);
  if (n === void 0) {
    n = NaN;
  } else if (!Number.isInteger(n)) {
    n = Number.parseInt(n, 10);
  }
  const state = this._readableState;
  const nOrig = n;
  if (n > state.highWaterMark) {
    state.highWaterMark = computeNewHighWaterMark(n);
  }
  if (n !== 0) {
    state.emittedReadable = false;
  }
  if (n === 0 && state.needReadable && ((state.highWaterMark !== 0 ? state.length >= state.highWaterMark : state.length > 0) || state.ended)) {
    debug("read: emitReadable", state.length, state.ended);
    if (state.length === 0 && state.ended) {
      endReadable(this);
    } else {
      emitReadable(this);
    }
    return null;
  }
  n = howMuchToRead(n, state);
  if (n === 0 && state.ended) {
    if (state.length === 0) {
      endReadable(this);
    }
    return null;
  }
  let doRead = state.needReadable;
  debug("need readable", doRead);
  if (state.length === 0 || state.length - n < state.highWaterMark) {
    doRead = true;
    debug("length less than watermark", doRead);
  }
  if (state.ended || state.reading || state.destroyed || state.errored || !state.constructed) {
    doRead = false;
    debug("reading, ended or constructing", doRead);
  } else if (doRead) {
    debug("do read");
    state.reading = true;
    state.sync = true;
    if (state.length === 0) {
      state.needReadable = true;
    }
    this._read(state.highWaterMark);
    state.sync = false;
    if (!state.reading) {
      n = howMuchToRead(nOrig, state);
    }
  }
  let ret;
  if (n > 0) {
    ret = fromList(n, state);
  } else {
    ret = null;
  }
  if (ret === null) {
    state.needReadable = state.length <= state.highWaterMark;
    n = 0;
  } else {
    state.length -= n;
    if (state.multiAwaitDrain) {
      state.awaitDrainWriters.clear();
    } else {
      state.awaitDrainWriters = null;
    }
  }
  if (state.length === 0) {
    if (!state.ended) {
      state.needReadable = true;
    }
    if (nOrig !== n && state.ended) {
      endReadable(this);
    }
  }
  if (ret !== null) {
    state.dataEmitted = true;
    this.emit("data", ret);
  }
  return ret;
};
function onEofChunk(stream, state) {
  debug("onEofChunk");
  if (state.ended)
    return;
  if (state.decoder) {
    const chunk = state.decoder.end();
    if (chunk && chunk.length) {
      state.buffer.push(chunk);
      state.length += state.objectMode ? 1 : chunk.length;
    }
  }
  state.ended = true;
  if (state.sync) {
    emitReadable(stream);
  } else {
    state.needReadable = false;
    state.emittedReadable = true;
    emitReadable_(stream);
  }
}
function emitReadable(stream) {
  const state = stream._readableState;
  debug("emitReadable", state.needReadable, state.emittedReadable);
  state.needReadable = false;
  if (!state.emittedReadable) {
    debug("emitReadable", state.flowing);
    state.emittedReadable = true;
    nextTick2(emitReadable_, stream);
  }
}
function emitReadable_(stream) {
  const state = stream._readableState;
  debug("emitReadable_", state.destroyed, state.length, state.ended);
  if (!state.destroyed && !state.errored && (state.length || state.ended)) {
    stream.emit("readable");
    state.emittedReadable = false;
  }
  state.needReadable = !state.flowing && !state.ended && state.length <= state.highWaterMark;
  flow(stream);
}
function maybeReadMore(stream, state) {
  if (!state.readingMore && state.constructed) {
    state.readingMore = true;
    nextTick2(maybeReadMore_, stream, state);
  }
}
function maybeReadMore_(stream, state) {
  while (!state.reading && !state.ended && (state.length < state.highWaterMark || state.flowing && state.length === 0)) {
    const len = state.length;
    debug("maybeReadMore read 0");
    stream.read(0);
    if (len === state.length) {
      break;
    }
  }
  state.readingMore = false;
}
Readable.prototype._read = function(n) {
  throw new ERR_METHOD_NOT_IMPLEMENTED("_read()");
};
Readable.prototype.pipe = function(dest, pipeOpts) {
  const src = this;
  const state = this._readableState;
  if (state.pipes.length === 1) {
    if (!state.multiAwaitDrain) {
      state.multiAwaitDrain = true;
      state.awaitDrainWriters = new Set(state.awaitDrainWriters ? [state.awaitDrainWriters] : []);
    }
  }
  state.pipes.push(dest);
  debug("pipe count=%d opts=%j", state.pipes.length, pipeOpts);
  const doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== stdio.stdout && dest !== stdio.stderr;
  const endFn = doEnd ? onend : unpipe;
  if (state.endEmitted) {
    nextTick2(endFn);
  } else {
    src.once("end", endFn);
  }
  dest.on("unpipe", onunpipe);
  function onunpipe(readable, unpipeInfo) {
    debug("onunpipe");
    if (readable === src) {
      if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
        unpipeInfo.hasUnpiped = true;
        cleanup();
      }
    }
  }
  function onend() {
    debug("onend");
    dest.end();
  }
  let ondrain;
  let cleanedUp = false;
  function cleanup() {
    debug("cleanup");
    dest.removeListener("close", onclose);
    dest.removeListener("finish", onfinish);
    if (ondrain) {
      dest.removeListener("drain", ondrain);
    }
    dest.removeListener("error", onerror);
    dest.removeListener("unpipe", onunpipe);
    src.removeListener("end", onend);
    src.removeListener("end", unpipe);
    src.removeListener("data", ondata);
    cleanedUp = true;
    if (ondrain && state.awaitDrainWriters && (!dest._writableState || dest._writableState.needDrain)) {
      ondrain();
    }
  }
  function pause() {
    if (!cleanedUp) {
      if (state.pipes.length === 1 && state.pipes[0] === dest) {
        debug("false write response, pause", 0);
        state.awaitDrainWriters = dest;
        state.multiAwaitDrain = false;
      } else if (state.pipes.length > 1 && state.pipes.includes(dest)) {
        debug("false write response, pause", state.awaitDrainWriters.size);
        state.awaitDrainWriters.add(dest);
      }
      src.pause();
    }
    if (!ondrain) {
      ondrain = pipeOnDrain(src, dest);
      dest.on("drain", ondrain);
    }
  }
  src.on("data", ondata);
  function ondata(chunk) {
    debug("ondata");
    const ret = dest.write(chunk);
    debug("dest.write", ret);
    if (ret === false) {
      pause();
    }
  }
  function onerror(er) {
    debug("onerror", er);
    unpipe();
    dest.removeListener("error", onerror);
    if (events_default.listenerCount(dest, "error") === 0) {
      const s = dest._writableState || dest._readableState;
      if (s && !s.errorEmitted) {
        errorOrDestroy2(dest, er);
      } else {
        dest.emit("error", er);
      }
    }
  }
  prependListener2(dest, "error", onerror);
  function onclose() {
    dest.removeListener("finish", onfinish);
    unpipe();
  }
  dest.once("close", onclose);
  function onfinish() {
    debug("onfinish");
    dest.removeListener("close", onclose);
    unpipe();
  }
  dest.once("finish", onfinish);
  function unpipe() {
    debug("unpipe");
    src.unpipe(dest);
  }
  dest.emit("pipe", src);
  if (dest.writableNeedDrain === true) {
    if (state.flowing) {
      pause();
    }
  } else if (!state.flowing) {
    debug("pipe resume");
    src.resume();
  }
  return dest;
};
function pipeOnDrain(src, dest) {
  return function pipeOnDrainFunctionResult() {
    const state = src._readableState;
    if (state.awaitDrainWriters === dest) {
      debug("pipeOnDrain", 1);
      state.awaitDrainWriters = null;
    } else if (state.multiAwaitDrain) {
      debug("pipeOnDrain", state.awaitDrainWriters.size);
      state.awaitDrainWriters.delete(dest);
    }
    if ((!state.awaitDrainWriters || state.awaitDrainWriters.size === 0) && events_default.listenerCount(src, "data")) {
      state.flowing = true;
      flow(src);
    }
  };
}
Readable.prototype.unpipe = function(dest) {
  const state = this._readableState;
  const unpipeInfo = { hasUnpiped: false };
  if (state.pipes.length === 0) {
    return this;
  }
  if (!dest) {
    const dests = state.pipes;
    state.pipes = [];
    this.pause();
    for (let i = 0; i < dests.length; i++) {
      dests[i].emit("unpipe", this, { hasUnpiped: false });
    }
    return this;
  }
  const index = state.pipes.indexOf(dest);
  if (index === -1) {
    return this;
  }
  state.pipes.splice(index, 1);
  if (state.pipes.length === 0) {
    this.pause();
  }
  dest.emit("unpipe", this, unpipeInfo);
  return this;
};
Readable.prototype.on = function(ev, fn) {
  const res = Stream.prototype.on.call(this, ev, fn);
  const state = this._readableState;
  if (ev === "data") {
    state.readableListening = this.listenerCount("readable") > 0;
    if (state.flowing !== false) {
      this.resume();
    }
  } else if (ev === "readable") {
    if (!state.endEmitted && !state.readableListening) {
      state.readableListening = state.needReadable = true;
      state.flowing = false;
      state.emittedReadable = false;
      debug("on readable", state.length, state.reading);
      if (state.length) {
        emitReadable(this);
      } else if (!state.reading) {
        nextTick2(nReadingNextTick, this);
      }
    }
  }
  return res;
};
Readable.prototype.addListener = Readable.prototype.on;
Readable.prototype.removeListener = function(ev, fn) {
  const res = Stream.prototype.removeListener.call(this, ev, fn);
  if (ev === "readable") {
    nextTick2(updateReadableListening, this);
  }
  return res;
};
Readable.prototype.off = Readable.prototype.removeListener;
Readable.prototype.removeAllListeners = function(ev) {
  const res = Stream.prototype.removeAllListeners.apply(this, arguments);
  if (ev === "readable" || ev === void 0) {
    nextTick2(updateReadableListening, this);
  }
  return res;
};
function updateReadableListening(self2) {
  const state = self2._readableState;
  state.readableListening = self2.listenerCount("readable") > 0;
  if (state.resumeScheduled && state[kPaused] === false) {
    state.flowing = true;
  } else if (self2.listenerCount("data") > 0) {
    self2.resume();
  } else if (!state.readableListening) {
    state.flowing = null;
  }
}
function nReadingNextTick(self2) {
  debug("readable nexttick read 0");
  self2.read(0);
}
Readable.prototype.resume = function() {
  const state = this._readableState;
  if (!state.flowing) {
    debug("resume");
    state.flowing = !state.readableListening;
    resume(this, state);
  }
  state[kPaused] = false;
  return this;
};
function resume(stream, state) {
  if (!state.resumeScheduled) {
    state.resumeScheduled = true;
    nextTick2(resume_, stream, state);
  }
}
function resume_(stream, state) {
  debug("resume", state.reading);
  if (!state.reading) {
    stream.read(0);
  }
  state.resumeScheduled = false;
  stream.emit("resume");
  flow(stream);
  if (state.flowing && !state.reading) {
    stream.read(0);
  }
}
Readable.prototype.pause = function() {
  debug("call pause flowing=%j", this._readableState.flowing);
  if (this._readableState.flowing !== false) {
    debug("pause");
    this._readableState.flowing = false;
    this.emit("pause");
  }
  this._readableState[kPaused] = true;
  return this;
};
function flow(stream) {
  const state = stream._readableState;
  debug("flow", state.flowing);
  while (state.flowing && stream.read() !== null)
    ;
}
Readable.prototype.wrap = function(stream) {
  let paused = false;
  stream.on("data", (chunk) => {
    if (!this.push(chunk) && stream.pause) {
      paused = true;
      stream.pause();
    }
  });
  stream.on("end", () => {
    this.push(null);
  });
  stream.on("error", (err) => {
    errorOrDestroy2(this, err);
  });
  stream.on("close", () => {
    this.destroy();
  });
  stream.on("destroy", () => {
    this.destroy();
  });
  this._read = () => {
    if (paused && stream.resume) {
      paused = false;
      stream.resume();
    }
  };
  const streamKeys = Object.keys(stream);
  for (let j2 = 1; j2 < streamKeys.length; j2++) {
    const i = streamKeys[j2];
    if (this[i] === void 0 && typeof stream[i] === "function") {
      this[i] = stream[i].bind(stream);
    }
  }
  return this;
};
Readable.prototype[Symbol.asyncIterator] = function() {
  return streamToAsyncIterator(this);
};
Readable.prototype.iterator = function(options) {
  if (options !== void 0) {
    validateObject(options, "options");
  }
  return streamToAsyncIterator(this, options);
};
function streamToAsyncIterator(stream, options) {
  if (typeof stream.read !== "function") {
    stream = Readable.wrap(stream, { objectMode: true });
  }
  const iter = createAsyncIterator(stream, options);
  iter.stream = stream;
  return iter;
}
async function* createAsyncIterator(stream, options) {
  let callback = nop2;
  const opts = {
    destroyOnReturn: true,
    destroyOnError: true,
    ...options
  };
  function next(resolve7) {
    if (this === stream) {
      callback();
      callback = nop2;
    } else {
      callback = resolve7;
    }
  }
  const state = stream._readableState;
  let error3 = state.errored;
  let errorEmitted = state.errorEmitted;
  let endEmitted = state.endEmitted;
  let closeEmitted = state.closeEmitted;
  stream.on("readable", next).on("error", function(err) {
    error3 = err;
    errorEmitted = true;
    next.call(this);
  }).on("end", function() {
    endEmitted = true;
    next.call(this);
  }).on("close", function() {
    closeEmitted = true;
    next.call(this);
  });
  let errorThrown = false;
  try {
    while (true) {
      const chunk = stream.destroyed ? null : stream.read();
      if (chunk !== null) {
        yield chunk;
      } else if (errorEmitted) {
        throw error3;
      } else if (endEmitted) {
        break;
      } else if (closeEmitted) {
        break;
      } else {
        await new Promise(next);
      }
    }
  } catch (err) {
    if (opts.destroyOnError) {
      destroy_default.destroyer(stream, err);
    }
    errorThrown = true;
    throw err;
  } finally {
    if (!errorThrown && opts.destroyOnReturn) {
      if (state.autoDestroy || !endEmitted) {
        destroy_default.destroyer(stream, null);
      }
    }
  }
}
Object.defineProperties(Readable.prototype, {
  readable: {
    get() {
      const r = this._readableState;
      return !!r && r.readable !== false && !r.destroyed && !r.errorEmitted && !r.endEmitted;
    },
    set(val) {
      if (this._readableState) {
        this._readableState.readable = !!val;
      }
    }
  },
  readableDidRead: {
    enumerable: false,
    get: function() {
      return this._readableState.dataEmitted;
    }
  },
  readableAborted: {
    enumerable: false,
    get: function() {
      return !!(this._readableState.destroyed || this._readableState.errored) && !this._readableState.endEmitted;
    }
  },
  readableHighWaterMark: {
    enumerable: false,
    get: function() {
      return this._readableState.highWaterMark;
    }
  },
  readableBuffer: {
    enumerable: false,
    get: function() {
      return this._readableState && this._readableState.buffer;
    }
  },
  readableFlowing: {
    enumerable: false,
    get: function() {
      return this._readableState.flowing;
    },
    set: function(state) {
      if (this._readableState) {
        this._readableState.flowing = state;
      }
    }
  },
  readableLength: {
    enumerable: false,
    get() {
      return this._readableState.length;
    }
  },
  readableObjectMode: {
    enumerable: false,
    get() {
      return this._readableState ? this._readableState.objectMode : false;
    }
  },
  readableEncoding: {
    enumerable: false,
    get() {
      return this._readableState ? this._readableState.encoding : null;
    }
  },
  destroyed: {
    enumerable: false,
    get() {
      if (this._readableState === void 0) {
        return false;
      }
      return this._readableState.destroyed;
    },
    set(value) {
      if (!this._readableState) {
        return;
      }
      this._readableState.destroyed = value;
    }
  },
  readableEnded: {
    enumerable: false,
    get() {
      return this._readableState ? this._readableState.endEmitted : false;
    }
  }
});
Object.defineProperties(ReadableState.prototype, {
  pipesCount: {
    get() {
      return this.pipes.length;
    }
  },
  paused: {
    get() {
      return this[kPaused] !== false;
    },
    set(value) {
      this[kPaused] = !!value;
    }
  }
});
function fromList(n, state) {
  if (state.length === 0) {
    return null;
  }
  let ret;
  if (state.objectMode) {
    ret = state.buffer.shift();
  } else if (!n || n >= state.length) {
    if (state.decoder) {
      ret = state.buffer.join("");
    } else if (state.buffer.length === 1) {
      ret = state.buffer.first();
    } else {
      ret = state.buffer.concat(state.length);
    }
    state.buffer.clear();
  } else {
    ret = state.buffer.consume(n, state.decoder);
  }
  return ret;
}
function endReadable(stream) {
  const state = stream._readableState;
  debug("endReadable", state.endEmitted);
  if (!state.endEmitted) {
    state.ended = true;
    nextTick2(endReadableNT, state, stream);
  }
}
function endReadableNT(state, stream) {
  debug("endReadableNT", state.endEmitted, state.length);
  if (!state.errorEmitted && !state.closeEmitted && !state.endEmitted && state.length === 0) {
    state.endEmitted = true;
    stream.emit("end");
    if (stream.writable && stream.allowHalfOpen === false) {
      nextTick2(endWritableNT, stream);
    } else if (state.autoDestroy) {
      const wState = stream._writableState;
      const autoDestroy = !wState || wState.autoDestroy && (wState.finished || wState.writable === false);
      if (autoDestroy) {
        stream.destroy();
      }
    }
  }
}
function endWritableNT(stream) {
  const writable = stream.writable && !stream.writableEnded && !stream.destroyed;
  if (writable) {
    stream.end();
  }
}
function readableFrom(iterable, opts) {
  return from_default(Readable, iterable, opts);
}
function wrap(src, options) {
  return new Readable({
    objectMode: src.readableObjectMode ?? src.objectMode ?? true,
    ...options,
    destroy(err, callback) {
      destroy_default.destroyer(src, err);
      callback(err);
    }
  }).wrap(src);
}
Readable._fromList = fromList;
Readable.ReadableState = ReadableState;
Readable.from = readableFrom;
Readable.wrap = wrap;
var readable_default = Readable;

// deno:https://deno.land/std@0.147.0/node/internal/streams/writable.mjs
var { errorOrDestroy: errorOrDestroy3 } = destroy_default;
function isDuplexStream(maybe_duplex) {
  const isReadable3 = readable_default.prototype.isPrototypeOf(maybe_duplex);
  let prototype = maybe_duplex;
  let isDuplex = false;
  while (prototype?.constructor && prototype.constructor.name !== "Object") {
    if (prototype.constructor.name === "Duplex") {
      isDuplex = true;
      break;
    }
    prototype = Object.getPrototypeOf(prototype);
  }
  return isReadable3 && isDuplex;
}
Object.setPrototypeOf(Writable.prototype, Stream.prototype);
Object.setPrototypeOf(Writable, Stream);
function nop3() {
}
var kOnFinished = Symbol("kOnFinished");
function WritableState(options, stream, isDuplex) {
  if (typeof isDuplex !== "boolean") {
    isDuplex = isDuplexStream(stream);
  }
  this.objectMode = !!(options && options.objectMode);
  if (isDuplex) {
    this.objectMode = this.objectMode || !!(options && options.writableObjectMode);
  }
  this.highWaterMark = options ? getHighWaterMark(this, options, "writableHighWaterMark", isDuplex) : getDefaultHighWaterMark(false);
  this.finalCalled = false;
  this.needDrain = false;
  this.ending = false;
  this.ended = false;
  this.finished = false;
  this.destroyed = false;
  const noDecode = !!(options && options.decodeStrings === false);
  this.decodeStrings = !noDecode;
  this.defaultEncoding = options && options.defaultEncoding || "utf8";
  this.length = 0;
  this.writing = false;
  this.corked = 0;
  this.sync = true;
  this.bufferProcessing = false;
  this.onwrite = onwrite.bind(void 0, stream);
  this.writecb = null;
  this.writelen = 0;
  this.afterWriteTickInfo = null;
  resetBuffer(this);
  this.pendingcb = 0;
  this.constructed = true;
  this.prefinished = false;
  this.errorEmitted = false;
  this.emitClose = !options || options.emitClose !== false;
  this.autoDestroy = !options || options.autoDestroy !== false;
  this.errored = null;
  this.closed = false;
  this.closeEmitted = false;
  this[kOnFinished] = [];
}
function resetBuffer(state) {
  state.buffered = [];
  state.bufferedIndex = 0;
  state.allBuffers = true;
  state.allNoop = true;
}
WritableState.prototype.getBuffer = function getBuffer() {
  return this.buffered.slice(this.bufferedIndex);
};
Object.defineProperty(WritableState.prototype, "bufferedRequestCount", {
  get() {
    return this.buffered.length - this.bufferedIndex;
  }
});
function Writable(options) {
  const isDuplex = isDuplexStream(this);
  if (!isDuplex && !Function.prototype[Symbol.hasInstance].call(Writable, this)) {
    return new Writable(options);
  }
  this._writableState = new WritableState(options, this, isDuplex);
  if (options) {
    if (typeof options.write === "function") {
      this._write = options.write;
    }
    if (typeof options.writev === "function") {
      this._writev = options.writev;
    }
    if (typeof options.destroy === "function") {
      this._destroy = options.destroy;
    }
    if (typeof options.final === "function") {
      this._final = options.final;
    }
    if (typeof options.construct === "function") {
      this._construct = options.construct;
    }
    if (options.signal) {
      addAbortSignalNoValidate(options.signal, this);
    }
  }
  Stream.call(this, options);
  destroy_default.construct(this, () => {
    const state = this._writableState;
    if (!state.writing) {
      clearBuffer(this, state);
    }
    finishMaybe(this, state);
  });
}
Object.defineProperty(Writable, Symbol.hasInstance, {
  value: function(object) {
    if (Function.prototype[Symbol.hasInstance].call(this, object))
      return true;
    if (this !== Writable)
      return false;
    return object && object._writableState instanceof WritableState;
  }
});
Writable.prototype.pipe = function() {
  errorOrDestroy3(this, new ERR_STREAM_CANNOT_PIPE());
};
function _write(stream, chunk, encoding, cb) {
  const state = stream._writableState;
  if (typeof encoding === "function") {
    cb = encoding;
    encoding = state.defaultEncoding;
  } else {
    if (!encoding) {
      encoding = state.defaultEncoding;
    } else if (encoding !== "buffer" && !Buffer3.isEncoding(encoding)) {
      throw new ERR_UNKNOWN_ENCODING(encoding);
    }
    if (typeof cb !== "function") {
      cb = nop3;
    }
  }
  if (chunk === null) {
    throw new ERR_STREAM_NULL_VALUES();
  } else if (!state.objectMode) {
    if (typeof chunk === "string") {
      if (state.decodeStrings !== false) {
        chunk = Buffer3.from(chunk, encoding);
        encoding = "buffer";
      }
    } else if (chunk instanceof Buffer3) {
      encoding = "buffer";
    } else if (isUint8Array(chunk)) {
      chunk = _uint8ArrayToBuffer(chunk);
      encoding = "buffer";
    } else {
      throw new ERR_INVALID_ARG_TYPE("chunk", ["string", "Buffer", "Uint8Array"], chunk);
    }
  }
  let err;
  if (state.ending) {
    err = new ERR_STREAM_WRITE_AFTER_END();
  } else if (state.destroyed) {
    err = new ERR_STREAM_DESTROYED("write");
  }
  if (err) {
    nextTick3(cb, err);
    errorOrDestroy3(stream, err, true);
    return err;
  }
  state.pendingcb++;
  return writeOrBuffer(stream, state, chunk, encoding, cb);
}
Writable.prototype.write = function(chunk, encoding, cb) {
  return _write(this, chunk, encoding, cb) === true;
};
Writable.prototype.cork = function() {
  this._writableState.corked++;
};
Writable.prototype.uncork = function() {
  const state = this._writableState;
  if (state.corked) {
    state.corked--;
    if (!state.writing) {
      clearBuffer(this, state);
    }
  }
};
Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
  if (typeof encoding === "string") {
    encoding = encoding.toLowerCase();
  }
  if (!Buffer3.isEncoding(encoding)) {
    throw new ERR_UNKNOWN_ENCODING(encoding);
  }
  this._writableState.defaultEncoding = encoding;
  return this;
};
function writeOrBuffer(stream, state, chunk, encoding, callback) {
  const len = state.objectMode ? 1 : chunk.length;
  state.length += len;
  const ret = state.length < state.highWaterMark;
  if (!ret) {
    state.needDrain = true;
  }
  if (state.writing || state.corked || state.errored || !state.constructed) {
    state.buffered.push({ chunk, encoding, callback });
    if (state.allBuffers && encoding !== "buffer") {
      state.allBuffers = false;
    }
    if (state.allNoop && callback !== nop3) {
      state.allNoop = false;
    }
  } else {
    state.writelen = len;
    state.writecb = callback;
    state.writing = true;
    state.sync = true;
    stream._write(chunk, encoding, state.onwrite);
    state.sync = false;
  }
  return ret && !state.errored && !state.destroyed;
}
function doWrite(stream, state, writev, len, chunk, encoding, cb) {
  state.writelen = len;
  state.writecb = cb;
  state.writing = true;
  state.sync = true;
  if (state.destroyed) {
    state.onwrite(new ERR_STREAM_DESTROYED("write"));
  } else if (writev) {
    stream._writev(chunk, state.onwrite);
  } else {
    stream._write(chunk, encoding, state.onwrite);
  }
  state.sync = false;
}
function onwriteError(stream, state, er, cb) {
  --state.pendingcb;
  cb(er);
  errorBuffer(state);
  errorOrDestroy3(stream, er);
}
function onwrite(stream, er) {
  const state = stream._writableState;
  const sync = state.sync;
  const cb = state.writecb;
  if (typeof cb !== "function") {
    errorOrDestroy3(stream, new ERR_MULTIPLE_CALLBACK());
    return;
  }
  state.writing = false;
  state.writecb = null;
  state.length -= state.writelen;
  state.writelen = 0;
  if (er) {
    er.stack;
    if (!state.errored) {
      state.errored = er;
    }
    if (stream._readableState && !stream._readableState.errored) {
      stream._readableState.errored = er;
    }
    if (sync) {
      nextTick3(onwriteError, stream, state, er, cb);
    } else {
      onwriteError(stream, state, er, cb);
    }
  } else {
    if (state.buffered.length > state.bufferedIndex) {
      clearBuffer(stream, state);
    }
    if (sync) {
      if (state.afterWriteTickInfo !== null && state.afterWriteTickInfo.cb === cb) {
        state.afterWriteTickInfo.count++;
      } else {
        state.afterWriteTickInfo = { count: 1, cb, stream, state };
        nextTick3(afterWriteTick, state.afterWriteTickInfo);
      }
    } else {
      afterWrite(stream, state, 1, cb);
    }
  }
}
function afterWriteTick({ stream, state, count, cb }) {
  state.afterWriteTickInfo = null;
  return afterWrite(stream, state, count, cb);
}
function afterWrite(stream, state, count, cb) {
  const needDrain = !state.ending && !stream.destroyed && state.length === 0 && state.needDrain;
  if (needDrain) {
    state.needDrain = false;
    stream.emit("drain");
  }
  while (count-- > 0) {
    state.pendingcb--;
    cb();
  }
  if (state.destroyed) {
    errorBuffer(state);
  }
  finishMaybe(stream, state);
}
function errorBuffer(state) {
  if (state.writing) {
    return;
  }
  for (let n = state.bufferedIndex; n < state.buffered.length; ++n) {
    const { chunk, callback } = state.buffered[n];
    const len = state.objectMode ? 1 : chunk.length;
    state.length -= len;
    callback(new ERR_STREAM_DESTROYED("write"));
  }
  const onfinishCallbacks = state[kOnFinished].splice(0);
  for (let i = 0; i < onfinishCallbacks.length; i++) {
    onfinishCallbacks[i](new ERR_STREAM_DESTROYED("end"));
  }
  resetBuffer(state);
}
function clearBuffer(stream, state) {
  if (state.corked || state.bufferProcessing || state.destroyed || !state.constructed) {
    return;
  }
  const { buffered, bufferedIndex, objectMode } = state;
  const bufferedLength = buffered.length - bufferedIndex;
  if (!bufferedLength) {
    return;
  }
  let i = bufferedIndex;
  state.bufferProcessing = true;
  if (bufferedLength > 1 && stream._writev) {
    state.pendingcb -= bufferedLength - 1;
    const callback = state.allNoop ? nop3 : (err) => {
      for (let n = i; n < buffered.length; ++n) {
        buffered[n].callback(err);
      }
    };
    const chunks = state.allNoop && i === 0 ? buffered : buffered.slice(i);
    chunks.allBuffers = state.allBuffers;
    doWrite(stream, state, true, state.length, chunks, "", callback);
    resetBuffer(state);
  } else {
    do {
      const { chunk, encoding, callback } = buffered[i];
      buffered[i++] = null;
      const len = objectMode ? 1 : chunk.length;
      doWrite(stream, state, false, len, chunk, encoding, callback);
    } while (i < buffered.length && !state.writing);
    if (i === buffered.length) {
      resetBuffer(state);
    } else if (i > 256) {
      buffered.splice(0, i);
      state.bufferedIndex = 0;
    } else {
      state.bufferedIndex = i;
    }
  }
  state.bufferProcessing = false;
}
Writable.prototype._write = function(chunk, encoding, cb) {
  if (this._writev) {
    this._writev([{ chunk, encoding }], cb);
  } else {
    throw new ERR_METHOD_NOT_IMPLEMENTED("_write()");
  }
};
Writable.prototype._writev = null;
Writable.prototype.end = function(chunk, encoding, cb) {
  const state = this._writableState;
  if (typeof chunk === "function") {
    cb = chunk;
    chunk = null;
    encoding = null;
  } else if (typeof encoding === "function") {
    cb = encoding;
    encoding = null;
  }
  let err;
  if (chunk !== null && chunk !== void 0) {
    const ret = _write(this, chunk, encoding);
    if (ret instanceof Error) {
      err = ret;
    }
  }
  if (state.corked) {
    state.corked = 1;
    this.uncork();
  }
  if (err) {
  } else if (!state.errored && !state.ending) {
    state.ending = true;
    finishMaybe(this, state, true);
    state.ended = true;
  } else if (state.finished) {
    err = new ERR_STREAM_ALREADY_FINISHED("end");
  } else if (state.destroyed) {
    err = new ERR_STREAM_DESTROYED("end");
  }
  if (typeof cb === "function") {
    if (err || state.finished) {
      nextTick3(cb, err);
    } else {
      state[kOnFinished].push(cb);
    }
  }
  return this;
};
function needFinish(state) {
  return state.ending && state.constructed && state.length === 0 && !state.errored && state.buffered.length === 0 && !state.finished && !state.writing && !state.errorEmitted && !state.closeEmitted;
}
function callFinal(stream, state) {
  let called = false;
  function onFinish(err) {
    if (called) {
      errorOrDestroy3(stream, err ?? ERR_MULTIPLE_CALLBACK());
      return;
    }
    called = true;
    state.pendingcb--;
    if (err) {
      const onfinishCallbacks = state[kOnFinished].splice(0);
      for (let i = 0; i < onfinishCallbacks.length; i++) {
        onfinishCallbacks[i](err);
      }
      errorOrDestroy3(stream, err, state.sync);
    } else if (needFinish(state)) {
      state.prefinished = true;
      stream.emit("prefinish");
      state.pendingcb++;
      nextTick3(finish, stream, state);
    }
  }
  state.sync = true;
  state.pendingcb++;
  try {
    const result = stream._final(onFinish);
    if (result != null) {
      const then = result.then;
      if (typeof then === "function") {
        then.call(result, function() {
          nextTick3(onFinish, null);
        }, function(err) {
          nextTick3(onFinish, err);
        });
      }
    }
  } catch (err) {
    onFinish(stream, state, err);
  }
  state.sync = false;
}
function prefinish(stream, state) {
  if (!state.prefinished && !state.finalCalled) {
    if (typeof stream._final === "function" && !state.destroyed) {
      state.finalCalled = true;
      callFinal(stream, state);
    } else {
      state.prefinished = true;
      stream.emit("prefinish");
    }
  }
}
function finishMaybe(stream, state, sync) {
  if (needFinish(state)) {
    prefinish(stream, state);
    if (state.pendingcb === 0 && needFinish(state)) {
      state.pendingcb++;
      if (sync) {
        nextTick3(finish, stream, state);
      } else {
        finish(stream, state);
      }
    }
  }
}
function finish(stream, state) {
  state.pendingcb--;
  state.finished = true;
  const onfinishCallbacks = state[kOnFinished].splice(0);
  for (let i = 0; i < onfinishCallbacks.length; i++) {
    onfinishCallbacks[i]();
  }
  stream.emit("finish");
  if (state.autoDestroy) {
    const rState = stream._readableState;
    const autoDestroy = !rState || rState.autoDestroy && (rState.endEmitted || rState.readable === false);
    if (autoDestroy) {
      stream.destroy();
    }
  }
}
Object.defineProperties(Writable.prototype, {
  destroyed: {
    get() {
      return this._writableState ? this._writableState.destroyed : false;
    },
    set(value) {
      if (this._writableState) {
        this._writableState.destroyed = value;
      }
    }
  },
  writable: {
    get() {
      const w2 = this._writableState;
      return !!w2 && w2.writable !== false && !w2.destroyed && !w2.errored && !w2.ending && !w2.ended;
    },
    set(val) {
      if (this._writableState) {
        this._writableState.writable = !!val;
      }
    }
  },
  writableFinished: {
    get() {
      return this._writableState ? this._writableState.finished : false;
    }
  },
  writableObjectMode: {
    get() {
      return this._writableState ? this._writableState.objectMode : false;
    }
  },
  writableBuffer: {
    get() {
      return this._writableState && this._writableState.getBuffer();
    }
  },
  writableEnded: {
    get() {
      return this._writableState ? this._writableState.ending : false;
    }
  },
  writableNeedDrain: {
    get() {
      const wState = this._writableState;
      if (!wState)
        return false;
      return !wState.destroyed && !wState.ending && wState.needDrain;
    }
  },
  writableHighWaterMark: {
    get() {
      return this._writableState && this._writableState.highWaterMark;
    }
  },
  writableCorked: {
    get() {
      return this._writableState ? this._writableState.corked : 0;
    }
  },
  writableLength: {
    get() {
      return this._writableState && this._writableState.length;
    }
  }
});
var destroy3 = destroy_default.destroy;
Writable.prototype.destroy = function(err, cb) {
  const state = this._writableState;
  if (!state.destroyed && (state.bufferedIndex < state.buffered.length || state[kOnFinished].length)) {
    nextTick3(errorBuffer, state);
  }
  destroy3.call(this, err, cb);
  return this;
};
Writable.prototype._undestroy = destroy_default.undestroy;
Writable.prototype._destroy = function(err, cb) {
  cb(err);
};
Writable.prototype[events_default.captureRejectionSymbol] = function(err) {
  this.destroy(err);
};
Writable.WritableState = WritableState;
var writable_default = Writable;

// deno:https://deno.land/std@0.147.0/node/internal/streams/duplex.mjs
Object.setPrototypeOf(Duplex.prototype, readable_default.prototype);
Object.setPrototypeOf(Duplex, readable_default);
{
  for (const method of Object.keys(writable_default.prototype)) {
    if (!Duplex.prototype[method]) {
      Duplex.prototype[method] = writable_default.prototype[method];
    }
  }
}
function Duplex(options) {
  if (!(this instanceof Duplex)) {
    return new Duplex(options);
  }
  readable_default.call(this, options);
  writable_default.call(this, options);
  this.allowHalfOpen = true;
  if (options) {
    if (options.readable === false) {
      this.readable = false;
    }
    if (options.writable === false) {
      this.writable = false;
    }
    if (options.allowHalfOpen === false) {
      this.allowHalfOpen = false;
    }
  }
}
Object.defineProperties(Duplex.prototype, {
  writable: Object.getOwnPropertyDescriptor(writable_default.prototype, "writable"),
  writableHighWaterMark: Object.getOwnPropertyDescriptor(writable_default.prototype, "writableHighWaterMark"),
  writableObjectMode: Object.getOwnPropertyDescriptor(writable_default.prototype, "writableObjectMode"),
  writableBuffer: Object.getOwnPropertyDescriptor(writable_default.prototype, "writableBuffer"),
  writableLength: Object.getOwnPropertyDescriptor(writable_default.prototype, "writableLength"),
  writableFinished: Object.getOwnPropertyDescriptor(writable_default.prototype, "writableFinished"),
  writableCorked: Object.getOwnPropertyDescriptor(writable_default.prototype, "writableCorked"),
  writableEnded: Object.getOwnPropertyDescriptor(writable_default.prototype, "writableEnded"),
  writableNeedDrain: Object.getOwnPropertyDescriptor(writable_default.prototype, "writableNeedDrain"),
  destroyed: {
    get() {
      if (this._readableState === void 0 || this._writableState === void 0) {
        return false;
      }
      return this._readableState.destroyed && this._writableState.destroyed;
    },
    set(value) {
      if (this._readableState && this._writableState) {
        this._readableState.destroyed = value;
        this._writableState.destroyed = value;
      }
    }
  }
});
function isReadableStream(object) {
  return object instanceof ReadableStream;
}
function isWritableStream(object) {
  return object instanceof WritableStream;
}
Duplex.fromWeb = function(pair, options) {
  validateObject(pair, "pair");
  const {
    readable: readableStream,
    writable: writableStream
  } = pair;
  if (!isReadableStream(readableStream)) {
    throw new ERR_INVALID_ARG_TYPE("pair.readable", "ReadableStream", readableStream);
  }
  if (!isWritableStream(writableStream)) {
    throw new ERR_INVALID_ARG_TYPE("pair.writable", "WritableStream", writableStream);
  }
  validateObject(options, "options");
  const {
    allowHalfOpen = false,
    objectMode = false,
    encoding,
    decodeStrings = true,
    highWaterMark,
    signal
  } = options;
  validateBoolean(objectMode, "options.objectMode");
  if (encoding !== void 0 && !Buffer3.isEncoding(encoding)) {
    throw new ERR_INVALID_ARG_VALUE(encoding, "options.encoding");
  }
  const writer = writableStream.getWriter();
  const reader = readableStream.getReader();
  let writableClosed = false;
  let readableClosed = false;
  const duplex = new Duplex({
    allowHalfOpen,
    highWaterMark,
    objectMode,
    encoding,
    decodeStrings,
    signal,
    writev(chunks, callback) {
      function done(error3) {
        error3 = error3.filter((e) => e);
        try {
          callback(error3.length === 0 ? void 0 : error3);
        } catch (error4) {
          nextTick3(() => destroy(duplex, error4));
        }
      }
      writer.ready.then(() => Promise.All(chunks.map((data) => writer.write(data.chunk))).then(done, done), done);
    },
    write(chunk, encoding2, callback) {
      if (typeof chunk === "string" && decodeStrings && !objectMode) {
        chunk = Buffer3.from(chunk, encoding2);
        chunk = new Uint8Array(chunk.buffer, chunk.byteOffset, chunk.byteLength);
      }
      function done(error3) {
        try {
          callback(error3);
        } catch (error4) {
          destroy(duplex, error4);
        }
      }
      writer.ready.then(() => writer.write(chunk).then(done, done), done);
    },
    final(callback) {
      function done(error3) {
        try {
          callback(error3);
        } catch (error4) {
          nextTick3(() => destroy(duplex, error4));
        }
      }
      if (!writableClosed) {
        writer.close().then(done, done);
      }
    },
    read() {
      reader.read().then((chunk) => {
        if (chunk.done) {
          duplex.push(null);
        } else {
          duplex.push(chunk.value);
        }
      }, (error3) => destroy(duplex, error3));
    },
    destroy(error3, callback) {
      function done() {
        try {
          callback(error3);
        } catch (error4) {
          nextTick3(() => {
            throw error4;
          });
        }
      }
      async function closeWriter() {
        if (!writableClosed) {
          await writer.abort(error3);
        }
      }
      async function closeReader() {
        if (!readableClosed) {
          await reader.cancel(error3);
        }
      }
      if (!writableClosed || !readableClosed) {
        Promise.All([
          closeWriter(),
          closeReader()
        ]).then(done, done);
        return;
      }
      done();
    }
  });
  writer.closed.then(() => {
    writableClosed = true;
    if (!isWritableEnded(duplex)) {
      destroy(duplex, new ERR_STREAM_PREMATURE_CLOSE());
    }
  }, (error3) => {
    writableClosed = true;
    readableClosed = true;
    destroy(duplex, error3);
  });
  reader.closed.then(() => {
    readableClosed = true;
    if (!isReadableEnded2(duplex)) {
      duplex.push(null);
    }
  }, (error3) => {
    writableClosed = true;
    readableClosed = true;
    destroy(duplex, error3);
  });
  return duplex;
};
var Duplexify = class extends Duplex {
  constructor(options) {
    super(options);
    if (options?.readable === false) {
      this._readableState.readable = false;
      this._readableState.ended = true;
      this._readableState.endEmitted = true;
    }
    if (options?.writable === false) {
      this._writableState.writable = false;
      this._writableState.ending = true;
      this._writableState.ended = true;
      this._writableState.finished = true;
    }
  }
};
function duplexify(body, name) {
  if (isDuplexNodeStream(body)) {
    return body;
  }
  if (isReadableNodeStream(body)) {
    return _duplexify({ readable: body });
  }
  if (isWritableNodeStream(body)) {
    return _duplexify({ writable: body });
  }
  if (isNodeStream(body)) {
    return _duplexify({ writable: false, readable: false });
  }
  if (typeof body === "function") {
    const { value, write: write5, final: final2, destroy: destroy4 } = fromAsyncGen(body);
    if (isIterable(value)) {
      return from_default(Duplexify, value, {
        objectMode: true,
        write: write5,
        final: final2,
        destroy: destroy4
      });
    }
    const then2 = value?.then;
    if (typeof then2 === "function") {
      let d4;
      const promise = then2.call(value, (val) => {
        if (val != null) {
          throw new ERR_INVALID_RETURN_VALUE("nully", "body", val);
        }
      }, (err) => {
        destroyer(d4, err);
      });
      return d4 = new Duplexify({
        objectMode: true,
        readable: false,
        write: write5,
        final(cb) {
          final2(async () => {
            try {
              await promise;
              nextTick3(cb, null);
            } catch (err) {
              nextTick3(cb, err);
            }
          });
        },
        destroy: destroy4
      });
    }
    throw new ERR_INVALID_RETURN_VALUE("Iterable, AsyncIterable or AsyncFunction", name, value);
  }
  if (isBlob(body)) {
    return duplexify(body.arrayBuffer());
  }
  if (isIterable(body)) {
    return from_default(Duplexify, body, {
      objectMode: true,
      writable: false
    });
  }
  if (typeof body?.writable === "object" || typeof body?.readable === "object") {
    const readable = body?.readable ? isReadableNodeStream(body?.readable) ? body?.readable : duplexify(body.readable) : void 0;
    const writable = body?.writable ? isWritableNodeStream(body?.writable) ? body?.writable : duplexify(body.writable) : void 0;
    return _duplexify({ readable, writable });
  }
  const then = body?.then;
  if (typeof then === "function") {
    let d4;
    then.call(body, (val) => {
      if (val != null) {
        d4.push(val);
      }
      d4.push(null);
    }, (err) => {
      destroyer(d4, err);
    });
    return d4 = new Duplexify({
      objectMode: true,
      writable: false,
      read() {
      }
    });
  }
  throw new ERR_INVALID_ARG_TYPE(name, [
    "Blob",
    "ReadableStream",
    "WritableStream",
    "Stream",
    "Iterable",
    "AsyncIterable",
    "Function",
    "{ readable, writable } pair",
    "Promise"
  ], body);
}
function fromAsyncGen(fn) {
  let { promise, resolve: resolve7 } = createDeferredPromise();
  const ac = new AbortController();
  const signal = ac.signal;
  const value = fn(async function* () {
    while (true) {
      const _promise = promise;
      promise = null;
      const { chunk, done, cb } = await _promise;
      nextTick3(cb);
      if (done)
        return;
      if (signal.aborted)
        throw new AbortError();
      ({ promise, resolve: resolve7 } = createDeferredPromise());
      yield chunk;
    }
  }(), { signal });
  return {
    value,
    write(chunk, encoding, cb) {
      const _resolve = resolve7;
      resolve7 = null;
      _resolve({ chunk, done: false, cb });
    },
    final(cb) {
      const _resolve = resolve7;
      resolve7 = null;
      _resolve({ done: true, cb });
    },
    destroy(err, cb) {
      ac.abort();
      cb(err);
    }
  };
}
function _duplexify(pair) {
  const r = pair.readable && typeof pair.readable.read !== "function" ? readable_default.wrap(pair.readable) : pair.readable;
  const w2 = pair.writable;
  let readable = !!isReadable2(r);
  let writable = !!isWritable2(w2);
  let ondrain;
  let onfinish;
  let onreadable;
  let onclose;
  let d4;
  function onfinished(err) {
    const cb = onclose;
    onclose = null;
    if (cb) {
      cb(err);
    } else if (err) {
      d4.destroy(err);
    } else if (!readable && !writable) {
      d4.destroy();
    }
  }
  d4 = new Duplexify({
    readableObjectMode: !!r?.readableObjectMode,
    writableObjectMode: !!w2?.writableObjectMode,
    readable,
    writable
  });
  if (writable) {
    end_of_stream_default(w2, (err) => {
      writable = false;
      if (err) {
        destroyer(r, err);
      }
      onfinished(err);
    });
    d4._write = function(chunk, encoding, callback) {
      if (w2.write(chunk, encoding)) {
        callback();
      } else {
        ondrain = callback;
      }
    };
    d4._final = function(callback) {
      w2.end();
      onfinish = callback;
    };
    w2.on("drain", function() {
      if (ondrain) {
        const cb = ondrain;
        ondrain = null;
        cb();
      }
    });
    w2.on("finish", function() {
      if (onfinish) {
        const cb = onfinish;
        onfinish = null;
        cb();
      }
    });
  }
  if (readable) {
    end_of_stream_default(r, (err) => {
      readable = false;
      if (err) {
        destroyer(r, err);
      }
      onfinished(err);
    });
    r.on("readable", function() {
      if (onreadable) {
        const cb = onreadable;
        onreadable = null;
        cb();
      }
    });
    r.on("end", function() {
      d4.push(null);
    });
    d4._read = function() {
      while (true) {
        const buf = r.read();
        if (buf === null) {
          onreadable = d4._read;
          return;
        }
        if (!d4.push(buf)) {
          return;
        }
      }
    };
  }
  d4._destroy = function(err, callback) {
    if (!err && onclose !== null) {
      err = new AbortError();
    }
    onreadable = null;
    ondrain = null;
    onfinish = null;
    if (onclose === null) {
      callback(err);
    } else {
      onclose = callback;
      destroyer(w2, err);
      destroyer(r, err);
    }
  };
  return d4;
}
function duplexFrom(body) {
  return duplexify(body, "body");
}
Duplex.from = duplexFrom;
var duplex_default = Duplex;

// deno:https://deno.land/std@0.147.0/node/internal/streams/transform.mjs
Object.setPrototypeOf(Transform.prototype, duplex_default.prototype);
Object.setPrototypeOf(Transform, duplex_default);
var kCallback = Symbol("kCallback");
function Transform(options) {
  if (!(this instanceof Transform)) {
    return new Transform(options);
  }
  duplex_default.call(this, options);
  this._readableState.sync = false;
  this[kCallback] = null;
  if (options) {
    if (typeof options.transform === "function") {
      this._transform = options.transform;
    }
    if (typeof options.flush === "function") {
      this._flush = options.flush;
    }
  }
  this.on("prefinish", prefinish2);
}
function final(cb) {
  let called = false;
  if (typeof this._flush === "function" && !this.destroyed) {
    const result = this._flush((er, data) => {
      called = true;
      if (er) {
        if (cb) {
          cb(er);
        } else {
          this.destroy(er);
        }
        return;
      }
      if (data != null) {
        this.push(data);
      }
      this.push(null);
      if (cb) {
        cb();
      }
    });
    if (result !== void 0 && result !== null) {
      try {
        const then = result.then;
        if (typeof then === "function") {
          then.call(result, (data) => {
            if (called) {
              return;
            }
            if (data != null) {
              this.push(data);
            }
            this.push(null);
            if (cb) {
              nextTick3(cb);
            }
          }, (err) => {
            if (cb) {
              nextTick3(cb, err);
            } else {
              nextTick3(() => this.destroy(err));
            }
          });
        }
      } catch (err) {
        nextTick3(() => this.destroy(err));
      }
    }
  } else {
    this.push(null);
    if (cb) {
      cb();
    }
  }
}
function prefinish2() {
  if (this._final !== final) {
    final.call(this);
  }
}
Transform.prototype._final = final;
Transform.prototype._transform = function(chunk, encoding, callback) {
  throw new ERR_METHOD_NOT_IMPLEMENTED("_transform()");
};
Transform.prototype._write = function(chunk, encoding, callback) {
  const rState = this._readableState;
  const wState = this._writableState;
  const length = rState.length;
  let called = false;
  const result = this._transform(chunk, encoding, (err, val) => {
    called = true;
    if (err) {
      callback(err);
      return;
    }
    if (val != null) {
      this.push(val);
    }
    if (wState.ended || length === rState.length || rState.length < rState.highWaterMark || rState.length === 0) {
      callback();
    } else {
      this[kCallback] = callback;
    }
  });
  if (result !== void 0 && result != null) {
    try {
      const then = result.then;
      if (typeof then === "function") {
        then.call(result, (val) => {
          if (called) {
            return;
          }
          if (val != null) {
            this.push(val);
          }
          if (wState.ended || length === rState.length || rState.length < rState.highWaterMark || rState.length === 0) {
            nextTick3(callback);
          } else {
            this[kCallback] = callback;
          }
        }, (err) => {
          nextTick3(callback, err);
        });
      }
    } catch (err) {
      nextTick3(callback, err);
    }
  }
};
Transform.prototype._read = function() {
  if (this[kCallback]) {
    const callback = this[kCallback];
    this[kCallback] = null;
    callback();
  }
};
var transform_default = Transform;

// deno:https://deno.land/std@0.147.0/node/internal/streams/passthrough.mjs
Object.setPrototypeOf(PassThrough.prototype, transform_default.prototype);
Object.setPrototypeOf(PassThrough, transform_default);
function PassThrough(options) {
  if (!(this instanceof PassThrough)) {
    return new PassThrough(options);
  }
  transform_default.call(this, options);
}
PassThrough.prototype._transform = function(chunk, encoding, cb) {
  cb(null, chunk);
};
var passthrough_default = PassThrough;

// deno:https://deno.land/std@0.147.0/node/internal/streams/pipeline.mjs
function destroyer2(stream, reading, writing, callback) {
  callback = once(callback);
  let finished2 = false;
  stream.on("close", () => {
    finished2 = true;
  });
  end_of_stream_default(stream, { readable: reading, writable: writing }, (err) => {
    finished2 = !err;
    const rState = stream._readableState;
    if (err && err.code === "ERR_STREAM_PREMATURE_CLOSE" && reading && (rState && rState.ended && !rState.errored && !rState.errorEmitted)) {
      stream.once("end", callback).once("error", callback);
    } else {
      callback(err);
    }
  });
  return (err) => {
    if (finished2)
      return;
    finished2 = true;
    destroy_default.destroyer(stream, err);
    callback(err || new ERR_STREAM_DESTROYED("pipe"));
  };
}
function popCallback(streams) {
  validateCallback(streams[streams.length - 1]);
  return streams.pop();
}
function makeAsyncIterable(val) {
  if (isIterable(val)) {
    return val;
  } else if (isReadableNodeStream(val)) {
    return fromReadable(val);
  }
  throw new ERR_INVALID_ARG_TYPE("val", ["Readable", "Iterable", "AsyncIterable"], val);
}
async function* fromReadable(val) {
  yield* readable_default.prototype[Symbol.asyncIterator].call(val);
}
async function pump(iterable, writable, finish2) {
  let error3;
  let onresolve = null;
  const resume2 = (err) => {
    if (err) {
      error3 = err;
    }
    if (onresolve) {
      const callback = onresolve;
      onresolve = null;
      callback();
    }
  };
  const wait = () => new Promise((resolve7, reject) => {
    if (error3) {
      reject(error3);
    } else {
      onresolve = () => {
        if (error3) {
          reject(error3);
        } else {
          resolve7();
        }
      };
    }
  });
  writable.on("drain", resume2);
  const cleanup = end_of_stream_default(writable, { readable: false }, resume2);
  try {
    if (writable.writableNeedDrain) {
      await wait();
    }
    for await (const chunk of iterable) {
      if (!writable.write(chunk)) {
        await wait();
      }
    }
    writable.end();
    await wait();
    finish2();
  } catch (err) {
    finish2(error3 !== err ? aggregateTwoErrors(error3, err) : err);
  } finally {
    cleanup();
    writable.off("drain", resume2);
  }
}
function pipeline(...streams) {
  const callback = once(popCallback(streams));
  if (Array.isArray(streams[0]) && streams.length === 1) {
    streams = streams[0];
  }
  return pipelineImpl(streams, callback);
}
function pipelineImpl(streams, callback, opts) {
  if (streams.length < 2) {
    throw new ERR_MISSING_ARGS("streams");
  }
  const ac = new AbortController();
  const signal = ac.signal;
  const outerSignal = opts?.signal;
  validateAbortSignal(outerSignal, "options.signal");
  function abort() {
    finishImpl(new AbortError());
  }
  outerSignal?.addEventListener("abort", abort);
  let error3;
  let value;
  const destroys = [];
  let finishCount = 0;
  function finish2(err) {
    finishImpl(err, --finishCount === 0);
  }
  function finishImpl(err, final2) {
    if (err && (!error3 || error3.code === "ERR_STREAM_PREMATURE_CLOSE")) {
      error3 = err;
    }
    if (!error3 && !final2) {
      return;
    }
    while (destroys.length) {
      destroys.shift()(error3);
    }
    outerSignal?.removeEventListener("abort", abort);
    ac.abort();
    if (final2) {
      callback(error3, value);
    }
  }
  let ret;
  for (let i = 0; i < streams.length; i++) {
    const stream = streams[i];
    const reading = i < streams.length - 1;
    const writing = i > 0;
    if (isNodeStream(stream)) {
      finishCount++;
      destroys.push(destroyer2(stream, reading, writing, finish2));
    }
    if (i === 0) {
      if (typeof stream === "function") {
        ret = stream({ signal });
        if (!isIterable(ret)) {
          throw new ERR_INVALID_RETURN_VALUE("Iterable, AsyncIterable or Stream", "source", ret);
        }
      } else if (isIterable(stream) || isReadableNodeStream(stream)) {
        ret = stream;
      } else {
        ret = duplex_default.from(stream);
      }
    } else if (typeof stream === "function") {
      ret = makeAsyncIterable(ret);
      ret = stream(ret, { signal });
      if (reading) {
        if (!isIterable(ret, true)) {
          throw new ERR_INVALID_RETURN_VALUE("AsyncIterable", `transform[${i - 1}]`, ret);
        }
      } else {
        const pt2 = new passthrough_default({
          objectMode: true
        });
        const then = ret?.then;
        if (typeof then === "function") {
          then.call(ret, (val) => {
            value = val;
            pt2.end(val);
          }, (err) => {
            pt2.destroy(err);
          });
        } else if (isIterable(ret, true)) {
          finishCount++;
          pump(ret, pt2, finish2);
        } else {
          throw new ERR_INVALID_RETURN_VALUE("AsyncIterable or Promise", "destination", ret);
        }
        ret = pt2;
        finishCount++;
        destroys.push(destroyer2(ret, false, true, finish2));
      }
    } else if (isNodeStream(stream)) {
      if (isReadableNodeStream(ret)) {
        ret.pipe(stream);
        if (stream === stdio.stdout || stream === stdio.stderr) {
          ret.on("end", () => stream.end());
        }
      } else {
        ret = makeAsyncIterable(ret);
        finishCount++;
        pump(ret, stream, finish2);
      }
      ret = stream;
    } else {
      ret = duplex_default.from(stream);
    }
  }
  if (signal?.aborted || outerSignal?.aborted) {
    nextTick3(abort);
  }
  return ret;
}

// deno:https://deno.land/std@0.147.0/node/internal/streams/compose.mjs
var ComposeDuplex = class extends duplex_default {
  constructor(options) {
    super(options);
    if (options?.readable === false) {
      this._readableState.readable = false;
      this._readableState.ended = true;
      this._readableState.endEmitted = true;
    }
    if (options?.writable === false) {
      this._writableState.writable = false;
      this._writableState.ending = true;
      this._writableState.ended = true;
      this._writableState.finished = true;
    }
  }
};
function compose(...streams) {
  if (streams.length === 0) {
    throw new ERR_MISSING_ARGS("streams");
  }
  if (streams.length === 1) {
    return duplex_default.from(streams[0]);
  }
  const orgStreams = [...streams];
  if (typeof streams[0] === "function") {
    streams[0] = duplex_default.from(streams[0]);
  }
  if (typeof streams[streams.length - 1] === "function") {
    const idx = streams.length - 1;
    streams[idx] = duplex_default.from(streams[idx]);
  }
  for (let n = 0; n < streams.length; ++n) {
    if (!isNodeStream(streams[n])) {
      continue;
    }
    if (n < streams.length - 1 && !isReadable2(streams[n])) {
      throw new ERR_INVALID_ARG_VALUE(`streams[${n}]`, orgStreams[n], "must be readable");
    }
    if (n > 0 && !isWritable2(streams[n])) {
      throw new ERR_INVALID_ARG_VALUE(`streams[${n}]`, orgStreams[n], "must be writable");
    }
  }
  let ondrain;
  let onfinish;
  let onreadable;
  let onclose;
  let d4;
  function onfinished(err) {
    const cb = onclose;
    onclose = null;
    if (cb) {
      cb(err);
    } else if (err) {
      d4.destroy(err);
    } else if (!readable && !writable) {
      d4.destroy();
    }
  }
  const head = streams[0];
  const tail = pipeline(streams, onfinished);
  const writable = !!isWritable2(head);
  const readable = !!isReadable2(tail);
  d4 = new ComposeDuplex({
    writableObjectMode: !!head?.writableObjectMode,
    readableObjectMode: !!tail?.writableObjectMode,
    writable,
    readable
  });
  if (writable) {
    d4._write = function(chunk, encoding, callback) {
      if (head.write(chunk, encoding)) {
        callback();
      } else {
        ondrain = callback;
      }
    };
    d4._final = function(callback) {
      head.end();
      onfinish = callback;
    };
    head.on("drain", function() {
      if (ondrain) {
        const cb = ondrain;
        ondrain = null;
        cb();
      }
    });
    tail.on("finish", function() {
      if (onfinish) {
        const cb = onfinish;
        onfinish = null;
        cb();
      }
    });
  }
  if (readable) {
    tail.on("readable", function() {
      if (onreadable) {
        const cb = onreadable;
        onreadable = null;
        cb();
      }
    });
    tail.on("end", function() {
      d4.push(null);
    });
    d4._read = function() {
      while (true) {
        const buf = tail.read();
        if (buf === null) {
          onreadable = d4._read;
          return;
        }
        if (!d4.push(buf)) {
          return;
        }
      }
    };
  }
  d4._destroy = function(err, callback) {
    if (!err && onclose !== null) {
      err = new AbortError();
    }
    onreadable = null;
    ondrain = null;
    onfinish = null;
    if (onclose === null) {
      callback(err);
    } else {
      onclose = callback;
      destroyer(tail, err);
    }
  };
  return d4;
}
var compose_default = compose;

// deno:https://deno.land/std@0.147.0/node/stream/promises.mjs
function pipeline2(...streams) {
  return new Promise((resolve7, reject) => {
    let signal;
    let end;
    const lastArg = streams[streams.length - 1];
    if (lastArg && typeof lastArg === "object" && !isNodeStream(lastArg) && !isIterable(lastArg)) {
      const options = streams.pop();
      signal = options.signal;
      end = options.end;
    }
    pipelineImpl(streams, (err, value) => {
      if (err) {
        reject(err);
      } else {
        resolve7(value);
      }
    }, { signal, end });
  });
}
function finished(stream, opts) {
  return new Promise((resolve7, reject) => {
    end_of_stream_default(stream, opts, (err) => {
      if (err) {
        reject(err);
      } else {
        resolve7();
      }
    });
  });
}
var promises_default = {
  finished,
  pipeline: pipeline2
};

// deno:https://deno.land/std@0.147.0/node/_stream.mjs
var { custom: customPromisify } = promisify;
Stream.isDisturbed = isDisturbed;
Stream.Readable = readable_default;
Stream.Writable = writable_default;
Stream.Duplex = duplex_default;
Stream.Transform = transform_default;
Stream.PassThrough = passthrough_default;
Stream.pipeline = pipeline;
Stream.addAbortSignal = addAbortSignal;
Stream.finished = end_of_stream_default;
Stream.destroy = destroyer;
Stream.compose = compose_default;
Object.defineProperty(Stream, "promises", {
  configurable: true,
  enumerable: true,
  get() {
    return promises_default;
  }
});
Object.defineProperty(pipeline, customPromisify, {
  enumerable: true,
  get() {
    return promises_default.pipeline;
  }
});
Object.defineProperty(end_of_stream_default, customPromisify, {
  enumerable: true,
  get() {
    return promises_default.finished;
  }
});
Stream.Stream = Stream;
Stream._isUint8Array = isUint8Array;
Stream._uint8ArrayToBuffer = _uint8ArrayToBuffer;
var stream_default = Stream;

// deno:https://deno.land/std@0.147.0/node/_process/streams.mjs
function createWritableStdioStream(writer, name) {
  const stream = new writable_default({
    write(buf, enc, cb) {
      if (!writer) {
        this.destroy(new Error(`Deno.${name} is not available in this environment`));
        return;
      }
      writer.writeSync(buf instanceof Uint8Array ? buf : Buffer3.from(buf, enc));
      cb();
    },
    destroy(err, cb) {
      cb(err);
      this._undestroy();
      if (!this._writableState.emitClose) {
        nextTick(() => this.emit("close"));
      }
    }
  });
  stream.fd = writer?.rid ?? -1;
  stream.destroySoon = stream.destroy;
  stream._isStdio = true;
  stream.once("close", () => writer?.close());
  Object.defineProperties(stream, {
    columns: {
      enumerable: true,
      configurable: true,
      get: () => Deno.isatty?.(writer?.rid) ? Deno.consoleSize?.(writer?.rid).columns : void 0
    },
    rows: {
      enumerable: true,
      configurable: true,
      get: () => Deno.isatty?.(writer?.rid) ? Deno.consoleSize?.(writer?.rid).rows : void 0
    },
    isTTY: {
      enumerable: true,
      configurable: true,
      get: () => Deno.isatty?.(writer?.rid)
    },
    getWindowSize: {
      enumerable: true,
      configurable: true,
      value: () => Deno.isatty?.(writer?.rid) ? Object.values(Deno.consoleSize?.(writer?.rid)) : void 0
    }
  });
  if (Deno.isatty?.(writer?.rid)) {
    stream.cursorTo = function(x, y4, callback) {
      return cursorTo(this, x, y4, callback);
    };
    stream.moveCursor = function(dx, dy, callback) {
      return moveCursor(this, dx, dy, callback);
    };
    stream.clearLine = function(dir, callback) {
      return clearLine(this, dir, callback);
    };
    stream.clearScreenDown = function(callback) {
      return clearScreenDown(this, callback);
    };
  }
  return stream;
}
var stderr = stdio.stderr = createWritableStdioStream(Deno.stderr, "stderr");
var stdout = stdio.stdout = createWritableStdioStream(Deno.stdout, "stdout");
var stdin = stdio.stdin = new readable_default({
  highWaterMark: 0,
  emitClose: false,
  read(size) {
    const p3 = Buffer3.alloc(size || 16 * 1024);
    if (!Deno.stdin) {
      this.destroy(new Error("Deno.stdin is not available in this environment"));
      return;
    }
    Deno.stdin.read(p3).then((length) => {
      this.push(length === null ? null : p3.slice(0, length));
    }, (error3) => {
      this.destroy(error3);
    });
  }
});
stdin.on("close", () => Deno.stdin?.close());
stdin.fd = Deno.stdin?.rid ?? -1;
Object.defineProperty(stdin, "isTTY", {
  enumerable: true,
  configurable: true,
  get() {
    return Deno.isatty?.(Deno.stdin.rid);
  }
});
stdin._isRawMode = false;
stdin.setRawMode = (enable) => {
  setRaw?.(Deno.stdin?.rid, enable);
  stdin._isRawMode = enable;
  return stdin;
};
Object.defineProperty(stdin, "isRaw", {
  enumerable: true,
  configurable: true,
  get() {
    return stdin._isRawMode;
  }
});

// deno:https://deno.land/std@0.147.0/node/internal_binding/async_wrap.ts
var async_wrap_exports = {};
__export(async_wrap_exports, {
  AsyncWrap: () => AsyncWrap,
  UidFields: () => UidFields,
  asyncIdFields: () => asyncIdFields,
  async_hook_fields: () => asyncHookFields,
  constants: () => constants,
  newAsyncId: () => newAsyncId,
  providerType: () => providerType,
  registerDestroyHook: () => registerDestroyHook
});
function registerDestroyHook(_target, _asyncId, _prop) {
}
var constants = /* @__PURE__ */ ((constants5) => {
  constants5[constants5["kInit"] = 0] = "kInit";
  constants5[constants5["kBefore"] = 1] = "kBefore";
  constants5[constants5["kAfter"] = 2] = "kAfter";
  constants5[constants5["kDestroy"] = 3] = "kDestroy";
  constants5[constants5["kPromiseResolve"] = 4] = "kPromiseResolve";
  constants5[constants5["kTotals"] = 5] = "kTotals";
  constants5[constants5["kCheck"] = 6] = "kCheck";
  constants5[constants5["kExecutionAsyncId"] = 7] = "kExecutionAsyncId";
  constants5[constants5["kTriggerAsyncId"] = 8] = "kTriggerAsyncId";
  constants5[constants5["kAsyncIdCounter"] = 9] = "kAsyncIdCounter";
  constants5[constants5["kDefaultTriggerAsyncId"] = 10] = "kDefaultTriggerAsyncId";
  constants5[constants5["kUsesExecutionAsyncResource"] = 11] = "kUsesExecutionAsyncResource";
  constants5[constants5["kStackLength"] = 12] = "kStackLength";
  return constants5;
})(constants || {});
var asyncHookFields = new Uint32Array(Object.keys(constants).length);
function newAsyncId() {
  return ++asyncIdFields[9 /* kAsyncIdCounter */];
}
var UidFields = /* @__PURE__ */ ((UidFields2) => {
  UidFields2[UidFields2["kExecutionAsyncId"] = 0] = "kExecutionAsyncId";
  UidFields2[UidFields2["kTriggerAsyncId"] = 1] = "kTriggerAsyncId";
  UidFields2[UidFields2["kAsyncIdCounter"] = 2] = "kAsyncIdCounter";
  UidFields2[UidFields2["kDefaultTriggerAsyncId"] = 3] = "kDefaultTriggerAsyncId";
  UidFields2[UidFields2["kUidFieldsCount"] = 4] = "kUidFieldsCount";
  return UidFields2;
})(UidFields || {});
var asyncIdFields = new Float64Array(Object.keys(UidFields).length);
asyncIdFields[2 /* kAsyncIdCounter */] = 1;
asyncIdFields[3 /* kDefaultTriggerAsyncId */] = -1;
var providerType = /* @__PURE__ */ ((providerType3) => {
  providerType3[providerType3["NONE"] = 0] = "NONE";
  providerType3[providerType3["DIRHANDLE"] = 1] = "DIRHANDLE";
  providerType3[providerType3["DNSCHANNEL"] = 2] = "DNSCHANNEL";
  providerType3[providerType3["ELDHISTOGRAM"] = 3] = "ELDHISTOGRAM";
  providerType3[providerType3["FILEHANDLE"] = 4] = "FILEHANDLE";
  providerType3[providerType3["FILEHANDLECLOSEREQ"] = 5] = "FILEHANDLECLOSEREQ";
  providerType3[providerType3["FIXEDSIZEBLOBCOPY"] = 6] = "FIXEDSIZEBLOBCOPY";
  providerType3[providerType3["FSEVENTWRAP"] = 7] = "FSEVENTWRAP";
  providerType3[providerType3["FSREQCALLBACK"] = 8] = "FSREQCALLBACK";
  providerType3[providerType3["FSREQPROMISE"] = 9] = "FSREQPROMISE";
  providerType3[providerType3["GETADDRINFOREQWRAP"] = 10] = "GETADDRINFOREQWRAP";
  providerType3[providerType3["GETNAMEINFOREQWRAP"] = 11] = "GETNAMEINFOREQWRAP";
  providerType3[providerType3["HEAPSNAPSHOT"] = 12] = "HEAPSNAPSHOT";
  providerType3[providerType3["HTTP2SESSION"] = 13] = "HTTP2SESSION";
  providerType3[providerType3["HTTP2STREAM"] = 14] = "HTTP2STREAM";
  providerType3[providerType3["HTTP2PING"] = 15] = "HTTP2PING";
  providerType3[providerType3["HTTP2SETTINGS"] = 16] = "HTTP2SETTINGS";
  providerType3[providerType3["HTTPINCOMINGMESSAGE"] = 17] = "HTTPINCOMINGMESSAGE";
  providerType3[providerType3["HTTPCLIENTREQUEST"] = 18] = "HTTPCLIENTREQUEST";
  providerType3[providerType3["JSSTREAM"] = 19] = "JSSTREAM";
  providerType3[providerType3["JSUDPWRAP"] = 20] = "JSUDPWRAP";
  providerType3[providerType3["MESSAGEPORT"] = 21] = "MESSAGEPORT";
  providerType3[providerType3["PIPECONNECTWRAP"] = 22] = "PIPECONNECTWRAP";
  providerType3[providerType3["PIPESERVERWRAP"] = 23] = "PIPESERVERWRAP";
  providerType3[providerType3["PIPEWRAP"] = 24] = "PIPEWRAP";
  providerType3[providerType3["PROCESSWRAP"] = 25] = "PROCESSWRAP";
  providerType3[providerType3["PROMISE"] = 26] = "PROMISE";
  providerType3[providerType3["QUERYWRAP"] = 27] = "QUERYWRAP";
  providerType3[providerType3["SHUTDOWNWRAP"] = 28] = "SHUTDOWNWRAP";
  providerType3[providerType3["SIGNALWRAP"] = 29] = "SIGNALWRAP";
  providerType3[providerType3["STATWATCHER"] = 30] = "STATWATCHER";
  providerType3[providerType3["STREAMPIPE"] = 31] = "STREAMPIPE";
  providerType3[providerType3["TCPCONNECTWRAP"] = 32] = "TCPCONNECTWRAP";
  providerType3[providerType3["TCPSERVERWRAP"] = 33] = "TCPSERVERWRAP";
  providerType3[providerType3["TCPWRAP"] = 34] = "TCPWRAP";
  providerType3[providerType3["TTYWRAP"] = 35] = "TTYWRAP";
  providerType3[providerType3["UDPSENDWRAP"] = 36] = "UDPSENDWRAP";
  providerType3[providerType3["UDPWRAP"] = 37] = "UDPWRAP";
  providerType3[providerType3["SIGINTWATCHDOG"] = 38] = "SIGINTWATCHDOG";
  providerType3[providerType3["WORKER"] = 39] = "WORKER";
  providerType3[providerType3["WORKERHEAPSNAPSHOT"] = 40] = "WORKERHEAPSNAPSHOT";
  providerType3[providerType3["WRITEWRAP"] = 41] = "WRITEWRAP";
  providerType3[providerType3["ZLIB"] = 42] = "ZLIB";
  return providerType3;
})(providerType || {});
var kInvalidAsyncId = -1;
var AsyncWrap = class {
  constructor(provider) {
    this.provider = 0 /* NONE */;
    this.asyncId = kInvalidAsyncId;
    this.provider = provider;
    this.getAsyncId();
  }
  getAsyncId() {
    this.asyncId = this.asyncId === kInvalidAsyncId ? newAsyncId() : this.asyncId;
    return this.asyncId;
  }
  getProviderType() {
    return this.provider;
  }
};

// deno:https://deno.land/std@0.147.0/node/internal_binding/config.ts
var config_exports = {};

// deno:https://deno.land/std@0.147.0/node/internal_binding/cares_wrap.ts
var cares_wrap_exports = {};
__export(cares_wrap_exports, {
  ChannelWrap: () => ChannelWrap,
  GetAddrInfoReqWrap: () => GetAddrInfoReqWrap,
  QueryReqWrap: () => QueryReqWrap,
  getaddrinfo: () => getaddrinfo,
  strerror: () => strerror
});

// deno:https://deno.land/std@0.147.0/node/internal/net.ts
var v4Seg = "(?:[0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])";
var v4Str = `(${v4Seg}[.]){3}${v4Seg}`;
var IPv4Reg = new RegExp(`^${v4Str}$`);
var v6Seg = "(?:[0-9a-fA-F]{1,4})";
var IPv6Reg = new RegExp(`^((?:${v6Seg}:){7}(?:${v6Seg}|:)|(?:${v6Seg}:){6}(?:${v4Str}|:${v6Seg}|:)|(?:${v6Seg}:){5}(?::${v4Str}|(:${v6Seg}){1,2}|:)|(?:${v6Seg}:){4}(?:(:${v6Seg}){0,1}:${v4Str}|(:${v6Seg}){1,3}|:)|(?:${v6Seg}:){3}(?:(:${v6Seg}){0,2}:${v4Str}|(:${v6Seg}){1,4}|:)|(?:${v6Seg}:){2}(?:(:${v6Seg}){0,3}:${v4Str}|(:${v6Seg}){1,5}|:)|(?:${v6Seg}:){1}(?:(:${v6Seg}){0,4}:${v4Str}|(:${v6Seg}){1,6}|:)|(?::((?::${v6Seg}){0,5}:${v4Str}|(?::${v6Seg}){1,7}|:)))(%[0-9a-zA-Z-.:]{1,})?$`);
function isIPv4(ip) {
  return RegExp.prototype.test.call(IPv4Reg, ip);
}
function isIPv6(ip) {
  return RegExp.prototype.test.call(IPv6Reg, ip);
}
function isIP(ip) {
  if (isIPv4(ip)) {
    return 4;
  }
  if (isIPv6(ip)) {
    return 6;
  }
  return 0;
}
var normalizedArgsSymbol = Symbol("normalizedArgs");

// deno:https://deno.land/std@0.147.0/node/internal_binding/ares.ts
var ARES_AI_CANONNAME = 1 << 0;
var ARES_AI_NUMERICHOST = 1 << 1;
var ARES_AI_PASSIVE = 1 << 2;
var ARES_AI_NUMERICSERV = 1 << 3;
var AI_V4MAPPED = 1 << 4;
var AI_ALL = 1 << 5;
var AI_ADDRCONFIG = 1 << 6;
var ARES_AI_NOSORT = 1 << 7;
var ARES_AI_ENVHOSTS = 1 << 8;
function ares_strerror(code2) {
  const errorText = [
    "Successful completion",
    "DNS server returned answer with no data",
    "DNS server claims query was misformatted",
    "DNS server returned general failure",
    "Domain name not found",
    "DNS server does not implement requested operation",
    "DNS server refused query",
    "Misformatted DNS query",
    "Misformatted domain name",
    "Unsupported address family",
    "Misformatted DNS reply",
    "Could not contact DNS servers",
    "Timeout while contacting DNS servers",
    "End of file",
    "Error reading file",
    "Out of memory",
    "Channel is being destroyed",
    "Misformatted string",
    "Illegal flags specified",
    "Given hostname is not numeric",
    "Illegal hints flags specified",
    "c-ares library initialization not yet performed",
    "Error loading iphlpapi.dll",
    "Could not find GetNetworkParams function",
    "DNS query cancelled"
  ];
  if (code2 >= 0 && code2 < errorText.length) {
    return errorText[code2];
  } else {
    return "unknown";
  }
}

// deno:https://deno.land/std@0.147.0/node/internal_binding/cares_wrap.ts
var GetAddrInfoReqWrap = class extends AsyncWrap {
  constructor() {
    super(10 /* GETADDRINFOREQWRAP */);
  }
};
function getaddrinfo(req, hostname, family, _hints, verbatim) {
  let addresses = [];
  const recordTypes = [];
  if (family === 0 || family === 4) {
    recordTypes.push("A");
  }
  if (family === 0 || family === 6) {
    recordTypes.push("AAAA");
  }
  (async () => {
    await Promise.allSettled(recordTypes.map((recordType) => Deno.resolveDns(hostname, recordType).then((records) => {
      records.forEach((record) => addresses.push(record));
    })));
    const error3 = addresses.length ? 0 : codeMap.get("EAI_NODATA");
    if (!verbatim) {
      addresses.sort((a, b2) => {
        if (isIPv4(a)) {
          return -1;
        } else if (isIPv4(b2)) {
          return 1;
        }
        return 0;
      });
    }
    if (isWindows && hostname === "localhost") {
      addresses = addresses.filter((address) => isIPv4(address));
    }
    req.oncomplete(error3, addresses);
  })();
  return 0;
}
var QueryReqWrap = class extends AsyncWrap {
  constructor() {
    super(27 /* QUERYWRAP */);
  }
};
function fqdnToHostname(fqdn) {
  return fqdn.replace(/\.$/, "");
}
function compressIPv6(address) {
  const formatted = address.replace(/\b(?:0+:){2,}/, ":");
  const finalAddress = formatted.split(":").map((octet) => {
    if (octet.match(/^\d+\.\d+\.\d+\.\d+$/)) {
      return Number(octet.replaceAll(".", "")).toString(16);
    }
    return octet.replace(/\b0+/g, "");
  }).join(":");
  return finalAddress;
}
var ChannelWrap = class extends AsyncWrap {
  #servers = [];
  #timeout;
  #tries;
  constructor(timeout, tries) {
    super(2 /* DNSCHANNEL */);
    this.#timeout = timeout;
    this.#tries = tries;
  }
  async #query(query, recordType) {
    let code2;
    let ret;
    if (this.#servers.length) {
      for (const [ipAddr, port] of this.#servers) {
        const resolveOptions = {
          nameServer: {
            ipAddr,
            port
          }
        };
        ({ code: code2, ret } = await this.#resolve(query, recordType, resolveOptions));
        if (code2 === 0 || code2 === codeMap.get("EAI_NODATA")) {
          break;
        }
      }
    } else {
      ({ code: code2, ret } = await this.#resolve(query, recordType));
    }
    return { code: code2, ret };
  }
  async #resolve(query, recordType, resolveOptions) {
    let ret = [];
    let code2 = 0;
    try {
      ret = await Deno.resolveDns(query, recordType, resolveOptions);
    } catch (e) {
      if (e instanceof Deno.errors.NotFound) {
        code2 = codeMap.get("EAI_NODATA");
      } else {
        code2 = codeMap.get("UNKNOWN");
      }
    }
    return { code: code2, ret };
  }
  queryAny(req, name) {
    (async () => {
      const records = [];
      await Promise.allSettled([
        this.#query(name, "A").then(({ ret }) => {
          ret.forEach((record) => records.push({ type: "A", address: record }));
        }),
        this.#query(name, "AAAA").then(({ ret }) => {
          ret.forEach((record) => records.push({ type: "AAAA", address: compressIPv6(record) }));
        }),
        this.#query(name, "CAA").then(({ ret }) => {
          ret.forEach(({ critical, tag: tag2, value }) => records.push({
            type: "CAA",
            [tag2]: value,
            critical: +critical && 128
          }));
        }),
        this.#query(name, "CNAME").then(({ ret }) => {
          ret.forEach((record) => records.push({ type: "CNAME", value: record }));
        }),
        this.#query(name, "MX").then(({ ret }) => {
          ret.forEach(({ preference, exchange }) => records.push({
            type: "MX",
            priority: preference,
            exchange: fqdnToHostname(exchange)
          }));
        }),
        this.#query(name, "NAPTR").then(({ ret }) => {
          ret.forEach(({ order, preference, flags, services, regexp, replacement }) => records.push({
            type: "NAPTR",
            order,
            preference,
            flags,
            service: services,
            regexp,
            replacement
          }));
        }),
        this.#query(name, "NS").then(({ ret }) => {
          ret.forEach((record) => records.push({ type: "NS", value: fqdnToHostname(record) }));
        }),
        this.#query(name, "PTR").then(({ ret }) => {
          ret.forEach((record) => records.push({ type: "PTR", value: fqdnToHostname(record) }));
        }),
        this.#query(name, "SOA").then(({ ret }) => {
          ret.forEach(({ mname, rname, serial, refresh, retry, expire, minimum }) => records.push({
            type: "SOA",
            nsname: fqdnToHostname(mname),
            hostmaster: fqdnToHostname(rname),
            serial,
            refresh,
            retry,
            expire,
            minttl: minimum
          }));
        }),
        this.#query(name, "SRV").then(({ ret }) => {
          ret.forEach(({ priority, weight, port, target }) => records.push({
            type: "SRV",
            priority,
            weight,
            port,
            name: target
          }));
        }),
        this.#query(name, "TXT").then(({ ret }) => {
          ret.forEach((record) => records.push({ type: "TXT", entries: record }));
        })
      ]);
      const err = records.length ? 0 : codeMap.get("EAI_NODATA");
      req.oncomplete(err, records);
    })();
    return 0;
  }
  queryA(req, name) {
    this.#query(name, "A").then(({ code: code2, ret }) => {
      req.oncomplete(code2, ret);
    });
    return 0;
  }
  queryAaaa(req, name) {
    this.#query(name, "AAAA").then(({ code: code2, ret }) => {
      const records = ret.map((record) => compressIPv6(record));
      req.oncomplete(code2, records);
    });
    return 0;
  }
  queryCaa(req, name) {
    this.#query(name, "CAA").then(({ code: code2, ret }) => {
      const records = ret.map(({ critical, tag: tag2, value }) => ({
        [tag2]: value,
        critical: +critical && 128
      }));
      req.oncomplete(code2, records);
    });
    return 0;
  }
  queryCname(req, name) {
    this.#query(name, "CNAME").then(({ code: code2, ret }) => {
      req.oncomplete(code2, ret);
    });
    return 0;
  }
  queryMx(req, name) {
    this.#query(name, "MX").then(({ code: code2, ret }) => {
      const records = ret.map(({ preference, exchange }) => ({
        priority: preference,
        exchange: fqdnToHostname(exchange)
      }));
      req.oncomplete(code2, records);
    });
    return 0;
  }
  queryNaptr(req, name) {
    this.#query(name, "NAPTR").then(({ code: code2, ret }) => {
      const records = ret.map(({ order, preference, flags, services, regexp, replacement }) => ({
        flags,
        service: services,
        regexp,
        replacement,
        order,
        preference
      }));
      req.oncomplete(code2, records);
    });
    return 0;
  }
  queryNs(req, name) {
    this.#query(name, "NS").then(({ code: code2, ret }) => {
      const records = ret.map((record) => fqdnToHostname(record));
      req.oncomplete(code2, records);
    });
    return 0;
  }
  queryPtr(req, name) {
    this.#query(name, "PTR").then(({ code: code2, ret }) => {
      const records = ret.map((record) => fqdnToHostname(record));
      req.oncomplete(code2, records);
    });
    return 0;
  }
  querySoa(req, name) {
    this.#query(name, "SOA").then(({ code: code2, ret }) => {
      let record = {};
      if (ret.length) {
        const { mname, rname, serial, refresh, retry, expire, minimum } = ret[0];
        record = {
          nsname: fqdnToHostname(mname),
          hostmaster: fqdnToHostname(rname),
          serial,
          refresh,
          retry,
          expire,
          minttl: minimum
        };
      }
      req.oncomplete(code2, record);
    });
    return 0;
  }
  querySrv(req, name) {
    this.#query(name, "SRV").then(({ code: code2, ret }) => {
      const records = ret.map(({ priority, weight, port, target }) => ({
        priority,
        weight,
        port,
        name: target
      }));
      req.oncomplete(code2, records);
    });
    return 0;
  }
  queryTxt(req, name) {
    this.#query(name, "TXT").then(({ code: code2, ret }) => {
      req.oncomplete(code2, ret);
    });
    return 0;
  }
  getHostByAddr(_req, _name) {
    notImplemented("cares.ChannelWrap.prototype.getHostByAddr");
  }
  getServers() {
    return this.#servers;
  }
  setServers(servers) {
    if (typeof servers === "string") {
      const tuples = [];
      for (let i = 0; i < servers.length; i += 2) {
        tuples.push([servers[i], parseInt(servers[i + 1])]);
      }
      this.#servers = tuples;
    } else {
      this.#servers = servers.map(([_ipVersion, ip, port]) => [ip, port]);
    }
    return 0;
  }
  setLocalAddress(_addr0, _addr1) {
    notImplemented("cares.ChannelWrap.prototype.setLocalAddress");
  }
  cancel() {
    notImplemented("cares.ChannelWrap.prototype.cancel");
  }
};
var DNS_ESETSRVPENDING = -1e3;
var EMSG_ESETSRVPENDING = "There are pending queries.";
function strerror(code2) {
  return code2 === DNS_ESETSRVPENDING ? EMSG_ESETSRVPENDING : ares_strerror(code2);
}

// deno:https://deno.land/std@0.147.0/node/internal_binding/contextify.ts
var contextify_exports = {};

// deno:https://deno.land/std@0.147.0/node/internal_binding/crypto.ts
var crypto_exports = {};
__export(crypto_exports, {
  getFipsCrypto: () => getFipsCrypto,
  setFipsCrypto: () => setFipsCrypto,
  timingSafeEqual: () => timingSafeEqual
});

// deno:https://deno.land/std@0.147.0/node/internal_binding/_timingSafeEqual.ts
var timingSafeEqual = (a, b2) => {
  if (a instanceof DataView)
    a = Buffer3.from(a.buffer);
  if (b2 instanceof DataView)
    b2 = Buffer3.from(b2.buffer);
  if (a instanceof ArrayBuffer)
    a = Buffer3.from(a);
  if (b2 instanceof ArrayBuffer)
    b2 = Buffer3.from(b2);
  let result = 0;
  if (a.byteLength !== b2.byteLength) {
    b2 = a;
    result = 1;
  }
  for (let i = 0; i < a.byteLength; i++) {
    result |= a[i] ^ b2[i];
  }
  return result === 0;
};

// deno:https://deno.land/std@0.147.0/node/internal_binding/crypto.ts
function getFipsCrypto() {
  notImplemented("crypto.getFipsCrypto");
}
function setFipsCrypto(_fips) {
  notImplemented("crypto.setFipsCrypto");
}

// deno:https://deno.land/std@0.147.0/node/internal_binding/credentials.ts
var credentials_exports = {};

// deno:https://deno.land/std@0.147.0/node/internal_binding/errors.ts
var errors_exports = {};

// deno:https://deno.land/std@0.147.0/node/internal_binding/fs.ts
var fs_exports = {};

// deno:https://deno.land/std@0.147.0/node/internal_binding/fs_dir.ts
var fs_dir_exports = {};

// deno:https://deno.land/std@0.147.0/node/internal_binding/fs_event_wrap.ts
var fs_event_wrap_exports = {};

// deno:https://deno.land/std@0.147.0/node/internal_binding/heap_utils.ts
var heap_utils_exports = {};

// deno:https://deno.land/std@0.147.0/node/internal_binding/http_parser.ts
var http_parser_exports = {};

// deno:https://deno.land/std@0.147.0/node/internal_binding/icu.ts
var icu_exports = {};

// deno:https://deno.land/std@0.147.0/node/internal_binding/inspector.ts
var inspector_exports = {};

// deno:https://deno.land/std@0.147.0/node/internal_binding/js_stream.ts
var js_stream_exports = {};

// deno:https://deno.land/std@0.147.0/node/internal_binding/messaging.ts
var messaging_exports = {};

// deno:https://deno.land/std@0.147.0/node/internal_binding/module_wrap.ts
var module_wrap_exports = {};

// deno:https://deno.land/std@0.147.0/node/internal_binding/native_module.ts
var native_module_exports = {};

// deno:https://deno.land/std@0.147.0/node/internal_binding/natives.ts
var natives_exports = {};

// deno:https://deno.land/std@0.147.0/node/internal_binding/options.ts
var options_exports = {};

// deno:https://deno.land/std@0.147.0/node/internal_binding/os.ts
var os_exports = {};

// deno:https://deno.land/std@0.147.0/node/internal_binding/pipe_wrap.ts
var pipe_wrap_exports = {};
__export(pipe_wrap_exports, {
  Pipe: () => Pipe,
  PipeConnectWrap: () => PipeConnectWrap,
  constants: () => constants2,
  socketType: () => socketType
});

// deno:https://deno.land/std@0.147.0/node/internal_binding/stream_wrap.ts
var stream_wrap_exports = {};
__export(stream_wrap_exports, {
  LibuvStreamWrap: () => LibuvStreamWrap,
  ShutdownWrap: () => ShutdownWrap,
  WriteWrap: () => WriteWrap,
  kArrayBufferOffset: () => kArrayBufferOffset,
  kBytesWritten: () => kBytesWritten,
  kLastWriteWasAsync: () => kLastWriteWasAsync,
  kNumStreamBaseStateFields: () => kNumStreamBaseStateFields,
  kReadBytesOrError: () => kReadBytesOrError,
  kStreamBaseField: () => kStreamBaseField,
  streamBaseState: () => streamBaseState
});

// deno:https://deno.land/std@0.147.0/node/internal_binding/handle_wrap.ts
var HandleWrap = class extends AsyncWrap {
  constructor(provider) {
    super(provider);
  }
  close(cb = () => {
  }) {
    this._onClose();
    cb();
  }
  ref() {
    unreachable();
  }
  unref() {
    unreachable();
  }
  _onClose() {
  }
};

// deno:https://deno.land/std@0.147.0/node/internal_binding/stream_wrap.ts
var kReadBytesOrError = 0 /* kReadBytesOrError */;
var kArrayBufferOffset = 1 /* kArrayBufferOffset */;
var kBytesWritten = 2 /* kBytesWritten */;
var kLastWriteWasAsync = 3 /* kLastWriteWasAsync */;
var kNumStreamBaseStateFields = 4 /* kNumStreamBaseStateFields */;
var streamBaseState = new Uint8Array(5);
streamBaseState[kLastWriteWasAsync] = 1;
var WriteWrap = class extends AsyncWrap {
  constructor() {
    super(41 /* WRITEWRAP */);
  }
};
var ShutdownWrap = class extends AsyncWrap {
  constructor() {
    super(28 /* SHUTDOWNWRAP */);
  }
};
var kStreamBaseField = Symbol("kStreamBaseField");
var SUGGESTED_SIZE = 64 * 1024;
var LibuvStreamWrap = class extends HandleWrap {
  constructor(provider, stream) {
    super(provider);
    this.#reading = false;
    this.destroyed = false;
    this.writeQueueSize = 0;
    this.bytesRead = 0;
    this.bytesWritten = 0;
    this.#attachToObject(stream);
  }
  #reading;
  readStart() {
    if (!this.#reading) {
      this.#reading = true;
      this.#read();
    }
    return 0;
  }
  readStop() {
    this.#reading = false;
    return 0;
  }
  shutdown(req) {
    const status = this._onClose();
    try {
      req.oncomplete(status);
    } catch {
    }
    return 0;
  }
  useUserBuffer(_userBuf) {
    notImplemented("LibuvStreamWrap.prototype.useUserBuffer");
  }
  writeBuffer(req, data) {
    this.#write(req, data);
    return 0;
  }
  writev(req, chunks, allBuffers) {
    const count = allBuffers ? chunks.length : chunks.length >> 1;
    const buffers = new Array(count);
    if (!allBuffers) {
      for (let i = 0; i < count; i++) {
        const chunk = chunks[i * 2];
        if (Buffer3.isBuffer(chunk)) {
          buffers[i] = chunk;
        }
        const encoding = chunks[i * 2 + 1];
        buffers[i] = Buffer3.from(chunk, encoding);
      }
    } else {
      for (let i = 0; i < count; i++) {
        buffers[i] = chunks[i];
      }
    }
    return this.writeBuffer(req, Buffer3.concat(buffers));
  }
  writeAsciiString(req, data) {
    const buffer = new TextEncoder().encode(data);
    return this.writeBuffer(req, buffer);
  }
  writeUtf8String(req, data) {
    const buffer = new TextEncoder().encode(data);
    return this.writeBuffer(req, buffer);
  }
  writeUcs2String(_req, _data) {
    notImplemented("LibuvStreamWrap.prototype.writeUcs2String");
  }
  writeLatin1String(req, data) {
    const buffer = Buffer3.from(data, "latin1");
    return this.writeBuffer(req, buffer);
  }
  _onClose() {
    let status = 0;
    this.#reading = false;
    try {
      this[kStreamBaseField]?.close();
    } catch {
      status = codeMap.get("ENOTCONN");
    }
    return status;
  }
  #attachToObject(stream) {
    this[kStreamBaseField] = stream;
  }
  async #read() {
    let buf = new Uint8Array(SUGGESTED_SIZE);
    let nread;
    try {
      nread = await this[kStreamBaseField].read(buf);
    } catch (e) {
      if (e instanceof Deno.errors.Interrupted || e instanceof Deno.errors.BadResource) {
        nread = codeMap.get("EOF");
      } else if (e instanceof Deno.errors.ConnectionReset || e instanceof Deno.errors.ConnectionAborted) {
        nread = codeMap.get("ECONNRESET");
      } else {
        nread = codeMap.get("UNKNOWN");
      }
      buf = new Uint8Array(0);
    }
    nread ??= codeMap.get("EOF");
    streamBaseState[kReadBytesOrError] = nread;
    if (nread > 0) {
      this.bytesRead += nread;
    }
    buf = buf.slice(0, nread);
    streamBaseState[kArrayBufferOffset] = 0;
    try {
      this.onread(buf, nread);
    } catch {
    }
    if (nread >= 0 && this.#reading) {
      this.#read();
    }
  }
  async #write(req, data) {
    const { byteLength: byteLength6 } = data;
    try {
      await writeAll(this[kStreamBaseField], data);
    } catch (e) {
      let status;
      if (e instanceof Deno.errors.BadResource || e instanceof Deno.errors.BrokenPipe) {
        status = codeMap.get("EBADF");
      } else {
        status = codeMap.get("UNKNOWN");
      }
      try {
        req.oncomplete(status);
      } catch {
      }
      return;
    }
    streamBaseState[kBytesWritten] = byteLength6;
    this.bytesWritten += byteLength6;
    try {
      req.oncomplete(0);
    } catch {
    }
    return;
  }
};
kStreamBaseField;

// deno:https://deno.land/std@0.147.0/node/internal_binding/connection_wrap.ts
var ConnectionWrap = class extends LibuvStreamWrap {
  constructor(provider, object) {
    super(provider, object);
    this.onconnection = null;
  }
  afterConnect(req, status) {
    const isSuccessStatus = !status;
    const readable = isSuccessStatus;
    const writable = isSuccessStatus;
    try {
      req.oncomplete(status, this, req, readable, writable);
    } catch {
    }
    return;
  }
};

// deno:https://deno.land/std@0.147.0/node/internal_binding/_listen.ts
function ceilPowOf2(n) {
  const roundPowOf2 = 1 << 31 - Math.clz32(n);
  return roundPowOf2 < n ? roundPowOf2 * 2 : roundPowOf2;
}
var INITIAL_ACCEPT_BACKOFF_DELAY = 5;
var MAX_ACCEPT_BACKOFF_DELAY = 1e3;

// deno:https://deno.land/std@0.147.0/node/internal_binding/pipe_wrap.ts
var socketType = /* @__PURE__ */ ((socketType2) => {
  socketType2[socketType2["SOCKET"] = 0] = "SOCKET";
  socketType2[socketType2["SERVER"] = 1] = "SERVER";
  socketType2[socketType2["IPC"] = 2] = "IPC";
  return socketType2;
})(socketType || {});
var Pipe = class extends ConnectionWrap {
  constructor(type, conn) {
    let provider;
    let ipc;
    switch (type) {
      case 0 /* SOCKET */: {
        provider = 24 /* PIPEWRAP */;
        ipc = false;
        break;
      }
      case 1 /* SERVER */: {
        provider = 23 /* PIPESERVERWRAP */;
        ipc = false;
        break;
      }
      case 2 /* IPC */: {
        provider = 24 /* PIPEWRAP */;
        ipc = true;
        break;
      }
      default: {
        unreachable();
      }
    }
    super(provider, conn);
    this.reading = false;
    this.#pendingInstances = 4;
    this.#connections = 0;
    this.#closed = false;
    this.ipc = ipc;
    if (conn && provider === 24 /* PIPEWRAP */) {
      const localAddr = conn.localAddr;
      this.#address = localAddr.path;
    }
  }
  #pendingInstances;
  #address;
  #backlog;
  #listener;
  #connections;
  #closed;
  #acceptBackoffDelay;
  open(_fd) {
    notImplemented("Pipe.prototype.open");
  }
  bind(name) {
    this.#address = name;
    return 0;
  }
  connect(req, address) {
    if (isWindows) {
      notImplemented("Pipe.prototype.connect - Windows");
    }
    const connectOptions = {
      path: address,
      transport: "unix"
    };
    connect(connectOptions).then((conn) => {
      const localAddr = conn.localAddr;
      this.#address = req.address = localAddr.path;
      this[kStreamBaseField] = conn;
      try {
        this.afterConnect(req, 0);
      } catch {
      }
    }, (e) => {
      let code2;
      if (e instanceof Deno.errors.NotFound) {
        code2 = codeMap.get("ENOENT");
      } else if (e instanceof Deno.errors.PermissionDenied) {
        code2 = codeMap.get("EACCES");
      } else {
        code2 = codeMap.get("ECONNREFUSED");
      }
      try {
        this.afterConnect(req, code2);
      } catch {
      }
    });
    return 0;
  }
  listen(backlog) {
    if (isWindows) {
      notImplemented("Pipe.prototype.listen - Windows");
    }
    this.#backlog = isWindows ? this.#pendingInstances : ceilPowOf2(backlog + 1);
    const listenOptions = {
      path: this.#address,
      transport: "unix"
    };
    let listener;
    try {
      listener = listen(listenOptions);
    } catch (e) {
      if (e instanceof Deno.errors.AddrInUse) {
        return codeMap.get("EADDRINUSE");
      } else if (e instanceof Deno.errors.AddrNotAvailable) {
        return codeMap.get("EADDRNOTAVAIL");
      }
      return codeMap.get("UNKNOWN");
    }
    const address = listener.addr;
    this.#address = address.path;
    this.#listener = listener;
    this.#accept();
    return 0;
  }
  ref() {
    if (this.#listener) {
      ListenerRef(this.#listener);
    }
  }
  unref() {
    if (this.#listener) {
      ListenerUnref(this.#listener);
    }
  }
  setPendingInstances(instances) {
    this.#pendingInstances = instances;
  }
  fchmod(mode) {
    if (mode != constants2.UV_READABLE && mode != constants2.UV_WRITABLE && mode != (constants2.UV_WRITABLE | constants2.UV_READABLE)) {
      return codeMap.get("EINVAL");
    }
    let desired_mode = 0;
    if (mode & constants2.UV_READABLE) {
      desired_mode |= fs.S_IRUSR | fs.S_IRGRP | fs.S_IROTH;
    }
    if (mode & constants2.UV_WRITABLE) {
      desired_mode |= fs.S_IWUSR | fs.S_IWGRP | fs.S_IWOTH;
    }
    try {
      Deno.chmodSync(this.#address, desired_mode);
    } catch {
      return codeMap.get("UNKNOWN");
    }
    return 0;
  }
  async #acceptBackoff() {
    if (!this.#acceptBackoffDelay) {
      this.#acceptBackoffDelay = INITIAL_ACCEPT_BACKOFF_DELAY;
    } else {
      this.#acceptBackoffDelay *= 2;
    }
    if (this.#acceptBackoffDelay >= MAX_ACCEPT_BACKOFF_DELAY) {
      this.#acceptBackoffDelay = MAX_ACCEPT_BACKOFF_DELAY;
    }
    await delay(this.#acceptBackoffDelay);
    this.#accept();
  }
  async #accept() {
    if (this.#closed) {
      return;
    }
    if (this.#connections > this.#backlog) {
      this.#acceptBackoff();
      return;
    }
    let connection;
    try {
      connection = await this.#listener.accept();
    } catch (e) {
      if (e instanceof Deno.errors.BadResource && this.#closed) {
        return;
      }
      try {
        this.onconnection(codeMap.get("UNKNOWN"), void 0);
      } catch {
      }
      this.#acceptBackoff();
      return;
    }
    this.#acceptBackoffDelay = void 0;
    const connectionHandle = new Pipe(0 /* SOCKET */, connection);
    this.#connections++;
    try {
      this.onconnection(0, connectionHandle);
    } catch {
    }
    return this.#accept();
  }
  _onClose() {
    this.#closed = true;
    this.reading = false;
    this.#address = void 0;
    this.#backlog = void 0;
    this.#connections = 0;
    this.#acceptBackoffDelay = void 0;
    if (this.provider === 23 /* PIPESERVERWRAP */) {
      try {
        this.#listener.close();
      } catch {
      }
    }
    return LibuvStreamWrap.prototype._onClose.call(this);
  }
};
var PipeConnectWrap = class extends AsyncWrap {
  constructor() {
    super(22 /* PIPECONNECTWRAP */);
  }
};
var constants2 = /* @__PURE__ */ ((constants5) => {
  constants5[constants5["SOCKET"] = 0 /* SOCKET */] = "SOCKET";
  constants5[constants5["SERVER"] = 1 /* SERVER */] = "SERVER";
  constants5[constants5["IPC"] = 2 /* IPC */] = "IPC";
  constants5[constants5["UV_READABLE"] = 1] = "UV_READABLE";
  constants5[constants5["UV_WRITABLE"] = 2] = "UV_WRITABLE";
  return constants5;
})(constants2 || {});

// deno:https://deno.land/std@0.147.0/node/internal_binding/performance.ts
var performance_exports = {};

// deno:https://deno.land/std@0.147.0/node/internal_binding/process_methods.ts
var process_methods_exports = {};

// deno:https://deno.land/std@0.147.0/node/internal_binding/report.ts
var report_exports = {};

// deno:https://deno.land/std@0.147.0/node/internal_binding/serdes.ts
var serdes_exports = {};

// deno:https://deno.land/std@0.147.0/node/internal_binding/signal_wrap.ts
var signal_wrap_exports = {};

// deno:https://deno.land/std@0.147.0/node/internal_binding/spawn_sync.ts
var spawn_sync_exports = {};

// deno:https://deno.land/std@0.147.0/node/internal_binding/symbols.ts
var symbols_exports = {};
__export(symbols_exports, {
  asyncIdSymbol: () => asyncIdSymbol,
  ownerSymbol: () => ownerSymbol
});
var asyncIdSymbol = Symbol("asyncIdSymbol");
var ownerSymbol = Symbol("ownerSymbol");

// deno:https://deno.land/std@0.147.0/node/internal_binding/task_queue.ts
var task_queue_exports = {};

// deno:https://deno.land/std@0.147.0/node/internal_binding/tcp_wrap.ts
var tcp_wrap_exports = {};
__export(tcp_wrap_exports, {
  TCP: () => TCP,
  TCPConnectWrap: () => TCPConnectWrap,
  constants: () => constants3
});
var TCPConnectWrap = class extends AsyncWrap {
  constructor() {
    super(32 /* TCPCONNECTWRAP */);
  }
};
var constants3 = /* @__PURE__ */ ((constants5) => {
  constants5[constants5["SOCKET"] = 0 /* SOCKET */] = "SOCKET";
  constants5[constants5["SERVER"] = 1 /* SERVER */] = "SERVER";
  constants5[constants5["UV_TCP_IPV6ONLY"] = 2] = "UV_TCP_IPV6ONLY";
  return constants5;
})(constants3 || {});
var _a;
var _TCP = class extends ConnectionWrap {
  constructor(type, conn) {
    let provider;
    switch (type) {
      case 0 /* SOCKET */: {
        provider = 34 /* TCPWRAP */;
        break;
      }
      case 1 /* SERVER */: {
        provider = 33 /* TCPSERVERWRAP */;
        break;
      }
      default: {
        unreachable();
      }
    }
    super(provider, conn);
    this[_a] = null;
    this.reading = false;
    this.#connections = 0;
    this.#closed = false;
    if (conn && provider === 34 /* TCPWRAP */) {
      const localAddr = conn.localAddr;
      this.#address = localAddr.hostname;
      this.#port = localAddr.port;
      const remoteAddr = conn.remoteAddr;
      this.#remoteAddress = remoteAddr.hostname;
      this.#remotePort = remoteAddr.port;
      this.#remoteFamily = isIP(remoteAddr.hostname);
    }
  }
  #address;
  #port;
  #remoteAddress;
  #remoteFamily;
  #remotePort;
  #backlog;
  #listener;
  #connections;
  #closed;
  #acceptBackoffDelay;
  open(_fd) {
    notImplemented("TCP.prototype.open");
  }
  bind(address, port) {
    return this.#bind(address, port, 0);
  }
  bind6(address, port, flags) {
    return this.#bind(address, port, flags);
  }
  connect(req, address, port) {
    return this.#connect(req, address, port);
  }
  connect6(req, address, port) {
    return this.#connect(req, address, port);
  }
  listen(backlog) {
    this.#backlog = ceilPowOf2(backlog + 1);
    const listenOptions = {
      hostname: this.#address,
      port: this.#port,
      transport: "tcp"
    };
    let listener;
    try {
      listener = Deno.listen(listenOptions);
    } catch (e) {
      if (e instanceof Deno.errors.AddrInUse) {
        return codeMap.get("EADDRINUSE");
      } else if (e instanceof Deno.errors.AddrNotAvailable) {
        return codeMap.get("EADDRNOTAVAIL");
      }
      return codeMap.get("UNKNOWN");
    }
    const address = listener.addr;
    this.#address = address.hostname;
    this.#port = address.port;
    this.#listener = listener;
    this.#accept();
    return 0;
  }
  ref() {
    if (this.#listener) {
      ListenerRef(this.#listener);
    }
  }
  unref() {
    if (this.#listener) {
      ListenerUnref(this.#listener);
    }
  }
  getsockname(sockname) {
    if (typeof this.#address === "undefined" || typeof this.#port === "undefined") {
      return codeMap.get("EADDRNOTAVAIL");
    }
    sockname.address = this.#address;
    sockname.port = this.#port;
    sockname.family = isIP(this.#address);
    return 0;
  }
  getpeername(peername) {
    if (typeof this.#remoteAddress === "undefined" || typeof this.#remotePort === "undefined") {
      return codeMap.get("EADDRNOTAVAIL");
    }
    peername.address = this.#remoteAddress;
    peername.port = this.#remotePort;
    peername.family = this.#remoteFamily;
    return 0;
  }
  setNoDelay(_noDelay) {
    return 0;
  }
  setKeepAlive(_enable, _initialDelay) {
    return 0;
  }
  setSimultaneousAccepts(_enable) {
    notImplemented("TCP.prototype.setSimultaneousAccepts");
  }
  #bind(address, port, _flags) {
    this.#address = address;
    this.#port = port;
    return 0;
  }
  #connect(req, address, port) {
    this.#remoteAddress = address;
    this.#remotePort = port;
    this.#remoteFamily = isIP(address);
    const connectOptions = {
      hostname: address,
      port,
      transport: "tcp"
    };
    Deno.connect(connectOptions).then((conn) => {
      const localAddr = conn.localAddr;
      this.#address = req.localAddress = localAddr.hostname;
      this.#port = req.localPort = localAddr.port;
      this[kStreamBaseField] = conn;
      try {
        this.afterConnect(req, 0);
      } catch {
      }
    }, () => {
      try {
        this.afterConnect(req, codeMap.get("ECONNREFUSED"));
      } catch {
      }
    });
    return 0;
  }
  async #acceptBackoff() {
    if (!this.#acceptBackoffDelay) {
      this.#acceptBackoffDelay = INITIAL_ACCEPT_BACKOFF_DELAY;
    } else {
      this.#acceptBackoffDelay *= 2;
    }
    if (this.#acceptBackoffDelay >= MAX_ACCEPT_BACKOFF_DELAY) {
      this.#acceptBackoffDelay = MAX_ACCEPT_BACKOFF_DELAY;
    }
    await delay(this.#acceptBackoffDelay);
    this.#accept();
  }
  async #accept() {
    if (this.#closed) {
      return;
    }
    if (this.#connections > this.#backlog) {
      this.#acceptBackoff();
      return;
    }
    let connection;
    try {
      connection = await this.#listener.accept();
    } catch (e) {
      if (e instanceof Deno.errors.BadResource && this.#closed) {
        return;
      }
      try {
        this.onconnection(codeMap.get("UNKNOWN"), void 0);
      } catch {
      }
      this.#acceptBackoff();
      return;
    }
    this.#acceptBackoffDelay = void 0;
    const connectionHandle = new _TCP(0 /* SOCKET */, connection);
    this.#connections++;
    try {
      this.onconnection(0, connectionHandle);
    } catch {
    }
    return this.#accept();
  }
  _onClose() {
    this.#closed = true;
    this.reading = false;
    this.#address = void 0;
    this.#port = void 0;
    this.#remoteAddress = void 0;
    this.#remoteFamily = void 0;
    this.#remotePort = void 0;
    this.#backlog = void 0;
    this.#connections = 0;
    this.#acceptBackoffDelay = void 0;
    if (this.provider === 33 /* TCPSERVERWRAP */) {
      try {
        this.#listener.close();
      } catch {
      }
    }
    return LibuvStreamWrap.prototype._onClose.call(this);
  }
};
var TCP = _TCP;
_a = ownerSymbol;

// deno:https://deno.land/std@0.147.0/node/internal_binding/timers.ts
var timers_exports = {};

// deno:https://deno.land/std@0.147.0/node/internal_binding/tls_wrap.ts
var tls_wrap_exports = {};

// deno:https://deno.land/std@0.147.0/node/internal_binding/trace_events.ts
var trace_events_exports = {};

// deno:https://deno.land/std@0.147.0/node/internal_binding/tty_wrap.ts
var tty_wrap_exports = {};

// deno:https://deno.land/std@0.147.0/node/internal_binding/udp_wrap.ts
var udp_wrap_exports = {};
__export(udp_wrap_exports, {
  SendWrap: () => SendWrap,
  UDP: () => UDP
});
var AF_INET = 2;
var AF_INET6 = 10;
var UDP_DGRAM_MAXSIZE = 64 * 1024;
var SendWrap = class extends AsyncWrap {
  constructor() {
    super(36 /* UDPSENDWRAP */);
  }
};
var _a2;
var UDP = class extends HandleWrap {
  constructor() {
    super(37 /* UDPWRAP */);
    this[_a2] = null;
    this.#receiving = false;
    this.#recvBufferSize = UDP_DGRAM_MAXSIZE;
    this.#sendBufferSize = UDP_DGRAM_MAXSIZE;
  }
  #address;
  #family;
  #port;
  #remoteAddress;
  #remoteFamily;
  #remotePort;
  #listener;
  #receiving;
  #recvBufferSize;
  #sendBufferSize;
  addMembership(_multicastAddress, _interfaceAddress) {
    notImplemented("udp.UDP.prototype.addMembership");
  }
  addSourceSpecificMembership(_sourceAddress, _groupAddress, _interfaceAddress) {
    notImplemented("udp.UDP.prototype.addSourceSpecificMembership");
  }
  bind(ip, port, flags) {
    return this.#doBind(ip, port, flags, AF_INET);
  }
  bind6(ip, port, flags) {
    return this.#doBind(ip, port, flags, AF_INET6);
  }
  bufferSize(size, buffer, ctx) {
    let err;
    if (size > UDP_DGRAM_MAXSIZE) {
      err = "EINVAL";
    } else if (!this.#address) {
      err = isWindows ? "ENOTSOCK" : "EBADF";
    }
    if (err) {
      ctx.errno = codeMap.get(err);
      ctx.code = err;
      ctx.message = errorMap.get(ctx.errno)[1];
      ctx.syscall = buffer ? "uv_recv_buffer_size" : "uv_send_buffer_size";
      return;
    }
    if (size !== 0) {
      size = isLinux ? size * 2 : size;
      if (buffer) {
        return this.#recvBufferSize = size;
      }
      return this.#sendBufferSize = size;
    }
    return buffer ? this.#recvBufferSize : this.#sendBufferSize;
  }
  connect(ip, port) {
    return this.#doConnect(ip, port, AF_INET);
  }
  connect6(ip, port) {
    return this.#doConnect(ip, port, AF_INET6);
  }
  disconnect() {
    this.#remoteAddress = void 0;
    this.#remotePort = void 0;
    this.#remoteFamily = void 0;
    return 0;
  }
  dropMembership(_multicastAddress, _interfaceAddress) {
    notImplemented("udp.UDP.prototype.dropMembership");
  }
  dropSourceSpecificMembership(_sourceAddress, _groupAddress, _interfaceAddress) {
    notImplemented("udp.UDP.prototype.dropSourceSpecificMembership");
  }
  getpeername(peername) {
    if (this.#remoteAddress === void 0) {
      return codeMap.get("EBADF");
    }
    peername.address = this.#remoteAddress;
    peername.port = this.#remotePort;
    peername.family = this.#remoteFamily;
    return 0;
  }
  getsockname(sockname) {
    if (this.#address === void 0) {
      return codeMap.get("EBADF");
    }
    sockname.address = this.#address;
    sockname.port = this.#port;
    sockname.family = this.#family;
    return 0;
  }
  open(_fd) {
    notImplemented("udp.UDP.prototype.open");
  }
  recvStart() {
    if (!this.#receiving) {
      this.#receiving = true;
      this.#receive();
    }
    return 0;
  }
  recvStop() {
    this.#receiving = false;
    return 0;
  }
  ref() {
    notImplemented("udp.UDP.prototype.ref");
  }
  send(req, bufs, count, ...args) {
    return this.#doSend(req, bufs, count, args, AF_INET);
  }
  send6(req, bufs, count, ...args) {
    return this.#doSend(req, bufs, count, args, AF_INET6);
  }
  setBroadcast(_bool) {
    notImplemented("udp.UDP.prototype.setBroadcast");
  }
  setMulticastInterface(_interfaceAddress) {
    notImplemented("udp.UDP.prototype.setMulticastInterface");
  }
  setMulticastLoopback(_bool) {
    notImplemented("udp.UDP.prototype.setMulticastLoopback");
  }
  setMulticastTTL(_ttl) {
    notImplemented("udp.UDP.prototype.setMulticastTTL");
  }
  setTTL(_ttl) {
    notImplemented("udp.UDP.prototype.setTTL");
  }
  unref() {
    notImplemented("udp.UDP.prototype.unref");
  }
  #doBind(ip, port, _flags, family) {
    const listenOptions = {
      port,
      hostname: ip,
      transport: "udp"
    };
    let listener;
    try {
      listener = listenDatagram(listenOptions);
    } catch (e) {
      if (e instanceof Deno.errors.AddrInUse) {
        return codeMap.get("EADDRINUSE");
      } else if (e instanceof Deno.errors.AddrNotAvailable) {
        return codeMap.get("EADDRNOTAVAIL");
      }
      return codeMap.get("UNKNOWN");
    }
    const address = listener.addr;
    this.#address = address.hostname;
    this.#port = address.port;
    this.#family = family === AF_INET6 ? "IPv6" : "IPv4";
    this.#listener = listener;
    return 0;
  }
  #doConnect(ip, port, family) {
    this.#remoteAddress = ip;
    this.#remotePort = port;
    this.#remoteFamily = family === AF_INET6 ? "IPv6" : "IPv4";
    return 0;
  }
  #doSend(req, bufs, _count, args, _family) {
    let hasCallback;
    if (args.length === 3) {
      this.#remotePort = args[0];
      this.#remoteAddress = args[1];
      hasCallback = args[2];
    } else {
      hasCallback = args[0];
    }
    const addr = {
      hostname: this.#remoteAddress,
      port: this.#remotePort,
      transport: "udp"
    };
    const payload = new Uint8Array(Buffer3.concat(bufs.map((buf) => {
      if (typeof buf === "string") {
        return Buffer3.from(buf);
      }
      return Buffer3.from(buf.buffer, buf.byteOffset, buf.byteLength);
    })));
    (async () => {
      let sent;
      let err = null;
      try {
        sent = await this.#listener.send(payload, addr);
      } catch (e) {
        if (e instanceof Deno.errors.BadResource) {
          err = codeMap.get("EBADF");
        } else if (e instanceof Error && e.message.match(/os error (40|90|10040)/)) {
          err = codeMap.get("EMSGSIZE");
        } else {
          err = codeMap.get("UNKNOWN");
        }
        sent = 0;
      }
      if (hasCallback) {
        try {
          req.oncomplete(err, sent);
        } catch {
        }
      }
    })();
    return 0;
  }
  async #receive() {
    if (!this.#receiving) {
      return;
    }
    const p3 = new Uint8Array(this.#recvBufferSize);
    let buf;
    let remoteAddr;
    let nread;
    try {
      [buf, remoteAddr] = await this.#listener.receive(p3);
      nread = buf.length;
    } catch (e) {
      if (e instanceof Deno.errors.Interrupted || e instanceof Deno.errors.BadResource) {
        nread = 0;
      } else {
        nread = codeMap.get("UNKNOWN");
      }
      buf = new Uint8Array(0);
      remoteAddr = null;
    }
    nread ??= 0;
    const rinfo = remoteAddr ? {
      address: remoteAddr.hostname,
      port: remoteAddr.port,
      family: isIP(remoteAddr.hostname) === 6 ? "IPv6" : "IPv4"
    } : void 0;
    try {
      this.onmessage(nread, this, Buffer3.from(buf), rinfo);
    } catch {
    }
    this.#receive();
  }
  _onClose() {
    this.#receiving = false;
    this.#address = void 0;
    this.#port = void 0;
    this.#family = void 0;
    try {
      this.#listener.close();
    } catch {
    }
    this.#listener = void 0;
    return 0;
  }
};
_a2 = ownerSymbol;

// deno:https://deno.land/std@0.147.0/node/internal_binding/url.ts
var url_exports = {};

// deno:https://deno.land/std@0.147.0/node/internal_binding/v8.ts
var v8_exports = {};

// deno:https://deno.land/std@0.147.0/node/internal_binding/worker.ts
var worker_exports = {};

// deno:https://deno.land/std@0.147.0/node/internal_binding/zlib.ts
var zlib_exports = {};

// deno:https://deno.land/std@0.147.0/node/internal_binding/mod.ts
var modules = {
  "async_wrap": async_wrap_exports,
  buffer: buffer_exports,
  "cares_wrap": cares_wrap_exports,
  config: config_exports,
  constants: constants_exports,
  contextify: contextify_exports,
  credentials: credentials_exports,
  crypto: crypto_exports,
  errors: errors_exports,
  fs: fs_exports,
  "fs_dir": fs_dir_exports,
  "fs_event_wrap": fs_event_wrap_exports,
  "heap_utils": heap_utils_exports,
  "http_parser": http_parser_exports,
  icu: icu_exports,
  inspector: inspector_exports,
  "js_stream": js_stream_exports,
  messaging: messaging_exports,
  "module_wrap": module_wrap_exports,
  "native_module": native_module_exports,
  natives: natives_exports,
  options: options_exports,
  os: os_exports,
  performance: performance_exports,
  "pipe_wrap": pipe_wrap_exports,
  "process_methods": process_methods_exports,
  report: report_exports,
  serdes: serdes_exports,
  "signal_wrap": signal_wrap_exports,
  "spawn_sync": spawn_sync_exports,
  "stream_wrap": stream_wrap_exports,
  "string_decoder": string_decoder_exports,
  symbols: symbols_exports,
  "task_queue": task_queue_exports,
  "tcp_wrap": tcp_wrap_exports,
  timers: timers_exports,
  "tls_wrap": tls_wrap_exports,
  "trace_events": trace_events_exports,
  "tty_wrap": tty_wrap_exports,
  types: types_exports,
  "udp_wrap": udp_wrap_exports,
  url: url_exports,
  util: util_exports,
  uv: uv_exports,
  v8: v8_exports,
  worker: worker_exports,
  zlib: zlib_exports
};
function getBinding(name) {
  const mod2 = modules[name];
  if (!mod2) {
    throw new Error(`No such module: ${name}`);
  }
  return mod2;
}

// deno:https://deno.land/std@0.147.0/node/internal/process/per_thread.mjs
var kInternal = Symbol("internal properties");
var replaceUnderscoresRegex = /_/g;
var leadingDashesRegex = /^--?/;
var trailingValuesRegex = /=.*$/;
function buildAllowedFlags() {
  const allowedNodeEnvironmentFlags = [
    "--track-heap-objects",
    "--no-track-heap-objects",
    "--node-snapshot",
    "--no-node-snapshot",
    "--require",
    "--max-old-space-size",
    "--trace-exit",
    "--no-trace-exit",
    "--disallow-code-generation-from-strings",
    "--experimental-json-modules",
    "--no-experimental-json-modules",
    "--interpreted-frames-native-stack",
    "--inspect-brk",
    "--no-inspect-brk",
    "--trace-tls",
    "--no-trace-tls",
    "--stack-trace-limit",
    "--experimental-repl-await",
    "--no-experimental-repl-await",
    "--preserve-symlinks",
    "--no-preserve-symlinks",
    "--report-uncaught-exception",
    "--no-report-uncaught-exception",
    "--experimental-modules",
    "--no-experimental-modules",
    "--report-signal",
    "--jitless",
    "--inspect-port",
    "--heapsnapshot-near-heap-limit",
    "--tls-keylog",
    "--force-context-aware",
    "--no-force-context-aware",
    "--napi-modules",
    "--abort-on-uncaught-exception",
    "--diagnostic-dir",
    "--verify-base-objects",
    "--no-verify-base-objects",
    "--unhandled-rejections",
    "--perf-basic-prof",
    "--trace-atomics-wait",
    "--no-trace-atomics-wait",
    "--deprecation",
    "--no-deprecation",
    "--perf-basic-prof-only-functions",
    "--perf-prof",
    "--max-http-header-size",
    "--report-on-signal",
    "--no-report-on-signal",
    "--throw-deprecation",
    "--no-throw-deprecation",
    "--warnings",
    "--no-warnings",
    "--force-fips",
    "--no-force-fips",
    "--pending-deprecation",
    "--no-pending-deprecation",
    "--input-type",
    "--tls-max-v1.3",
    "--no-tls-max-v1.3",
    "--tls-min-v1.2",
    "--no-tls-min-v1.2",
    "--inspect",
    "--no-inspect",
    "--heapsnapshot-signal",
    "--trace-warnings",
    "--no-trace-warnings",
    "--trace-event-categories",
    "--experimental-worker",
    "--tls-max-v1.2",
    "--no-tls-max-v1.2",
    "--perf-prof-unwinding-info",
    "--preserve-symlinks-main",
    "--no-preserve-symlinks-main",
    "--policy-integrity",
    "--experimental-wasm-modules",
    "--no-experimental-wasm-modules",
    "--node-memory-debug",
    "--inspect-publish-uid",
    "--tls-min-v1.3",
    "--no-tls-min-v1.3",
    "--experimental-specifier-resolution",
    "--secure-heap",
    "--tls-min-v1.0",
    "--no-tls-min-v1.0",
    "--redirect-warnings",
    "--experimental-report",
    "--trace-event-file-pattern",
    "--trace-uncaught",
    "--no-trace-uncaught",
    "--experimental-loader",
    "--http-parser",
    "--dns-result-order",
    "--trace-sigint",
    "--no-trace-sigint",
    "--secure-heap-min",
    "--enable-fips",
    "--no-enable-fips",
    "--enable-source-maps",
    "--no-enable-source-maps",
    "--insecure-http-parser",
    "--no-insecure-http-parser",
    "--use-openssl-ca",
    "--no-use-openssl-ca",
    "--tls-cipher-list",
    "--experimental-top-level-await",
    "--no-experimental-top-level-await",
    "--openssl-config",
    "--icu-data-dir",
    "--v8-pool-size",
    "--report-on-fatalerror",
    "--no-report-on-fatalerror",
    "--title",
    "--tls-min-v1.1",
    "--no-tls-min-v1.1",
    "--report-filename",
    "--trace-deprecation",
    "--no-trace-deprecation",
    "--report-compact",
    "--no-report-compact",
    "--experimental-policy",
    "--experimental-import-meta-resolve",
    "--no-experimental-import-meta-resolve",
    "--zero-fill-buffers",
    "--no-zero-fill-buffers",
    "--report-dir",
    "--use-bundled-ca",
    "--no-use-bundled-ca",
    "--experimental-vm-modules",
    "--no-experimental-vm-modules",
    "--force-async-hooks-checks",
    "--no-force-async-hooks-checks",
    "--frozen-intrinsics",
    "--no-frozen-intrinsics",
    "--huge-max-old-generation-size",
    "--disable-proto",
    "--debug-arraybuffer-allocations",
    "--no-debug-arraybuffer-allocations",
    "--conditions",
    "--experimental-wasi-unstable-preview1",
    "--no-experimental-wasi-unstable-preview1",
    "--trace-sync-io",
    "--no-trace-sync-io",
    "--use-largepages",
    "--experimental-abortcontroller",
    "--debug-port",
    "--es-module-specifier-resolution",
    "--prof-process",
    "-C",
    "--loader",
    "--report-directory",
    "-r",
    "--trace-events-enabled"
  ];
  const trimLeadingDashes = (flag) => flag.replace(leadingDashesRegex, "");
  const nodeFlags = allowedNodeEnvironmentFlags.map(trimLeadingDashes);
  class NodeEnvironmentFlagsSet extends Set {
    constructor(array) {
      super();
      this[kInternal] = { array };
    }
    add() {
      return this;
    }
    delete() {
      return false;
    }
    clear() {
    }
    has(key2) {
      if (typeof key2 === "string") {
        key2 = key2.replace(replaceUnderscoresRegex, "-");
        if (leadingDashesRegex.test(key2)) {
          key2 = key2.replace(trailingValuesRegex, "");
          return this[kInternal].array.includes(key2);
        }
        return nodeFlags.includes(key2);
      }
      return false;
    }
    entries() {
      this[kInternal].set ??= new Set(this[kInternal].array);
      return this[kInternal].set.entries();
    }
    forEach(callback, thisArg = void 0) {
      this[kInternal].array.forEach((v2) => Reflect.apply(callback, thisArg, [v2, v2, this]));
    }
    get size() {
      return this[kInternal].array.length;
    }
    values() {
      this[kInternal].set ??= new Set(this[kInternal].array);
      return this[kInternal].set.values();
    }
  }
  NodeEnvironmentFlagsSet.prototype.keys = NodeEnvironmentFlagsSet.prototype[Symbol.iterator] = NodeEnvironmentFlagsSet.prototype.values;
  Object.freeze(NodeEnvironmentFlagsSet.prototype.constructor);
  Object.freeze(NodeEnvironmentFlagsSet.prototype);
  return Object.freeze(new NodeEnvironmentFlagsSet(allowedNodeEnvironmentFlags));
}

// deno:https://deno.land/std@0.147.0/node/process.ts
var stderr2 = stderr;
var stdin2 = stdin;
var stdout2 = stdout;
var notImplementedEvents = [
  "beforeExit",
  "disconnect",
  "message",
  "multipleResolves",
  "rejectionHandled",
  "uncaughtException",
  "uncaughtExceptionMonitor",
  "unhandledRejection",
  "worker"
];
var argv = ["", "", ...Deno.args];
Object.defineProperty(argv, "0", { get: Deno.execPath });
Object.defineProperty(argv, "1", {
  get: () => {
    if (Deno.mainModule.startsWith("file:")) {
      return fromFileUrl3(Deno.mainModule);
    } else {
      return join5(Deno.cwd(), "$deno$node.js");
    }
  }
});
var exit = (code2) => {
  if (code2 || code2 === 0) {
    if (typeof code2 === "string") {
      const parsedCode = parseInt(code2);
      process2.exitCode = isNaN(parsedCode) ? void 0 : parsedCode;
    } else {
      process2.exitCode = code2;
    }
  }
  if (!process2._exiting) {
    process2._exiting = true;
    process2.emit("exit", process2.exitCode || 0);
  }
  Deno.exit(process2.exitCode || 0);
};
function addReadOnlyProcessAlias(name, option, enumerable = true) {
  const value = getOptionValue(option);
  if (value) {
    Object.defineProperty(process2, name, {
      writable: false,
      configurable: true,
      enumerable,
      value
    });
  }
}
function createWarningObject(warning, type, code2, ctor, detail) {
  assert2(typeof warning === "string");
  const warningErr = new Error(warning);
  warningErr.name = String(type || "Warning");
  if (code2 !== void 0) {
    warningErr.code = code2;
  }
  if (detail !== void 0) {
    warningErr.detail = detail;
  }
  Error.captureStackTrace(warningErr, ctor || process2.emitWarning);
  return warningErr;
}
function doEmitWarning(warning) {
  process2.emit("warning", warning);
}
function emitWarning(warning, type, code2, ctor) {
  let detail;
  if (type !== null && typeof type === "object" && !Array.isArray(type)) {
    ctor = type.ctor;
    code2 = type.code;
    if (typeof type.detail === "string") {
      detail = type.detail;
    }
    type = type.type || "Warning";
  } else if (typeof type === "function") {
    ctor = type;
    code2 = void 0;
    type = "Warning";
  }
  if (type !== void 0) {
    validateString(type, "type");
  }
  if (typeof code2 === "function") {
    ctor = code2;
    code2 = void 0;
  } else if (code2 !== void 0) {
    validateString(code2, "code");
  }
  if (typeof warning === "string") {
    warning = createWarningObject(warning, type, code2, ctor, detail);
  } else if (!(warning instanceof Error)) {
    throw new ERR_INVALID_ARG_TYPE("warning", ["Error", "string"], warning);
  }
  if (warning.name === "DeprecationWarning") {
    if (process2.noDeprecation) {
      return;
    }
    if (process2.throwDeprecation) {
      return process2.nextTick(() => {
        throw warning;
      });
    }
  }
  process2.nextTick(doEmitWarning, warning);
}
function hrtime(time) {
  const milli = performance.now();
  const sec = Math.floor(milli / 1e3);
  const nano = Math.floor(milli * 1e6 - sec * 1e9);
  if (!time) {
    return [sec, nano];
  }
  const [prevSec, prevNano] = time;
  return [sec - prevSec, nano - prevNano];
}
hrtime.bigint = function() {
  const [sec, nano] = hrtime();
  return BigInt(sec) * 1000000000n + BigInt(nano);
};
function memoryUsage() {
  return {
    ...Deno.memoryUsage(),
    arrayBuffers: 0
  };
}
memoryUsage.rss = function() {
  return memoryUsage().rss;
};
function kill(pid2, sig = "SIGTERM") {
  if (pid2 != (pid2 | 0)) {
    throw new ERR_INVALID_ARG_TYPE("pid", "number", pid2);
  }
  if (typeof sig === "string") {
    try {
      Deno.kill(pid2, sig);
    } catch (e) {
      if (e instanceof TypeError) {
        throw new ERR_UNKNOWN_SIGNAL(sig);
      }
      throw e;
    }
  } else {
    throw new ERR_UNKNOWN_SIGNAL(sig.toString());
  }
  return true;
}
var Process = class extends EventEmitter {
  constructor() {
    super();
    this.arch = arch;
    this.argv = argv;
    this.chdir = chdir;
    this.config = {
      target_defaults: {},
      variables: {}
    };
    this.cwd = cwd;
    this.env = env;
    this.execArgv = [];
    this.exit = exit;
    this._exiting = _exiting;
    this.exitCode = void 0;
    this.mainModule = void 0;
    this.nextTick = nextTick3;
    this.pid = pid;
    this.platform = platform;
    this.hrtime = hrtime;
    this.kill = kill;
    this.memoryUsage = memoryUsage;
    this.stderr = stderr2;
    this.stdin = stdin2;
    this.stdout = stdout2;
    this.version = version;
    this.versions = versions;
    this.emitWarning = emitWarning;
    this._eval = void 0;
    this.#startTime = Date.now();
    this.#allowedFlags = buildAllowedFlags();
    this.features = { inspector: false };
    globalThis.addEventListener("unload", () => {
      if (!process2._exiting) {
        process2._exiting = true;
        super.emit("exit", process2.exitCode || 0);
      }
    });
  }
  on(event, listener) {
    if (notImplementedEvents.includes(event)) {
      warnNotImplemented(`process.on("${event}")`);
      super.on(event, listener);
    } else if (event.startsWith("SIG")) {
      if (event === "SIGBREAK" && Deno.build.os !== "windows") {
      } else {
        addSignalListener(event, listener);
      }
    } else {
      super.on(event, listener);
    }
    return this;
  }
  off(event, listener) {
    if (notImplementedEvents.includes(event)) {
      warnNotImplemented(`process.off("${event}")`);
      super.off(event, listener);
    } else if (event.startsWith("SIG")) {
      if (event === "SIGBREAK" && Deno.build.os !== "windows") {
      } else {
        removeSignalListener(event, listener);
      }
    } else {
      super.off(event, listener);
    }
    return this;
  }
  emit(event, ...args) {
    if (event.startsWith("SIG")) {
      if (event === "SIGBREAK" && Deno.build.os !== "windows") {
      } else {
        Deno.kill(Deno.pid, event);
      }
    } else {
      return super.emit(event, ...args);
    }
    return true;
  }
  prependListener(event, listener) {
    if (notImplementedEvents.includes(event)) {
      warnNotImplemented(`process.prependListener("${event}")`);
      super.prependListener(event, listener);
    } else if (event.startsWith("SIG")) {
      if (event === "SIGBREAK" && Deno.build.os !== "windows") {
      } else {
        addSignalListener(event, listener);
      }
    } else {
      super.prependListener(event, listener);
    }
    return this;
  }
  addListener(event, listener) {
    if (notImplementedEvents.includes(event)) {
      warnNotImplemented(`process.addListener("${event}")`);
    }
    return this.on(event, listener);
  }
  removeListener(event, listener) {
    if (notImplementedEvents.includes(event)) {
      warnNotImplemented(`process.removeListener("${event}")`);
    }
    return this.off(event, listener);
  }
  binding(name) {
    return getBinding(name);
  }
  umask() {
    return 18;
  }
  getuid() {
    return NaN;
  }
  getgid() {
    return NaN;
  }
  get execPath() {
    return argv[0];
  }
  #startTime;
  uptime() {
    return (Date.now() - this.#startTime) / 1e3;
  }
  #allowedFlags;
  get allowedNodeEnvironmentFlags() {
    return this.#allowedFlags;
  }
};
var process2 = new Process();
Object.defineProperty(process2, Symbol.toStringTag, {
  enumerable: false,
  writable: true,
  configurable: false,
  value: "process"
});
addReadOnlyProcessAlias("noDeprecation", "--no-deprecation");
addReadOnlyProcessAlias("throwDeprecation", "--throw-deprecation");
var removeListener2 = process2.removeListener;
var removeAllListeners2 = process2.removeAllListeners;
var process_default = process2;

// deno:https://deno.land/std@0.147.0/node/internal/crypto/_randomBytes.ts
var MAX_RANDOM_VALUES = 65536;
var MAX_SIZE2 = 4294967295;
function generateRandomBytes(size) {
  if (size > MAX_SIZE2) {
    throw new RangeError(`The value of "size" is out of range. It must be >= 0 && <= ${MAX_SIZE2}. Received ${size}`);
  }
  const bytes = Buffer3.allocUnsafe(size);
  if (size > MAX_RANDOM_VALUES) {
    for (let generated = 0; generated < size; generated += MAX_RANDOM_VALUES) {
      globalThis.crypto.getRandomValues(bytes.slice(generated, generated + MAX_RANDOM_VALUES));
    }
  } else {
    globalThis.crypto.getRandomValues(bytes);
  }
  return bytes;
}
function randomBytes(size, cb) {
  if (typeof cb === "function") {
    let err = null, bytes;
    try {
      bytes = generateRandomBytes(size);
    } catch (e) {
      if (e instanceof RangeError && e.message.includes('The value of "size" is out of range')) {
        throw e;
      } else if (e instanceof Error) {
        err = e;
      } else {
        err = new Error("[non-error thrown]");
      }
    }
    setTimeout(() => {
      if (err) {
        cb(err);
      } else {
        cb(null, bytes);
      }
    }, 0);
  } else {
    return generateRandomBytes(size);
  }
}

// deno:https://deno.land/std@0.147.0/node/internal/crypto/_randomFill.ts
var kBufferMaxLength = 2147483647;
function assertOffset(offset, length) {
  if (offset > MAX_SIZE2 || offset < 0) {
    throw new TypeError("offset must be a uint32");
  }
  if (offset > kBufferMaxLength || offset > length) {
    throw new RangeError("offset out of range");
  }
}
function assertSize2(size, offset, length) {
  if (size > MAX_SIZE2 || size < 0) {
    throw new TypeError("size must be a uint32");
  }
  if (size + offset > length || size > kBufferMaxLength) {
    throw new RangeError("buffer too small");
  }
}
function randomFill(buf, offset, size, cb) {
  if (typeof offset === "function") {
    cb = offset;
    offset = 0;
    size = buf.length;
  } else if (typeof size === "function") {
    cb = size;
    size = buf.length - Number(offset);
  }
  assertOffset(offset, buf.length);
  assertSize2(size, offset, buf.length);
  randomBytes(size, (err, bytes) => {
    if (err)
      return cb(err, buf);
    bytes?.copy(buf, offset);
    cb(null, buf);
  });
}
function randomFillSync(buf, offset = 0, size) {
  assertOffset(offset, buf.length);
  if (size === void 0)
    size = buf.length - offset;
  assertSize2(size, offset, buf.length);
  const bytes = randomBytes(size);
  bytes.copy(buf, offset);
  return buf;
}

// deno:https://deno.land/std@0.147.0/node/internal/crypto/_randomInt.ts
function randomInt(max2, min4, cb) {
  if (typeof max2 === "number" && typeof min4 === "number") {
    [max2, min4] = [min4, max2];
  }
  if (min4 === void 0)
    min4 = 0;
  else if (typeof min4 === "function") {
    cb = min4;
    min4 = 0;
  }
  if (!Number.isSafeInteger(min4) || typeof max2 === "number" && !Number.isSafeInteger(max2)) {
    throw new Error("max or min is not a Safe Number");
  }
  if (max2 - min4 > Math.pow(2, 48)) {
    throw new RangeError("max - min should be less than 2^48!");
  }
  if (min4 >= max2) {
    throw new Error("Min is bigger than Max!");
  }
  const randomBuffer = new Uint32Array(1);
  globalThis.crypto.getRandomValues(randomBuffer);
  const randomNumber = randomBuffer[0] / (4294967295 + 1);
  min4 = Math.ceil(min4);
  max2 = Math.floor(max2);
  const result = Math.floor(randomNumber * (max2 - min4)) + min4;
  if (cb) {
    cb(null, result);
    return;
  }
  return result;
}

// deno:https://deno.land/std@0.147.0/node/internal/crypto/random.ts
function checkPrime(_candidate, _options, _callback) {
  notImplemented("crypto.checkPrime");
}
function checkPrimeSync(_candidate, _options) {
  notImplemented("crypto.checkPrimeSync");
}
function generatePrime(_size, _options, _callback) {
  notImplemented("crypto.generatePrime");
}
function generatePrimeSync(_size, _options) {
  notImplemented("crypto.generatePrimeSync");
}
var randomUUID = () => globalThis.crypto.randomUUID();

// deno:https://deno.land/std@0.147.0/_wasm_crypto/lib/deno_std_wasm_crypto.generated.mjs
var wasm;
var heap = new Array(32).fill(void 0);
heap.push(void 0, null, true, false);
function getObject(idx) {
  return heap[idx];
}
var heap_next = heap.length;
function dropObject(idx) {
  if (idx < 36)
    return;
  heap[idx] = heap_next;
  heap_next = idx;
}
function takeObject(idx) {
  const ret = getObject(idx);
  dropObject(idx);
  return ret;
}
function addHeapObject(obj2) {
  if (heap_next === heap.length)
    heap.push(heap.length + 1);
  const idx = heap_next;
  heap_next = heap[idx];
  heap[idx] = obj2;
  return idx;
}
var cachedTextDecoder = new TextDecoder("utf-8", {
  ignoreBOM: true,
  fatal: true
});
cachedTextDecoder.decode();
var cachedUint8Memory0;
function getUint8Memory0() {
  if (cachedUint8Memory0.byteLength === 0) {
    cachedUint8Memory0 = new Uint8Array(wasm.memory.buffer);
  }
  return cachedUint8Memory0;
}
function getStringFromWasm0(ptr, len) {
  return cachedTextDecoder.decode(getUint8Memory0().subarray(ptr, ptr + len));
}
var WASM_VECTOR_LEN = 0;
var cachedTextEncoder = new TextEncoder("utf-8");
var encodeString = function(arg, view) {
  return cachedTextEncoder.encodeInto(arg, view);
};
function passStringToWasm0(arg, malloc, realloc) {
  if (realloc === void 0) {
    const buf = cachedTextEncoder.encode(arg);
    const ptr2 = malloc(buf.length);
    getUint8Memory0().subarray(ptr2, ptr2 + buf.length).set(buf);
    WASM_VECTOR_LEN = buf.length;
    return ptr2;
  }
  let len = arg.length;
  let ptr = malloc(len);
  const mem = getUint8Memory0();
  let offset = 0;
  for (; offset < len; offset++) {
    const code2 = arg.charCodeAt(offset);
    if (code2 > 127)
      break;
    mem[ptr + offset] = code2;
  }
  if (offset !== len) {
    if (offset !== 0) {
      arg = arg.slice(offset);
    }
    ptr = realloc(ptr, len, len = offset + arg.length * 3);
    const view = getUint8Memory0().subarray(ptr + offset, ptr + len);
    const ret = encodeString(arg, view);
    offset += ret.written;
  }
  WASM_VECTOR_LEN = offset;
  return ptr;
}
function isLikeNone(x) {
  return x === void 0 || x === null;
}
var cachedInt32Memory0;
function getInt32Memory0() {
  if (cachedInt32Memory0.byteLength === 0) {
    cachedInt32Memory0 = new Int32Array(wasm.memory.buffer);
  }
  return cachedInt32Memory0;
}
function getArrayU8FromWasm0(ptr, len) {
  return getUint8Memory0().subarray(ptr / 1, ptr / 1 + len);
}
function digest(algorithm, data, length) {
  try {
    const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
    const ptr0 = passStringToWasm0(algorithm, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
    const len0 = WASM_VECTOR_LEN;
    wasm.digest(retptr, ptr0, len0, addHeapObject(data), !isLikeNone(length), isLikeNone(length) ? 0 : length);
    var r03 = getInt32Memory0()[retptr / 4 + 0];
    var r1 = getInt32Memory0()[retptr / 4 + 1];
    var r2 = getInt32Memory0()[retptr / 4 + 2];
    var r3 = getInt32Memory0()[retptr / 4 + 3];
    if (r3) {
      throw takeObject(r2);
    }
    var v13 = getArrayU8FromWasm0(r03, r1).slice();
    wasm.__wbindgen_free(r03, r1 * 1);
    return v13;
  } finally {
    wasm.__wbindgen_add_to_stack_pointer(16);
  }
}
var DigestContextFinalization = new FinalizationRegistry((ptr) => wasm.__wbg_digestcontext_free(ptr));
var DigestContext = class {
  static __wrap(ptr) {
    const obj2 = Object.create(DigestContext.prototype);
    obj2.ptr = ptr;
    DigestContextFinalization.register(obj2, obj2.ptr, obj2);
    return obj2;
  }
  __destroy_into_raw() {
    const ptr = this.ptr;
    this.ptr = 0;
    DigestContextFinalization.unregister(this);
    return ptr;
  }
  free() {
    const ptr = this.__destroy_into_raw();
    wasm.__wbg_digestcontext_free(ptr);
  }
  constructor(algorithm) {
    try {
      const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
      const ptr0 = passStringToWasm0(algorithm, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
      const len0 = WASM_VECTOR_LEN;
      wasm.digestcontext_new(retptr, ptr0, len0);
      var r03 = getInt32Memory0()[retptr / 4 + 0];
      var r1 = getInt32Memory0()[retptr / 4 + 1];
      var r2 = getInt32Memory0()[retptr / 4 + 2];
      if (r2) {
        throw takeObject(r1);
      }
      return DigestContext.__wrap(r03);
    } finally {
      wasm.__wbindgen_add_to_stack_pointer(16);
    }
  }
  update(data) {
    try {
      const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
      wasm.digestcontext_update(retptr, this.ptr, addHeapObject(data));
      var r03 = getInt32Memory0()[retptr / 4 + 0];
      var r1 = getInt32Memory0()[retptr / 4 + 1];
      if (r1) {
        throw takeObject(r03);
      }
    } finally {
      wasm.__wbindgen_add_to_stack_pointer(16);
    }
  }
  digest(length) {
    try {
      const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
      wasm.digestcontext_digest(retptr, this.ptr, !isLikeNone(length), isLikeNone(length) ? 0 : length);
      var r03 = getInt32Memory0()[retptr / 4 + 0];
      var r1 = getInt32Memory0()[retptr / 4 + 1];
      var r2 = getInt32Memory0()[retptr / 4 + 2];
      var r3 = getInt32Memory0()[retptr / 4 + 3];
      if (r3) {
        throw takeObject(r2);
      }
      var v0 = getArrayU8FromWasm0(r03, r1).slice();
      wasm.__wbindgen_free(r03, r1 * 1);
      return v0;
    } finally {
      wasm.__wbindgen_add_to_stack_pointer(16);
    }
  }
  digestAndReset(length) {
    try {
      const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
      wasm.digestcontext_digestAndReset(retptr, this.ptr, !isLikeNone(length), isLikeNone(length) ? 0 : length);
      var r03 = getInt32Memory0()[retptr / 4 + 0];
      var r1 = getInt32Memory0()[retptr / 4 + 1];
      var r2 = getInt32Memory0()[retptr / 4 + 2];
      var r3 = getInt32Memory0()[retptr / 4 + 3];
      if (r3) {
        throw takeObject(r2);
      }
      var v0 = getArrayU8FromWasm0(r03, r1).slice();
      wasm.__wbindgen_free(r03, r1 * 1);
      return v0;
    } finally {
      wasm.__wbindgen_add_to_stack_pointer(16);
    }
  }
  digestAndDrop(length) {
    try {
      const ptr = this.__destroy_into_raw();
      const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
      wasm.digestcontext_digestAndDrop(retptr, ptr, !isLikeNone(length), isLikeNone(length) ? 0 : length);
      var r03 = getInt32Memory0()[retptr / 4 + 0];
      var r1 = getInt32Memory0()[retptr / 4 + 1];
      var r2 = getInt32Memory0()[retptr / 4 + 2];
      var r3 = getInt32Memory0()[retptr / 4 + 3];
      if (r3) {
        throw takeObject(r2);
      }
      var v0 = getArrayU8FromWasm0(r03, r1).slice();
      wasm.__wbindgen_free(r03, r1 * 1);
      return v0;
    } finally {
      wasm.__wbindgen_add_to_stack_pointer(16);
    }
  }
  reset() {
    try {
      const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
      wasm.digestcontext_reset(retptr, this.ptr);
      var r03 = getInt32Memory0()[retptr / 4 + 0];
      var r1 = getInt32Memory0()[retptr / 4 + 1];
      if (r1) {
        throw takeObject(r03);
      }
    } finally {
      wasm.__wbindgen_add_to_stack_pointer(16);
    }
  }
  clone() {
    const ret = wasm.digestcontext_clone(this.ptr);
    return DigestContext.__wrap(ret);
  }
};
var imports = {
  __wbindgen_placeholder__: {
    __wbg_new_a4b61a0f54824cfd: function(arg0, arg1) {
      const ret = new TypeError(getStringFromWasm0(arg0, arg1));
      return addHeapObject(ret);
    },
    __wbindgen_object_drop_ref: function(arg0) {
      takeObject(arg0);
    },
    __wbg_byteLength_3e250b41a8915757: function(arg0) {
      const ret = getObject(arg0).byteLength;
      return ret;
    },
    __wbg_byteOffset_4204ecb24a6e5df9: function(arg0) {
      const ret = getObject(arg0).byteOffset;
      return ret;
    },
    __wbg_buffer_facf0398a281c85b: function(arg0) {
      const ret = getObject(arg0).buffer;
      return addHeapObject(ret);
    },
    __wbg_newwithbyteoffsetandlength_4b9b8c4e3f5adbff: function(arg0, arg1, arg2) {
      const ret = new Uint8Array(getObject(arg0), arg1 >>> 0, arg2 >>> 0);
      return addHeapObject(ret);
    },
    __wbg_length_1eb8fc608a0d4cdb: function(arg0) {
      const ret = getObject(arg0).length;
      return ret;
    },
    __wbindgen_memory: function() {
      const ret = wasm.memory;
      return addHeapObject(ret);
    },
    __wbg_buffer_397eaa4d72ee94dd: function(arg0) {
      const ret = getObject(arg0).buffer;
      return addHeapObject(ret);
    },
    __wbg_new_a7ce447f15ff496f: function(arg0) {
      const ret = new Uint8Array(getObject(arg0));
      return addHeapObject(ret);
    },
    __wbg_set_969ad0a60e51d320: function(arg0, arg1, arg2) {
      getObject(arg0).set(getObject(arg1), arg2 >>> 0);
    },
    __wbindgen_throw: function(arg0, arg1) {
      throw new Error(getStringFromWasm0(arg0, arg1));
    }
  }
};
function instantiate() {
  return instantiateWithInstance().exports;
}
var instanceWithExports;
function instantiateWithInstance() {
  if (instanceWithExports == null) {
    const instance = instantiateInstance();
    wasm = instance.exports;
    cachedInt32Memory0 = new Int32Array(wasm.memory.buffer);
    cachedUint8Memory0 = new Uint8Array(wasm.memory.buffer);
    instanceWithExports = {
      instance,
      exports: { digest, DigestContext }
    };
  }
  return instanceWithExports;
}
function instantiateInstance() {
  const wasmBytes = base64decode("AGFzbQEAAAABo4GAgAAYYAAAYAABf2ABfwBgAX8Bf2ABfwF+YAJ/fwBgAn9/AX9gA39/fwBgA39/fwF/YAR/f39/AGAEf39/fwF/YAV/f39/fwBgBX9/f39/AX9gBn9/f39/fwBgBn9/f39/fwF/YAV/f39+fwBgB39/f35/f38Bf2ADf39+AGAFf399f38AYAV/f3x/fwBgAn9+AGAEf31/fwBgBH98f38AYAJ+fwF/AqSFgIAADBhfX3diaW5kZ2VuX3BsYWNlaG9sZGVyX18aX193YmdfbmV3X2E0YjYxYTBmNTQ4MjRjZmQABhhfX3diaW5kZ2VuX3BsYWNlaG9sZGVyX18aX193YmluZGdlbl9vYmplY3RfZHJvcF9yZWYAAhhfX3diaW5kZ2VuX3BsYWNlaG9sZGVyX18hX193YmdfYnl0ZUxlbmd0aF8zZTI1MGI0MWE4OTE1NzU3AAMYX193YmluZGdlbl9wbGFjZWhvbGRlcl9fIV9fd2JnX2J5dGVPZmZzZXRfNDIwNGVjYjI0YTZlNWRmOQADGF9fd2JpbmRnZW5fcGxhY2Vob2xkZXJfXx1fX3diZ19idWZmZXJfZmFjZjAzOThhMjgxYzg1YgADGF9fd2JpbmRnZW5fcGxhY2Vob2xkZXJfXzFfX3diZ19uZXd3aXRoYnl0ZW9mZnNldGFuZGxlbmd0aF80YjliOGM0ZTNmNWFkYmZmAAgYX193YmluZGdlbl9wbGFjZWhvbGRlcl9fHV9fd2JnX2xlbmd0aF8xZWI4ZmM2MDhhMGQ0Y2RiAAMYX193YmluZGdlbl9wbGFjZWhvbGRlcl9fEV9fd2JpbmRnZW5fbWVtb3J5AAEYX193YmluZGdlbl9wbGFjZWhvbGRlcl9fHV9fd2JnX2J1ZmZlcl8zOTdlYWE0ZDcyZWU5NGRkAAMYX193YmluZGdlbl9wbGFjZWhvbGRlcl9fGl9fd2JnX25ld19hN2NlNDQ3ZjE1ZmY0OTZmAAMYX193YmluZGdlbl9wbGFjZWhvbGRlcl9fGl9fd2JnX3NldF85NjlhZDBhNjBlNTFkMzIwAAcYX193YmluZGdlbl9wbGFjZWhvbGRlcl9fEF9fd2JpbmRnZW5fdGhyb3cABQPrgICAAGoJBwkHBxEFBwcFAwcHDwMHBRACBQUFBwUCCAYHBxQMCA4HBwcHBwcIFw0FBQkICA0HCQUJCQYGBQUFBQUFBwcHBwcABQIICgcHAgUDDgwLDAsLEhMJBQgIAwYGAgUAAAYDBgAABQUEAAUCBIWAgIAAAXABFRUFg4CAgAABABEGiYCAgAABfwFBgIDAAAsHtoKAgAAOBm1lbW9yeQIABmRpZ2VzdAA1GF9fd2JnX2RpZ2VzdGNvbnRleHRfZnJlZQBQEWRpZ2VzdGNvbnRleHRfbmV3ADwUZGlnZXN0Y29udGV4dF91cGRhdGUAVBRkaWdlc3Rjb250ZXh0X2RpZ2VzdAA9HGRpZ2VzdGNvbnRleHRfZGlnZXN0QW5kUmVzZXQAPxtkaWdlc3Rjb250ZXh0X2RpZ2VzdEFuZERyb3AAOBNkaWdlc3Rjb250ZXh0X3Jlc2V0ACETZGlnZXN0Y29udGV4dF9jbG9uZQAaH19fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIAbBFfX3diaW5kZ2VuX21hbGxvYwBXEl9fd2JpbmRnZW5fcmVhbGxvYwBiD19fd2JpbmRnZW5fZnJlZQBoCZqAgIAAAQBBAQsUZWZtdGtZO1pbWGNgXF1eX3VBQnIK0smIgABqoH4CEn8CfiMAQbAlayIEJAACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkAgASgCAA4YAAECAwQcGxoZGBcWFRQTEhEQDw4NDAsKAAsgASgCBCEBQdABEBYiBUUNBCAEQZASakE4aiABQThqKQMANwMAIARBkBJqQTBqIAFBMGopAwA3AwAgBEGQEmpBKGogAUEoaikDADcDACAEQZASakEgaiABQSBqKQMANwMAIARBkBJqQRhqIAFBGGopAwA3AwAgBEGQEmpBEGogAUEQaikDADcDACAEQZASakEIaiABQQhqKQMANwMAIAQgASkDADcDkBIgASkDQCEWIARBkBJqQcgAaiABQcgAahBDIAQgFjcD0BIgBSAEQZASakHQARA5GkEAIQZBACEBDB8LIAEoAgQhAUHQARAWIgVFDQQgBEGQEmpBOGogAUE4aikDADcDACAEQZASakEwaiABQTBqKQMANwMAIARBkBJqQShqIAFBKGopAwA3AwAgBEGQEmpBIGogAUEgaikDADcDACAEQZASakEYaiABQRhqKQMANwMAIARBkBJqQRBqIAFBEGopAwA3AwAgBEGQEmpBCGogAUEIaikDADcDACAEIAEpAwA3A5ASIAEpA0AhFiAEQZASakHIAGogAUHIAGoQQyAEIBY3A9ASIAUgBEGQEmpB0AEQORpBASEBDBsLIAEoAgQhAUHQARAWIgVFDQQgBEGQEmpBOGogAUE4aikDADcDACAEQZASakEwaiABQTBqKQMANwMAIARBkBJqQShqIAFBKGopAwA3AwAgBEGQEmpBIGogAUEgaikDADcDACAEQZASakEYaiABQRhqKQMANwMAIARBkBJqQRBqIAFBEGopAwA3AwAgBEGQEmpBCGogAUEIaikDADcDACAEIAEpAwA3A5ASIAEpA0AhFiAEQZASakHIAGogAUHIAGoQQyAEIBY3A9ASIAUgBEGQEmpB0AEQORpBAiEBDBoLIAEoAgQhAUHwABAWIgVFDQQgBEGQEmpBIGogAUEgaikDADcDACAEQZASakEYaiABQRhqKQMANwMAIARBkBJqQRBqIAFBEGopAwA3AwAgBCABKQMINwOYEiABKQMAIRYgBEGQEmpBKGogAUEoahA3IAQgFjcDkBIgBSAEQZASakHwABA5GkEDIQEMGQsgASgCBCEBQfgOEBYiBUUNBCAEQZASakGIAWogAUGIAWopAwA3AwAgBEGQEmpBgAFqIAFBgAFqKQMANwMAIARBkBJqQfgAaiABQfgAaikDADcDACAEQZASakEQaiABQRBqKQMANwMAIARBkBJqQRhqIAFBGGopAwA3AwAgBEGQEmpBIGogAUEgaikDADcDACAEQZASakEwaiABQTBqKQMANwMAIARBkBJqQThqIAFBOGopAwA3AwAgBEGQEmpBwABqIAFBwABqKQMANwMAIARBkBJqQcgAaiABQcgAaikDADcDACAEQZASakHQAGogAUHQAGopAwA3AwAgBEGQEmpB2ABqIAFB2ABqKQMANwMAIARBkBJqQeAAaiABQeAAaikDADcDACAEIAEpA3A3A4ATIAQgASkDCDcDmBIgBCABKQMoNwO4EiABKQMAIRYgAS0AaiEHIAEtAGkhCCABLQBoIQkCQCABKAKQAUEFdCIKDQBBACEKDBsLIARBGGoiCyABQZQBaiIGQRhqKQAANwMAIARBEGoiDCAGQRBq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EDkaIAFBuCJqQThqIgogAUGQEmpBPGopAgA3AwAgAUG4ImpBMGoiAyABQZASakE0aikCADcDACABQbgiakEoaiIPIAFBkBJqQSxqKQIANwMAIAFBuCJqQSBqIgsgAUGQEmpBJGopAgA3AwAgAUG4ImpBGGoiDCABQZASakEcaikCADcDACABQbgiakEQaiINIAFBkBJqQRRqKQIANwMAIAFBuCJqQQhqIhAgAUGQEmpBDGopAgA3AwAgASABKQKUEjcDuCIgAUGQEmogAUHQARA5GiABIAEpA9ASIAFB2BNqLQAAIgatfDcD0BIgAUHYEmohAgJAIAZBgAFGDQAgAiAGakEAQYABIAZrEDoaCyABQQA6ANgTIAFBkBJqIAJCfxARIAFB+A5qQQhqIgYgAUGQEmpBCGopAwA3AwAgAUH4DmpBEGoiAiABQZASakEQaikDADcDACABQfgOakEYaiIOIAFBkBJqQRhqKQMANwMAIAFB+A5qQSBqIgcgASkDsBI3AwAgAUH4DmpBKGoiCCABQZASakEoaikDADcDACABQfgOakEwaiIJIAFBkBJqQTBqKQMANwMAIAFB+A5qQThqIhEgAUGQEmpBOGopAwA3AwAgASABKQOQEjcD+A4gECAGKQMANwMAIA0gAikDADcDACAMIA4pAwA3AwAgCyAHKQMANwMAIA8gCCkDADcDACADIAkpAwA3AwAgCiARKQMANwMAIAEgASkD+A43A7giQcAAEBYiBkUNHCAGIAEpA7giNwAAIAZBOGogAUG4ImpBOGopAwA3AAAgBkEwaiABQbgiakEwaikDADcAACAGQShqIAFBuCJqQShqKQMANwAAIAZBIGogAUG4ImpBIGopAwA3AAAgBkEYaiABQbgiakEYaikDADcAACAGQRBqIAFBuCJqQRBqKQMANwAAIAZBCGogAUG4ImpBCGopAwA3AABBwAAhAwwaCyAEIAVB0AEQOSIBQfgOakEcakIANwIAIAFB+A5qQRRqQgA3AgAgAUH4DmpBDGpCADcCACABQgA3AvwOIAFBIDYC+A4gAUGQEmpBGGoiCyABQfgOakEYaiICKQMANwMAIAFBkBJqQRBqIgwgAUH4DmpBEGoiCikDADcDACABQZASakEIaiINIAFB+A5qQQhqIgMpAwA3AwAgAUGQEmpBIGogAUH4DmpBIGoiECgCADYCACABIAEpA/gONwOQEiABQbgiakEQaiIOIAFBkBJqQRRqKQIANwMAIAFBuCJqQQhqIgcgAUGQEmpBDGopAgA3AwAgAUG4ImpBGGoiCCABQZASakEcaikCADcDACABIAEpApQSNwO4IiABQZASaiABQdABEDkaIAEgASkD0BIgAUHYE2otAAAiBq18NwPQEiABQdgSaiEPAkAgBkGAAUYNACAPIAZqQQBBgAEgBmsQOhoLIAFBADoA2BMgAUGQEmogD0J/EBEgAyANKQMANwMAIAogDCkDADcDACACIAspAwA3AwAgECABKQOwEjcDACABQfgOakEoaiABQZASakEoaikDADcDACABQfgOakEwaiABQZASakEwaikDADcDACABQfgOakE4aiABQZASakE4aikDADcDACABIAEpA5ASNwP4DiAHIAMpAwA3AwAgDiAKKQMANwMAIAggAikDADcDACABIAEpA/gONwO4IkEgEBYiBkUNHCAGIAEpA7giNwAAIAZBGGogAUG4ImpBGGopAwA3AAAgBkEQaiABQbgiakEQaikDADcAACAGQQhqIAFBuCJqQQhqKQMANwAAQSAhAwwZCyAEIAVB0AEQOSIBQfgOakEsakIANwIAIAFB+A5qQSRqQgA3AgAgAUH4DmpBHGpCADcCACABQfgOakEUakIANwIAIAFB+A5qQQxqQgA3AgAgAUIANwL8DiABQTA2AvgOIAFBkBJqQShqIg0gAUH4DmpBKGoiAikDADcDACABQZASakEgaiABQfgOakEgaiIKKQMANwMAIAFBkBJqQRhqIhAgAUH4DmpBGGoiAykDADcDACABQZASakEQaiIOIAFB+A5qQRBqIg8pAwA3AwAgAUGQEmpBCGoiByABQfgOakEIaiILKQMANwMAIAFBkBJqQTBqIgggAUH4DmpBMGoiCSgCADYCACABIAEpA/gONwOQEiABQbgiakEgaiIRIAFBkBJqQSRqKQIANwMAIAFBuCJqQRhqIhIgAUGQEmpBHGopAgA3AwAgAUG4ImpBEGoiEyABQZASakEUaikCADcDACABQbgiakEIaiIUIAFBkBJqQQxqKQIANwMAIAFBuCJqQShqIhUgAUGQEmpBLGopAgA3AwAgASABKQKUEjcDuCIgAUGQEmogAUHQARA5GiABIAEpA9ASIAFB2BNqLQAAIgatfDcD0BIgAUHYEmohDAJAIAZBgAFGDQAgDCAGakEAQYABIAZrEDoaCyABQQA6ANgTIAFBkBJqIAxCfxARIAsgBykDADcDACAPIA4pAwA3AwAgAyAQKQMANwMAIAogASkDsBI3AwAgAiANKQMANwMAIAkgCCkDADcDACABQfgOakE4aiABQZASakE4aikDADcDACABIAEpA5ASNwP4DiAUIAspAwA3AwAgEyAPKQMANwMAIBIgAykDADcDACARIAopAwA3AwAgFSACKQMANwMAIAEgASkD+A43A7giQTAQFiIGRQ0cIAYgASkDuCI3AAAgBkEoaiABQbgiakEoaikDADcAACAGQSBqIAFBuCJqQSBqKQMANwAAIAZBGGogAUG4ImpBGGopAwA3AAAgBkEQaiABQbgiakEQaikDADcAACAGQQhqIAFBuCJqQQhqKQMANwAAQTAhAwwYCyAEIAVB8AAQOSIBQfgOakEcakIANwIAIAFB+A5qQRRqQgA3AgAgAUH4DmpBDGpCADcCACABQgA3AvwOIAFBIDYC+A4gAUGQEmpBGGoiCiABQfgOakEYaikDADcDACABQZASakEQaiIDIAFB+A5qQRBqKQMANwMAIAFBkBJqQQhqIAFB+A5qQQhqIg8pAwA3AwAgAUGQEmpBIGoiCyABQfgOakEgaigCADYCACABIAEpA/gONwOQEiABQegjakEQaiIMIAFBkBJqQRRqKQIANwMAIAFB6CNqQQhqIg0gAUGQEmpBDGopAgA3AwAgAUHoI2pBGGoiECABQZASakEcaikCADcDACABIAEpApQSNwPoIyABQZASaiABQfAAEDkaIAEgASkDkBIgAUH4EmotAAAiBq18NwOQEiABQbgSaiECAkAgBkHAAEYNACACIAZqQQBBwAAgBmsQOhoLIAFBADoA+BIgAUGQEmogAkF/EBMgDyADKQMAIhY3AwAgDSAWNwMAIAwgCikDADcDACAQIAspAwA3AwAgASABKQOYEiIWNwP4DiABIBY3A+gjQSAQFiIGRQ0cIAYgASkD6CM3AAAgBkEYaiABQegjakEYaikDADcAACAGQRBqIAFB6CNqQRBqKQMANwAAIAZBCGogAUHoI2pBCGopAwA3AABBICEDDBcLIAQgBUH4DhA5IQEgA0EASA0SAkACQCADDQBBASEGDAELIAMQFiIGRQ0dIAZBfGotAABBA3FFDQAgBkEAIAMQOhoLIAFBkBJqIAFB+A4QORogAUH4DmogAUGQEmoQIyABQfgOaiAGIAMQGAwWCyAEIAVB4AIQOSIKQZASaiAKQeACEDkaIApBkBJqIApB6BRqLQAAIgFqQcgBaiECAkAgAUGQAUYNACACQQBBkAEgAWsQOhoLQQAhBiAKQQA6AOgUIAJBAToAACAKQecUaiIBIAEtAABBgAFyOgAAA0AgCkGQEmogBmoiASABLQAAIAFByAFqLQAAczoAACABQQFqIgIgAi0AACABQckBai0AAHM6AAAgAUECaiICIAItAAAgAUHKAWotAABzOgAAIAFBA2oiAiACLQAAIAFBywFqLQAAczoAACAGQQRqIgZBkAFHDQALIApBkBJqECQgCkH4DmpBGGoiASAKQZASakEYaigCADYCACAKQfgOakEQaiICIApBkBJqQRBqKQMANwMAIApB+A5qQQhqIg8gCkGQEmpBCGopAwA3AwAgCiAKKQOQEjcD+A5BHCEDQRwQFiIGRQ0cIAYgCikD+A43AAAgBkEYaiABKAIANgAAIAZBEGogAikDADcAACAGQQhqIA8pAwA3AAAMFQsgBCAFQdgCEDkiCkGQEmogCkHYAhA5GiAKQZASaiAKQeAUai0AACIBakHIAWohAgJAIAFBiAFGDQAgAkEAQYgBIAFrEDoaC0EAIQYgCkEAOgDgFCACQQE6AAAgCkHfFGoiASABLQAAQYABcjoAAANAIApBkBJqIAZqIgEgAS0AACABQcgBai0AAHM6AAAgAUEBaiICIAItAAAgAUHJAWotAABzOgAAIAFBAmoiAiACLQAAIAFBygFqLQAAczoAACABQQNqIgIgAi0AACABQcsBai0AAHM6AAAgBkEEaiIGQYgBRw0ACyAKQZASahAkIApB+A5qQRhqIgEgCkGQEmpBGGopAwA3AwAgCkH4DmpBEGoiAiAKQZASakEQaikDADcDACAKQfgOakEIaiIPIApBkBJqQQhqKQMANwMAIAogCikDkBI3A/gOQSAhA0EgEBYiBkUNHCAGIAopA/gONwAAIAZBGGogASkDADcAACAGQRBqIAIpAwA3AAAgBkEIaiAPKQMANwAADBQLIAQgBUG4AhA5IgpBkBJqIApBuAIQORogCkGQEmogCkHAFGotAAAiAWpByAFqIQICQCABQegARg0AIAJBAEHoACABaxA6GgtBACEGIApBADoAwBQgAkEBOgAAIApBvxRqIgEgAS0AAEGAAXI6AAADQCAKQZASaiAGaiIBIAEtAAAgAUHIAWotAABzOgAAIAFBAWoiAiACLQAAIAFByQFqLQAAczoAACABQQJqIgIgAi0AACABQcoBai0AAHM6AAAgAUEDaiICIAItAAAgAUHLAWotAABzOgAAIAZBBGoiBkHoAEcNAAsgCkGQEmoQJCAKQfgOakEoaiIBIApBkBJqQShqKQMANwMAIApB+A5qQSBqIgIgCkGQEmpBIGopAwA3AwAgCkH4DmpBGGoiDyAKQZASakEYaikDADcDACAKQfgOakEQaiILIApBkBJqQRBqKQMANwMAIApB+A5qQQhqIgwgCkGQEmpBCGopAwA3AwAgCiAKKQOQEjcD+A5BMCEDQTAQFiIGRQ0cIAYgCikD+A43AAAgBkEoaiABKQMANwAAIAZBIGogAikDADcAACAGQRhqIA8pAwA3AAAgBkEQaiALKQMANwAAIAZBCGogDCkDADcAAAwTCyAEIAVBmAIQOSIKQZASaiAKQZgCEDkaIApBkBJqIApBoBRqLQAAIgFqQcgBaiECAkAgAUHIAEYNACACQQBByAAgAWsQOhoLQQAhBiAKQQA6AKAUIAJBAToAACAKQZ8UaiIBIAEtAABBgAFyOgAAA0AgCkGQEmogBmoiASABLQAAIAFByAFqLQAAczoAACABQQFqIgIgAi0AACABQckBai0AAHM6AAAgAUECaiICIAItAAAgAUHKAWotAABzOgAAIAFBA2oiAiACLQAAIAFBywFqLQAAczoAACAGQQRqIgZByABHDQALIApBkBJqECQgCkH4DmpBOGoiASAKQZASakE4aikDADcDACAKQfgOakEwaiICIApBkBJqQTBqKQMANwMAIApB+A5qQShqIg8gCkGQEmpBKGopAwA3AwAgCkH4DmpBIGoiCyAKQZASakEgaikDADcDACAKQfgOakEYaiIMIApBkBJqQRhqKQMANwMAIApB+A5qQRBqIg0gCkGQEmpBEGopAwA3AwAgCkH4DmpBCGoiECAKQZASakEIaikDADcDACAKIAopA5ASNwP4DkHAACEDQcAAEBYiBkUNHCAGIAopA/gONwAAIAZBOGogASkDADcAACAGQTBqIAIpAwA3AAAgBkEoaiAPKQMANwAAIAZBIGogCykDADcAACAGQRhqIAwpAwA3AAAgBkEQaiANKQMANwAAIAZBCGogECkDADcAAAwSCyAEIAVB4AAQOSIBQfgOakEMakIANwIAIAFCADcC/A5BECEDIAFBEDYC+A4gAUGQEmpBEGogAUH4DmpBEGooAgA2AgAgAUGQEmpBCGogAUH4DmpBCGopAwA3AwAgAUHoI2pBCGoiAiABQZASakEMaikCADcDACABIAEpA/gONwOQEiABIAEpApQSNwPoIyABQZASaiABQeAAEDkaIAFBkBJqIAFBqBJqIAFB6CNqEC9BEBAWIgZFDRwgBiABKQPoIzcAACAGQQhqIAIpAwA3AAAMEQsgBCAFQeAAEDkiAUH4DmpBDGpCADcCACABQgA3AvwOQRAhAyABQRA2AvgOIAFBkBJqQRBqIAFB+A5qQRBqKAIANgIAIAFBkBJqQQhqIAFB+A5qQQhqKQMANwMAIAFB6CNqQQhqIgIgAUGQEmpBDGopAgA3AwAgASABKQP4DjcDkBIgASABKQKUEjcD6CMgAUGQEmogAUHgABA5GiABQZASaiABQagSaiABQegjahAuQRAQFiIGRQ0cIAYgASkD6CM3AAAgBkEIaiACKQMANwAADBALQRQhAyAEIAVB6AAQOSIBQfgOakEUakEANgIAIAFB+A5qQQxqQgA3AgAgAUEANgL4DiABQgA3AvwOIAFBFDYC+A4gAUGQEmpBEGogAUH4DmpBEGopAwA3AwAgAUGQEmpBCGogAUH4DmpBCGopAwA3AwAgAUHoI2pBCGoiAiABQZASakEMaikCADcDACABQegjakEQaiIKIAFBkBJqQRRqKAIANgIAIAEgASkD+A43A5ASIAEgASkClBI3A+gjIAFBkBJqIAFB6AAQORogAUGQEmogAUGwEmogAUHoI2oQLUEUEBYiBkUNHCAGIAEpA+gjNwAAIAZBEGogCigCADYAACAGQQhqIAIpAwA3AAAMDwtBFCEDIAQgBUHoABA5IgFB+A5qQRRqQQA2AgAgAUH4DmpBDGpCADcCACABQQA2AvgOIAFCADcC/A4gAUEUNgL4DiABQZASakEQaiABQfgOakEQaikDADcDACABQZASakEIaiABQfgOakEIaikDADcDACABQegjakEIaiICIAFBkBJqQQxqKQIANwMAIAFB6CNqQRBqIgogAUGQEmpBFGooAgA2AgAgASABKQP4DjcDkBIgASABKQKUEjcD6CMgAUGQEmogAUHoABA5GiABQZASaiABQbASaiABQegjahAoQRQQFiIGRQ0cIAYgASkD6CM3AAAgBkEQaiAKKAIANgAAIAZBCGogAikDADcAAAwOCyAEIAVB4AIQOSIKQZASaiAKQeACEDkaIApBkBJqIApB6BRqLQAAIgFqQcgBaiECAkAgAUGQAUYNACACQQBBkAEgAWsQOhoLQQAhBiAKQQA6AOgUIAJBBjoAACAKQecUaiIBIAEtAABBgAFyOgAAA0AgCkGQEmogBmoiASABLQAAIAFByAFqLQAAczoAACABQQFqIgIgAi0AACABQckBai0AAHM6AAAgAUECaiICIAItAAAgAUHKAWotAABzOgAAIAFBA2oiAiACLQAAIAFBywFqLQAAczoAACAGQQRqIgZBkAFHDQALIApBkBJqECQgCkH4DmpBGGoiASAKQZASakEYaigCADYCACAKQfgOakEQaiICIApBkBJqQRBqKQMANwMAIApB+A5qQQhqIg8gCkGQEmpBCGopAwA3AwAgCiAKKQOQEjcD+A5BHCEDQRwQFiIGRQ0cIAYgCikD+A43AAAgBkEYaiABKAIANgAAIAZBEGogAikDADcAACAGQQhqIA8pAwA3AAAMDQsgBCAFQdgCEDkiCkGQEmogCkHYAhA5GiAKQZASaiAKQeAUai0AACIBakHIAWohAgJAIAFBiAFGDQAgAkEAQYgBIAFrEDoaC0EAIQYgCkEAOgDgFCACQQY6AAAgCkHfFGoiASABLQAAQYABcjoAAANAIApBkBJqIAZqIgEgAS0AACABQcgBai0AAHM6AAAgAUEBaiICIAItAAAgAUHJAWotAABzOgAAIAFBAmoiAiACLQAAIAFBygFqLQAAczoAACABQQNqIgIgAi0AACABQcsBai0AAHM6AAAgBkEEaiIGQYgBRw0ACyAKQZASahAkIApB+A5qQRhqIgEgCkGQEmpBGGopAwA3AwAgCkH4DmpBEGoiAiAKQZASakEQaikDADcDACAKQfgOakEIaiIPIApBkBJqQQhqKQMANwMAIAogCikDkBI3A/gOQSAhA0EgEBYiBkUNHCAGIAopA/gONwAAIAZBGGogASkDADcAACAGQRBqIAIpAwA3AAAgBkEIaiAPKQMANwAADAwLIAQgBUG4AhA5IgpBkBJqIApBuAIQORogCkGQEmogCkHAFGotAAAiAWpByAFqIQICQCABQegARg0AIAJBAEHoACABaxA6GgtBACEGIApBADoAwBQgAkEGOgAAIApBvxRqIgEgAS0AAEGAAXI6AAADQCAKQZASaiAGaiIBIAEtAAAgAUHIAWotAABzOgAAIAFBAWoiAiACLQAAIAFByQFqLQAAczoAACABQQJqIgIgAi0AACABQcoBai0AAHM6AAAgAUEDaiICIAItAAAgAUHLAWotAABzOgAAIAZBBGoiBkHoAEcNAAsgCkGQEmoQJCAKQfgOakEoaiIBIApBkBJqQShqKQMANwMAIApB+A5qQSBqIgIgCkGQEmpBIGopAwA3AwAgCkH4DmpBGGoiDyAKQZASakEYaikDADcDACAKQfgOakEQaiILIApBkBJqQRBqKQMANwMAIApB+A5qQQhqIgwgCkGQEmpBCGopAwA3AwAgCiAKKQOQEjcD+A5BMCEDQTAQFiIGRQ0cIAYgCikD+A43AAAgBkEoaiABKQMANwAAIAZBIGogAikDADcAACAGQRhqIA8pAwA3AAAgBkEQaiALKQMANwAAIAZBCGogDCkDADcAAAwLCyAEIAVBmAIQOSIKQZASaiAKQZgCEDkaIApBkBJqIApBoBRqLQAAIgFqQcgBaiECAkAgAUHIAEYNACACQQBByAAgAWsQOhoLQQAhBiAKQQA6AKAUIAJBBjoAACAKQZ8UaiIBIAEtAABBgAFyOgAAA0AgCkGQEmogBmoiASABLQAAIAFByAFqLQAAczoAACABQQFqIgIgAi0AACABQckBai0AAHM6AAAgAUECaiICIAItAAAgAUHKAWotAABzOgAAIAFBA2oiAiACLQAAIAFBywFqLQAAczoAACAGQQRqIgZByABHDQALIApBkBJqECQgCkH4DmpBOGoiASAKQZASakE4aikDADcDACAKQfgOakEwaiICIApBkBJqQTBqKQMANwMAIApB+A5qQShqIg8gCkGQEmpBKGopAwA3AwAgCkH4DmpBIGoiCyAKQZASakEgaikDADcDACAKQfgOakEYaiIMIApBkBJqQRhqKQMANwMAIApB+A5qQRBqIg0gCkGQEmpBEGopAwA3AwAgCkH4DmpBCGoiECAKQZASakEIaikDADcDACAKIAopA5ASNwP4DkHAACEDQcAAEBYiBkUNHCAGIAopA/gONwAAIAZBOGogASkDADcAACAGQTBqIAIpAwA3AAAgBkEoaiAPKQMANwAAIAZBIGogCykDADcAACAGQRhqIAwpAwA3AAAgBkEQaiANKQMANwAAIAZBCGogECkDADcAAAwKCyAEIAVB8AAQOSIBQZASaiABQfAAEDkaQRwhAyABQegjakEcakIANwIAIAFB6CNqQRRqQgA3AgAgAUHoI2pBDGpCADcCACABQgA3AuwjIAFBIDYC6CMgAUH4DmpBGGoiAiABQegjakEYaikDADcDACABQfgOakEQaiIKIAFB6CNqQRBqKQMANwMAIAFB+A5qQQhqIg8gAUHoI2pBCGopAwA3AwAgAUH4DmpBIGogAUHoI2pBIGooAgA2AgAgASABKQPoIzcD+A4gAUG4ImpBEGoiBiABQfgOakEUaikCADcDACABQbgiakEIaiILIAFB+A5qQQxqKQIANwMAIAFBuCJqQRhqIgwgAUH4DmpBHGopAgA3AwAgASABKQL8DjcDuCIgAUGQEmogAUG4EmogAUG4ImoQJyACIAwoAgA2AgAgCiAGKQMANwMAIA8gCykDADcDACABIAEpA7giNwP4DkEcEBYiBkUNHCAGIAEpA/gONwAAIAZBGGogAigCADYAACAGQRBqIAopAwA3AAAgBkEIaiAPKQMANwAADAkLIAQgBUHwABA5IgFBkBJqIAFB8AAQORogAUHoI2pBHGpCADcCACABQegjakEUakIANwIAIAFB6CNqQQxqQgA3AgAgAUIANwLsI0EgIQMgAUEgNgLoIyABQfgOakEgaiABQegjakEgaigCADYCACABQfgOakEYaiICIAFB6CNqQRhqKQMANwMAIAFB+A5qQRBqIgogAUHoI2pBEGopAwA3AwAgAUH4DmpBCGoiDyABQegjakEIaikDADcDACABIAEpA+gjNwP4DiABQbgiakEYaiIGIAFB+A5qQRxqKQIANwMAIAFBuCJqQRBqIgsgAUH4DmpBFGopAgA3AwAgAUG4ImpBCGoiDCABQfgOakEMaikCADcDACABIAEpAvwONwO4IiABQZASaiABQbgSaiABQbgiahAnIAIgBikDADcDACAKIAspAwA3AwAgDyAMKQMANwMAIAEgASkDuCI3A/gOQSAQFiIGRQ0cIAYgASkD+A43AAAgBkEYaiACKQMANwAAIAZBEGogCikDADcAACAGQQhqIA8pAwA3AAAMCAsgBCAFQdgBEDkiAUGQEmogAUHYARA5GiABQegjakEMakIANwIAIAFB6CNqQRRqQgA3AgAgAUHoI2pBHGpCADcCACABQegjakEkakIANwIAIAFB6CNqQSxqQgA3AgAgAUHoI2pBNGpCADcCACABQegjakE8akIANwIAIAFCADcC7CMgAUHAADYC6CMgAUH4DmogAUHoI2pBxAAQORogAUHwImogAUH4DmpBPGopAgA3AwBBMCEDIAFBuCJqQTBqIAFB+A5qQTRqKQIANwMAIAFBuCJqQShqIgYgAUH4DmpBLGopAgA3AwAgAUG4ImpBIGoiAiABQfgOakEkaikCADcDACABQbgiakEYaiIKIAFB+A5qQRxqKQIANwMAIAFBuCJqQRBqIg8gAUH4DmpBFGopAgA3AwAgAUG4ImpBCGoiCyABQfgOakEMaikCADcDACABIAEpAvwONwO4IiABQZASaiABQeASaiABQbgiahAiIAFB+A5qQShqIgwgBikDADcDACABQfgOakEgaiINIAIpAwA3AwAgAUH4DmpBGGoiAiAKKQMANwMAIAFB+A5qQRBqIgogDykDADcDACABQfgOakEIaiIPIAspAwA3AwAgASABKQO4IjcD+A5BMBAWIgZFDRwgBiABKQP4DjcAACAGQShqIAwpAwA3AAAgBkEgaiANKQMANwAAIAZBGGogAikDADcAACAGQRBqIAopAwA3AAAgBkEIaiAPKQMANwAADAcLIAQgBUHYARA5IgFBkBJqIAFB2AEQORogAUHoI2pBDGpCADcCACABQegjakEUakIANwIAIAFB6CNqQRxqQgA3AgAgAUHoI2pBJGpCADcCACABQegjakEsakIANwIAIAFB6CNqQTRqQgA3AgAgAUHoI2pBPGpCADcCACABQgA3AuwjQcAAIQMgAUHAADYC6CMgAUH4DmogAUHoI2pBxAAQORogAUG4ImpBOGoiBiABQfgOakE8aikCADcDACABQbgiakEwaiICIAFB+A5qQTRqKQIANwMAIAFBuCJqQShqIgogAUH4DmpBLGopAgA3AwAgAUG4ImpB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QaADakEYaiIKIARBKGpBHGopAgA3AwAgBEGgA2pBEGoiCyAEQShqQRRqKQIANwMAIARBoANqQQhqIgwgBEEoakEMaikCADcDACAEIAQpAiw3A6ADIAIgAikDQCACQcgBaiIDLQAAIgGtfDcDQCACQcgAaiEFAkAgAUGAAUYNACAFIAFqQQBBgAEgAWsQOhoLQQAhASADQQA6AAAgAiAFQn8QESAEQShqQQhqIgUgAkEIaikDACIQNwMAIARBKGpBEGogAkEQaikDACIRNwMAIARBKGpBGGogAkEYaikDACISNwMAIARBKGpBIGogAikDICITNwMAIARBKGpBKGogAkEoaikDACIUNwMAIAwgEDcDACALIBE3AwAgCiASNwMAIAkgEzcDACAIIBQ3AwAgByACQTBqKQMANwMAIAYgAkE4aikDADcDACAEIAIpAwAiEDcDKCAEIBA3A6ADIAVBwAAQTyACIAVByAAQORogA0EAOgAAQcAAEBYiAkUNGiACIAQpA6ADNwAAIAJBOGogBEGgA2pBOGopAwA3AAAgAkEwaiAEQaADakEwaikDADcAACACQShqIARBoANqQShqKQMANwAAIAJBIGogBEGgA2pBIGopAwA3AAAgAkEYaiAEQaADakEYaikDADcAACACQRBqIARBoANqQRBqKQMANwAAIAJBCGogBEGgA2pBCGopAwA3AABBwAAhAwwyCyABKAIEIQIgBEHQBGpBHGpCADcCACAEQdAEakEUakIANwIAIARB0ARqQQxqQgA3AgAgBEIANwLUBCAEQSA2AtAEIARBKGpBGGoiByAEQdAEakEYaikDADcDACAEQShqQRBqIgggBEHQBGpBEGopAwA3AwAgBEEoakEIaiIDIARB0ARqQQhqKQMANwMAIARBKGpBIGoiCSAEQdAEakEgaigCADYCACAEIAQpA9AENwMoIARBoANqQRBqIgogBEEoakEUaikCADcDACAEQaADakEIaiILIARBKGpBDGopAgA3AwAgBEGgA2pBGGoiDCAEQShqQRxqKQIANwMAIAQgBCkCLDcDoAMgAiACKQNAIAJByAFqIgUtAAAiAa18NwNAIAJByABqIQYCQCABQYABRg0AIAYgAWpBAEGAASABaxA6GgtBACEBIAVBADoAACACIAZCfxARIAMgAkEIaikDACIQNwMAIAggAkEQaikDACIRNwMAIAcgAkEYaikDACISNwMAIAkgAikDIDcDACAEQShqQShqIAJBKGopAwA3AwAgCyAQNwMAIAogETcDACAMIBI3AwAgBCACKQMAIhA3AyggBCAQNwOgAyADQSAQTyACIANByAAQORogBUEAOgAAQSAQFiICRQ0aIAIgBCkDoAM3AAAgAkEYaiAEQaADakEYaikDADcAACACQRBqIARBoANqQRBqKQMANwAAIAJBCGogBEGgA2pBCGopAwA3AABBICEDDDELIAEoAgQhAiAEQdAEakEsakIANwIAIARB0ARqQSRqQgA3AgAgBEHQBGpBHGpCADcCACAEQdAEakEUakIANwIAIARB0ARqQQxqQgA3AgAgBEIANwLUBCAEQTA2AtAEIARBKGpBKGoiByAEQdAEakEoaikDADcDACAEQShqQSBqIgggBEHQBGpBIGopAwA3AwAgBEEoakEYaiIJIARB0ARqQRhqKQMANwMAIARBKGpBEGoiCiAEQdAEakEQaikDADcDACAEQShqQQhqIgMgBEHQBGpBCGopAwA3AwAgBEEoakEwaiAEQdAEakEwaigCADYCACAEIAQpA9AENwMoIARBoANqQSBqIgsgBEEoakEkaikCADcDACAEQaADakEYaiIMIARBKGpBHGopAgA3AwAgBEGgA2pBEGoiDSAEQShqQRRqKQIANwMAIARBoANqQQhqIg4gBEEoakEMaikCADcDACAEQaADakEoaiIPIARBKGpBLGopAgA3AwAgBCAEKQIsNwOgAyACIAIpA0AgAkHIAWoiBS0AACIBrXw3A0AgAkHIAGohBgJAIAFBgAFGDQAgBiABakEAQYABIAFrEDoaC0EAIQEgBUEAOgAAIAIgBkJ/EBEgAyACQQhqKQMAIhA3AwAgCiACQRBqKQMAIhE3AwAgCSACQRhqKQMAIhI3AwAgCCACKQMgIhM3AwAgByACQShqKQMAIhQ3AwAgDiAQNwMAIA0gETcDACAMIBI3AwAgCyATNwMAIA8gFDcDACAEIAIpAwAiEDcDKCAEIBA3A6ADIANBMBBPIAIgA0HIABA5GiAFQQA6AABBMBAWIgJFDRogAiAEKQOgAzcAACACQShqIARBoANqQShqKQMANwAAIAJBIGogBEGgA2pBIGopAwA3AAAgAkEYaiAEQaADakEYaikD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QQhqKQMANwMAIARBKGpBIGogBEHQBGpBIGooAgA2AgAgBCAEKQPQBDcDKCAEQaADakEQaiIBIARBKGpBFGopAgA3AwAgBEGgA2pBCGoiCCAEQShqQQxqKQIANwMAIARBoANqQRhqIgkgBEEoakEcaikCADcDACAEIAQpAiw3A6ADIAIgAkEoaiAEQaADahAnIAUgCSgCADYCACAGIAEpAwA3AwAgByAIKQMANwMAIAQgBCkDoAM3AyggAkIANwMAQQAhASACQegAakEAOgAAIAJBACkDkI5ANwMIIAJBEGpBACkDmI5ANwMAIAJBGGpBACkDoI5ANwMAIAJBIGpBACkDqI5ANwMAQRwQFiICRQ0aIAIgBCkDKDcAACACQRhqIAUoAgA2AAAgAkEQaiAGKQMANwAAIAJBCGogBykDADcAAAwhCyABKAIEIQIgBEHQBGpBHGpCADcCACAEQdAEakEUakIANwIAIARB0ARqQQxqQgA3AgAgBEIANwLUBEEgIQMgBEEgNgLQBCAEQShqQSBqIARB0ARqQSBqKAIANgIAIARBKGpBGGoiBSAEQdAEakEYaikDADcDACAEQShqQRBqIgYgBEHQBGpBEGopAwA3AwAgBEEoakEIaiIHIARB0ARqQQhqKQMANwMAIAQgBCkD0AQ3AyggBEGgA2pBGGoiASAEQShqQRxqKQIANwMAIARBoANqQRBqIgggBEEoakEUaikCADcDACAEQaADakEIaiIJIARBKGpBDGopAgA3AwAgBCAEKQIsNwOgAyACIAJBKGogBEGgA2oQJyAFIAEpAwA3AwAgBiAIKQMANwMAIAcgCSkDADcDACAEIAQpA6ADNwMoIAJCADcDAEEAIQEgAkHoAGpBADoAACACQQApA/CNQDcDCCACQRBqQQApA/iNQDcDACACQRhqQQApA4COQDcDACACQSBqQQApA4iOQDcDAEEgEBYiAkUNGiACIAQpAyg3AAAgAkEYaiAFKQMANwAAIAJBEGogBikDADcAACACQQhqIAcpAwA3AAAMIAsgASgCBCECIARB0ARqQQxqQgA3AgAgBEHQBGpBFGpCADcCACAEQdAEakEcakIANwIAIARB0ARqQSRqQgA3AgAgBEHQBGpBLGpCADcCACAEQdAEakE0akIANwIAIARB0ARqQTxqQgA3AgAgBEIANwLUBCAEQcAANgLQBCAEQShqIARB0ARqQcQAEDkaIARBoANqQThqIARBKGpBPGopAgA3AwBBMCEDIARBoANqQTBqIARBKGpBNGopAgA3AwAgBEGgA2pBKGoiASAEQShqQSxqKQIANwMAIARBoANqQSBqIgUgBEEoakEkaikCADcDACAEQaADakEYaiIGIARBKGpBHGopAgA3AwAgBEGgA2pBEGoiByAEQShqQRRqKQIANwMAIARBoANqQQhqIgggBEEoakEMaikCADcDACAEIAQpAiw3A6ADIAIgAkHQAGogBEGgA2oQIiAEQShqQShqIgkgASkDADcDACAEQShqQSBqIgogBSkDADcDACAEQShqQRhqIgUgBikDADcDACAEQShqQRBqIgYgBykDADcDACAEQShqQQhqIgcgCCkDADcDACAEIAQpA6ADNwMoIAJByABqQgA3AwAgAkIANwNAQQAhASACQThqQQApA6iPQDcDACACQTBqQQApA6CPQDcDACACQShqQQApA5iPQDcDACACQSBqQQApA5CPQDcDACACQRhqQQApA4iPQDcDACACQRBqQQApA4CPQDcDACACQQhqQQApA/iOQDcDACACQQApA/COQDcDACACQdABakEAOgAAQTAQFiICRQ0aIAIgBCkDKDcAACACQShqIAkpAwA3AAAgAkEgaiAKKQMANwAAIAJBGGogBSkDADcAACACQRBqIAYpAwA3AAAgAkEIaiAHKQMANwAADB8LIAEoAgQhAiAEQdAEakEMakIANwIAIARB0ARqQRRqQgA3AgAgBEHQBGpBHGpCADcCACAEQdAEakEkakIANwIAIARB0ARqQSxqQgA3AgAgBEHQBGpBNGpCADcCACAEQdAEakE8akIANwIAIARCADcC1ARBwAAhAyAEQcAANgLQBCAEQShqIARB0ARqQcQAEDkaIARBoANqQThqIgEgBEEoakE8aikCADcDACAEQaADakEwaiIFIARBKGpBNGopAgA3AwAgBEGgA2pBKGoiBiAEQShqQSxqKQIANwMAIARBoANqQSBqIgcgBEEoakEkaikCADcDACAEQaADakEYaiIIIARBKGpBHGopAgA3AwAgBEGgA2pBEGoiCSAEQShqQRRqKQIANwMAIARBoANqQQhqIgogBEEoakEMaikCADcDACAEIAQpAiw3A6ADIAIgAkHQAGogBEGgA2oQIiAEQShqQThqIgsgASkDADcDACAEQShqQTBqIgwgBSkDADcDACAEQShqQShqIgUgBikDADcDACAEQShqQSBqIgYgBykDADcDACAEQShqQRhqIgcgCCkDADcDACAEQShqQRBqIgggCSkDADcDACAEQShqQQhqIgkgCikDADcDACAEIAQpA6ADNwMoIAJByABqQgA3AwAgAkIANwNAQQAhASACQThqQQApA+iOQDcDACACQTBqQQApA+COQDcDACACQShqQQApA9iOQDcDACACQSBqQQApA9COQDcDACACQRhqQQApA8iOQDcDACACQRBqQQApA8COQDcDACACQQhqQQApA7iOQDcDACACQQApA7COQDcDACACQdABakEAOgAAQcAAEBYiAkUNGiACIAQpAyg3AAAgAkE4aiALKQMANwAAIAJBMGogDCkDADcAACACQShqIAUpAwA3AAAgAkEgaiAGKQMANwAAIAJBGGogBykDADcAACACQRBqIAgpAwA3AAAgAkEIaiAJKQMANwAADB4LIANBAEgNASABKAIEIQcCQAJAIAMNAEEBIQIMAQsgAxAWIgJFDRsgAkF8ai0AAEEDcUUNACACQQAgAxA6GgsgByAHQfACaiIILQAAIgFqQcgBaiEGAkAgAUGoAUYNACAGQQBBqAEgAWsQOhoLQQAhBSAIQQA6AAAgBkEfOgAAIAdB7wJqIgEgAS0AAEGAAXI6AAADQCAHIAVqIgEgAS0AACABQcgBai0AAHM6AAAgAUEBaiIGIAYtAAAgAUHJAWotAABzOgAAIAFBAmoiBiAGLQAAIAFBygFqLQAAczoAACABQQNqIgYgBi0AACABQcsBai0AAHM6AAAgBUEEaiIFQagBRw0ACyAHECQgBEEoaiAHQcgBEDkaQQAhASAHQQBByAEQOkHwAmpBADoAACAEQQA2AqADIARBoANqQQRyQQBBqAEQOhogBEGoATYCoAMgBEHQBGogBEGgA2pBrAEQORogBEEoakHIAWogBEHQBGpBBHJBqAEQORogBEEoakHwAmpBADoAACAEQShqIAIgAxAxDB0LIANBAEgNACABKAIEIQcgAw0BQQEhAgwCCxBpAAsgAxAWIgJFDRggAkF8ai0AAEEDcUUNACACQQAgAxA6GgsgByAHQdACaiIILQAAIgFqQcgBaiEG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B3QhBiABIQUDQCAAIAApA0BCgAF8NwNAIAAgBUIAEBEgBUGAAWohBSAGQYB/aiIGDQAMQgsLIAQgBWogASACEDkaIAUgAmohAgxBCyAAKAIEIgBByABqIQQCQEGAASAAQcgBai0AACIFayIGIAJPDQACQCAFRQ0AIAQgBWogASAGEDkaIAAgACkDQEKAAXw3A0AgACAEQgAQESABIAZqIQEgAiAGayECCyACIAJBB3YiBiACQQBHIAJB/wBxRXEiB2siBUEHdCIIayECIAVFDT0gCEUNPSAGQQAgB2tqQQd0IQYgASEFA0AgACAAKQNAQoABfDcDQCAAIAVCABARIAVBgAFqIQUgBkGAf2oiBg0ADD4LCyAEIAVqIAEgAhA5GiAFIAJqIQIMPQsgACgCBCIAQShqIQQCQEHAACAAQegAai0AACIFayIGIAJPDQACQCAFRQ0AIAQgBWogASAGEDkaIAAgACkDAELAAHw3AwAgACAEQQAQEyABIAZqIQEgAiAGayECCyACIAJBBnYiBiACQQBHIAJBP3FFcSIHayIFQQZ0IghrIQIgBUUNOSAIRQ05IAZBACAHa2pBBnQhBiABIQUDQCAAIAApAwBCwAB8NwMAIAAgBUEAEBMgBUHAAGohBSAGQUBqIgYNAAw6CwsgBCAFaiABIAIQORogBSACaiECDDkLIAAoAgQiCEHpAGotAABBBnQgCC0AaGoiAEUNNiAIIAEgAkGACCAAayIAIAAgAksbIgUQMxogAiAFayICRQ1CIANB+ABqQRBqIAhBEGoiACkDADcDACADQfgAakEYaiAIQRhqIgYpAwA3AwAgA0H4AGpBIGogCEEgaiIEKQMANwMAIANB+ABqQTBqIAhBMGopAwA3AwAgA0H4AGpBOGogCEE4aikDADcDACADQfgAakHAAGogCEHAAGopAwA3AwAgA0H4AGpByABqIAhByABqKQMANwMAIANB+ABqQdAAaiAIQdAAaikDADcDACADQfgAakHYAGogCEHYAGopAwA3AwAgA0H4AGpB4ABqIAhB4ABqKQMANwMAIAMgCCkDCDcDgAEgAyAIKQMoNwOgASAIQekAai0AACEHIAgtAGohCSADIAgtAGgiCjoA4AEgAyAIKQMAIh03A3ggAyAJIAdFckECciIHOgDhASADQegBakEYaiIJIAQpAgA3AwAgA0HoAWpBEGoiBCAGKQIANwMAIANB6AFqQQhqIgYgACkCADcDACADIAgpAgg3A+gBIANB6AFqIANB+ABqQShqIAogHSAHEBkgCSgCACEHIAQoAgAhBCAGKAIAIQkgAygChAIhCiADKAL8ASELIAMoAvQBIQwgAygC7AEhDSADKALoASEOIAggCCkDABApIAgoApABIgZBN08NEyAIQZABaiAGQQV0aiIAQSBqIAo2AgAgAEEcaiAHNgIAIABBGGogCzYCACAAQRRqIAQ2AgAgAEEQaiAMNgIAIABBDGogCTYCACAAQQhqIA02AgAgAEEEaiAONgIAIAggBkEBajYCkAEgCEEoaiIAQgA3AwAgAEEIakIANwMAIABBEGpCADcDACAAQRhqQgA3AwAgAEEgakIANwMAIABBKGpCADcDACAAQTBqQgA3AwAgAEE4akIANwMAIAhBADsBaCAIQQhqIgAgCCkDcDcDACAAQQhqIAhB+ABqKQMANwMAIABBEGogCEGAAWopAwA3AwAgAEEYaiAIQYgBaikDADcDACAIIAgpAwBCAXw3AwAgASAFaiEBDDYLIAAoAgQiBEHIAWohCgJAQZABIARB2AJqLQAAIgBrIgggAksNAAJAIABFDQAgCiAAaiABIAgQORogAiAIayECQQAhBQNAIAQgBWoiACAALQAAIABByAFqLQAAczoAACAAQQFqIgYgBi0AACAAQckBai0AAHM6AAAgAEECaiIGIAYtAAAgAEHKAWotAABzOgAAIABBA2oiBiAGLQAAIABBywFqLQAAczoAACAFQQRqIgVBkAFHDQALIAQQJCABIAhqIQELIAEgAkGQAW5BkAFsIgBqIQcgAiAAayEJIAJBjwFNDTMgAEUNMwNAIAFBkAFqIQhBACEFA0AgBCAFaiIAIAAtAAAgASAFaiIGLQAAczoAACAAQQFqIgIgAi0AACAGQQFqLQAAczoAACAAQQJqIgIgAi0AACAGQQJqLQAAczoAACAAQQNqIgAgAC0AACAGQQNqLQAAczoAACAFQQRqIgVBkAFHDQALIAQQJCAIIQEgCCAHRg00DAALCyAKIABqIAEgAhA5GiAAIAJqIQkMMwsgACgCBCIEQcgBaiEKAkBBiAEgBEHQAmotAAAiAGsiCCACSw0AAkAgAEUNACAKIABqIAEgCBA5GiACIAhrIQJBACEFA0AgBCAFaiIAIAAtAAAgAEHIAWotAABzOgAAIABBAWoiBiAGLQAAIABByQFqLQAAczoAACAAQQJqIgYgBi0AACAAQcoBai0AAHM6AAAgAEEDaiIGIAYtAAAgAEHLAWotAABzOgAAIAVBBGoiBUGIAUcNAAsgBBAkIAEgCGohAQsgASACQYgBbkGIAWwiAGohByACIABrIQkgAkGHAU0NLyAARQ0vA0AgAUGIAWohCEEAIQUDQCAEIAVqIgAgAC0AACABIAVqIgYtAABzOgAAIABBAWoiAiACLQAAIAZBAWotAABzOgAAIABBAmoiAiACLQAAIAZBAmotAABzOgAAIABBA2oiACAALQAAIAZBA2otAABzOgAAIAVBBGoiBUGIAUcNAAsgBBAkIAghASAIIAdGDTAMAAsLIAogAGogASACEDkaIAAgAmohCQwvCyAAKAIEIgRByAFqIQoCQEHoACAEQbACai0AACIAayIIIAJLDQACQCAARQ0AIAogAGogASAIEDkaIAIgCGshAkEAIQUDQCAEIAVqIgAgAC0AACAAQcgBai0AAHM6AAAgAEEBaiIGIAYtAAAgAEHJAWotAABzOgAAIABBAmoiBiAGLQAAIABBygFqLQAAczoAACAAQQNqIgYgBi0AACAAQcsBai0AAHM6AAAgBUEEaiIFQegARw0ACyAEECQgASAIaiEBCyABIAJB6ABuQegAbCIAaiEHIAIgAGshCSACQecATQ0rIABFDSsDQCABQegAaiEIQQAhBQNAIAQgBWoiACAALQAAIAEgBWoiBi0AAHM6AAAgAEEBaiICIAItAAAgBkEBai0AAHM6AAAgAEECaiICIAItAAAgBkECai0AAHM6AAAgAEEDaiIAIAAtAAAgBkEDai0AAHM6AAAgBUEEaiIFQegARw0ACyAEECQgCCEBIAggB0YNLAwACwsgCiAAaiABIAIQORogACACaiEJDCsLIAAoAgQiBEHIAWohCgJAQcgAIARBkAJqLQAAIgBrIgggAksNAAJAIABFDQAgCiAAaiABIAgQORogAiAIayECQQAhBQNAIAQgBWoiACAALQAAIABByAFqLQAAczoAACAAQQFqIgYgBi0AACAAQckBai0AAHM6AAAgAEECaiIGIAYtAAAgAEHKAWotAABzOgAAIABBA2oiBiAGLQAAIABBywFq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OgDiASADQfgAaiABIAAQMxogDCALKQMANwMAIAxBCGogBSkDADcDACAMQRBqIAYpAwA3AwAgDEEYaiAHKQMANwMAIAogCSkDADcDACAKQQhqIA4pAwA3AwAgCkEQaiAXKQMANwMAIApBGGogGCkDADcDACAKQSBqIBkpAwA3AwAgCkEoaiAaKQMANwMAIApBMGogGykDADcDACAKQThqIBwpAwA3AwAgAy0A4gEhDiADLQDhASEXIAMgAy0A4AEiGDoAcCADIAMpA3giHjcDCCADIA4gF0VyQQJyIg46AHEgA0HoAWpBGGoiFyAHKQIANwMAIANB6AFqQRBqIgcgBikCADcDACADQegBakEIaiIGIAUpAgA3AwAgAyALKQIANwPoASADQegBaiAKIBggHiAOEBkgFygCACEOIAcoAgAhByAGKAIAIRcgAygChAIhGCADKAL8ASEZIAMoAvQBIRogAygC7AEhGyADKALoASEcIAggCCkDABApIAgoApABIgZBN08NCSANIAZBBXRqIgUgGDYCHCAFIA42AhggBSAZNgIUIAUgBzYCECAFIBo2AgwgBSAXNgIIIAUgGzYCBCAFIBw2AgAgCCAGQQFqNgKQAQsgCCAIKQMAIB18Ih43AwAgAiAASQ0JIAEgAGohASACIABrIgJBgAhLDQALCyACRQ0TIAggASACEDMaIAggCCkDABApDBMLIAAgAkGghcAAEEkACyAFQcAAQeCEwAAQSQALIAZBwABB8ITAABBJAAsgBkEgQYCFwAAQSQALIANBkAJqQQhqIgEgGjYCACADQZACakEQaiIAIBg2AgAgA0GQAmpBGGoiBSAONgIAIAMgGTYCnAIgA0GBAWoiBiABKQMANwAAIAMgFzYCpAIgA0GJAWoiASAAKQMANwAAIAMgBzYCrAIgA0GRAWoiACAFKQMANwAAIAMgGzYClAIgAyAcNgKQAiADIAMpA5ACNwB5IANBCGpBGGogACkAADcDACADQQhqQRBqIAEpAAA3AwAgA0EIakEIaiAGKQAANwMAIAMgAykAeTcDCEGQksAAIANBCGpBgIbAAEH4hsAAEEAACyADQZACakEIaiIBIBQ2AgAgA0GQAmpBEGoiACASNgIAIANBkAJqQRhqIgUgEDYCACADIBM2ApwCIANBgQFqIgYgASkDADcAACADIBE2AqQC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BEHYAGogAkGwAWpBNGopAgA3AAAgBEHQAGogAkGwAWpBLGopAgA3AAAgBEHIAGogAkGwAWpBJGopAgA3AAAgBEHAAGogAkGwAWpBHGopAgA3AAAgBEE4aiACQbABakEUaikCADcAACAEQTBqIAJBsAFqQQxqKQIANwAAIAQgAikCtAE3ACggBEEAOgBoQQMhBQwiCwJAAkACQAJAIANBuoDAAEEKEFFFDQAgA0HEgMAAQQoQUUUNASADQc6AwABBChBRRQ0CIANB2IDAAEEKEFFFDQMgA0HogMAAQQoQUQ0MQegAEBYiBEUNFiACQQxqQgA3AgAgAkEUakIANwIAIAJBHGpCADcCACACQSRqQgA3AgAgAkEsakIANwIAIAJBNGpCADcCACACQTxqQgA3AgAgAkIANwIEIAJBwAA2AgAgAkGwAWogAkHEABA5GiAEQdgAaiACQbABakE8aikCADcAACAEQdAAaiACQbABakE0aikCADcAACAEQcgAaiACQbABakEsaikCADcAACAEQcAAaiACQbABakEkaikCADcAACAEQThqIAJBsAFqQRxqKQIANwAAIARBMGogAkGwAWpBFGopAgA3AAAgBEEoaiACQbABakEMaikCADcAACAEIAIpArQBNwAgIARCADcDACAEQQA6AGAgBEEAKQPYjUA3AwggBEEQakEAKQPgjUA3AwAgBEEYakEAKALojUA2AgBBCyEFDCULQeACEBYiBEUNDyAEQQBByAEQOiEFIAJBADYCACACQQRyQQBBkAEQOhogAkGQATYCACACQbABaiACQZQBEDkaIAVByAFqIAJBsAFqQQRyQZABEDkaIAVBADoA2AJBBSEFDCQLQdgCEBYiBEUNDyAEQQBByAEQOiEFIAJBADYCACACQQRyQQBBiAEQOhogAkGIATYCACACQbABaiACQYwBEDkaIAVByAFqIAJBsAFqQQRyQYgBEDkaIAVBADoA0AJBBiEFDCMLQbgCEBYiBEUNDyAEQQBByAEQOiEFIAJBADYCACACQQRyQQBB6AAQOhogAkHoADYCACACQbABaiACQewAEDkaIAVByAFqIAJBsAFqQQRyQegAEDkaIAVBADoAsAJBByEFDCILQZgCEBYiBEUNDyAEQQBByAEQOiEFIAJBADYCACACQQRyQQBByAAQOhogAkHIADYCACACQbABaiACQcwAEDkaIAVByAFqIAJBsAFqQQRyQcgAEDkaIAVBADoAkAJBCCEFDCELAkAgA0HigMAAQQMQUUUNACADQeWAwABBAxBRDQhB4AAQFiIERQ0RIAJBDGpCADcCACACQRRqQgA3AgAgAkEcakIANwIAIAJBJGpCADcCACACQSxqQgA3AgAgAkE0akIANwIAIAJBPGpCADcCACACQgA3AgQgAkHAADYCACACQbABaiACQcQAEDkaIARB0ABqIAJBsAFqQTxqKQIANwAAIARByABqIAJBsAFqQTRqKQIANwAAIARBwABqIAJBsAFqQSxqKQIANwAAIARBOGogAkGwAWpBJGopAgA3AAAgBEEwaiACQbABakEcaikCADcAACAEQShqIAJBsAFqQRRqKQIANwAAIARBIGogAkGwAWpBDGopAgA3AAAgBCACKQK0ATcAGCAEQv6568XpjpWZEDcDECAEQoHGlLqW8ermbzcDCCAEQgA3AwAgBEEAOgBYQQohBQwhC0HgABAWIgRFDQ8gAkEMakIANwIAIAJBFGpCADcCACACQRxqQgA3AgAgAkEkakIANwIAIAJBLGpCADcCACACQTRqQgA3AgAgAkE8akIANwIAIAJCADcCBCACQcAANgIAIAJBsAFqIAJBxAAQORogBEHQAGogAkGwAWpBPGopAgA3AAAgBEHIAGogAkGwAWpBNGopAgA3AAAgBEHAAGogAkGwAWpBLGopAgA3AAAgBEE4aiACQbABakEkaikCADcAACAEQTBqIAJBsAFqQRxqKQIANwAAIARBKGogAkGwAWpBFGopAgA3AAAgBEEgaiACQbABakEMaikCADcAACAEIAIpArQBNwAYIARC/rnrxemOlZkQNwMQIARCgcaUupbx6uZvNwMIIARCADcDACAEQQA6AFhBCSEFDCALAkACQAJAAkAgAykAAELTkIWa08WMmTRRDQAgAykAAELTkIWa08XMmjZRDQEgAykAAELTkIWa0+WMnDRRDQIgAykAAELTkIWa06XNmDJRDQMgAykAAELTkIXa1KiMmThRDQcgAykAAELTkIXa1MjMmjZSDQpB2AIQFiIERQ0eIARBAEHIARA6IQUgAkEANgIAIAJBBHJBAEGIARA6GiACQYgBNgIAIAJBsAFqIAJBjAEQORogBUHIAWogAkGwAWpBBHJBiAEQORogBUEAOgDQAkEWIQUMIwtB4AIQFiIERQ0UIARBAEHIARA6IQUgAkEANgIAIAJBBHJBAEGQARA6GiACQZABNgIAIAJBsAFqIAJBlAEQORogBUHIAWogAkGwAWpBBHJBkAEQORogBUEAOgDYAkENIQUMIgtB2AIQFiIERQ0UIARBAEHIARA6IQUgAkEANgIAIAJBBHJBAEGIARA6GiACQYgBNgIAIAJBsAFqIAJBjAEQORogBUHIAWogAkGwAWpBBHJBiAEQORogBUEAOgDQAkEOIQUMIQtBuAIQFiIERQ0UIARBAEHIARA6IQUgAkEANgIAIAJBBHJBAEHoABA6GiACQegANgIAIAJBsAFqIAJB7AAQORogBUHIAWogAkGwAWpBBHJB6AAQORogBUEAOgCwAkEPIQUMIAtBmAIQFiIERQ0UIARBAEHIARA6IQUgAkEANgIAIAJBBHJBAEHIABA6GiACQcgANgIAIAJBsAFqIAJBzAAQORogBUHIAWogAkGwAWpBBHJByAAQORogBUEAOgCQAkEQIQUMHwtB8AAQFiIERQ0UIAJBDGpCADcCACACQRRqQgA3AgAgAkEcakIANwIAIAJBJGpCADcCACACQSxqQgA3AgAgAkE0akIANwIAIAJBPGpCADcCACACQgA3AgQgAkHAADYCACACQbABaiACQcQAEDkaIARB4ABqIAJBsAFqQTxqKQIANwAAIARB2ABqIAJBsAFqQTRqKQIANwAAIARB0ABqIAJBsAFqQSxqKQIANwAAIARByABqIAJBsAFqQSRqKQIANwAAIARBwABqIAJBsAFqQRxqKQIANwAAIARBOGogAkGwAWpBFGopAgA3AAAgBEEwaiACQbABakEMaikCADcAACAEIAIpArQBNwAoIARCADcDACAEQQA6AGggBEEAKQOQjkA3AwggBEEQakEAKQOYjkA3AwAgBEEYakEAKQOgjkA3AwAgBEEgakEAKQOojkA3AwBBESEFDB4LQfAAEBYiBEUNFCACQQxqQgA3AgAgAkEUakIANwIAIAJBHGpCADcCACACQSRqQgA3AgAgAkEsakIANwIAIAJBNGpCADcCACACQTxqQgA3AgAgAkIANwIEIAJBwAA2AgAgAkGwAWogAkHEABA5GiAEQeAAaiACQbABakE8aikCADcAACAEQdgAaiACQbABakE0aikCADcAACAEQdAAaiACQbABakEsaikCADcAACAEQcgAaiACQbABakEkaikCADcAACAEQcAAaiACQbABakEcaikCADcAACAEQThqIAJBsAFqQRRqKQIANwAAIARBMGogAkGwAWpBDGopAgA3AAAgBCACKQK0ATcAKCAEQgA3AwAgBEEAOgBoIARBACkD8I1ANwMIIARBEGpBACkD+I1ANwMAIARBGGpBACkDgI5ANwMAIARBIGpBACkDiI5ANwMAQRIhBQwdC0HYARAWIgRFDRQgAkEANgIAIAJBBHJBAEGAARA6GiACQYABNgIAIAJBsAFqIAJBhAEQORogBEHQAGogAkGwAWpBBHJBgAEQORogBEHIAGpCADcDACAEQgA3A0AgBEEAOgDQASAEQQApA/COQDcDACAEQQhqQQApA/iOQDcDACAEQRBqQQApA4CPQDcDACAEQRhqQQApA4iPQDcDACAEQSBqQQApA5CPQDcDACAEQShqQQApA5iPQDcDACAEQTBqQQApA6CPQDcDACAEQThqQQApA6iPQDcDAEETIQUMHAtB+AIQFiIERQ0VIARBAEHIARA6IQUgAkEANgIAIAJBBHJBAEGoARA6GiACQagBNgIAIAJBsAFqIAJBrAEQORogBUHIAWogAkGwAWpBBHJBqAEQORogBUEAOgDwAkEVIQUMGwsgA0HygMAAQQUQUUUNFyADQZOBwABBBRBRDQFB6AAQFiIERQ0WIARCADcDACAEQQApA/iRQDcDCCAEQRBqQQApA4CSQDcDACAEQRhqQQApA4iSQDcDACACQQxqQgA3AgAgAkEUakIANwIAIAJBHGpCADcCACACQSRqQgA3AgAgAkEsakIANwIAIAJBNGpCADcCACACQTxqQgA3AgAgAkIANwIEIAJBwAA2AgAgAkGwAWogAkHEABA5GiAEQdgAaiACQbABakE8aikCADcAACAEQdAAaiACQbABakE0aikCADcAACAEQcgAaiACQbABakEsaikCADcAACAEQcAAaiACQbABakEkaikCADcAACAEQThqIAJBsAFqQRxqKQIANwAAIARBMGogAkGwAWpBFGopAgA3AAAgBEEoaiACQbABakEMaikCADcAACAEIAIpArQBNwAgIARBADoAYEEXIQUMGgsgA0G0gMAAQQYQUUUNFwtBASEEQZiB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IBtqIhdqIhUgBnNBFHciBmoiCXM2AgggACABIAogEGogFyAdc0EZdyIQaiIXaiAXIA1zQRB3IgEgEmoiDSAQc0EUdyIQaiIXIAFzQRh3IgEgDWoiDSALIBggB2ogBCAIc0EZdyIIaiIHaiAHIA5zQRB3IgcgD2oiDyAIc0EUdyIIaiIOczYCBCAAIA4gB3NBGHciByAPaiIPIBdzNgIMIAAgCSAFc0EYdyIFIBVqIg4gE3M2AgAgACACIBFzQRl3IAVzNgIUIAAgDSAQc0EZdyAHczYCECAAIA4gBnNBGXcgDHM2AhwgACAPIAhzQRl3IAFzNgIYC5EiAg5/An4jAEGgD2siASQAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkAgAEUNACAAKAIAIgJBf0YNASAAIAJBAWo2AgAgAEEEaiECAkACQAJAAkACQCAAKAIEDhgAAQIDBB4dHBsaGRgXFhUUExIREA8ODQwACyACKAIEIQNB0AEQFiICRQ0GIAFBCGpBOGogA0E4aikDADcDACABQQhqQTBqIANBMGopAwA3AwAgAUEIakEoaiADQShqKQMANwMAIAFBCGpBIGogA0EgaikDADcDACABQQhqQRhqIANBGGopAwA3AwAgAUEIakEQaiADQRBqKQMANwMAIAFBCGpBCGogA0EIaikDADcDACABIAMpAwA3AwggAykDQCEPIAFBCGpByABqIANByABqEEMgASAPNwNIIAIgAUEIakHQARA5GkEAIQMMHwsgAigCBCEDQdABEBYiAkUNBiABQQhqQThqIANBOGopAwA3AwAgAUEIakEwaiADQTBqKQMANwMAIAFBCGpBKGogA0EoaikDADcDACABQQhqQSBqIANBIGopAwA3AwAgAUEIakEYaiADQRhqKQMANwMAIAFBCGpBEGogA0EQaikDADcDACABQQhqQQhqIANBCGopAwA3AwAgASADKQMANwMIIAMpA0AhDyABQQhqQcgAaiADQcgAahBDIAEgDzcDSCACIAFBCGpB0AEQORpBASEDDB4LIAIoAgQhA0HQARAWIgJFDQYgAUEIakE4aiADQThqKQMANwMAIAFBCGpBMGogA0EwaikDADcDACABQQhqQShqIANBKGopAwA3AwAgAUEIakEgaiADQSBqKQMANwMAIAFBCGpBGGogA0EYaikDADcDACABQQhqQRBqIANBEGopAwA3AwAgAUEIakEIaiADQQhqKQMANwMAIAEgAykDADcDCCADKQNAIQ8gAUEIakHIAGogA0HIAGoQQyABIA83A0ggAiABQQhqQdABEDkaQQIhAwwdCyACKAIEIQNB8AAQFiICRQ0GIAFBCGpBIGogA0EgaikDADcDACABQQhqQRhqIANBGGopAwA3AwAgAUEIakEQaiADQRBqKQMANwMAIAEgAykDCDcDECADKQMAIQ8gAUEIakEoaiADQShqEDcgASAPNwMIIAIgAUEIakHwABA5GkEDIQMMHAsgAigCBCEDQfgOEBYiAkUNBiABQQhqQYgBaiADQYgBaikDADcDACABQQhqQYABaiADQYABaikDADcDACABQQhqQfgAaiADQfgAaikDADcDACABQQhqQRBqIANBEGopAwA3AwAgAUEIakEYaiADQRhqKQMANwMAIAFBCGpBIGogA0EgaikDADcDACABQQhqQTBqIANBMGopAwA3AwAgAUEIakE4aiADQThqKQMANwMAIAFBCGpBwABqIANBwABqKQMANwMAIAFBCGpByABqIANByABqKQMANwMAIAFBCGpB0ABqIANB0ABqKQMANwMAIAFBCGpB2ABqIANB2ABqKQMANwMAIAFBCGpB4ABqIANB4ABqKQMANwMAIAEgAykDcDcDeCABIAMpAwg3AxAgASADKQMoNwMwIAMpAwAhDyADLQBqIQQgAy0AaSEFIAMtAGghBgJAIAMoApABQQV0IgcNAEEAIQcMGwsgAUGAD2pBGGoiCCADQZQBaiIJQRhqKQAANwMAIAFBgA9qQRBqIgogCUEQaikAADcDACABQYAPakEIaiILIAlBCGopAAA3AwAgASAJKQAANwOADyADQdQBaiEJQQAgB0FgakEFdmshDCABQbwBaiEDQQIhBwNAIANBYGoiDSABKQOADzcAACANQRhqIAgpAwA3AAAgDUEQaiAKKQMANwAAIA1BCGogCykDADcAAAJAAkAgDCAHaiIOQQJGDQAgCCAJQWBqIg1BGGopAAA3AwAgCiANQRBqKQAANwMAIAsgDUEIaikAADcDACABIA0pAAA3A4APIAdBOEcNARBqAAsgB0F/aiEHDBwLIAMgASkDgA83AAAgA0EYaiAIKQMANwAAIANBEGogCikDADcAACADQQhqIAspAwA3AAAgDkEBRg0bIAggCUEYaikAADcDACAKIAlBEGopAAA3AwAgCyAJQQhqKQAANwMAIAEgCSkAADcDgA8gA0HAAGohAyAHQQJqIQcgCUHAAGohCQwACwsQbgALEG8AC0HQAUEIQQAoAvjUQCIBQQQgARsRBQAAC0HQAUEIQQAoAvjUQCIBQQQgARsRBQAAC0HQAUEIQQAoAvjUQCIBQQQgARsRBQAAC0HwAEEIQQAoAvjUQCIBQQQgARsRBQAAC0H4DkEIQQAoAvjUQCIBQQQgARsRBQAACyACKAIEIQMCQEHoABAWIgJFDQAgAUEIakEQaiADQRBqKQMANwMAIAFBCGpBGGogA0EYaikDADcDACABIAMpAwg3AxAgAykDACEPIAFBCGpBIGogA0EgahA3IAEgDzcDCCACIAFBCGpB6AAQORpBFyEDDBQLQegAQQhBACgC+NRAIgFBBCABGxEFAAALIAIoAgQhAwJAQdgCEBYiAkUNACABQQhqIANByAEQORogAUEIakHIAWogA0HIAWoQRCACIAFBCGpB2AIQORpBFiEDDBMLQdgCQQhBACgC+NRAIgFBBCABGxEFAAALIAIoAgQhAwJAQfgCEBYiAkUNACABQQhqIANByAEQORogAUEIakHIAWogA0HIAWoQRSACIAFBCGpB+AIQORpBFSEDDBILQfgCQQhBACgC+NRAIgFBBCABGxEFAAALIAIoAgQhAwJAQdgBEBYiAkUNACABQQhqQThqIANBOGopAwA3AwAgAUEIakEwaiADQTBqKQMANwMAIAFBCGpBKGogA0EoaikDADcDACABQQhqQSBqIANBIGopAwA3AwAgAUEIakEYaiADQRhqKQMANwMAIAFBCGpBEGogA0EQaikDADcDACABQQhqQQhqIANBCGopAwA3AwAgASADKQMANwMIIANByABqKQMAIQ8gAykDQCEQIAFBCGpB0ABqIANB0ABqEEMgAUEIakHIAGogDzcDACABIBA3A0ggAiABQQhqQdgBEDkaQRQhAwwRC0HYAUEIQQAoAvjUQCIBQQQgARsRBQAACyACKAIEIQMCQEHYARAWIgJFDQAgAUEIakE4aiADQThqKQMANwMAIAFBCGpBMGogA0EwaikDADcDACABQQhq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ASAFOgBxIAEgBjoAcCABIA83AwggAiABQQhqQfgOEDkaQQQhAwsgACAAKAIAQX9qNgIAAkBBDBAWIgBFDQAgACACNgIIIAAgAzYCBCAAQQA2AgAgAUGgD2okACAADwtBDEEEQQAoAvjUQCIBQQQgARsRBQAAC6MSARp/IwBBwABrIQMgACgCACgCACIEIAQpAwAgAq18NwMAAkAgAkEGdCICRQ0AIAEgAmohBSAEKAIUIQYgBCgCECEHIAQoAgwhAiAEKAIIIQgDQCADQRhqIgBCADcDACADQSBqIglCADcDACADQThqQgA3AwAgA0EwakIANwMAIANBKGpCADcDACADQQhqIgogAUEIaikAADcDACADQRBqIgsgAUEQaikAADcDACAAIAFBGGooAAAiDDYCACAJIAFBIGooAAAiDTYCACADIAEpAAA3AwAgAyABQRxqKAAAIg42AhwgAyABQSRqKAAAIg82AiQgCigCACIQIAwgAUEoaigAACIRIAFBOGooAAAiEiABQTxqKAAAIhMgAygCDCIUIA4gAUEsaigAACIVIA4gFCATIBUgEiARIAwgByAQaiAGIAMoAgQiFmogCCACIAdxaiAGIAJBf3NxaiADKAIAIhdqQfjIqrt9akEHdyACaiIAIAJxaiAHIABBf3NxakHW7p7GfmpBDHcgAGoiCSAAcWogAiAJQX9zcWpB2+GBoQJqQRF3IAlqIgpqIAMoAhQiGCAJaiAAIAsoAgAiGWogAiAUaiAKIAlxaiAAIApBf3NxakHunfeNfGpBFncgCmoiACAKcWogCSAAQX9zcWpBr5/wq39qQQd3IABqIgkgAHFqIAogCUF/c3FqQaqMn7wEakEMdyAJaiIKIAlxaiAAIApBf3NxakGTjMHBempBEXcgCmoiC2ogDyAKaiANIAlqIA4gAGogCyAKcWogCSALQX9zcWpBgaqaampBFncgC2oiACALcWogCiAAQX9zcWpB2LGCzAZqQQd3IABqIgkgAHFqIAsgCUF/c3FqQa/vk9p4akEMdyAJaiIKIAlxaiAAIApBf3NxakGxt31qQRF3IApqIgtqIAFBNGooAAAiGiAKaiABQTBqKAAAIhsgCWogFSAAaiALIApxaiAJIAtBf3NxakG+r/PKeGpBFncgC2oiACALcWogCiAAQX9zcWpBoqLA3AZqQQd3IABq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A0EBdmtBH3EgA0EfRht0IQIDQCAFIAJBHXZBBHFqQRBqIgYoAgAiA0UNAiACQQF0IQIgAyEFIAMoAgRBeHEgAEcNAAsLIAMoAggiACABNgIMIAMgATYCCCABQRhqQQA2AgAgASADNgIMIAEgADYCCAwCCyAGIAE2AgAgAUEYaiAFNgIACyABIAE2AgwgASABNgIIC0EAQQAoAsTYQEF/aiIBNgLE2EAgAQ0DQQAoArTYQCIADQFB/x8hAQwCCyAAQQN2IgNBA3RBjNXAAGohAAJAAkBBACgChNVAIgJBASADdCIDcUUNACAAKAIIIQMMAQtBACACIANyNgKE1UAgACEDCyAAIAE2AgggAyABNgIMIAEgADYCDCABIAM2AggPC0EAIQEDQCABQQFqIQEgACgCCCIADQALIAFB/x8gAUH/H0sbIQELQQAgATYCxNhADwsLlQwBGH8jACECIAAoAgAhAyAAKAIIIQQgACgCDCEFIAAoAgQhBiACQcAAayICQRhqIgdCADcDACACQSBqIghCADcDACACQThqIglCADcDACACQTBqIgpCADcDACACQShqIgtCADcDACACQQhqIgwgASkACDcDACACQRBqIg0gASkAEDcDACAHIAEoABgiDjYCACAIIAEoACAiDzYCACACIAEpAAA3AwAgAiABKAAcIhA2AhwgAiABKAAkIhE2AiQgCyABKAAoIhI2AgAgAiABKAAsIgs2AiwgCiABKAAwIhM2AgAgAiABKAA0Igo2AjQgCSABKAA4IhQ2AgAgAiABKAA8IhU2AjwgACADIBMgCyASIBEgDyAQIA4gBiAEIAUgBiADIAYgBHFqIAUgBkF/c3FqIAIoAgAiFmpBA3ciAXFqIAQgAUF/c3FqIAIoAgQiF2pBB3ciByABcWogBiAHQX9zcWogDCgCACIMakELdyIIIAdxaiABIAhBf3NxaiACKAIMIhhqQRN3IgkgCHEgAWogByAJQX9zcWogDSgCACINakEDdyIBIAlxIAdqIAggAUF/c3FqIAIoAhQiGWpBB3ciAiABcSAIaiAJIAJBf3NxampBC3ciByACcSAJaiABIAdBf3NxampBE3ciCCAHcSABaiACIAhBf3NxampBA3ciASAIcSACaiAHIAFBf3NxampBB3ciAiABcSAHaiAIIAJBf3NxampBC3ciByACcSAI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BCEDIAJBCGoiBEHAABBPIAMgBEHIABA5QcgBakEAOgAADBcLIAMoAgQhAyACQQhqIgRBIBBPIAMgBEHIABA5QcgBakEAOgAADBYLIAMoAgQhAyACQQhqIgRBMBBPIAMgBEHIABA5QcgBakEAOgAADBULIAMoAgQhAyACQQhqEFUgA0EgaiACQShqKQMANwMAIANBGGogAkEgaikDADcDACADQRBqIAJBGGopAwA3AwAgA0EIaiACQRBqKQMANwMAIAMgAikDCDcDACADQegAakEAOgAADBQLIAMoAgQiA0IANwMAIAMgAykDcDcDCCADQSBqIANBiAFqKQMANwMAIANBGGogA0GAAWopAwA3AwAgA0EQaiADQfgAaikDADcDACADQShqQQBBwgAQOhogAygCkAFFDRMgA0EANgKQAQwTCyADKAIEQQBByAEQOkHYAmpBADoAAAwSCyADKAIEQQBByAEQOkHQAmpBADoAAAwRCyADKAIEQQBByAEQOkGwAmpBADoAAAwQCyADKAIEQQBByAEQOkGQAmpBADoAAAwPCyADKAIEIgNCgcaUupbx6uZvNwMIIANCADcDACADQdgAakEAOgAAIANBEGpC/rnrxemOlZkQNwMADA4LIAMoAgQiA0KBxpS6lvHq5m83AwggA0IANwMAIANB2ABqQQA6AAAgA0EQakL+uevF6Y6VmRA3AwAMDQsgAygCBCIDQgA3AwAgA0HgAGpBADoAACADQQApA9iNQDcDCCADQRBqQQApA+CNQDcDACADQRhqQQAoAuiNQDYCAAwMCyADKAIEIgNCgcaUupbx6uZvNwMIIANCADcDACADQeAAakEAOgAAIANBGGpB8MPLnnw2AgAgA0EQakL+uevF6Y6VmRA3AwAMCwsgAygCBEEAQcgBEDpB2AJqQQA6AAAMCgsgAygCBEEAQcgBEDpB0AJqQQA6AAAMCQsgAygCBEEAQcgBEDpBsAJqQQA6AAAMCAsgAygCBEEAQcgBEDpBkAJqQQA6AAAMBwsgAygCBCIDQgA3AwAgA0HoAGpBADoAACADQQApA5COQDcDCCADQRBqQQApA5iOQDcDACADQRhqQQApA6COQDcDACADQSBqQQApA6iOQDcDAAwGCyADKAIEIgNCADcDACADQegAakEAOgAAIANBACkD8I1ANwMIIANBEGpBACkD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QYCA/AdxciAAQQh2QYD+A3EgAEEYdnJyNgAcIANB0AFqJAALogYCA38CfiMAQfABayIDJAAgACkDACEGIAEgAUHAAGotAAAiBGoiBUGAAToAACADQQhqQRBqIABBGGooAgA2AgAgA0EQaiAAQRBqKQIANwMAIAMgACkCCDcDCCAGQgmGIAStQgOGhCIGQgiIQoCAgPgPgyAGQhiIQoCA/AeDhCAGQiiIQoD+A4MgBkI4iISEIQcgBkI4hiAGQiiGQoCAgICAgMD/AIOEIAZCGIZCgICAgIDgP4MgBkIIhkKAgICA8B+DhIQhBgJAIARBP3MiAEUNACAFQQFqQQAgABA6GgsgBiAHhCEGAkACQCAEQThxQThGDQAgAUE4aiAGNwAAIANBCGogAUEBEBQMAQsgA0EIaiABQQEQFCADQeAAakEMakIANwIAIANB4ABqQRRqQgA3AgAgA0HgAGpBHGpCADcCACADQeAAakEkakIANwIAIANB4ABqQSxqQgA3AgAgA0HgAGpBNGpCADcCACADQZwBakIANwIAIANCADcCZCADQcAANgJgIANBqAFqIANB4ABqQcQAEDkaIANB0ABqIANBqAFqQTRqKQIANwMAIANByABqIANBqAFqQSxqKQIANwMAIANBwABqIANBqAFqQSRqKQIANwMAIANBOGogA0GoAWpBHGopAgA3AwAgA0EwaiADQagBakEUaikCADcDACADQShqIANBqAFqQQxqKQIANwMAIAMgAykCrAE3AyAgAyAGNwNYIANBCGogA0EgakEBEBQLIAFBwABqQQA6AAAgAiADKAIIIgFBGHQgAUEIdEGAgPwHcXIgAUEIdkGA/gNxIAFBGHZycjYAACACIAMoAgwiAUEYdCABQQh0QYCA/AdxciABQQh2QYD+A3EgAUEYdnJyNgAEIAIgAygCECIBQRh0IAFBCHRBgID8B3FyIAFBCHZBgP4DcSABQRh2cnI2AAggAiADKAIUIgFBGHQgAUEIdEGAgPwHcXIgAUEIdkGA/gNxIAFBGHZycjYADCACIAMoAhgiAUEYdCABQQh0QYCA/AdxciABQQh2QYD+A3EgAUEYdnJyNgAQIANB8AFqJAALsgYBFX8jAEGwAWsiAiQAAkACQAJAIAAoApABIgMgAXunIgRNDQAgAEHwAGohBSACQShqIQYgAkEIaiEH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QT9zIgBFDQAgBUEBakEAIAAQOhoLIAYgB4QhBgJAAkAgBEE4cUE4Rg0AIAFBOGogBjcAACADQQhqIAEQEgwBCyADQQhqIAEQEiADQeAAakEMakIANwIAIANB4ABqQRRqQgA3AgAgA0HgAGpBHGpCADcCACADQeAAakEkakIANwIAIANB4ABqQSxqQgA3AgAgA0HgAGpBNGpCADcCACADQZwBakIANwIAIANCADcCZCADQcAANgJgIANBqAFqIANB4ABqQcQAEDkaIANB0ABqIANBqAFqQTRqKQIANwMAIANByABqIANBqAFqQSxqKQIANwMAIANBwABqIANBqAFqQSRqKQIANwMAIANBOGogA0GoAWpBHGopAgA3AwAgA0EwaiADQagBakEUaikCADcDACADQShqIANBqAFqQQxqKQIANwMAIAMgAykCrAE3AyAgAyAGNwNYIANBCGogA0EgahASCyACIAMoAgg2AAAgAiADKQIMNwAEIAIgAykCFDcADCABQcAAakEAOgAAIANB8AFqJAAL8AMCA38CfiMAQfABayIDJAAgAUHAAGotAAAhBCAAKQMAIQYgA0EQaiAAQRBqKQIANwMAIAMgACkCCDcDCCABIARqIgBBgAE6AAAgBkIJhiEGIAStQgOGIQcgAyADQQhqNgIcAkAgBEE/cyIFRQ0AIABBAWpBACAFEDoaCyAHIAaEIQYCQAJAIARBOHFBOEYNACABQThqIAY3AAAgA0EcaiABEBwMAQsgA0EcaiABEBwgA0HgAGpBDGpCADcCACADQeAAakEUakIANwIAIANB4ABqQRxqQgA3AgAgA0HgAGpBJGpCADcCACADQeAAakEsakIANwIAIANB4ABqQTRqQgA3AgAgA0GcAWpCADcCACADQgA3AmQgA0HAADYCYCADQagBaiADQeAAakHEABA5GiADQdAAaiADQagBakE0aikCADcDACADQcgAaiADQagBakEsaikCADcDACADQcAAaiADQagBakEkaikCADcDACADQThqIANBqAFqQRxqKQIANwMAIANBMGogA0GoAWpBFGopAgA3AwAgA0EoaiADQagBakEMaikCADcDACADIAMpAqwBNwMgIAMgBjcDWCADQRxqIANBIGoQHAsgAUHAAGpBADoAACACIAMpAwg3AAAgAiADKQMQNwAIIANB8AFqJAAL2QMCA38CfiMAQeABayIDJAAgACkDACEGIAEgAUHAAGotAAAiBGoiBUGAAToAACADQQhqIABBEGopAgA3AwAgAyAAKQIINwMAIAZCCYYhBiAErUIDhiEHAkAgBEE/cyIARQ0AIAVBAWpBACAAEDoaCyAHIAaEIQYCQAJAIARBOHFBOEYNACABQThqIAY3AAAgAyABEB8MAQsgAyABEB8gA0HQAGpBDGpCADcCACADQdAAakEUakIANwIAIANB0ABqQRxqQgA3AgAgA0HQAGpBJGpCADcCACADQdAAakEsakIANwIAIANB0ABqQTRqQgA3AgAgA0GMAWpCADcCACADQgA3AlQgA0HAADYCUCADQZgBaiADQdAAakHEABA5GiADQcAAaiADQZgBakE0aikCADcDACADQThqIANBmAFqQSxqKQIANwMAIANBMGogA0GYAWpBJGopAgA3AwAgA0EoaiADQZgBakEcaikCADcDACADQSBqIANBmAFqQRRqKQIANwMAIANBGGogA0GYAWpBDGopAgA3AwAgAyADKQKcATcDECADIAY3A0ggAyADQRBqEB8LIAIgAykDADcAACACIAMpAwg3AAggAUHAAGpBADoAACADQeABaiQAC9QDAgR/An4jAEHQAWsiAyQAIAEgAUHAAGotAAAiBGoiBUEBOgAAIAApAwBCCYYhByAErUIDhiEIAkAgBEE/cyIGRQ0AIAVBAWpBACAGEDoaCyAHIAiEIQcCQAJAIARBOHFBOEYNACABQThqIAc3AAAgAEEIaiABQQEQFwwBCyAAQQhqIgQgAUEBEBcgA0HAAGpBDGpCADcCACADQcAAakEUakIANwIAIANBwABqQRxqQgA3AgAgA0HAAGpBJGpCADcCACADQcAAakEsakIANwIAIANBwABqQTRqQgA3AgAgA0H8AGpCADcCACADQgA3AkQgA0HAADYCQCADQYgBaiADQcAAakHEABA5GiADQTBqIANBiAFqQTRqKQIANwMAIANBKGogA0GIAWpBLGopAgA3AwAgA0EgaiADQYgBakEkaikCADcDACADQRhqIANBiAFqQRxqKQIANwMAIANBEGogA0GIAWpBFGopAgA3AwAgA0EIaiADQYgBakEMaikCADcDACADIAMpAowBNwMAIAMgBzcDOCAEIANBARAXCyABQcAAakEAOgAAIAIgACkDCDcAACACIABBEGopAwA3AAggAiAAQRhqKQMANwAQIANB0AFqJAALlwMBBX8jAEGQBGsiAyQAIABByAFqIQQCQAJAAkACQAJAIABB8AJqLQAAIgVFDQBBqAEgBWsiBiACSw0BIAEgBCAFaiAGEDkgBmohASACIAZrIQILIAIgAkGoAW4iBUGoAWwiB0kNASACIAdrIQYCQCAFQagBbCICRQ0AIAEhBQNAIANB4AJqIABBqAEQORogABAkIAUgA0HgAmpBqAEQOUGoAWohBSACQdh+aiICDQALCwJAIAYNAEEAIQYMBAsgA0EANgKwASADQbABakEEckEAQagBEDoaIANBqAE2ArABIANB4AJqIANBsAFqQawBEDkaIANBCGogA0HgAmpBBHJBqAEQORogA0HgAmogAEGoARA5GiAAECQgA0EIaiADQeACakGoARA5GiAGQakBTw0CIAEgB2ogA0EIaiAGEDkaIAQgA0EIakGoARA5GgwDCyABIAQgBWogAhA5GiAFIAJqIQYMAgtBoY3AAEEjQcSNwAAQUwALIAZBqAFBxIzAABBJAAsgAEHwAmogBjoAACADQZAEaiQAC5cDAQV/IwBBsANrIgMkACAAQcgBaiEEAkACQAJAAkACQCAAQdACai0AACIFRQ0AQYgBIAVrIgYgAksNASABIAQgBWogBhA5IAZqIQEgAiAGayECCyACIAJBiAFuIgVBiAFsIgdJDQEgAiAHayEGAkAgBUGIAWwiAkUNACABIQUDQCADQaACaiAAQYgBEDkaIAAQJCAFIANBoAJqQYgBEDlBiAFqIQUgAkH4fmoiAg0ACwsCQCAGDQBBACEGDAQLIANBADYCkAEgA0GQAWpBBHJBAEGIARA6GiADQYgBNgKQASADQaACaiADQZABakGMARA5GiADQQhqIANBoAJqQQRyQYgBEDkaIANBoAJqIABBiAEQORogABAkIANBCGogA0GgAmpBiAEQORogBkGJAU8NAiABIAdqIANBCGogBhA5GiAEIANBCGpBiAEQORoMAwsgASAEIAVqIAIQORogBSACaiEGDAILQaGNwABBI0HEjcAAEFMACyAGQYgBQcSMwAAQSQALIABB0AJqIAY6AAAgA0GwA2okAAuCAwEDfwJAAkACQAJAIAAtAGgiA0UNAAJAIANBwQBPDQAg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AAuaAQEDfyMAQRBrIgQkAAJAAkAgAUUNACABKAIADQEgAUF/NgIAIAQgAUEEaiACQQBHIAMQDiAEQQhqKAIAIQMgBCgCBCECAkACQCAEKAIAIgVBAUYNAEEAIQYMAQsgAiADEAAiBiECCyABQQA2AgAgACAFNgIMIAAgBjYCCCAAIAM2AgQgACACNgIAIARBEGokAA8LEG4ACxBvAAt+AQF/IwBBwABrIgQkACAEQSs2AgwgBCAANgIIIAQgAjYCFCAEIAE2AhAgBEEsakECNgIAIARBPGpBATYCACAEQgI3AhwgBEGYiMAANgIYIARBAjYCNCAEIARBMGo2AiggBCAEQRBqNgI4IAQgBEEIajYCMCAEQRhqIAMQVgALfgECfyMAQTBrIgIkACACQRRqQQI2AgAgAkG4h8AANgIQIAJBAjYCDCACQZiHwAA2AgggAUEcaigCACEDIAEoAhghASACQSxqQQI2AgAgAkICNwIcIAJBmIjAADYCGCACIAJBCGo2AiggASADIAJBGGoQKyEBIAJBMGokACABC34BAn8jAEEwayICJAAgAkEUakECNgIAIAJBuIfAADYCECACQQI2AgwgAkGYh8AANgIIIAFBHGooAgAhAyABKAIYIQEgAkEsakECNgIAIAJCAjcCHCACQZiIwAA2AhggAiACQQhqNgIoIAEgAyACQRhqECshASACQTBqJAAgAQt0AQJ/IwBBkAJrIgIkAEEAIQMgAkEANgIAA0AgAiADakEEaiABIANqKAAANgIAIANBBGoiA0GAAUcNAAsgAkGAATYCACACQYgBaiACQYQBEDkaIAAgAkGIAWpBBHJBgAEQOSABLQCAAToAgAEgAkGQAmokAAt0AQJ/IwBBoAJrIgIkAEEAIQMgAkEANgIAA0AgAiADakEEaiABIANqKAAANgIAIANBBGoiA0GIAUcNAAsgAkGIATYCACACQZABaiACQYwBEDkaIAAgAkGQAWpBBHJBiAEQOSABLQCIAToAiAEgAkGgAmokAAt0AQJ/IwBB4AJrIgIkAEEAIQMgAkEANgIAA0AgAiADakEEaiABIANqKAAANgIAIANBBGoiA0GoAUcNAAsgAkGoATYCACACQbABaiACQawBEDkaIAAgAkGwAWpBBHJBqAEQOSABLQCoAToAqAEgAkHgAmokAAtyAQJ/IwBBoAFrIgIkAEEAIQMgAkEANgIAA0AgAiADakEEaiABIANqKAAANgIAIANBBGoiA0HIAEcNAAsgAkHIADYCACACQdAAaiACQcwAEDkaIAAgAkHQAGpBBHJByAAQOSABLQBIOgBIIAJBoAFqJAALcgECfyMAQeABayICJABBACEDIAJBADYCAANAIAIgA2pBBGogASADaigAADYCACADQQRqIgNB6ABHDQALIAJB6AA2AgAgAkHwAGogAkHsABA5GiAAIAJB8ABqQQRyQegAEDkgAS0AaDoAaCACQeABaiQAC3QBAn8jAEGwAmsiAiQAQQAhAyACQQA2AgADQCACIANqQQRqIAEgA2ooAAA2AgAgA0EEaiIDQZABRw0ACyACQZABNgIAIAJBmAFqIAJBlAEQORogACACQZgBakEEckGQARA5IAEtAJABOgCQASACQbACaiQAC2wBAX8jAEEwayIDJAAgAyABNgIEIAMgADYCACADQRxqQQI2AgAgA0EsakEDNgIAIANCAjcCDCADQciKwAA2AgggA0EDNgIkIAMgA0EgajYCGCADIANBBGo2AiggAyADNgIgIANBCGogAhBWAAtsAQF/IwBBMGsiAyQAIAMgATYCBCADIAA2AgAgA0EcakECNgIAIANBLGpBAzYCACADQgI3AgwgA0GoisAANgIIIANBAzYCJCADIANBIGo2AhggAyADQQRqNgIoIAMgAzYCICADQQhqIAIQVgALbAEBfyMAQTBrIgMkACADIAE2AgQgAyAANgIAIANBHGpBAjYCACADQSxqQQM2AgAgA0ICNwIMIANB/IrAADYCCCADQQM2AiQgAyADQSBqNgIYIAMgA0EEajYCKCADIAM2AiAgA0EIaiACEFYAC2wBAX8jAEEwayIDJAAgAyABNgIEIAMgADYCACADQRxqQQI2AgAgA0EsakEDNgIAIANCAzcCDCADQcyLwAA2AgggA0EDNgIkIAMgA0EgajYCGCADIAM2AiggAyADQQRqNgIgIANBCGogAhBWAAtsAQF/IwBBMGsiAyQAIAMgATYCBCADIAA2AgAgA0EcakECNgIAIANBLGpBAzYCACADQgI3AgwgA0GEiMAANgIIIANBAzYCJCADIANBIGo2AhggAyADNgIoIAMgA0EEajYCICADQQhqIAIQVgALdQECf0EBIQBBAEEAKAKA1UAiAUEBajYCgNVAAkACQEEAKALI2EBBAUcNAEEAKALM2EBBAWohAAwBC0EAQQE2AsjYQAtBACAANgLM2EACQCABQQBIDQAgAEECSw0AQQAoAvzUQEF/TA0AIABBAUsNABBzAAsAC5oBACMAQTBrGiAAQgA3A0AgAEE4akL5wvibkaOz8NsANwMAIABBMGpC6/qG2r+19sEfNwMAIABBKGpCn9j52cKR2oKbfzcDACAAQtGFmu/6z5SH0QA3AyAgAELx7fT4paf9p6V/NwMYIABCq/DT9K/uvLc8NwMQIABCu86qptjQ67O7fzcDCCAAIAGtQoiS95X/zPmE6gCFNwMAC1UBAn8CQAJAIABFDQAgACgCAA0BIABBADYCACAAKAIIIQEgACgCBCECIAAQHgJAIAJBBEcNACABKAKQAUUNACABQQA2ApABCyABEB4PCxBuAAsQbwALSgEDf0EAIQMCQCACRQ0AAkADQCAALQAAIgQgAS0AACIFRw0BIABBAWohACABQQFqIQEgAkF/aiICRQ0CDAALCyAEIAVrIQMLIAMLVAEBfwJAAkACQCABQYCAxABGDQBBASEEIAAoAhggASAAQRxqKAIAKAIQEQYADQELIAINAUEAIQQLIAQPCyAAKAIYIAIgAyAAQRxqKAIAKAIMEQgAC0cBAX8jAEEgayIDJAAgA0EUakEANgIAIANBoJHAADYCECADQgE3AgQgAyABNgIcIAMgADYCGCADIANBGGo2AgAgAyACEFYACzkAAkACQCABRQ0AIAEoAgANASABQX82AgAgAUEEaiACEDYgAUEANgIAIABCADcDAA8LEG4ACxBvAAtSACAAQsfMo9jW0Ouzu383AwggAEIANwMAIABBIGpCq7OP/JGjs/DbADcDACAAQRhqQv+kuYjFkdqCm383AwAgAEEQakLy5rvjo6f9p6V/NwMACzQBAX8jAEEQayICJAAgAiABNgIMIAIgADYCCCACQcCHwAA2AgQgAkGgkcAANgIAIAIQZwALIwACQCAAQXxLDQACQCAADQBBBA8LIAAQFiIARQ0AIAAPCwALJQACQCAADQBBsI/AAEEwEHAACyAAIAIgAyAEIAUgASgCEBEMAAsjAAJAIAANAEGwj8AAQTAQcAALIAAgAiADIAQgASgCEBEKAAsjAAJAIAANAEGwj8AAQTAQcAALIAAg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OjpieXRlX29mZnNldDo6X193YmdfYnl0ZU9mZnNldF80MjA0ZWNiMjRhNmU1ZGY5OjpoOGY0YmM4MWQ5MGE4MjMzZQRManNfc3lzOjpVaW50OEFycmF5OjpidWZmZXI6Ol9fd2JnX2J1ZmZlcl9mYWNmMDM5OGEyODFjODViOjpoMGZiNjA5YTUxNjQ3NmU5MgV5anNfc3lzOjpVaW50OEFycmF5OjpuZXdfd2l0aF9ieXRlX29mZnNldF9hbmRfbGVuZ3RoOjpfX3diZ19uZXd3aXRoYnl0ZW9mZnNldGFuZGxlbmd0aF80YjliOGM0ZTNmNWFkYmZmOjpoYzI4MjE3ODU0OTVlMmE2MgZManNfc3lzOjpVaW50OEFycmF5OjpsZW5ndGg6Ol9fd2JnX2xlbmd0aF8xZWI4ZmM2MDhhMGQ0Y2RiOjpoNzNkYzkyYWJjODFkM2ZhNwcyd2FzbV9iaW5kZ2VuOjpfX3diaW5kZ2VuX21lbW9yeTo6aDRjOWRjYzlmYzQzMmZlMmMIVWpzX3N5czo6V2ViQXNzZW1ibHk6Ok1lbW9yeTo6YnVmZmVyOjpfX3diZ19idWZmZXJfMzk3ZWFhNGQ3MmVlOTRkZDo6aDM5ZDIzMjAwNzgzMjBiYzAJRmpzX3N5czo6VWludDhBcnJheTo6bmV3OjpfX3diZ19uZXdfYTdjZTQ0N2YxNWZmNDk2Zjo6aDZjZjg5NDdiODY4ZmRlZWYKRmpzX3N5czo6VWludDhBcnJheTo6c2V0OjpfX3diZ19zZXRfOTY5YWQwYTYwZTUxZDMyMDo6aDUxN2Q1OGEyM2QyYjc4MTkLMXdhc21fYmluZGdlbjo6X193YmluZGdlbl90aHJvdzo6aDY5MTE5ZDhjZWJhYTQ0M2YMQGRlbm9fc3RkX3dhc21fY3J5cHRvOjpkaWdlc3Q6OkNvbnRleHQ6OmRpZ2VzdDo6aDgyOGE3MDExNDE1ZjA1MjANLHNoYTI6OnNoYTUxMjo6Y29tcHJlc3M1MTI6Omg2YjEwYzMzYWQwNWMzNWY2DkpkZW5vX3N0ZF93YXNtX2NyeXB0bzo6ZGlnZXN0OjpDb250ZXh0OjpkaWdlc3RfYW5kX3Jlc2V0OjpoZjlkNDIwYzUyNDhhOTJmNg9AZGVub19zdGRfd2FzbV9jcnlwdG86OmRpZ2VzdDo6Q29udGV4dDo6dXBkYXRlOjpoMWFhNzQ2YmE5ZTJlMTdhNRAsc2hhMjo6c2hhMjU2Ojpjb21wcmVzczI1Njo6aGU4NzgwMjljY2ZkZDNkZjQRM2JsYWtlMjo6Qmxha2UyYlZhckNvcmU6OmNvbXByZXNzOjpoOWY4N2E3NmE4ZmJlZTIyYhIpcmlwZW1kOjpjMTYwOjpjb21wcmVzczo6aDE4OWM0NzlmYmQ2N2FmYWQTM2JsYWtlMjo6Qmxha2Uyc1ZhckNvcmU6OmNvbXByZXNzOjpoOWRkYTljMmEyYjYxNzY4ORQrc2hhMTo6Y29tcHJlc3M6OmNvbXByZXNzOjpoNTBlNWQ4M2U5MWQ2NTRhYRU7ZGVub19zdGRfd2FzbV9jcnlwdG86OkRpZ2VzdENvbnRleHQ6Om5ldzo6aGY0NjA2NTg2NmYzZDY2NjAWOmRsbWFsbG9jOjpkbG1hbGxvYzo6RGxtYWxsb2M8QT46Om1hbGxvYzo6aDJhMjcyMDdlZTlhZjdmZTkXLHRpZ2VyOjpjb21wcmVzczo6Y29tcHJlc3M6Omg2ZDI1OGZiZjc1NDhiZmUxGC1ibGFrZTM6Ok91dHB1dFJlYWRlcjo6ZmlsbDo6aGE5YzI3MGM5YjdmZjQxZWUZNmJsYWtlMzo6cG9ydGFibGU6OmNvbXByZXNzX2luX3BsYWNlOjpoYzRhZDc0NzdjYmY1MmYwZRoTZGlnZXN0Y29udGV4dF9jbG9uZRtlPGRpZ2VzdDo6Y29yZV9hcGk6OndyYXBwZXI6OkNvcmVXcmFwcGVyPFQ+IGFzIGRpZ2VzdDo6VXBkYXRlPjo6dXBkYXRlOjp7e2Nsb3N1cmV9fTo6aGU3N2FmYjMxMmY4OGY0MzccaDxtZDU6Ok1kNUNvcmUgYXMgZGlnZXN0Ojpjb3JlX2FwaTo6Rml4ZWRPdXRwdXRDb3JlPjo6ZmluYWxpemVfZml4ZWRfY29yZTo6e3tjbG9zdXJlfX06Omg3OThjNzA3YzdjZGEzNTkyHTBibGFrZTM6OmNvbXByZXNzX3N1YnRyZWVfd2lkZTo6aDk5NWY5MmEwOTlkOTg2MzQeOGRsbWFsbG9jOjpkbG1hbGxvYzo6RGxtYWxsb2M8QT46OmZyZWU6OmhjYjc5NDdhOWE3ZTI4MmNhHyBtZDQ6OmNvbXByZXNzOjpoOTBkNTQwMzZjYTYzM2UzYyBBZGxtYWxsb2M6OmRsbWFsbG9jOjpEbG1hbGxvYzxBPjo6ZGlzcG9zZV9jaHVuazo6aDJmOTBiZGRmYWI5ZmRhZjkhE2RpZ2VzdGNvbnRleHRfcmVzZXQicjxzaGEyOjpjb3JlX2FwaTo6U2hhNTEyVmFyQ29yZSBhcyBkaWdlc3Q6OmNvcmVfYXBpOjpWYXJpYWJsZU91dHB1dENvcmU+OjpmaW5hbGl6ZV92YXJpYWJsZV9jb3JlOjpoOWVhNGEyMTU4ZTA3MDMzYiMvYmxha2UzOjpIYXNoZXI6OmZpbmFsaXplX3hvZjo6aGI4ODNlNmM1YzRlNWQ0MGIkIGtlY2Nhazo6ZjE2MDA6OmhhODI1NzkwY2YyNWE1ZjVlJSxjb3JlOjpmbXQ6OkZvcm1hdHRlcjo6cGFkOjpoNDlkMmNmY2NhZmJiZGU0ZCYOX19ydXN0X3JlYWxsb2MncjxzaGEyOjpjb3JlX2FwaTo6U2hhMjU2VmFyQ29yZSBhcyBkaWdlc3Q6OmNvcmVfYXBpOjpWYXJpYWJsZU91dHB1dENvcmU+OjpmaW5hbGl6ZV92YXJpYWJsZV9jb3JlOjpoMDNhOTMwYjhjNzRjOWVkNShdPHNoYTE6OlNoYTFDb3JlIGFzIGRpZ2VzdDo6Y29yZV9hcGk6OkZpeGVkT3V0cHV0Q29yZT46OmZpbmFsaXplX2ZpeGVkX2NvcmU6OmhiNWQ5ZWM3MDI0OGUxODIwKTFibGFrZTM6Okhhc2hlcjo6bWVyZ2VfY3Zfc3RhY2s6Omg0N2I2ZTI0ZTY3ZTIxNjViKjVjb3JlOjpmbXQ6OkZvcm1hdHRlcjo6cGFkX2ludGVncmFsOjpoYzY2OTQ3YjFkZWQ1NzhhYSsjY29yZTo6Zm10Ojp3cml0ZTo6aGJiYWYzOWYwOWJmNDllZmIsNGJsYWtlMzo6Y29tcHJlc3NfcGFyZW50c19wYXJhbGxlbDo6aGEwNzMyZmFjYjEyNzY5YmItZDxyaXBlbWQ6OlJpcGVtZDE2MENvcmUgYXMgZGlnZXN0Ojpjb3JlX2FwaTo6Rml4ZWRPdXRwdXRDb3JlPjo6ZmluYWxpemVfZml4ZWRfY29yZTo6aGRlOGZjMmFmNzExZjE4NWYuWzxtZDU6Ok1kNUNvcmUgYXMgZGlnZXN0Ojpjb3JlX2FwaTo6Rml4ZWRPdXRwdXRDb3JlPjo6ZmluYWxpemVfZml4ZWRfY29yZTo6aDBiMzAwM2U0ODQyOWFjM2QvWzxtZDQ6Ok1kNENvcmUgYXMgZGlnZXN0Ojpjb3JlX2FwaTo6Rml4ZWRPdXRwdXRDb3JlPjo6ZmluYWxpemVfZml4ZWRfY29yZTo6aDNlMmIzMDA3MzBhYThhZjAwXzx0aWdlcjo6VGlnZXJDb3JlIGFzIGRpZ2VzdDo6Y29yZV9hcGk6OkZpeGVkT3V0cHV0Q29yZT46OmZpbmFsaXplX2ZpeGVkX2NvcmU6Omg0NTczYTQwZWJjNTRjYTUzMWU8ZGlnZXN0Ojpjb3JlX2FwaTo6eG9mX3JlYWRlcjo6WG9mUmVhZGVyQ29yZVdyYXBwZXI8VD4gYXMgZGlnZXN0OjpYb2ZSZWFkZXI+OjpyZWFkOjpoZTUwZWUyZjliMmYyYmQ0YTJlPGRpZ2VzdDo6Y29yZV9hcGk6OnhvZl9yZWFkZXI6OlhvZlJlYWRlckNvcmVXcmFwcGVyPFQ+IGFzIGRpZ2VzdDo6WG9mUmVhZGVyPjo6cmVhZDo6aDZkN2E3MzhlNTE0MWViZTAzLWJsYWtlMzo6Q2h1bmtTdGF0ZTo6dXBkYXRlOjpoYzU4OGE4Y2Q3YzI2Y2VmNTQvY29yZTo6Zm10OjpudW06OmltcDo6Zm10X3U2NDo6aDY2MjhhM2U3MjI3ZTg1NTM1BmRpZ2VzdDY+ZGVub19zdGRfd2FzbV9jcnlwdG86OkRpZ2VzdENvbnRleHQ6OnVwZGF0ZTo6aDEzYWE5MGI2YzVlZGM0ODY3WzxibG9ja19idWZmZXI6OkJsb2NrQnVmZmVyPEJsb2NrU2l6ZSxLaW5kPiBhcyBjb3JlOjpjbG9uZTo6Q2xvbmU+OjpjbG9uZTo6aDU2ZDNhMWQ5YzZmOTE3YmU4G2RpZ2VzdGNvbnRleHRfZGlnZXN0QW5kRHJvcDkGbWVtY3B5OgZtZW1zZXQ7P3dhc21fYmluZGdlbjo6Y29udmVydDo6Y2xvc3VyZXM6Omludm9rZTNfbXV0OjpoZDk2N2Y0MzRjNzJmNGU0MjwRZGlnZXN0Y29udGV4dF9uZXc9FGRpZ2VzdGNvbnRleHRfZGlnZXN0Pi1qc19zeXM6OlVpbnQ4QXJyYXk6OnRvX3ZlYzo6aDYzOWJmOTBlOTEwZTgxZDQ/HGRpZ2VzdGNvbnRleHRfZGlnZXN0QW5kUmVzZXRALmNvcmU6OnJlc3VsdDo6dW53cmFwX2ZhaWxlZDo6aGQ1ODRlZmI3Yjg0YmYzMjZBUDxhcnJheXZlYzo6ZXJyb3JzOjpDYXBhY2l0eUVycm9yPFQ+IGFzIGNvcmU6OmZtdDo6RGVidWc+OjpmbXQ6Omg4Y2EzNjljOTgxMGMyMjI5QlA8YXJyYXl2ZWM6OmVycm9yczo6Q2FwYWNpdHlFcnJvcjxUPiBhcyBjb3JlOjpmbXQ6OkRlYnVnPjo6Zm10OjpoYWJkMmI2NDNkZDBlY2QyY0NbPGJsb2NrX2J1ZmZlcjo6QmxvY2tCdWZmZXI8QmxvY2tTaXplLEtpbmQ+IGFzIGNvcmU6OmNsb25lOjpDbG9uZT46OmNsb25lOjpoMDhkN2U1MzhlNjI5MDQzOERbPGJsb2NrX2J1ZmZlcjo6QmxvY2tCdWZmZXI8QmxvY2tTaXplLEtpbmQ+IGFzIGNvcmU6OmNsb25lOjpDbG9uZT46OmNsb25lOjpoODc3ODZlMzY2MmMyNmQ2NEVbPGJsb2NrX2J1ZmZlcjo6QmxvY2tCdWZmZXI8QmxvY2tTaXplLEtpbmQ+IGFzIGNvcmU6OmNsb25lOjpDbG9uZT46OmNsb25lOjpoNWExYTExYjkwNmU5M2QwM0ZbPGJsb2NrX2J1ZmZlcjo6QmxvY2tCdWZmZXI8QmxvY2tTaXplLEtpbmQ+IGFzIGNvcmU6OmNsb25lOjpDbG9uZT46OmNsb25lOjpoNDUyMGIyMWMwYzI5ODk4Y0dbPGJsb2NrX2J1ZmZlcjo6QmxvY2tCdWZmZXI8QmxvY2tTaXplLEtpbmQ+IGFzIGNvcmU6OmNsb25lOjpDbG9uZT46OmNsb25lOjpoYzQ4ZjUyNTk0NDZjMmVlY0hbPGJsb2NrX2J1ZmZlcjo6QmxvY2tCdWZmZXI8QmxvY2tTaXplLEtpbmQ+IGFzIGNvcmU6OmNsb25lOjpDbG9uZT46OmNsb25lOjpoMWM0ZTBjNjhlY2Q2NmI1NEk/Y29yZTo6c2xpY2U6OmluZGV4OjpzbGljZV9lbmRfaW5kZXhfbGVuX2ZhaWw6OmhjM2UwZGNmNmQ4NjZlMWJlSkFjb3JlOjpzbGljZTo6aW5kZXg6OnNsaWNlX3N0YXJ0X2luZGV4X2xlbl9mYWlsOjpoNmMxMDlhYzg1ODdmMjkxMUs9Y29yZTo6c2xpY2U6OmluZGV4OjpzbGljZV9pbmRleF9vcmRlcl9mYWlsOjpoZDI3ZGMzODVhN2VjMTNjMUxOY29yZTo6c2xpY2U6OjxpbXBsIFtUXT46OmNvcHlfZnJvbV9zbGljZTo6bGVuX21pc21hdGNoX2ZhaWw6OmhlZGQxMGM1YmNjMDI2MTBjTTZjb3JlOjpwYW5pY2tpbmc6OnBhbmljX2JvdW5kc19jaGVjazo6aGNlMDUwMmY2MzcxMWZhZDhON3N0ZDo6cGFuaWNraW5nOjpydXN0X3BhbmljX3dpdGhfaG9vazo6aDYwNmQ3YzdmN2E0MjNiOThPOmJsYWtlMjo6Qmxha2UyYlZhckNvcmU6Om5ld193aXRoX3BhcmFtczo6aDU4N2Y5YTcyNzlmMzcxNmRQGF9fd2JnX2RpZ2VzdGNvbnRleHRfZnJlZVEGbWVtY21wUkNjb3JlOjpmbXQ6OkZvcm1hdHRlcjo6cGFkX2ludGVncmFsOjp3cml0ZV9wcmVmaXg6OmhhYTBhZGYwMGNiNjdkZWQ3Uyljb3JlOjpwYW5pY2tpbmc6OnBhbmljOjpoZWMxZmMwNTdiZDBiYWYwYlQUZGlnZXN0Y29udGV4dF91cGRhdGVVOmJsYWtlMjo6Qmxha2Uyc1ZhckNvcmU6Om5ld193aXRoX3BhcmFtczo6aDVmZjQ1OWYyMzFhYjhkNjhWLWNvcmU6OnBhbmlja2luZzo6cGFuaWNfZm10OjpoNjMxNGI1YzkxYWJlNzM0OVcRX193YmluZGdlbl9tYWxsb2NYP3dhc21fYmluZGdlbjo6Y29udmVydDo6Y2xvc3VyZXM6Omludm9rZTRfbXV0OjpoMDhiMDAxNWQ0NTZmMjBjN1k/d2FzbV9iaW5kZ2VuOjpjb252ZXJ0OjpjbG9zdXJlczo6aW52b2tlM19tdXQ6OmgzYWI0ZThkMTgzNDk0OWU4Wj93YXNtX2JpbmRnZW46OmNvbnZlcnQ6OmNsb3N1cmVzOjppbnZva2UzX211dDo6aDBlZmUyNDJjN2Q3ZmU2MGVbP3dhc21fYmluZGdlbjo6Y29udmVydDo6Y2xvc3VyZXM6Omludm9rZTNfbXV0OjpoYzRhYTBlM2VmMWQ2ZDdhMVw/d2FzbV9iaW5kZ2VuOjpjb252ZXJ0OjpjbG9zdXJlczo6aW52b2tlM19tdXQ6Omg3OTlhYmFiYmRjZDEyZmEzXT93YXNtX2JpbmRnZW46OmNvbnZlcnQ6OmNsb3N1cmVzOjppbnZva2UzX211dDo6aGE5NDFjMTBjNDA4ODhjNTBeP3dhc21fYmluZGdlbjo6Y29udmVydDo6Y2xvc3VyZXM6Omludm9rZTNfbXV0OjpoMTE4OWQ1YjVlY2U4MjQxYV8/d2FzbV9iaW5kZ2VuOjpjb252ZXJ0OjpjbG9zdXJlczo6aW52b2tlM19tdXQ6OmhiZGM0ZjBhM2ViZGQ5MDg2YD93YXNtX2JpbmRnZW46OmNvbnZlcnQ6OmNsb3N1cmVzOjppbnZva2UyX211dDo6aGE2NDc2YjFhNTZlZDFhYjZhQ3N0ZDo6cGFuaWNraW5nOjpiZWdpbl9wYW5pY19oYW5kbGVyOjp7e2Nsb3N1cmV9fTo6aDliOTg1YTI5M2FhYzRjZTFiEl9fd2JpbmRnZW5fcmVhbGxvY2M/d2FzbV9iaW5kZ2VuOjpjb252ZXJ0OjpjbG9zdXJlczo6aW52b2tlMV9tdXQ6OmgwNzE4MzRjY2I3MGRmNzI1ZDJjb3JlOjpvcHRpb246Ok9wdGlvbjxUPjo6dW53cmFwOjpoNWE3ZGY5MWI1ZDYwOTBjYmUwPCZUIGFzIGNvcmU6OmZtdDo6RGVidWc+OjpmbXQ6OmgwZDljZDYyNmRhYmFhMWVmZjI8JlQgYXMgY29yZTo6Zm10OjpEaXNwbGF5Pjo6Zm10OjpoZDMwM2JjMTZhZWU1NTkxMGcRcnVzdF9iZWdpbl91bndpbmRoD19fd2JpbmRnZW5fZnJlZWk0YWxsb2M6OnJhd192ZWM6OmNhcGFjaXR5X292ZXJmbG93OjpoNGI0OTAxNDgzMGNhZmU2M2ozYXJyYXl2ZWM6OmFycmF5dmVjOjpleHRlbmRfcGFuaWM6OmgzN2Q1OThkNzVkMGQyZTZmazljb3JlOjpvcHM6OmZ1bmN0aW9uOjpGbk9uY2U6OmNhbGxfb25jZTo6aDJhYjg2NzY3ZWMxN2M1MGRsH19fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXJtTmNvcmU6OmZtdDo6bnVtOjppbXA6OjxpbXBsIGNvcmU6OmZtdDo6RGlzcGxheSBmb3IgdTMyPjo6Zm10OjpoMDQ2ZWNjNWVhYWIzNGNkNW4xd2FzbV9iaW5kZ2VuOjpfX3J0Ojp0aHJvd19udWxsOjpoM2Q3YjQ3NDgzNGRkZjJkOW8yd2FzbV9iaW5kZ2VuOjpfX3J0Ojpib3Jyb3dfZmFpbDo6aGU1Njk3Y2E4ZTIxZWQ1YTVwKndhc21fYmluZGdlbjo6dGhyb3dfc3RyOjpoNWViNDYxODBmZTVlMWQxYXFJc3RkOjpzeXNfY29tbW9uOjpiYWNrdHJhY2U6Ol9fcnVzdF9lbmRfc2hvcnRfYmFja3RyYWNlOjpoYTAzYWJlZjAyYThiNzBmZHIxPFQgYXMgY29yZTo6YW55OjpBbnk+Ojp0eXBlX2lkOjpoYTBjNDQ5MjIxNmQ0ZDJlN3MKcnVzdF9wYW5pY3Q3c3RkOjphbGxvYzo6ZGVmYXVsdF9hbGxvY19lcnJvcl9ob29rOjpoZjljMzkzYmEzY2QyODdlMXVvY29yZTo6cHRyOjpkcm9wX2luX3BsYWNlPCZjb3JlOjppdGVyOjphZGFwdGVyczo6Y29waWVkOjpDb3BpZWQ8Y29yZTo6c2xpY2U6Oml0ZXI6Okl0ZXI8dTg+Pj46Omg2M2MyZTE0OTdiNTJmM2Q3AO+AgIAACXByb2R1Y2VycwIIbGFuZ3VhZ2UBBFJ1c3QADHByb2Nlc3NlZC1ieQMFcnVzdGMdMS41Ny4wIChmMWVkZDA0MjkgMjAyMS0xMS0yOSkGd2FscnVzBjAuMTkuMAx3YXNtLWJpbmRnZW4GMC4yLjgx");
  const wasmModule = new WebAssembly.Module(wasmBytes);
  return new WebAssembly.Instance(wasmModule, imports);
}
function base64decode(b64) {
  const binString = atob(b64);
  const size = binString.length;
  const bytes = new Uint8Array(size);
  for (let i = 0; i < size; i++) {
    bytes[i] = binString.charCodeAt(i);
  }
  return bytes;
}

// deno:https://deno.land/std@0.147.0/_wasm_crypto/mod.ts
var digestAlgorithms = [
  "BLAKE2B-256",
  "BLAKE2B-384",
  "BLAKE2B",
  "BLAKE2S",
  "BLAKE3",
  "KECCAK-224",
  "KECCAK-256",
  "KECCAK-384",
  "KECCAK-512",
  "SHA-384",
  "SHA3-224",
  "SHA3-256",
  "SHA3-384",
  "SHA3-512",
  "SHAKE128",
  "SHAKE256",
  "TIGER",
  "RIPEMD-160",
  "SHA-224",
  "SHA-256",
  "SHA-512",
  "MD4",
  "MD5",
  "SHA-1"
];

// deno:https://deno.land/std@0.147.0/encoding/hex.ts
var hexTable = new TextEncoder().encode("0123456789abcdef");
function encode3(src) {
  const dst = new Uint8Array(src.length * 2);
  for (let i = 0; i < dst.length; i++) {
    const v2 = src[i];
    dst[i * 2] = hexTable[v2 >> 4];
    dst[i * 2 + 1] = hexTable[v2 & 15];
  }
  return dst;
}

// deno:https://deno.land/std@0.147.0/node/internal/crypto/hash.ts
var coerceToBytes = (data) => {
  if (data instanceof Uint8Array) {
    return data;
  } else if (typeof data === "string") {
    return new TextEncoder().encode(data);
  } else if (ArrayBuffer.isView(data)) {
    return new Uint8Array(data.buffer, data.byteOffset, data.byteLength);
  } else if (data instanceof ArrayBuffer) {
    return new Uint8Array(data);
  } else {
    throw new TypeError("expected data to be string | BufferSource");
  }
};
var Hash = class extends transform_default {
  #context;
  constructor(algorithm, _opts) {
    super({
      transform(chunk, _encoding, callback) {
        context.update(coerceToBytes(chunk));
        callback();
      },
      flush(callback) {
        this.push(context.digest(void 0));
        callback();
      }
    });
    if (typeof algorithm === "string") {
      algorithm = algorithm.toUpperCase();
      if (opensslToWebCryptoDigestNames[algorithm]) {
        algorithm = opensslToWebCryptoDigestNames[algorithm];
      }
      this.#context = new (instantiate()).DigestContext(algorithm);
    } else {
      this.#context = algorithm;
    }
    const context = this.#context;
  }
  copy() {
    return new Hash(this.#context.clone());
  }
  update(data, _encoding) {
    let bytes;
    if (typeof data === "string") {
      data = new TextEncoder().encode(data);
      bytes = coerceToBytes(data);
    } else {
      bytes = coerceToBytes(data);
    }
    this.#context.update(bytes);
    return this;
  }
  digest(encoding) {
    const digest2 = this.#context.digest(void 0);
    if (encoding === void 0) {
      return Buffer3.from(digest2);
    }
    switch (encoding) {
      case "hex":
        return new TextDecoder().decode(encode3(new Uint8Array(digest2)));
      case "binary":
        return String.fromCharCode(...digest2);
      case "base64":
        return encode(digest2);
      default:
        throw new Error(`The output encoding for hash digest is not implemented: ${encoding}`);
    }
  }
};
var Hmac = class extends transform_default {
  constructor(hmac, _key, _options) {
    validateString(hmac, "hmac");
    super();
    notImplemented("crypto.Hmac");
  }
  digest(_encoding) {
    notImplemented("crypto.Hmac.prototype.digest");
  }
  update(_data, _inputEncoding) {
    notImplemented("crypto.Hmac.prototype.update");
  }
};
var opensslToWebCryptoDigestNames = {
  BLAKE2B512: "BLAKE2B",
  BLAKE2S256: "BLAKE2S",
  RIPEMD160: "RIPEMD-160",
  RMD160: "RIPEMD-160",
  SHA1: "SHA-1",
  SHA224: "SHA-224",
  SHA256: "SHA-256",
  SHA384: "SHA-384",
  SHA512: "SHA-512"
};
function createHash(algorithm, opts) {
  return new Hash(algorithm, opts);
}

// deno:https://deno.land/std@0.147.0/node/internal/crypto/pbkdf2.ts
var MAX_ALLOC = Math.pow(2, 30) - 1;
var createHasher = (algorithm) => (value) => Buffer3.from(createHash(algorithm).update(value).digest());
function getZeroes(zeros2) {
  return Buffer3.alloc(zeros2);
}
var sizes = {
  md5: 16,
  sha1: 20,
  sha224: 28,
  sha256: 32,
  sha384: 48,
  sha512: 64,
  rmd160: 20,
  ripemd160: 20
};
function toBuffer(bufferable) {
  if (bufferable instanceof Uint8Array || typeof bufferable === "string") {
    return Buffer3.from(bufferable);
  } else {
    return Buffer3.from(bufferable.buffer);
  }
}
var Hmac2 = class {
  constructor(alg, key2, saltLen) {
    this.hash = createHasher(alg);
    const blocksize = alg === "sha512" || alg === "sha384" ? 128 : 64;
    if (key2.length > blocksize) {
      key2 = this.hash(key2);
    } else if (key2.length < blocksize) {
      key2 = Buffer3.concat([key2, getZeroes(blocksize - key2.length)], blocksize);
    }
    const ipad = Buffer3.allocUnsafe(blocksize + sizes[alg]);
    const opad = Buffer3.allocUnsafe(blocksize + sizes[alg]);
    for (let i = 0; i < blocksize; i++) {
      ipad[i] = key2[i] ^ 54;
      opad[i] = key2[i] ^ 92;
    }
    const ipad1 = Buffer3.allocUnsafe(blocksize + saltLen + 4);
    ipad.copy(ipad1, 0, 0, blocksize);
    this.ipad1 = ipad1;
    this.ipad2 = ipad;
    this.opad = opad;
    this.alg = alg;
    this.blocksize = blocksize;
    this.size = sizes[alg];
  }
  run(data, ipad) {
    data.copy(ipad, this.blocksize);
    const h = this.hash(ipad);
    h.copy(this.opad, this.blocksize);
    return this.hash(this.opad);
  }
};
function pbkdf2Sync(password, salt, iterations, keylen, digest2 = "sha1") {
  if (typeof iterations !== "number" || iterations < 0) {
    throw new TypeError("Bad iterations");
  }
  if (typeof keylen !== "number" || keylen < 0 || keylen > MAX_ALLOC) {
    throw new TypeError("Bad key length");
  }
  const bufferedPassword = toBuffer(password);
  const bufferedSalt = toBuffer(salt);
  const hmac = new Hmac2(digest2, bufferedPassword, bufferedSalt.length);
  const DK = Buffer3.allocUnsafe(keylen);
  const block1 = Buffer3.allocUnsafe(bufferedSalt.length + 4);
  bufferedSalt.copy(block1, 0, 0, bufferedSalt.length);
  let destPos = 0;
  const hLen = sizes[digest2];
  const l = Math.ceil(keylen / hLen);
  for (let i = 1; i <= l; i++) {
    block1.writeUInt32BE(i, bufferedSalt.length);
    const T4 = hmac.run(block1, hmac.ipad1);
    let U2 = T4;
    for (let j2 = 1; j2 < iterations; j2++) {
      U2 = hmac.run(U2, hmac.ipad2);
      for (let k6 = 0; k6 < hLen; k6++)
        T4[k6] ^= U2[k6];
    }
    T4.copy(DK, destPos);
    destPos += hLen;
  }
  return DK;
}
function pbkdf2(password, salt, iterations, keylen, digest2 = "sha1", callback) {
  setTimeout(() => {
    let err = null, res;
    try {
      res = pbkdf2Sync(password, salt, iterations, keylen, digest2);
    } catch (e) {
      err = e;
    }
    if (err) {
      callback(err instanceof Error ? err : new Error("[non-error thrown]"));
    } else {
      callback(null, res);
    }
  }, 0);
}

// deno:https://deno.land/std@0.147.0/node/internal/crypto/scrypt.ts
var fixOpts = (opts) => {
  const out = { N: 16384, p: 1, r: 8, maxmem: 32 << 20 };
  if (!opts)
    return out;
  if (opts.N)
    out.N = opts.N;
  else if (opts.cost)
    out.N = opts.cost;
  if (opts.p)
    out.p = opts.p;
  else if (opts.parallelization)
    out.p = opts.parallelization;
  if (opts.r)
    out.r = opts.r;
  else if (opts.blockSize)
    out.r = opts.blockSize;
  if (opts.maxmem)
    out.maxmem = opts.maxmem;
  return out;
};
function blockxor(S3, Si, D6, Di, len) {
  let i = -1;
  while (++i < len)
    D6[Di + i] ^= S3[Si + i];
}
function arraycopy(src, srcPos, dest, destPos, length) {
  src.copy(dest, destPos, srcPos, srcPos + length);
}
var R = (a, b2) => a << b2 | a >>> 32 - b2;
var ScryptRom = class {
  constructor(b2, r, N4, p3) {
    this.B = b2;
    this.r = r;
    this.N = N4;
    this.p = p3;
    this.XY = Buffer3.allocUnsafe(256 * r);
    this.V = Buffer3.allocUnsafe(128 * r * N4);
    this.B32 = new Int32Array(16);
    this.x = new Int32Array(16);
    this._X = Buffer3.allocUnsafe(64);
  }
  run() {
    const p3 = this.p | 0;
    const r = this.r | 0;
    for (let i = 0; i < p3; i++)
      this.scryptROMix(i, r);
    return this.B;
  }
  scryptROMix(i, r) {
    const blockStart = i * 128 * r;
    const offset = (2 * r - 1) * 64;
    const blockLen = 128 * r;
    const B3 = this.B;
    const N4 = this.N | 0;
    const V3 = this.V;
    const XY = this.XY;
    B3.copy(XY, 0, blockStart, blockStart + blockLen);
    for (let i1 = 0; i1 < N4; i1++) {
      XY.copy(V3, i1 * blockLen, 0, blockLen);
      this.blockmix_salsa8(blockLen);
    }
    let j2;
    for (let i2 = 0; i2 < N4; i2++) {
      j2 = XY.readUInt32LE(offset) & N4 - 1;
      blockxor(V3, j2 * blockLen, XY, 0, blockLen);
      this.blockmix_salsa8(blockLen);
    }
    XY.copy(B3, blockStart, 0, blockLen);
  }
  blockmix_salsa8(blockLen) {
    const BY = this.XY;
    const r = this.r;
    const _X = this._X;
    arraycopy(BY, (2 * r - 1) * 64, _X, 0, 64);
    let i;
    for (i = 0; i < 2 * r; i++) {
      blockxor(BY, i * 64, _X, 0, 64);
      this.salsa20_8();
      arraycopy(_X, 0, BY, blockLen + i * 64, 64);
    }
    for (i = 0; i < r; i++) {
      arraycopy(BY, blockLen + i * 2 * 64, BY, i * 64, 64);
      arraycopy(BY, blockLen + (i * 2 + 1) * 64, BY, (i + r) * 64, 64);
    }
  }
  salsa20_8() {
    const B32 = this.B32;
    const B3 = this._X;
    const x = this.x;
    let i;
    for (i = 0; i < 16; i++) {
      B32[i] = (B3[i * 4 + 0] & 255) << 0;
      B32[i] |= (B3[i * 4 + 1] & 255) << 8;
      B32[i] |= (B3[i * 4 + 2] & 255) << 16;
      B32[i] |= (B3[i * 4 + 3] & 255) << 24;
    }
    for (i = 0; i < 16; i++)
      x[i] = B32[i];
    for (i = 0; i < 4; i++) {
      x[4] ^= R(x[0] + x[12], 7);
      x[8] ^= R(x[4] + x[0], 9);
      x[12] ^= R(x[8] + x[4], 13);
      x[0] ^= R(x[12] + x[8], 18);
      x[9] ^= R(x[5] + x[1], 7);
      x[13] ^= R(x[9] + x[5], 9);
      x[1] ^= R(x[13] + x[9], 13);
      x[5] ^= R(x[1] + x[13], 18);
      x[14] ^= R(x[10] + x[6], 7);
      x[2] ^= R(x[14] + x[10], 9);
      x[6] ^= R(x[2] + x[14], 13);
      x[10] ^= R(x[6] + x[2], 18);
      x[3] ^= R(x[15] + x[11], 7);
      x[7] ^= R(x[3] + x[15], 9);
      x[11] ^= R(x[7] + x[3], 13);
      x[15] ^= R(x[11] + x[7], 18);
      x[1] ^= R(x[0] + x[3], 7);
      x[2] ^= R(x[1] + x[0], 9);
      x[3] ^= R(x[2] + x[1], 13);
      x[0] ^= R(x[3] + x[2], 18);
      x[6] ^= R(x[5] + x[4], 7);
      x[7] ^= R(x[6] + x[5], 9);
      x[4] ^= R(x[7] + x[6], 13);
      x[5] ^= R(x[4] + x[7], 18);
      x[11] ^= R(x[10] + x[9], 7);
      x[8] ^= R(x[11] + x[10], 9);
      x[9] ^= R(x[8] + x[11], 13);
      x[10] ^= R(x[9] + x[8], 18);
      x[12] ^= R(x[15] + x[14], 7);
      x[13] ^= R(x[12] + x[15], 9);
      x[14] ^= R(x[13] + x[12], 13);
      x[15] ^= R(x[14] + x[13], 18);
    }
    for (i = 0; i < 16; i++)
      B32[i] += x[i];
    let bi;
    for (i = 0; i < 16; i++) {
      bi = i * 4;
      B3[bi + 0] = B32[i] >> 0 & 255;
      B3[bi + 1] = B32[i] >> 8 & 255;
      B3[bi + 2] = B32[i] >> 16 & 255;
      B3[bi + 3] = B32[i] >> 24 & 255;
    }
  }
  clean() {
    this.XY.fill(0);
    this.V.fill(0);
    this._X.fill(0);
    this.B.fill(0);
    for (let i = 0; i < 16; i++) {
      this.B32[i] = 0;
      this.x[i] = 0;
    }
  }
};
function scryptSync(password, salt, keylen, _opts) {
  const { N: N4, r, p: p3, maxmem } = fixOpts(_opts);
  const blen = p3 * 128 * r;
  if (32 * r * (N4 + 2) * 4 + blen > maxmem) {
    throw new Error("excedes max memory");
  }
  const b2 = pbkdf2Sync(password, salt, 1, blen, "sha256");
  const scryptRom = new ScryptRom(b2, r, N4, p3);
  const out = scryptRom.run();
  const fin = pbkdf2Sync(password, out, 1, keylen, "sha256");
  scryptRom.clean();
  return fin;
}
function scrypt(password, salt, keylen, _opts, cb) {
  if (!cb) {
    cb = _opts;
    _opts = null;
  }
  const { N: N4, r, p: p3, maxmem } = fixOpts(_opts);
  const blen = p3 * 128 * r;
  if (32 * r * (N4 + 2) * 4 + blen > maxmem) {
    throw new Error("excedes max memory");
  }
  try {
    const b2 = pbkdf2Sync(password, salt, 1, blen, "sha256");
    const scryptRom = new ScryptRom(b2, r, N4, p3);
    const out = scryptRom.run();
    const result = pbkdf2Sync(password, out, 1, keylen, "sha256");
    scryptRom.clean();
    cb(null, result);
  } catch (err) {
    return cb(err);
  }
}

// deno:https://deno.land/std@0.147.0/node/_crypto/crypto_browserify/browserify_aes/modes/ecb.js
var ecb_exports = {};
__export(ecb_exports, {
  decrypt: () => decrypt,
  encrypt: () => encrypt
});
var encrypt = function(self2, block) {
  return self2._cipher.encryptBlock(block);
};
var decrypt = function(self2, block) {
  return self2._cipher.decryptBlock(block);
};

// deno:https://deno.land/std@0.147.0/node/_crypto/crypto_browserify/browserify_aes/modes/cbc.js
var cbc_exports = {};
__export(cbc_exports, {
  decrypt: () => decrypt2,
  encrypt: () => encrypt2
});

// deno:https://deno.land/std@0.147.0/node/_crypto/crypto_browserify/browserify_aes/xor.ts
function xor(a, b2) {
  const length = Math.min(a.length, b2.length);
  const buffer = Buffer3.allocUnsafe(length);
  for (let i = 0; i < length; ++i) {
    buffer[i] = a[i] ^ b2[i];
  }
  return buffer;
}

// deno:https://deno.land/std@0.147.0/node/_crypto/crypto_browserify/browserify_aes/modes/cbc.js
var encrypt2 = function(self2, block) {
  const data = xor(block, self2._prev);
  self2._prev = self2._cipher.encryptBlock(data);
  return self2._prev;
};
var decrypt2 = function(self2, block) {
  const pad3 = self2._prev;
  self2._prev = block;
  const out = self2._cipher.decryptBlock(block);
  return xor(out, pad3);
};

// deno:https://deno.land/std@0.147.0/node/_crypto/crypto_browserify/browserify_aes/modes/cfb.js
var cfb_exports = {};
__export(cfb_exports, {
  encrypt: () => encrypt3
});
function encryptStart(self2, data, decrypt4) {
  const len = data.length;
  const out = xor(data, self2._cache);
  self2._cache = self2._cache.slice(len);
  self2._prev = Buffer3.concat([self2._prev, decrypt4 ? data : out]);
  return out;
}
var encrypt3 = function(self2, data, decrypt4) {
  let out = Buffer3.allocUnsafe(0);
  let len;
  while (data.length) {
    if (self2._cache.length === 0) {
      self2._cache = self2._cipher.encryptBlock(self2._prev);
      self2._prev = Buffer3.allocUnsafe(0);
    }
    if (self2._cache.length <= data.length) {
      len = self2._cache.length;
      out = Buffer3.concat([
        out,
        encryptStart(self2, data.slice(0, len), decrypt4)
      ]);
      data = data.slice(len);
    } else {
      out = Buffer3.concat([out, encryptStart(self2, data, decrypt4)]);
      break;
    }
  }
  return out;
};

// deno:https://deno.land/std@0.147.0/node/_crypto/crypto_browserify/browserify_aes/modes/cfb8.js
var cfb8_exports = {};
__export(cfb8_exports, {
  encrypt: () => encrypt4
});
function encryptByte(self2, byteParam, decrypt4) {
  const pad3 = self2._cipher.encryptBlock(self2._prev);
  const out = pad3[0] ^ byteParam;
  self2._prev = Buffer3.concat([
    self2._prev.slice(1),
    Buffer3.from([decrypt4 ? byteParam : out])
  ]);
  return out;
}
var encrypt4 = function(self2, chunk, decrypt4) {
  const len = chunk.length;
  const out = Buffer3.allocUnsafe(len);
  let i = -1;
  while (++i < len) {
    out[i] = encryptByte(self2, chunk[i], decrypt4);
  }
  return out;
};

// deno:https://deno.land/std@0.147.0/node/_crypto/crypto_browserify/browserify_aes/modes/cfb1.js
var cfb1_exports = {};
__export(cfb1_exports, {
  encrypt: () => encrypt5
});
function encryptByte2(self2, byteParam, decrypt4) {
  let pad3;
  let i = -1;
  const len = 8;
  let out = 0;
  let bit, value;
  while (++i < len) {
    pad3 = self2._cipher.encryptBlock(self2._prev);
    bit = byteParam & 1 << 7 - i ? 128 : 0;
    value = pad3[0] ^ bit;
    out += (value & 128) >> i % 8;
    self2._prev = shiftIn(self2._prev, decrypt4 ? bit : value);
  }
  return out;
}
function shiftIn(buffer, value) {
  const len = buffer.length;
  let i = -1;
  const out = Buffer3.allocUnsafe(buffer.length);
  buffer = Buffer3.concat([buffer, Buffer3.from([value])]);
  while (++i < len) {
    out[i] = buffer[i] << 1 | buffer[i + 1] >> 7;
  }
  return out;
}
var encrypt5 = function(self2, chunk, decrypt4) {
  const len = chunk.length;
  const out = Buffer3.allocUnsafe(len);
  let i = -1;
  while (++i < len) {
    out[i] = encryptByte2(self2, chunk[i], decrypt4);
  }
  return out;
};

// deno:https://deno.land/std@0.147.0/node/_crypto/crypto_browserify/browserify_aes/modes/ofb.js
var ofb_exports = {};
__export(ofb_exports, {
  encrypt: () => encrypt6
});
function getBlock(self2) {
  self2._prev = self2._cipher.encryptBlock(self2._prev);
  return self2._prev;
}
var encrypt6 = function(self2, chunk) {
  while (self2._cache.length < chunk.length) {
    self2._cache = Buffer3.concat([self2._cache, getBlock(self2)]);
  }
  const pad3 = self2._cache.slice(0, chunk.length);
  self2._cache = self2._cache.slice(chunk.length);
  return xor(chunk, pad3);
};

// deno:https://deno.land/std@0.147.0/node/_crypto/crypto_browserify/browserify_aes/modes/ctr.js
var ctr_exports = {};
__export(ctr_exports, {
  encrypt: () => encrypt7
});

// deno:https://deno.land/std@0.147.0/node/_crypto/crypto_browserify/browserify_aes/incr32.js
function incr32(iv) {
  let len = iv.length;
  let item;
  while (len--) {
    item = iv.readUInt8(len);
    if (item === 255) {
      iv.writeUInt8(0, len);
    } else {
      item++;
      iv.writeUInt8(item, len);
      break;
    }
  }
}

// deno:https://deno.land/std@0.147.0/node/_crypto/crypto_browserify/browserify_aes/modes/ctr.js
function getBlock2(self2) {
  const out = self2._cipher.encryptBlockRaw(self2._prev);
  incr32(self2._prev);
  return out;
}
var blockSize = 16;
var encrypt7 = function(self2, chunk) {
  const chunkNum = Math.ceil(chunk.length / blockSize);
  const start = self2._cache.length;
  self2._cache = Buffer3.concat([
    self2._cache,
    Buffer3.allocUnsafe(chunkNum * blockSize)
  ]);
  for (let i = 0; i < chunkNum; i++) {
    const out = getBlock2(self2);
    const offset = start + i * blockSize;
    self2._cache.writeUInt32BE(out[0], offset + 0);
    self2._cache.writeUInt32BE(out[1], offset + 4);
    self2._cache.writeUInt32BE(out[2], offset + 8);
    self2._cache.writeUInt32BE(out[3], offset + 12);
  }
  const pad3 = self2._cache.slice(0, chunk.length);
  self2._cache = self2._cache.slice(chunk.length);
  return xor(chunk, pad3);
};

// deno:https://deno.land/std@0.147.0/node/_crypto/crypto_browserify/browserify_aes/modes/mod.js
var GCM = ctr_exports;
var modeModules = {
  ECB: ecb_exports,
  CBC: cbc_exports,
  CFB: cfb_exports,
  CFB8: cfb8_exports,
  CFB1: cfb1_exports,
  OFB: ofb_exports,
  CTR: ctr_exports,
  GCM
};
var MODES = {
  "aes-128-ecb": {
    "cipher": "AES",
    "key": 128,
    "iv": 0,
    "mode": "ECB",
    "type": "block"
  },
  "aes-192-ecb": {
    "cipher": "AES",
    "key": 192,
    "iv": 0,
    "mode": "ECB",
    "type": "block"
  },
  "aes-256-ecb": {
    "cipher": "AES",
    "key": 256,
    "iv": 0,
    "mode": "ECB",
    "type": "block"
  },
  "aes-128-cbc": {
    "cipher": "AES",
    "key": 128,
    "iv": 16,
    "mode": "CBC",
    "type": "block"
  },
  "aes-192-cbc": {
    "cipher": "AES",
    "key": 192,
    "iv": 16,
    "mode": "CBC",
    "type": "block"
  },
  "aes-256-cbc": {
    "cipher": "AES",
    "key": 256,
    "iv": 16,
    "mode": "CBC",
    "type": "block"
  },
  "aes128": {
    "cipher": "AES",
    "key": 128,
    "iv": 16,
    "mode": "CBC",
    "type": "block"
  },
  "aes192": {
    "cipher": "AES",
    "key": 192,
    "iv": 16,
    "mode": "CBC",
    "type": "block"
  },
  "aes256": {
    "cipher": "AES",
    "key": 256,
    "iv": 16,
    "mode": "CBC",
    "type": "block"
  },
  "aes-128-cfb": {
    "cipher": "AES",
    "key": 128,
    "iv": 16,
    "mode": "CFB",
    "type": "stream"
  },
  "aes-192-cfb": {
    "cipher": "AES",
    "key": 192,
    "iv": 16,
    "mode": "CFB",
    "type": "stream"
  },
  "aes-256-cfb": {
    "cipher": "AES",
    "key": 256,
    "iv": 16,
    "mode": "CFB",
    "type": "stream"
  },
  "aes-128-cfb8": {
    "cipher": "AES",
    "key": 128,
    "iv": 16,
    "mode": "CFB8",
    "type": "stream"
  },
  "aes-192-cfb8": {
    "cipher": "AES",
    "key": 192,
    "iv": 16,
    "mode": "CFB8",
    "type": "stream"
  },
  "aes-256-cfb8": {
    "cipher": "AES",
    "key": 256,
    "iv": 16,
    "mode": "CFB8",
    "type": "stream"
  },
  "aes-128-cfb1": {
    "cipher": "AES",
    "key": 128,
    "iv": 16,
    "mode": "CFB1",
    "type": "stream"
  },
  "aes-192-cfb1": {
    "cipher": "AES",
    "key": 192,
    "iv": 16,
    "mode": "CFB1",
    "type": "stream"
  },
  "aes-256-cfb1": {
    "cipher": "AES",
    "key": 256,
    "iv": 16,
    "mode": "CFB1",
    "type": "stream"
  },
  "aes-128-ofb": {
    "cipher": "AES",
    "key": 128,
    "iv": 16,
    "mode": "OFB",
    "type": "stream"
  },
  "aes-192-ofb": {
    "cipher": "AES",
    "key": 192,
    "iv": 16,
    "mode": "OFB",
    "type": "stream"
  },
  "aes-256-ofb": {
    "cipher": "AES",
    "key": 256,
    "iv": 16,
    "mode": "OFB",
    "type": "stream"
  },
  "aes-128-ctr": {
    "cipher": "AES",
    "key": 128,
    "iv": 16,
    "mode": "CTR",
    "type": "stream"
  },
  "aes-192-ctr": {
    "cipher": "AES",
    "key": 192,
    "iv": 16,
    "mode": "CTR",
    "type": "stream"
  },
  "aes-256-ctr": {
    "cipher": "AES",
    "key": 256,
    "iv": 16,
    "mode": "CTR",
    "type": "stream"
  },
  "aes-128-gcm": {
    "cipher": "AES",
    "key": 128,
    "iv": 12,
    "mode": "GCM",
    "type": "auth"
  },
  "aes-192-gcm": {
    "cipher": "AES",
    "key": 192,
    "iv": 12,
    "mode": "GCM",
    "type": "auth"
  },
  "aes-256-gcm": {
    "cipher": "AES",
    "key": 256,
    "iv": 12,
    "mode": "GCM",
    "type": "auth"
  }
};
for (const mode of Object.values(MODES)) {
  mode.module = modeModules[mode.mode];
}

// deno:https://deno.land/std@0.147.0/node/_crypto/crypto_browserify/browserify_aes/aes.js
function asUInt32Array(buf) {
  if (!Buffer3.isBuffer(buf))
    buf = Buffer3.from(buf);
  var len = buf.length / 4 | 0;
  var out = new Array(len);
  for (var i = 0; i < len; i++) {
    out[i] = buf.readUInt32BE(i * 4);
  }
  return out;
}
function scrubVec(v2) {
  for (var i = 0; i < v2.length; v2++) {
    v2[i] = 0;
  }
}
function cryptBlock(M4, keySchedule, SUB_MIX, SBOX, nRounds) {
  var SUB_MIX0 = SUB_MIX[0];
  var SUB_MIX1 = SUB_MIX[1];
  var SUB_MIX2 = SUB_MIX[2];
  var SUB_MIX3 = SUB_MIX[3];
  var s03 = M4[0] ^ keySchedule[0];
  var s1 = M4[1] ^ keySchedule[1];
  var s2 = M4[2] ^ keySchedule[2];
  var s3 = M4[3] ^ keySchedule[3];
  var t03, t1, t2, t3;
  var ksRow = 4;
  for (var round = 1; round < nRounds; round++) {
    t03 = SUB_MIX0[s03 >>> 24] ^ SUB_MIX1[s1 >>> 16 & 255] ^ SUB_MIX2[s2 >>> 8 & 255] ^ SUB_MIX3[s3 & 255] ^ keySchedule[ksRow++];
    t1 = SUB_MIX0[s1 >>> 24] ^ SUB_MIX1[s2 >>> 16 & 255] ^ SUB_MIX2[s3 >>> 8 & 255] ^ SUB_MIX3[s03 & 255] ^ keySchedule[ksRow++];
    t2 = SUB_MIX0[s2 >>> 24] ^ SUB_MIX1[s3 >>> 16 & 255] ^ SUB_MIX2[s03 >>> 8 & 255] ^ SUB_MIX3[s1 & 255] ^ keySchedule[ksRow++];
    t3 = SUB_MIX0[s3 >>> 24] ^ SUB_MIX1[s03 >>> 16 & 255] ^ SUB_MIX2[s1 >>> 8 & 255] ^ SUB_MIX3[s2 & 255] ^ keySchedule[ksRow++];
    s03 = t03;
    s1 = t1;
    s2 = t2;
    s3 = t3;
  }
  t03 = (SBOX[s03 >>> 24] << 24 | SBOX[s1 >>> 16 & 255] << 16 | SBOX[s2 >>> 8 & 255] << 8 | SBOX[s3 & 255]) ^ keySchedule[ksRow++];
  t1 = (SBOX[s1 >>> 24] << 24 | SBOX[s2 >>> 16 & 255] << 16 | SBOX[s3 >>> 8 & 255] << 8 | SBOX[s03 & 255]) ^ keySchedule[ksRow++];
  t2 = (SBOX[s2 >>> 24] << 24 | SBOX[s3 >>> 16 & 255] << 16 | SBOX[s03 >>> 8 & 255] << 8 | SBOX[s1 & 255]) ^ keySchedule[ksRow++];
  t3 = (SBOX[s3 >>> 24] << 24 | SBOX[s03 >>> 16 & 255] << 16 | SBOX[s1 >>> 8 & 255] << 8 | SBOX[s2 & 255]) ^ keySchedule[ksRow++];
  t03 = t03 >>> 0;
  t1 = t1 >>> 0;
  t2 = t2 >>> 0;
  t3 = t3 >>> 0;
  return [t03, t1, t2, t3];
}
var RCON = [0, 1, 2, 4, 8, 16, 32, 64, 128, 27, 54];
var G = function() {
  var d4 = new Array(256);
  for (var j2 = 0; j2 < 256; j2++) {
    if (j2 < 128) {
      d4[j2] = j2 << 1;
    } else {
      d4[j2] = j2 << 1 ^ 283;
    }
  }
  var SBOX = [];
  var INV_SBOX = [];
  var SUB_MIX = [[], [], [], []];
  var INV_SUB_MIX = [[], [], [], []];
  var x = 0;
  var xi = 0;
  for (var i = 0; i < 256; ++i) {
    var sx = xi ^ xi << 1 ^ xi << 2 ^ xi << 3 ^ xi << 4;
    sx = sx >>> 8 ^ sx & 255 ^ 99;
    SBOX[x] = sx;
    INV_SBOX[sx] = x;
    var x2 = d4[x];
    var x4 = d4[x2];
    var x8 = d4[x4];
    var t = d4[sx] * 257 ^ sx * 16843008;
    SUB_MIX[0][x] = t << 24 | t >>> 8;
    SUB_MIX[1][x] = t << 16 | t >>> 16;
    SUB_MIX[2][x] = t << 8 | t >>> 24;
    SUB_MIX[3][x] = t;
    t = x8 * 16843009 ^ x4 * 65537 ^ x2 * 257 ^ x * 16843008;
    INV_SUB_MIX[0][sx] = t << 24 | t >>> 8;
    INV_SUB_MIX[1][sx] = t << 16 | t >>> 16;
    INV_SUB_MIX[2][sx] = t << 8 | t >>> 24;
    INV_SUB_MIX[3][sx] = t;
    if (x === 0) {
      x = xi = 1;
    } else {
      x = x2 ^ d4[d4[d4[x8 ^ x2]]];
      xi ^= d4[d4[xi]];
    }
  }
  return {
    SBOX,
    INV_SBOX,
    SUB_MIX,
    INV_SUB_MIX
  };
}();
function AES(key2) {
  this._key = asUInt32Array(key2);
  this._reset();
}
AES.blockSize = 4 * 4;
AES.keySize = 256 / 8;
AES.prototype.blockSize = AES.blockSize;
AES.prototype.keySize = AES.keySize;
AES.prototype._reset = function() {
  var keyWords = this._key;
  var keySize = keyWords.length;
  var nRounds = keySize + 6;
  var ksRows = (nRounds + 1) * 4;
  var keySchedule = [];
  for (var k6 = 0; k6 < keySize; k6++) {
    keySchedule[k6] = keyWords[k6];
  }
  for (k6 = keySize; k6 < ksRows; k6++) {
    var t = keySchedule[k6 - 1];
    if (k6 % keySize === 0) {
      t = t << 8 | t >>> 24;
      t = G.SBOX[t >>> 24] << 24 | G.SBOX[t >>> 16 & 255] << 16 | G.SBOX[t >>> 8 & 255] << 8 | G.SBOX[t & 255];
      t ^= RCON[k6 / keySize | 0] << 24;
    } else if (keySize > 6 && k6 % keySize === 4) {
      t = G.SBOX[t >>> 24] << 24 | G.SBOX[t >>> 16 & 255] << 16 | G.SBOX[t >>> 8 & 255] << 8 | G.SBOX[t & 255];
    }
    keySchedule[k6] = keySchedule[k6 - keySize] ^ t;
  }
  var invKeySchedule = [];
  for (var ik = 0; ik < ksRows; ik++) {
    var ksR = ksRows - ik;
    var tt = keySchedule[ksR - (ik % 4 ? 0 : 4)];
    if (ik < 4 || ksR <= 4) {
      invKeySchedule[ik] = tt;
    } else {
      invKeySchedule[ik] = G.INV_SUB_MIX[0][G.SBOX[tt >>> 24]] ^ G.INV_SUB_MIX[1][G.SBOX[tt >>> 16 & 255]] ^ G.INV_SUB_MIX[2][G.SBOX[tt >>> 8 & 255]] ^ G.INV_SUB_MIX[3][G.SBOX[tt & 255]];
    }
  }
  this._nRounds = nRounds;
  this._keySchedule = keySchedule;
  this._invKeySchedule = invKeySchedule;
};
AES.prototype.encryptBlockRaw = function(M4) {
  M4 = asUInt32Array(M4);
  return cryptBlock(M4, this._keySchedule, G.SUB_MIX, G.SBOX, this._nRounds);
};
AES.prototype.encryptBlock = function(M4) {
  var out = this.encryptBlockRaw(M4);
  var buf = Buffer3.allocUnsafe(16);
  buf.writeUInt32BE(out[0], 0);
  buf.writeUInt32BE(out[1], 4);
  buf.writeUInt32BE(out[2], 8);
  buf.writeUInt32BE(out[3], 12);
  return buf;
};
AES.prototype.decryptBlock = function(M4) {
  M4 = asUInt32Array(M4);
  var m13 = M4[1];
  M4[1] = M4[3];
  M4[3] = m13;
  var out = cryptBlock(M4, this._invKeySchedule, G.INV_SUB_MIX, G.INV_SBOX, this._nRounds);
  var buf = Buffer3.allocUnsafe(16);
  buf.writeUInt32BE(out[0], 0);
  buf.writeUInt32BE(out[3], 4);
  buf.writeUInt32BE(out[2], 8);
  buf.writeUInt32BE(out[1], 12);
  return buf;
};
AES.prototype.scrub = function() {
  scrubVec(this._keySchedule);
  scrubVec(this._invKeySchedule);
  scrubVec(this._key);
};

// deno:https://deno.land/std@0.147.0/node/_crypto/crypto_browserify/cipher_base.js
function CipherBase(hashMode) {
  transform_default.call(this);
  this.hashMode = typeof hashMode === "string";
  if (this.hashMode) {
    this[hashMode] = this._finalOrDigest;
  } else {
    this.final = this._finalOrDigest;
  }
  if (this._final) {
    this.__final = this._final;
    this._final = null;
  }
  this._decoder = null;
  this._encoding = null;
}
CipherBase.prototype = Object.create(transform_default.prototype, {
  constructor: {
    value: CipherBase,
    enumerable: false,
    writable: true,
    configurable: true
  }
});
CipherBase.prototype.update = function(data, inputEnc, outputEnc) {
  if (typeof data === "string") {
    data = Buffer3.from(data, inputEnc);
  }
  var outData = this._update(data);
  if (this.hashMode)
    return this;
  if (outputEnc) {
    outData = this._toString(outData, outputEnc);
  }
  return outData;
};
CipherBase.prototype.setAutoPadding = function() {
};
CipherBase.prototype.getAuthTag = function() {
  throw new Error("trying to get auth tag in unsupported state");
};
CipherBase.prototype.setAuthTag = function() {
  throw new Error("trying to set auth tag in unsupported state");
};
CipherBase.prototype.setAAD = function() {
  throw new Error("trying to set aad in unsupported state");
};
CipherBase.prototype._transform = function(data, _2, next) {
  var err;
  try {
    if (this.hashMode) {
      this._update(data);
    } else {
      this.push(this._update(data));
    }
  } catch (e) {
    err = e;
  } finally {
    next(err);
  }
};
CipherBase.prototype._flush = function(done) {
  var err;
  try {
    this.push(this.__final());
  } catch (e) {
    err = e;
  }
  done(err);
};
CipherBase.prototype._finalOrDigest = function(outputEnc) {
  var outData = this.__final() || Buffer3.alloc(0);
  if (outputEnc) {
    outData = this._toString(outData, outputEnc, true);
  }
  return outData;
};
CipherBase.prototype._toString = function(value, enc, fin) {
  if (!this._decoder) {
    this._decoder = new StringDecoder(enc);
    this._encoding = enc;
  }
  if (this._encoding !== enc)
    throw new Error("can't switch encodings");
  var out = this._decoder.write(value);
  if (fin) {
    out += this._decoder.end();
  }
  return out;
};
var cipher_base_default = CipherBase;

// deno:https://deno.land/std@0.147.0/node/_crypto/crypto_browserify/browserify_aes/ghash.js
var ZEROES = Buffer3.alloc(16, 0);
function toArray(buf) {
  return [
    buf.readUInt32BE(0),
    buf.readUInt32BE(4),
    buf.readUInt32BE(8),
    buf.readUInt32BE(12)
  ];
}
function fromArray(out) {
  var buf = Buffer3.allocUnsafe(16);
  buf.writeUInt32BE(out[0] >>> 0, 0);
  buf.writeUInt32BE(out[1] >>> 0, 4);
  buf.writeUInt32BE(out[2] >>> 0, 8);
  buf.writeUInt32BE(out[3] >>> 0, 12);
  return buf;
}
function GHASH(key2) {
  this.h = key2;
  this.state = Buffer3.alloc(16, 0);
  this.cache = Buffer3.allocUnsafe(0);
}
GHASH.prototype.ghash = function(block) {
  var i = -1;
  while (++i < block.length) {
    this.state[i] ^= block[i];
  }
  this._multiply();
};
GHASH.prototype._multiply = function() {
  var Vi = toArray(this.h);
  var Zi3 = [0, 0, 0, 0];
  var j2, xi, lsbVi;
  var i = -1;
  while (++i < 128) {
    xi = (this.state[~~(i / 8)] & 1 << 7 - i % 8) !== 0;
    if (xi) {
      Zi3[0] ^= Vi[0];
      Zi3[1] ^= Vi[1];
      Zi3[2] ^= Vi[2];
      Zi3[3] ^= Vi[3];
    }
    lsbVi = (Vi[3] & 1) !== 0;
    for (j2 = 3; j2 > 0; j2--) {
      Vi[j2] = Vi[j2] >>> 1 | (Vi[j2 - 1] & 1) << 31;
    }
    Vi[0] = Vi[0] >>> 1;
    if (lsbVi) {
      Vi[0] = Vi[0] ^ 225 << 24;
    }
  }
  this.state = fromArray(Zi3);
};
GHASH.prototype.update = function(buf) {
  this.cache = Buffer3.concat([this.cache, buf]);
  var chunk;
  while (this.cache.length >= 16) {
    chunk = this.cache.slice(0, 16);
    this.cache = this.cache.slice(16);
    this.ghash(chunk);
  }
};
GHASH.prototype.final = function(abl, bl) {
  if (this.cache.length) {
    this.ghash(Buffer3.concat([this.cache, ZEROES], 16));
  }
  this.ghash(fromArray([0, abl, 0, bl]));
  return this.state;
};

// deno:https://deno.land/std@0.147.0/node/_crypto/crypto_browserify/browserify_aes/auth_cipher.js
function xorTest(a, b2) {
  var out = 0;
  if (a.length !== b2.length)
    out++;
  var len = Math.min(a.length, b2.length);
  for (var i = 0; i < len; ++i) {
    out += a[i] ^ b2[i];
  }
  return out;
}
function calcIv(self2, iv, ck) {
  if (iv.length === 12) {
    self2._finID = Buffer3.concat([iv, Buffer3.from([0, 0, 0, 1])]);
    return Buffer3.concat([iv, Buffer3.from([0, 0, 0, 2])]);
  }
  var ghash = new GHASH(ck);
  var len = iv.length;
  var toPad = len % 16;
  ghash.update(iv);
  if (toPad) {
    toPad = 16 - toPad;
    ghash.update(Buffer3.alloc(toPad, 0));
  }
  ghash.update(Buffer3.alloc(8, 0));
  var ivBits = len * 8;
  var tail = Buffer3.alloc(8);
  tail.writeUIntBE(ivBits, 2, 6);
  ghash.update(tail);
  self2._finID = ghash.state;
  var out = Buffer3.from(self2._finID);
  incr32(out);
  return out;
}
function StreamCipher(mode, key2, iv, decrypt4) {
  cipher_base_default.call(this);
  var h = Buffer3.alloc(4, 0);
  this._cipher = new AES(key2);
  var ck = this._cipher.encryptBlock(h);
  this._ghash = new GHASH(ck);
  iv = calcIv(this, iv, ck);
  this._prev = Buffer3.from(iv);
  this._cache = Buffer3.allocUnsafe(0);
  this._secCache = Buffer3.allocUnsafe(0);
  this._decrypt = decrypt4;
  this._alen = 0;
  this._len = 0;
  this._mode = mode;
  this._authTag = null;
  this._called = false;
}
StreamCipher.prototype = Object.create(cipher_base_default.prototype, {
  constructor: {
    value: StreamCipher,
    enumerable: false,
    writable: true,
    configurable: true
  }
});
StreamCipher.prototype._update = function(chunk) {
  if (!this._called && this._alen) {
    var rump = 16 - this._alen % 16;
    if (rump < 16) {
      rump = Buffer3.alloc(rump, 0);
      this._ghash.update(rump);
    }
  }
  this._called = true;
  var out = this._mode.encrypt(this, chunk);
  if (this._decrypt) {
    this._ghash.update(chunk);
  } else {
    this._ghash.update(out);
  }
  this._len += chunk.length;
  return out;
};
StreamCipher.prototype._final = function() {
  if (this._decrypt && !this._authTag) {
    throw new Error("Unsupported state or unable to authenticate data");
  }
  var tag2 = xor(this._ghash.final(this._alen * 8, this._len * 8), this._cipher.encryptBlock(this._finID));
  if (this._decrypt && xorTest(tag2, this._authTag)) {
    throw new Error("Unsupported state or unable to authenticate data");
  }
  this._authTag = tag2;
  this._cipher.scrub();
};
StreamCipher.prototype.getAuthTag = function getAuthTag() {
  if (this._decrypt || !Buffer3.isBuffer(this._authTag)) {
    throw new Error("Attempting to get auth tag in unsupported state");
  }
  return this._authTag;
};
StreamCipher.prototype.setAuthTag = function setAuthTag(tag2) {
  if (!this._decrypt) {
    throw new Error("Attempting to set auth tag in unsupported state");
  }
  this._authTag = tag2;
};
StreamCipher.prototype.setAAD = function setAAD(buf) {
  if (this._called) {
    throw new Error("Attempting to set AAD in unsupported state");
  }
  this._ghash.update(buf);
  this._alen += buf.length;
};
var auth_cipher_default = StreamCipher;

// deno:https://deno.land/std@0.147.0/node/_crypto/crypto_browserify/browserify_aes/stream_cipher.js
function StreamCipher2(mode, key2, iv, decrypt4) {
  cipher_base_default.call(this);
  this._cipher = new AES(key2);
  this._prev = Buffer3.from(iv);
  this._cache = Buffer3.allocUnsafe(0);
  this._secCache = Buffer3.allocUnsafe(0);
  this._decrypt = decrypt4;
  this._mode = mode;
}
StreamCipher2.prototype = Object.create(cipher_base_default.prototype, {
  constructor: {
    value: StreamCipher2,
    enumerable: false,
    writable: true,
    configurable: true
  }
});
StreamCipher2.prototype._update = function(chunk) {
  return this._mode.encrypt(this, chunk, this._decrypt);
};
StreamCipher2.prototype._final = function() {
  this._cipher.scrub();
};
var stream_cipher_default = StreamCipher2;

// deno:https://deno.land/std@0.147.0/node/_crypto/crypto_browserify/evp_bytes_to_key.ts
function EVP_BytesToKey(password, salt, keyBits, ivLen) {
  if (!Buffer3.isBuffer(password))
    password = Buffer3.from(password, "binary");
  if (salt) {
    if (!Buffer3.isBuffer(salt))
      salt = Buffer3.from(salt, "binary");
    if (salt.length !== 8) {
      throw new RangeError("salt should be Buffer with 8 byte length");
    }
  }
  let keyLen = keyBits / 8;
  const key2 = Buffer3.alloc(keyLen);
  const iv = Buffer3.alloc(ivLen || 0);
  let tmp = Buffer3.alloc(0);
  while (keyLen > 0 || ivLen > 0) {
    const hash = createHash("md5");
    hash.update(tmp);
    hash.update(password);
    if (salt)
      hash.update(salt);
    tmp = hash.digest();
    let used = 0;
    if (keyLen > 0) {
      const keyStart = key2.length - keyLen;
      used = Math.min(keyLen, tmp.length);
      tmp.copy(key2, keyStart, 0, used);
      keyLen -= used;
    }
    if (used < tmp.length && ivLen > 0) {
      const ivStart = iv.length - ivLen;
      const length = Math.min(ivLen, tmp.length - used);
      tmp.copy(iv, ivStart, used, used + length);
      ivLen -= length;
    }
  }
  tmp.fill(0);
  return { key: key2, iv };
}
var evp_bytes_to_key_default = EVP_BytesToKey;

// deno:https://deno.land/std@0.147.0/node/_crypto/crypto_browserify/browserify_aes/encrypter.js
function Cipher(mode, key2, iv) {
  cipher_base_default.call(this);
  this._cache = new Splitter();
  this._cipher = new AES(key2);
  this._prev = Buffer3.from(iv);
  this._mode = mode;
  this._autopadding = true;
}
Cipher.prototype = Object.create(cipher_base_default.prototype, {
  constructor: {
    value: Cipher,
    enumerable: false,
    writable: true,
    configurable: true
  }
});
Cipher.prototype._update = function(data) {
  this._cache.add(data);
  var chunk;
  var thing;
  var out = [];
  while (chunk = this._cache.get()) {
    thing = this._mode.encrypt(this, chunk);
    out.push(thing);
  }
  return Buffer3.concat(out);
};
var PADDING = Buffer3.alloc(16, 16);
Cipher.prototype._final = function() {
  var chunk = this._cache.flush();
  if (this._autopadding) {
    chunk = this._mode.encrypt(this, chunk);
    this._cipher.scrub();
    return chunk;
  }
  if (!chunk.equals(PADDING)) {
    this._cipher.scrub();
    throw new Error("data not multiple of block length");
  }
};
Cipher.prototype.setAutoPadding = function(setTo) {
  this._autopadding = !!setTo;
  return this;
};
function Splitter() {
  this.cache = Buffer3.allocUnsafe(0);
}
Splitter.prototype.add = function(data) {
  this.cache = Buffer3.concat([this.cache, data]);
};
Splitter.prototype.get = function() {
  if (this.cache.length > 15) {
    const out = this.cache.slice(0, 16);
    this.cache = this.cache.slice(16);
    return out;
  }
  return null;
};
Splitter.prototype.flush = function() {
  var len = 16 - this.cache.length;
  var padBuff = Buffer3.allocUnsafe(len);
  var i = -1;
  while (++i < len) {
    padBuff.writeUInt8(len, i);
  }
  return Buffer3.concat([this.cache, padBuff]);
};

// deno:https://deno.land/std@0.147.0/node/_crypto/crypto_browserify/browserify_aes/decrypter.js
function Decipher(mode, key2, iv) {
  cipher_base_default.call(this);
  this._cache = new Splitter2();
  this._last = void 0;
  this._cipher = new AES(key2);
  this._prev = Buffer3.from(iv);
  this._mode = mode;
  this._autopadding = true;
}
Decipher.prototype = Object.create(cipher_base_default.prototype, {
  constructor: {
    value: Decipher,
    enumerable: false,
    writable: true,
    configurable: true
  }
});
Decipher.prototype._update = function(data) {
  this._cache.add(data);
  var chunk;
  var thing;
  var out = [];
  while (chunk = this._cache.get(this._autopadding)) {
    thing = this._mode.decrypt(this, chunk);
    out.push(thing);
  }
  return Buffer3.concat(out);
};
Decipher.prototype._final = function() {
  var chunk = this._cache.flush();
  if (this._autopadding) {
    return unpad(this._mode.decrypt(this, chunk));
  } else if (chunk) {
    throw new Error("data not multiple of block length");
  }
};
Decipher.prototype.setAutoPadding = function(setTo) {
  this._autopadding = !!setTo;
  return this;
};
function Splitter2() {
  this.cache = Buffer3.allocUnsafe(0);
}
Splitter2.prototype.add = function(data) {
  this.cache = Buffer3.concat([this.cache, data]);
};
Splitter2.prototype.get = function(autoPadding) {
  var out;
  if (autoPadding) {
    if (this.cache.length > 16) {
      out = this.cache.slice(0, 16);
      this.cache = this.cache.slice(16);
      return out;
    }
  } else {
    if (this.cache.length >= 16) {
      out = this.cache.slice(0, 16);
      this.cache = this.cache.slice(16);
      return out;
    }
  }
  return null;
};
Splitter2.prototype.flush = function() {
  if (this.cache.length)
    return this.cache;
};
function unpad(last) {
  var padded = last[15];
  if (padded < 1 || padded > 16) {
    throw new Error("unable to decrypt data");
  }
  var i = -1;
  while (++i < padded) {
    if (last[i + (16 - padded)] !== padded) {
      throw new Error("unable to decrypt data");
    }
  }
  if (padded === 16)
    return;
  return last.slice(0, 16 - padded);
}
function createDecipheriv(suite, password, iv) {
  var config = MODES[suite.toLowerCase()];
  if (!config)
    throw new TypeError("invalid suite type");
  if (typeof iv === "string")
    iv = Buffer3.from(iv);
  if (config.mode !== "GCM" && iv.length !== config.iv) {
    throw new TypeError("invalid iv length " + iv.length);
  }
  if (typeof password === "string")
    password = Buffer3.from(password);
  if (password.length !== config.key / 8) {
    throw new TypeError("invalid key length " + password.length);
  }
  if (config.type === "stream") {
    return new stream_cipher_default(config.module, password, iv, true);
  } else if (config.type === "auth") {
    return new auth_cipher_default(config.module, password, iv, true);
  }
  return new Decipher(config.module, password, iv);
}

// deno:https://deno.land/std@0.147.0/node/_crypto/crypto_browserify/browserify_aes/mod.js
function getCiphers() {
  return Object.keys(MODES);
}

// deno:https://deno.land/std@0.147.0/node/internal/crypto/util.ts
var defaultEncoding = "buffer";
function getDefaultEncoding() {
  return defaultEncoding;
}
function toBuf(val, encoding) {
  if (typeof val === "string") {
    if (encoding === "buffer") {
      encoding = "utf8";
    }
    return Buffer3.from(val, encoding);
  }
  return val;
}
var validateByteSource = hideStackFrames((val, name) => {
  val = toBuf(val);
  if (isAnyArrayBuffer2(val) || isArrayBufferView(val)) {
    return;
  }
  throw new ERR_INVALID_ARG_TYPE(name, ["string", "ArrayBuffer", "TypedArray", "DataView", "Buffer"], val);
});
function getHashes() {
  return digestAlgorithms;
}
function getCurves() {
  notImplemented("crypto.getCurves");
}
function secureHeapUsed() {
  notImplemented("crypto.secureHeapUsed");
}
function setEngine(_engine, _flags) {
  notImplemented("crypto.setEngine");
}

// deno:https://deno.land/std@0.147.0/node/internal/crypto/keys.ts
var KeyObject = class {
  constructor(type, handle) {
    if (type !== "secret" && type !== "public" && type !== "private") {
      throw new ERR_INVALID_ARG_VALUE("type", type);
    }
    if (typeof handle !== "object") {
      throw new ERR_INVALID_ARG_TYPE("handle", "object", handle);
    }
    this[kKeyType] = type;
    Object.defineProperty(this, kHandle, {
      value: handle,
      enumerable: false,
      configurable: false,
      writable: false
    });
  }
  get type() {
    return this[kKeyType];
  }
  get asymmetricKeyDetails() {
    notImplemented("crypto.KeyObject.prototype.asymmetricKeyDetails");
    return void 0;
  }
  get asymmetricKeyType() {
    notImplemented("crypto.KeyObject.prototype.asymmetricKeyType");
    return void 0;
  }
  get symmetricKeySize() {
    notImplemented("crypto.KeyObject.prototype.symmetricKeySize");
    return void 0;
  }
  static from(key2) {
    if (!isCryptoKey(key2)) {
      throw new ERR_INVALID_ARG_TYPE("key", "CryptoKey", key2);
    }
    notImplemented("crypto.KeyObject.prototype.from");
  }
  equals(otherKeyObject) {
    if (!isKeyObject(otherKeyObject)) {
      throw new ERR_INVALID_ARG_TYPE("otherKeyObject", "KeyObject", otherKeyObject);
    }
    notImplemented("crypto.KeyObject.prototype.equals");
  }
  export(_options) {
    notImplemented("crypto.KeyObject.prototype.asymmetricKeyType");
  }
};
kKeyType, kHandle;
function createPrivateKey(_key) {
  notImplemented("crypto.createPrivateKey");
}
function createPublicKey(_key) {
  notImplemented("crypto.createPublicKey");
}
function createSecretKey(_key, _encoding) {
  notImplemented("crypto.createSecretKey");
}

// deno:https://deno.land/std@0.147.0/node/internal/crypto/hkdf.ts
var validateParameters = hideStackFrames((hash, key2, salt, info2, length) => {
  key2 = prepareKey(key2);
  salt = toBuf(salt);
  info2 = toBuf(info2);
  validateString(hash, "digest");
  validateByteSource(salt, "salt");
  validateByteSource(info2, "info");
  validateInteger(length, "length", 0, kMaxLength);
  if (info2.byteLength > 1024) {
    throw new ERR_OUT_OF_RANGE("info", "must not contain more than 1024 bytes", info2.byteLength);
  }
  return {
    hash,
    key: key2,
    salt,
    info: info2,
    length
  };
});
function prepareKey(key2) {
  if (isKeyObject(key2)) {
    return key2;
  }
  if (isAnyArrayBuffer2(key2)) {
    return createSecretKey(new Uint8Array(key2));
  }
  key2 = toBuf(key2);
  if (!isArrayBufferView(key2)) {
    throw new ERR_INVALID_ARG_TYPE("ikm", [
      "string",
      "SecretKeyObject",
      "ArrayBuffer",
      "TypedArray",
      "DataView",
      "Buffer"
    ], key2);
  }
  return createSecretKey(key2);
}
function hkdf(hash, key2, salt, info2, length, callback) {
  ({ hash, key: key2, salt, info: info2, length } = validateParameters(hash, key2, salt, info2, length));
  validateCallback(callback);
  notImplemented("crypto.hkdf");
}
function hkdfSync(hash, key2, salt, info2, length) {
  ({ hash, key: key2, salt, info: info2, length } = validateParameters(hash, key2, salt, info2, length));
  notImplemented("crypto.hkdfSync");
}

// deno:https://deno.land/std@0.147.0/node/internal/crypto/keygen.ts
function generateKey(_type, _options, _callback) {
  notImplemented("crypto.generateKey");
}
function generateKeyPair(_type, _options, _callback) {
  notImplemented("crypto.generateKeyPair");
}
function generateKeyPairSync(_type, _options) {
  notImplemented("crypto.generateKeyPairSync");
}
function generateKeySync(_type, _options) {
  notImplemented("crypto.generateKeySync");
}

// deno:https://deno.land/std@0.147.0/node/internal/crypto/diffiehellman.ts
var DH_GENERATOR = 2;
var DiffieHellman = class {
  constructor(sizeOrKey, keyEncoding, generator, genEncoding) {
    if (typeof sizeOrKey !== "number" && typeof sizeOrKey !== "string" && !isArrayBufferView(sizeOrKey) && !isAnyArrayBuffer2(sizeOrKey)) {
      throw new ERR_INVALID_ARG_TYPE("sizeOrKey", ["number", "string", "ArrayBuffer", "Buffer", "TypedArray", "DataView"], sizeOrKey);
    }
    if (typeof sizeOrKey === "number") {
      validateInt32(sizeOrKey, "sizeOrKey");
    }
    if (keyEncoding && !Buffer3.isEncoding(keyEncoding) && keyEncoding !== "buffer") {
      genEncoding = generator;
      generator = keyEncoding;
      keyEncoding = false;
    }
    const encoding = getDefaultEncoding();
    keyEncoding = keyEncoding || encoding;
    genEncoding = genEncoding || encoding;
    if (typeof sizeOrKey !== "number") {
      sizeOrKey = toBuf(sizeOrKey, keyEncoding);
    }
    if (!generator) {
      generator = DH_GENERATOR;
    } else if (typeof generator === "number") {
      validateInt32(generator, "generator");
    } else if (typeof generator === "string") {
      generator = toBuf(generator, genEncoding);
    } else if (!isArrayBufferView(generator) && !isAnyArrayBuffer2(generator)) {
      throw new ERR_INVALID_ARG_TYPE("generator", ["number", "string", "ArrayBuffer", "Buffer", "TypedArray", "DataView"], generator);
    }
    notImplemented("crypto.DiffieHellman");
  }
  computeSecret(_otherPublicKey, _inputEncoding, _outputEncoding) {
    notImplemented("crypto.DiffieHellman.prototype.computeSecret");
  }
  generateKeys(_encoding) {
    notImplemented("crypto.DiffieHellman.prototype.generateKeys");
  }
  getGenerator(_encoding) {
    notImplemented("crypto.DiffieHellman.prototype.getGenerator");
  }
  getPrime(_encoding) {
    notImplemented("crypto.DiffieHellman.prototype.getPrime");
  }
  getPrivateKey(_encoding) {
    notImplemented("crypto.DiffieHellman.prototype.getPrivateKey");
  }
  getPublicKey(_encoding) {
    notImplemented("crypto.DiffieHellman.prototype.getPublicKey");
  }
  setPrivateKey(_privateKey, _encoding) {
    notImplemented("crypto.DiffieHellman.prototype.setPrivateKey");
  }
  setPublicKey(_publicKey, _encoding) {
    notImplemented("crypto.DiffieHellman.prototype.setPublicKey");
  }
};
var DiffieHellmanGroup = class {
  constructor(_name) {
    notImplemented("crypto.DiffieHellmanGroup");
  }
  computeSecret(_otherPublicKey, _inputEncoding, _outputEncoding) {
    notImplemented("crypto.DiffieHellman.prototype.computeSecret");
  }
  generateKeys(_encoding) {
    notImplemented("crypto.DiffieHellman.prototype.generateKeys");
  }
  getGenerator(_encoding) {
    notImplemented("crypto.DiffieHellman.prototype.getGenerator");
  }
  getPrime(_encoding) {
    notImplemented("crypto.DiffieHellman.prototype.getPrime");
  }
  getPrivateKey(_encoding) {
    notImplemented("crypto.DiffieHellman.prototype.getPrivateKey");
  }
  getPublicKey(_encoding) {
    notImplemented("crypto.DiffieHellman.prototype.getPublicKey");
  }
};
var ECDH = class {
  constructor(curve) {
    validateString(curve, "curve");
    notImplemented("crypto.ECDH");
  }
  static convertKey(_key, _curve, _inputEncoding, _outputEncoding, _format3) {
    notImplemented("crypto.ECDH.prototype.convertKey");
  }
  computeSecret(_otherPublicKey, _inputEncoding, _outputEncoding) {
    notImplemented("crypto.ECDH.prototype.computeSecret");
  }
  generateKeys(_encoding, _format3) {
    notImplemented("crypto.ECDH.prototype.generateKeys");
  }
  getPrivateKey(_encoding) {
    notImplemented("crypto.ECDH.prototype.getPrivateKey");
  }
  getPublicKey(_encoding, _format3) {
    notImplemented("crypto.ECDH.prototype.getPublicKey");
  }
  setPrivateKey(_privateKey, _encoding) {
    notImplemented("crypto.ECDH.prototype.setPrivateKey");
  }
};
function diffieHellman(_options) {
  notImplemented("crypto.diffieHellman");
}

// deno:https://deno.land/std@0.147.0/node/_crypto/crypto_browserify/bn.js/bn.js
function assert3(val, msg) {
  if (!val)
    throw new Error(msg || "Assertion failed");
}
function inherits2(ctor, superCtor) {
  ctor.super_ = superCtor;
  var TempCtor = function() {
  };
  TempCtor.prototype = superCtor.prototype;
  ctor.prototype = new TempCtor();
  ctor.prototype.constructor = ctor;
}
function BN(number, base3, endian) {
  if (BN.isBN(number)) {
    return number;
  }
  this.negative = 0;
  this.words = null;
  this.length = 0;
  this.red = null;
  if (number !== null) {
    if (base3 === "le" || base3 === "be") {
      endian = base3;
      base3 = 10;
    }
    this._init(number || 0, base3 || 10, endian || "be");
  }
}
var bn_default = BN;
BN.BN = BN;
BN.wordSize = 26;
BN.isBN = function isBN(num) {
  if (num instanceof BN) {
    return true;
  }
  return num !== null && typeof num === "object" && num.constructor.wordSize === BN.wordSize && Array.isArray(num.words);
};
BN.max = function max(left, right) {
  if (left.cmp(right) > 0)
    return left;
  return right;
};
BN.min = function min2(left, right) {
  if (left.cmp(right) < 0)
    return left;
  return right;
};
BN.prototype._init = function init(number, base3, endian) {
  if (typeof number === "number") {
    return this._initNumber(number, base3, endian);
  }
  if (typeof number === "object") {
    return this._initArray(number, base3, endian);
  }
  if (base3 === "hex") {
    base3 = 16;
  }
  assert3(base3 === (base3 | 0) && base3 >= 2 && base3 <= 36);
  number = number.toString().replace(/\s+/g, "");
  var start = 0;
  if (number[0] === "-") {
    start++;
    this.negative = 1;
  }
  if (start < number.length) {
    if (base3 === 16) {
      this._parseHex(number, start, endian);
    } else {
      this._parseBase(number, base3, start);
      if (endian === "le") {
        this._initArray(this.toArray(), base3, endian);
      }
    }
  }
};
BN.prototype._initNumber = function _initNumber(number, base3, endian) {
  if (number < 0) {
    this.negative = 1;
    number = -number;
  }
  if (number < 67108864) {
    this.words = [number & 67108863];
    this.length = 1;
  } else if (number < 4503599627370496) {
    this.words = [
      number & 67108863,
      number / 67108864 & 67108863
    ];
    this.length = 2;
  } else {
    assert3(number < 9007199254740992);
    this.words = [
      number & 67108863,
      number / 67108864 & 67108863,
      1
    ];
    this.length = 3;
  }
  if (endian !== "le")
    return;
  this._initArray(this.toArray(), base3, endian);
};
BN.prototype._initArray = function _initArray(number, base3, endian) {
  assert3(typeof number.length === "number");
  if (number.length <= 0) {
    this.words = [0];
    this.length = 1;
    return this;
  }
  this.length = Math.ceil(number.length / 3);
  this.words = new Array(this.length);
  for (var i = 0; i < this.length; i++) {
    this.words[i] = 0;
  }
  var j2, w2;
  var off = 0;
  if (endian === "be") {
    for (i = number.length - 1, j2 = 0; i >= 0; i -= 3) {
      w2 = number[i] | number[i - 1] << 8 | number[i - 2] << 16;
      this.words[j2] |= w2 << off & 67108863;
      this.words[j2 + 1] = w2 >>> 26 - off & 67108863;
      off += 24;
      if (off >= 26) {
        off -= 26;
        j2++;
      }
    }
  } else if (endian === "le") {
    for (i = 0, j2 = 0; i < number.length; i += 3) {
      w2 = number[i] | number[i + 1] << 8 | number[i + 2] << 16;
      this.words[j2] |= w2 << off & 67108863;
      this.words[j2 + 1] = w2 >>> 26 - off & 67108863;
      off += 24;
      if (off >= 26) {
        off -= 26;
        j2++;
      }
    }
  }
  return this._strip();
};
function parseHex4Bits(string, index) {
  var c5 = string.charCodeAt(index);
  if (c5 >= 48 && c5 <= 57) {
    return c5 - 48;
  } else if (c5 >= 65 && c5 <= 70) {
    return c5 - 55;
  } else if (c5 >= 97 && c5 <= 102) {
    return c5 - 87;
  } else {
    assert3(false, "Invalid character in " + string);
  }
}
function parseHexByte(string, lowerBound, index) {
  var r = parseHex4Bits(string, index);
  if (index - 1 >= lowerBound) {
    r |= parseHex4Bits(string, index - 1) << 4;
  }
  return r;
}
BN.prototype._parseHex = function _parseHex(number, start, endian) {
  this.length = Math.ceil((number.length - start) / 6);
  this.words = new Array(this.length);
  for (var i = 0; i < this.length; i++) {
    this.words[i] = 0;
  }
  var off = 0;
  var j2 = 0;
  var w2;
  if (endian === "be") {
    for (i = number.length - 1; i >= start; i -= 2) {
      w2 = parseHexByte(number, start, i) << off;
      this.words[j2] |= w2 & 67108863;
      if (off >= 18) {
        off -= 18;
        j2 += 1;
        this.words[j2] |= w2 >>> 26;
      } else {
        off += 8;
      }
    }
  } else {
    var parseLength = number.length - start;
    for (i = parseLength % 2 === 0 ? start + 1 : start; i < number.length; i += 2) {
      w2 = parseHexByte(number, start, i) << off;
      this.words[j2] |= w2 & 67108863;
      if (off >= 18) {
        off -= 18;
        j2 += 1;
        this.words[j2] |= w2 >>> 26;
      } else {
        off += 8;
      }
    }
  }
  this._strip();
};
function parseBase(str, start, end, mul4) {
  var r = 0;
  var b2 = 0;
  var len = Math.min(str.length, end);
  for (var i = start; i < len; i++) {
    var c5 = str.charCodeAt(i) - 48;
    r *= mul4;
    if (c5 >= 49) {
      b2 = c5 - 49 + 10;
    } else if (c5 >= 17) {
      b2 = c5 - 17 + 10;
    } else {
      b2 = c5;
    }
    assert3(c5 >= 0 && b2 < mul4, "Invalid character");
    r += b2;
  }
  return r;
}
BN.prototype._parseBase = function _parseBase(number, base3, start) {
  this.words = [0];
  this.length = 1;
  for (var limbLen = 0, limbPow = 1; limbPow <= 67108863; limbPow *= base3) {
    limbLen++;
  }
  limbLen--;
  limbPow = limbPow / base3 | 0;
  var total = number.length - start;
  var mod2 = total % limbLen;
  var end = Math.min(total, total - mod2) + start;
  var word = 0;
  for (var i = start; i < end; i += limbLen) {
    word = parseBase(number, i, i + limbLen, base3);
    this.imuln(limbPow);
    if (this.words[0] + word < 67108864) {
      this.words[0] += word;
    } else {
      this._iaddn(word);
    }
  }
  if (mod2 !== 0) {
    var pow3 = 1;
    word = parseBase(number, i, number.length, base3);
    for (i = 0; i < mod2; i++) {
      pow3 *= base3;
    }
    this.imuln(pow3);
    if (this.words[0] + word < 67108864) {
      this.words[0] += word;
    } else {
      this._iaddn(word);
    }
  }
  this._strip();
};
BN.prototype.copy = function copy3(dest) {
  dest.words = new Array(this.length);
  for (var i = 0; i < this.length; i++) {
    dest.words[i] = this.words[i];
  }
  dest.length = this.length;
  dest.negative = this.negative;
  dest.red = this.red;
};
function move(dest, src) {
  dest.words = src.words;
  dest.length = src.length;
  dest.negative = src.negative;
  dest.red = src.red;
}
BN.prototype._move = function _move(dest) {
  move(dest, this);
};
BN.prototype.clone = function clone() {
  var r = new BN(null);
  this.copy(r);
  return r;
};
BN.prototype._expand = function _expand(size) {
  while (this.length < size) {
    this.words[this.length++] = 0;
  }
  return this;
};
BN.prototype._strip = function strip() {
  while (this.length > 1 && this.words[this.length - 1] === 0) {
    this.length--;
  }
  return this._normSign();
};
BN.prototype._normSign = function _normSign() {
  if (this.length === 1 && this.words[0] === 0) {
    this.negative = 0;
  }
  return this;
};
if (typeof Symbol !== "undefined" && typeof Symbol.for === "function") {
  try {
    BN.prototype[Symbol.for("nodejs.util.inspect.custom")] = inspect3;
  } catch (e) {
    BN.prototype.inspect = inspect3;
  }
} else {
  BN.prototype.inspect = inspect3;
}
function inspect3() {
  return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
}
var zeros = [
  "",
  "0",
  "00",
  "000",
  "0000",
  "00000",
  "000000",
  "0000000",
  "00000000",
  "000000000",
  "0000000000",
  "00000000000",
  "000000000000",
  "0000000000000",
  "00000000000000",
  "000000000000000",
  "0000000000000000",
  "00000000000000000",
  "000000000000000000",
  "0000000000000000000",
  "00000000000000000000",
  "000000000000000000000",
  "0000000000000000000000",
  "00000000000000000000000",
  "000000000000000000000000",
  "0000000000000000000000000"
];
var groupSizes = [
  0,
  0,
  25,
  16,
  12,
  11,
  10,
  9,
  8,
  8,
  7,
  7,
  7,
  7,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5
];
var groupBases = [
  0,
  0,
  33554432,
  43046721,
  16777216,
  48828125,
  60466176,
  40353607,
  16777216,
  43046721,
  1e7,
  19487171,
  35831808,
  62748517,
  7529536,
  11390625,
  16777216,
  24137569,
  34012224,
  47045881,
  64e6,
  4084101,
  5153632,
  6436343,
  7962624,
  9765625,
  11881376,
  14348907,
  17210368,
  20511149,
  243e5,
  28629151,
  33554432,
  39135393,
  45435424,
  52521875,
  60466176
];
BN.prototype.toString = function toString2(base3, padding) {
  base3 = base3 || 10;
  padding = padding | 0 || 1;
  var out;
  if (base3 === 16 || base3 === "hex") {
    out = "";
    var off = 0;
    var carry = 0;
    for (var i = 0; i < this.length; i++) {
      var w2 = this.words[i];
      var word = ((w2 << off | carry) & 16777215).toString(16);
      carry = w2 >>> 24 - off & 16777215;
      if (carry !== 0 || i !== this.length - 1) {
        out = zeros[6 - word.length] + word + out;
      } else {
        out = word + out;
      }
      off += 2;
      if (off >= 26) {
        off -= 26;
        i--;
      }
    }
    if (carry !== 0) {
      out = carry.toString(16) + out;
    }
    while (out.length % padding !== 0) {
      out = "0" + out;
    }
    if (this.negative !== 0) {
      out = "-" + out;
    }
    return out;
  }
  if (base3 === (base3 | 0) && base3 >= 2 && base3 <= 36) {
    var groupSize = groupSizes[base3];
    var groupBase = groupBases[base3];
    out = "";
    var c5 = this.clone();
    c5.negative = 0;
    while (!c5.isZero()) {
      var r = c5.modrn(groupBase).toString(base3);
      c5 = c5.idivn(groupBase);
      if (!c5.isZero()) {
        out = zeros[groupSize - r.length] + r + out;
      } else {
        out = r + out;
      }
    }
    if (this.isZero()) {
      out = "0" + out;
    }
    while (out.length % padding !== 0) {
      out = "0" + out;
    }
    if (this.negative !== 0) {
      out = "-" + out;
    }
    return out;
  }
  assert3(false, "Base should be between 2 and 36");
};
BN.prototype.toNumber = function toNumber() {
  var ret = this.words[0];
  if (this.length === 2) {
    ret += this.words[1] * 67108864;
  } else if (this.length === 3 && this.words[2] === 1) {
    ret += 4503599627370496 + this.words[1] * 67108864;
  } else if (this.length > 2) {
    assert3(false, "Number can only safely store up to 53 bits");
  }
  return this.negative !== 0 ? -ret : ret;
};
BN.prototype.toJSON = function toJSON2() {
  return this.toString(16, 2);
};
if (Buffer3) {
  BN.prototype.toBuffer = function toBuffer2(endian, length) {
    return this.toArrayLike(Buffer3, endian, length);
  };
}
BN.prototype.toArray = function toArray2(endian, length) {
  return this.toArrayLike(Array, endian, length);
};
var allocate = function allocate2(ArrayType, size) {
  if (ArrayType.allocUnsafe) {
    return ArrayType.allocUnsafe(size);
  }
  return new ArrayType(size);
};
BN.prototype.toArrayLike = function toArrayLike(ArrayType, endian, length) {
  this._strip();
  var byteLength6 = this.byteLength();
  var reqLength = length || Math.max(1, byteLength6);
  assert3(byteLength6 <= reqLength, "byte array longer than desired length");
  assert3(reqLength > 0, "Requested array length <= 0");
  var res = allocate(ArrayType, reqLength);
  var postfix = endian === "le" ? "LE" : "BE";
  this["_toArrayLike" + postfix](res, byteLength6);
  return res;
};
BN.prototype._toArrayLikeLE = function _toArrayLikeLE(res, byteLength6) {
  var position = 0;
  var carry = 0;
  for (var i = 0, shift = 0; i < this.length; i++) {
    var word = this.words[i] << shift | carry;
    res[position++] = word & 255;
    if (position < res.length) {
      res[position++] = word >> 8 & 255;
    }
    if (position < res.length) {
      res[position++] = word >> 16 & 255;
    }
    if (shift === 6) {
      if (position < res.length) {
        res[position++] = word >> 24 & 255;
      }
      carry = 0;
      shift = 0;
    } else {
      carry = word >>> 24;
      shift += 2;
    }
  }
  if (position < res.length) {
    res[position++] = carry;
    while (position < res.length) {
      res[position++] = 0;
    }
  }
};
BN.prototype._toArrayLikeBE = function _toArrayLikeBE(res, byteLength6) {
  var position = res.length - 1;
  var carry = 0;
  for (var i = 0, shift = 0; i < this.length; i++) {
    var word = this.words[i] << shift | carry;
    res[position--] = word & 255;
    if (position >= 0) {
      res[position--] = word >> 8 & 255;
    }
    if (position >= 0) {
      res[position--] = word >> 16 & 255;
    }
    if (shift === 6) {
      if (position >= 0) {
        res[position--] = word >> 24 & 255;
      }
      carry = 0;
      shift = 0;
    } else {
      carry = word >>> 24;
      shift += 2;
    }
  }
  if (position >= 0) {
    res[position--] = carry;
    while (position >= 0) {
      res[position--] = 0;
    }
  }
};
if (Math.clz32) {
  BN.prototype._countBits = function _countBits(w2) {
    return 32 - Math.clz32(w2);
  };
} else {
  BN.prototype._countBits = function _countBits(w2) {
    var t = w2;
    var r = 0;
    if (t >= 4096) {
      r += 13;
      t >>>= 13;
    }
    if (t >= 64) {
      r += 7;
      t >>>= 7;
    }
    if (t >= 8) {
      r += 4;
      t >>>= 4;
    }
    if (t >= 2) {
      r += 2;
      t >>>= 2;
    }
    return r + t;
  };
}
BN.prototype._zeroBits = function _zeroBits(w2) {
  if (w2 === 0)
    return 26;
  var t = w2;
  var r = 0;
  if ((t & 8191) === 0) {
    r += 13;
    t >>>= 13;
  }
  if ((t & 127) === 0) {
    r += 7;
    t >>>= 7;
  }
  if ((t & 15) === 0) {
    r += 4;
    t >>>= 4;
  }
  if ((t & 3) === 0) {
    r += 2;
    t >>>= 2;
  }
  if ((t & 1) === 0) {
    r++;
  }
  return r;
};
BN.prototype.bitLength = function bitLength() {
  var w2 = this.words[this.length - 1];
  var hi2 = this._countBits(w2);
  return (this.length - 1) * 26 + hi2;
};
function toBitArray(num) {
  var w2 = new Array(num.bitLength());
  for (var bit = 0; bit < w2.length; bit++) {
    var off = bit / 26 | 0;
    var wbit = bit % 26;
    w2[bit] = num.words[off] >>> wbit & 1;
  }
  return w2;
}
BN.prototype.zeroBits = function zeroBits() {
  if (this.isZero())
    return 0;
  var r = 0;
  for (var i = 0; i < this.length; i++) {
    var b2 = this._zeroBits(this.words[i]);
    r += b2;
    if (b2 !== 26)
      break;
  }
  return r;
};
BN.prototype.byteLength = function byteLength2() {
  return Math.ceil(this.bitLength() / 8);
};
BN.prototype.toTwos = function toTwos(width) {
  if (this.negative !== 0) {
    return this.abs().inotn(width).iaddn(1);
  }
  return this.clone();
};
BN.prototype.fromTwos = function fromTwos(width) {
  if (this.testn(width - 1)) {
    return this.notn(width).iaddn(1).ineg();
  }
  return this.clone();
};
BN.prototype.isNeg = function isNeg() {
  return this.negative !== 0;
};
BN.prototype.neg = function neg() {
  return this.clone().ineg();
};
BN.prototype.ineg = function ineg() {
  if (!this.isZero()) {
    this.negative ^= 1;
  }
  return this;
};
BN.prototype.iuor = function iuor(num) {
  while (this.length < num.length) {
    this.words[this.length++] = 0;
  }
  for (var i = 0; i < num.length; i++) {
    this.words[i] = this.words[i] | num.words[i];
  }
  return this._strip();
};
BN.prototype.ior = function ior(num) {
  assert3((this.negative | num.negative) === 0);
  return this.iuor(num);
};
BN.prototype.or = function or(num) {
  if (this.length > num.length)
    return this.clone().ior(num);
  return num.clone().ior(this);
};
BN.prototype.uor = function uor(num) {
  if (this.length > num.length)
    return this.clone().iuor(num);
  return num.clone().iuor(this);
};
BN.prototype.iuand = function iuand(num) {
  var b2;
  if (this.length > num.length) {
    b2 = num;
  } else {
    b2 = this;
  }
  for (var i = 0; i < b2.length; i++) {
    this.words[i] = this.words[i] & num.words[i];
  }
  this.length = b2.length;
  return this._strip();
};
BN.prototype.iand = function iand(num) {
  assert3((this.negative | num.negative) === 0);
  return this.iuand(num);
};
BN.prototype.and = function and(num) {
  if (this.length > num.length)
    return this.clone().iand(num);
  return num.clone().iand(this);
};
BN.prototype.uand = function uand(num) {
  if (this.length > num.length)
    return this.clone().iuand(num);
  return num.clone().iuand(this);
};
BN.prototype.iuxor = function iuxor(num) {
  var a;
  var b2;
  if (this.length > num.length) {
    a = this;
    b2 = num;
  } else {
    a = num;
    b2 = this;
  }
  for (var i = 0; i < b2.length; i++) {
    this.words[i] = a.words[i] ^ b2.words[i];
  }
  if (this !== a) {
    for (; i < a.length; i++) {
      this.words[i] = a.words[i];
    }
  }
  this.length = a.length;
  return this._strip();
};
BN.prototype.ixor = function ixor(num) {
  assert3((this.negative | num.negative) === 0);
  return this.iuxor(num);
};
BN.prototype.xor = function xor2(num) {
  if (this.length > num.length)
    return this.clone().ixor(num);
  return num.clone().ixor(this);
};
BN.prototype.uxor = function uxor(num) {
  if (this.length > num.length)
    return this.clone().iuxor(num);
  return num.clone().iuxor(this);
};
BN.prototype.inotn = function inotn(width) {
  assert3(typeof width === "number" && width >= 0);
  var bytesNeeded = Math.ceil(width / 26) | 0;
  var bitsLeft = width % 26;
  this._expand(bytesNeeded);
  if (bitsLeft > 0) {
    bytesNeeded--;
  }
  for (var i = 0; i < bytesNeeded; i++) {
    this.words[i] = ~this.words[i] & 67108863;
  }
  if (bitsLeft > 0) {
    this.words[i] = ~this.words[i] & 67108863 >> 26 - bitsLeft;
  }
  return this._strip();
};
BN.prototype.notn = function notn(width) {
  return this.clone().inotn(width);
};
BN.prototype.setn = function setn(bit, val) {
  assert3(typeof bit === "number" && bit >= 0);
  var off = bit / 26 | 0;
  var wbit = bit % 26;
  this._expand(off + 1);
  if (val) {
    this.words[off] = this.words[off] | 1 << wbit;
  } else {
    this.words[off] = this.words[off] & ~(1 << wbit);
  }
  return this._strip();
};
BN.prototype.iadd = function iadd(num) {
  var r;
  if (this.negative !== 0 && num.negative === 0) {
    this.negative = 0;
    r = this.isub(num);
    this.negative ^= 1;
    return this._normSign();
  } else if (this.negative === 0 && num.negative !== 0) {
    num.negative = 0;
    r = this.isub(num);
    num.negative = 1;
    return r._normSign();
  }
  var a, b2;
  if (this.length > num.length) {
    a = this;
    b2 = num;
  } else {
    a = num;
    b2 = this;
  }
  var carry = 0;
  for (var i = 0; i < b2.length; i++) {
    r = (a.words[i] | 0) + (b2.words[i] | 0) + carry;
    this.words[i] = r & 67108863;
    carry = r >>> 26;
  }
  for (; carry !== 0 && i < a.length; i++) {
    r = (a.words[i] | 0) + carry;
    this.words[i] = r & 67108863;
    carry = r >>> 26;
  }
  this.length = a.length;
  if (carry !== 0) {
    this.words[this.length] = carry;
    this.length++;
  } else if (a !== this) {
    for (; i < a.length; i++) {
      this.words[i] = a.words[i];
    }
  }
  return this;
};
BN.prototype.add = function add(num) {
  var res;
  if (num.negative !== 0 && this.negative === 0) {
    num.negative = 0;
    res = this.sub(num);
    num.negative ^= 1;
    return res;
  } else if (num.negative === 0 && this.negative !== 0) {
    this.negative = 0;
    res = num.sub(this);
    this.negative = 1;
    return res;
  }
  if (this.length > num.length)
    return this.clone().iadd(num);
  return num.clone().iadd(this);
};
BN.prototype.isub = function isub(num) {
  if (num.negative !== 0) {
    num.negative = 0;
    var r = this.iadd(num);
    num.negative = 1;
    return r._normSign();
  } else if (this.negative !== 0) {
    this.negative = 0;
    this.iadd(num);
    this.negative = 1;
    return this._normSign();
  }
  var cmp2 = this.cmp(num);
  if (cmp2 === 0) {
    this.negative = 0;
    this.length = 1;
    this.words[0] = 0;
    return this;
  }
  var a, b2;
  if (cmp2 > 0) {
    a = this;
    b2 = num;
  } else {
    a = num;
    b2 = this;
  }
  var carry = 0;
  for (var i = 0; i < b2.length; i++) {
    r = (a.words[i] | 0) - (b2.words[i] | 0) + carry;
    carry = r >> 26;
    this.words[i] = r & 67108863;
  }
  for (; carry !== 0 && i < a.length; i++) {
    r = (a.words[i] | 0) + carry;
    carry = r >> 26;
    this.words[i] = r & 67108863;
  }
  if (carry === 0 && i < a.length && a !== this) {
    for (; i < a.length; i++) {
      this.words[i] = a.words[i];
    }
  }
  this.length = Math.max(this.length, i);
  if (a !== this) {
    this.negative = 1;
  }
  return this._strip();
};
BN.prototype.sub = function sub(num) {
  return this.clone().isub(num);
};
function smallMulTo(self2, num, out) {
  out.negative = num.negative ^ self2.negative;
  var len = self2.length + num.length | 0;
  out.length = len;
  len = len - 1 | 0;
  var a = self2.words[0] | 0;
  var b2 = num.words[0] | 0;
  var r = a * b2;
  var lo3 = r & 67108863;
  var carry = r / 67108864 | 0;
  out.words[0] = lo3;
  for (var k6 = 1; k6 < len; k6++) {
    var ncarry = carry >>> 26;
    var rword = carry & 67108863;
    var maxJ = Math.min(k6, num.length - 1);
    for (var j2 = Math.max(0, k6 - self2.length + 1); j2 <= maxJ; j2++) {
      var i = k6 - j2 | 0;
      a = self2.words[i] | 0;
      b2 = num.words[j2] | 0;
      r = a * b2 + rword;
      ncarry += r / 67108864 | 0;
      rword = r & 67108863;
    }
    out.words[k6] = rword | 0;
    carry = ncarry | 0;
  }
  if (carry !== 0) {
    out.words[k6] = carry | 0;
  } else {
    out.length--;
  }
  return out._strip();
}
var comb10MulTo = function comb10MulTo2(self2, num, out) {
  var a = self2.words;
  var b2 = num.words;
  var o2 = out.words;
  var c5 = 0;
  var lo3;
  var mid;
  var hi2;
  var a03 = a[0] | 0;
  var al0 = a03 & 8191;
  var ah0 = a03 >>> 13;
  var a1 = a[1] | 0;
  var al1 = a1 & 8191;
  var ah1 = a1 >>> 13;
  var a2 = a[2] | 0;
  var al2 = a2 & 8191;
  var ah2 = a2 >>> 13;
  var a3 = a[3] | 0;
  var al3 = a3 & 8191;
  var ah3 = a3 >>> 13;
  var a4 = a[4] | 0;
  var al4 = a4 & 8191;
  var ah4 = a4 >>> 13;
  var a5 = a[5] | 0;
  var al5 = a5 & 8191;
  var ah5 = a5 >>> 13;
  var a6 = a[6] | 0;
  var al6 = a6 & 8191;
  var ah6 = a6 >>> 13;
  var a7 = a[7] | 0;
  var al7 = a7 & 8191;
  var ah7 = a7 >>> 13;
  var a8 = a[8] | 0;
  var al8 = a8 & 8191;
  var ah8 = a8 >>> 13;
  var a93 = a[9] | 0;
  var al9 = a93 & 8191;
  var ah9 = a93 >>> 13;
  var b0 = b2[0] | 0;
  var bl0 = b0 & 8191;
  var bh0 = b0 >>> 13;
  var b13 = b2[1] | 0;
  var bl1 = b13 & 8191;
  var bh1 = b13 >>> 13;
  var b22 = b2[2] | 0;
  var bl2 = b22 & 8191;
  var bh2 = b22 >>> 13;
  var b3 = b2[3] | 0;
  var bl3 = b3 & 8191;
  var bh3 = b3 >>> 13;
  var b4 = b2[4] | 0;
  var bl4 = b4 & 8191;
  var bh4 = b4 >>> 13;
  var b5 = b2[5] | 0;
  var bl5 = b5 & 8191;
  var bh5 = b5 >>> 13;
  var b6 = b2[6] | 0;
  var bl6 = b6 & 8191;
  var bh6 = b6 >>> 13;
  var b7 = b2[7] | 0;
  var bl7 = b7 & 8191;
  var bh7 = b7 >>> 13;
  var b8 = b2[8] | 0;
  var bl8 = b8 & 8191;
  var bh8 = b8 >>> 13;
  var b9 = b2[9] | 0;
  var bl9 = b9 & 8191;
  var bh9 = b9 >>> 13;
  out.negative = self2.negative ^ num.negative;
  out.length = 19;
  lo3 = Math.imul(al0, bl0);
  mid = Math.imul(al0, bh0);
  mid = mid + Math.imul(ah0, bl0) | 0;
  hi2 = Math.imul(ah0, bh0);
  var w0 = (c5 + lo3 | 0) + ((mid & 8191) << 13) | 0;
  c5 = (hi2 + (mid >>> 13) | 0) + (w0 >>> 26) | 0;
  w0 &= 67108863;
  lo3 = Math.imul(al1, bl0);
  mid = Math.imul(al1, bh0);
  mid = mid + Math.imul(ah1, bl0) | 0;
  hi2 = Math.imul(ah1, bh0);
  lo3 = lo3 + Math.imul(al0, bl1) | 0;
  mid = mid + Math.imul(al0, bh1) | 0;
  mid = mid + Math.imul(ah0, bl1) | 0;
  hi2 = hi2 + Math.imul(ah0, bh1) | 0;
  var w12 = (c5 + lo3 | 0) + ((mid & 8191) << 13) | 0;
  c5 = (hi2 + (mid >>> 13) | 0) + (w12 >>> 26) | 0;
  w12 &= 67108863;
  lo3 = Math.imul(al2, bl0);
  mid = Math.imul(al2, bh0);
  mid = mid + Math.imul(ah2, bl0) | 0;
  hi2 = Math.imul(ah2, bh0);
  lo3 = lo3 + Math.imul(al1, bl1) | 0;
  mid = mid + Math.imul(al1, bh1) | 0;
  mid = mid + Math.imul(ah1, bl1) | 0;
  hi2 = hi2 + Math.imul(ah1, bh1) | 0;
  lo3 = lo3 + Math.imul(al0, bl2) | 0;
  mid = mid + Math.imul(al0, bh2) | 0;
  mid = mid + Math.imul(ah0, bl2) | 0;
  hi2 = hi2 + Math.imul(ah0, bh2) | 0;
  var w2 = (c5 + lo3 | 0) + ((mid & 8191) << 13) | 0;
  c5 = (hi2 + (mid >>> 13) | 0) + (w2 >>> 26) | 0;
  w2 &= 67108863;
  lo3 = Math.imul(al3, bl0);
  mid = Math.imul(al3, bh0);
  mid = mid + Math.imul(ah3, bl0) | 0;
  hi2 = Math.imul(ah3, bh0);
  lo3 = lo3 + Math.imul(al2, bl1) | 0;
  mid = mid + Math.imul(al2, bh1) | 0;
  mid = mid + Math.imul(ah2, bl1) | 0;
  hi2 = hi2 + Math.imul(ah2, bh1) | 0;
  lo3 = lo3 + Math.imul(al1, bl2) | 0;
  mid = mid + Math.imul(al1, bh2) | 0;
  mid = mid + Math.imul(ah1, bl2) | 0;
  hi2 = hi2 + Math.imul(ah1, bh2) | 0;
  lo3 = lo3 + Math.imul(al0, bl3) | 0;
  mid = mid + Math.imul(al0, bh3) | 0;
  mid = mid + Math.imul(ah0, bl3) | 0;
  hi2 = hi2 + Math.imul(ah0, bh3) | 0;
  var w3 = (c5 + lo3 | 0) + ((mid & 8191) << 13) | 0;
  c5 = (hi2 + (mid >>> 13) | 0) + (w3 >>> 26) | 0;
  w3 &= 67108863;
  lo3 = Math.imul(al4, bl0);
  mid = Math.imul(al4, bh0);
  mid = mid + Math.imul(ah4, bl0) | 0;
  hi2 = Math.imul(ah4, bh0);
  lo3 = lo3 + Math.imul(al3, bl1) | 0;
  mid = mid + Math.imul(al3, bh1) | 0;
  mid = mid + Math.imul(ah3, bl1) | 0;
  hi2 = hi2 + Math.imul(ah3, bh1) | 0;
  lo3 = lo3 + Math.imul(al2, bl2) | 0;
  mid = mid + Math.imul(al2, bh2) | 0;
  mid = mid + Math.imul(ah2, bl2) | 0;
  hi2 = hi2 + Math.imul(ah2, bh2) | 0;
  lo3 = lo3 + Math.imul(al1, bl3) | 0;
  mid = mid + Math.imul(al1, bh3) | 0;
  mid = mid + Math.imul(ah1, bl3) | 0;
  hi2 = hi2 + Math.imul(ah1, bh3) | 0;
  lo3 = lo3 + Math.imul(al0, bl4) | 0;
  mid = mid + Math.imul(al0, bh4) | 0;
  mid = mid + Math.imul(ah0, bl4) | 0;
  hi2 = hi2 + Math.imul(ah0, bh4) | 0;
  var w4 = (c5 + lo3 | 0) + ((mid & 8191) << 13) | 0;
  c5 = (hi2 + (mid >>> 13) | 0) + (w4 >>> 26) | 0;
  w4 &= 67108863;
  lo3 = Math.imul(al5, bl0);
  mid = Math.imul(al5, bh0);
  mid = mid + Math.imul(ah5, bl0) | 0;
  hi2 = Math.imul(ah5, bh0);
  lo3 = lo3 + Math.imul(al4, bl1) | 0;
  mid = mid + Math.imul(al4, bh1) | 0;
  mid = mid + Math.imul(ah4, bl1) | 0;
  hi2 = hi2 + Math.imul(ah4, bh1) | 0;
  lo3 = lo3 + Math.imul(al3, bl2) | 0;
  mid = mid + Math.imul(al3, bh2) | 0;
  mid = mid + Math.imul(ah3, bl2) | 0;
  hi2 = hi2 + Math.imul(ah3, bh2) | 0;
  lo3 = lo3 + Math.imul(al2, bl3) | 0;
  mid = mid + Math.imul(al2, bh3) | 0;
  mid = mid + Math.imul(ah2, bl3) | 0;
  hi2 = hi2 + Math.imul(ah2, bh3) | 0;
  lo3 = lo3 + Math.imul(al1, bl4) | 0;
  mid = mid + Math.imul(al1, bh4) | 0;
  mid = mid + Math.imul(ah1, bl4) | 0;
  hi2 = hi2 + Math.imul(ah1, bh4) | 0;
  lo3 = lo3 + Math.imul(al0, bl5) | 0;
  mid = mid + Math.imul(al0, bh5) | 0;
  mid = mid + Math.imul(ah0, bl5) | 0;
  hi2 = hi2 + Math.imul(ah0, bh5) | 0;
  var w5 = (c5 + lo3 | 0) + ((mid & 8191) << 13) | 0;
  c5 = (hi2 + (mid >>> 13) | 0) + (w5 >>> 26) | 0;
  w5 &= 67108863;
  lo3 = Math.imul(al6, bl0);
  mid = Math.imul(al6, bh0);
  mid = mid + Math.imul(ah6, bl0) | 0;
  hi2 = Math.imul(ah6, bh0);
  lo3 = lo3 + Math.imul(al5, bl1) | 0;
  mid = mid + Math.imul(al5, bh1) | 0;
  mid = mid + Math.imul(ah5, bl1) | 0;
  hi2 = hi2 + Math.imul(ah5, bh1) | 0;
  lo3 = lo3 + Math.imul(al4, bl2) | 0;
  mid = mid + Math.imul(al4, bh2) | 0;
  mid = mid + Math.imul(ah4, bl2) | 0;
  hi2 = hi2 + Math.imul(ah4, bh2) | 0;
  lo3 = lo3 + Math.imul(al3, bl3) | 0;
  mid = mid + Math.imul(al3, bh3) | 0;
  mid = mid + Math.imul(ah3, bl3) | 0;
  hi2 = hi2 + Math.imul(ah3, bh3) | 0;
  lo3 = lo3 + Math.imul(al2, bl4) | 0;
  mid = mid + Math.imul(al2, bh4) | 0;
  mid = mid + Math.imul(ah2, bl4) | 0;
  hi2 = hi2 + Math.imul(ah2, bh4) | 0;
  lo3 = lo3 + Math.imul(al1, bl5) | 0;
  mid = mid + Math.imul(al1, bh5) | 0;
  mid = mid + Math.imul(ah1, bl5) | 0;
  hi2 = hi2 + Math.imul(ah1, bh5) | 0;
  lo3 = lo3 + Math.imul(al0, bl6) | 0;
  mid = mid + Math.imul(al0, bh6) | 0;
  mid = mid + Math.imul(ah0, bl6) | 0;
  hi2 = hi2 + Math.imul(ah0, bh6) | 0;
  var w6 = (c5 + lo3 | 0) + ((mid & 8191) << 13) | 0;
  c5 = (hi2 + (mid >>> 13) | 0) + (w6 >>> 26) | 0;
  w6 &= 67108863;
  lo3 = Math.imul(al7, bl0);
  mid = Math.imul(al7, bh0);
  mid = mid + Math.imul(ah7, bl0) | 0;
  hi2 = Math.imul(ah7, bh0);
  lo3 = lo3 + Math.imul(al6, bl1) | 0;
  mid = mid + Math.imul(al6, bh1) | 0;
  mid = mid + Math.imul(ah6, bl1) | 0;
  hi2 = hi2 + Math.imul(ah6, bh1) | 0;
  lo3 = lo3 + Math.imul(al5, bl2) | 0;
  mid = mid + Math.imul(al5, bh2) | 0;
  mid = mid + Math.imul(ah5, bl2) | 0;
  hi2 = hi2 + Math.imul(ah5, bh2) | 0;
  lo3 = lo3 + Math.imul(al4, bl3) | 0;
  mid = mid + Math.imul(al4, bh3) | 0;
  mid = mid + Math.imul(ah4, bl3) | 0;
  hi2 = hi2 + Math.imul(ah4, bh3) | 0;
  lo3 = lo3 + Math.imul(al3, bl4) | 0;
  mid = mid + Math.imul(al3, bh4) | 0;
  mid = mid + Math.imul(ah3, bl4) | 0;
  hi2 = hi2 + Math.imul(ah3, bh4) | 0;
  lo3 = lo3 + Math.imul(al2, bl5) | 0;
  mid = mid + Math.imul(al2, bh5) | 0;
  mid = mid + Math.imul(ah2, bl5) | 0;
  hi2 = hi2 + Math.imul(ah2, bh5) | 0;
  lo3 = lo3 + Math.imul(al1, bl6) | 0;
  mid = mid + Math.imul(al1, bh6) | 0;
  mid = mid + Math.imul(ah1, bl6) | 0;
  hi2 = hi2 + Math.imul(ah1, bh6) | 0;
  lo3 = lo3 + Math.imul(al0, bl7) | 0;
  mid = mid + Math.imul(al0, bh7) | 0;
  mid = mid + Math.imul(ah0, bl7) | 0;
  hi2 = hi2 + Math.imul(ah0, bh7) | 0;
  var w7 = (c5 + lo3 | 0) + ((mid & 8191) << 13) | 0;
  c5 = (hi2 + (mid >>> 13) | 0) + (w7 >>> 26) | 0;
  w7 &= 67108863;
  lo3 = Math.imul(al8, bl0);
  mid = Math.imul(al8, bh0);
  mid = mid + Math.imul(ah8, bl0) | 0;
  hi2 = Math.imul(ah8, bh0);
  lo3 = lo3 + Math.imul(al7, bl1) | 0;
  mid = mid + Math.imul(al7, bh1) | 0;
  mid = mid + Math.imul(ah7, bl1) | 0;
  hi2 = hi2 + Math.imul(ah7, bh1) | 0;
  lo3 = lo3 + Math.imul(al6, bl2) | 0;
  mid = mid + Math.imul(al6, bh2) | 0;
  mid = mid + Math.imul(ah6, bl2) | 0;
  hi2 = hi2 + Math.imul(ah6, bh2) | 0;
  lo3 = lo3 + Math.imul(al5, bl3) | 0;
  mid = mid + Math.imul(al5, bh3) | 0;
  mid = mid + Math.imul(ah5, bl3) | 0;
  hi2 = hi2 + Math.imul(ah5, bh3) | 0;
  lo3 = lo3 + Math.imul(al4, bl4) | 0;
  mid = mid + Math.imul(al4, bh4) | 0;
  mid = mid + Math.imul(ah4, bl4) | 0;
  hi2 = hi2 + Math.imul(ah4, bh4) | 0;
  lo3 = lo3 + Math.imul(al3, bl5) | 0;
  mid = mid + Math.imul(al3, bh5) | 0;
  mid = mid + Math.imul(ah3, bl5) | 0;
  hi2 = hi2 + Math.imul(ah3, bh5) | 0;
  lo3 = lo3 + Math.imul(al2, bl6) | 0;
  mid = mid + Math.imul(al2, bh6) | 0;
  mid = mid + Math.imul(ah2, bl6) | 0;
  hi2 = hi2 + Math.imul(ah2, bh6) | 0;
  lo3 = lo3 + Math.imul(al1, bl7) | 0;
  mid = mid + Math.imul(al1, bh7) | 0;
  mid = mid + Math.imul(ah1, bl7) | 0;
  hi2 = hi2 + Math.imul(ah1, bh7) | 0;
  lo3 = lo3 + Math.imul(al0, bl8) | 0;
  mid = mid + Math.imul(al0, bh8) | 0;
  mid = mid + Math.imul(ah0, bl8) | 0;
  hi2 = hi2 + Math.imul(ah0, bh8) | 0;
  var w8 = (c5 + lo3 | 0) + ((mid & 8191) << 13) | 0;
  c5 = (hi2 + (mid >>> 13) | 0) + (w8 >>> 26) | 0;
  w8 &= 67108863;
  lo3 = Math.imul(al9, bl0);
  mid = Math.imul(al9, bh0);
  mid = mid + Math.imul(ah9, bl0) | 0;
  hi2 = Math.imul(ah9, bh0);
  lo3 = lo3 + Math.imul(al8, bl1) | 0;
  mid = mid + Math.imul(al8, bh1) | 0;
  mid = mid + Math.imul(ah8, bl1) | 0;
  hi2 = hi2 + Math.imul(ah8, bh1) | 0;
  lo3 = lo3 + Math.imul(al7, bl2) | 0;
  mid = mid + Math.imul(al7, bh2) | 0;
  mid = mid + Math.imul(ah7, bl2) | 0;
  hi2 = hi2 + Math.imul(ah7, bh2) | 0;
  lo3 = lo3 + Math.imul(al6, bl3) | 0;
  mid = mid + Math.imul(al6, bh3) | 0;
  mid = mid + Math.imul(ah6, bl3) | 0;
  hi2 = hi2 + Math.imul(ah6, bh3) | 0;
  lo3 = lo3 + Math.imul(al5, bl4) | 0;
  mid = mid + Math.imul(al5, bh4) | 0;
  mid = mid + Math.imul(ah5, bl4) | 0;
  hi2 = hi2 + Math.imul(ah5, bh4) | 0;
  lo3 = lo3 + Math.imul(al4, bl5) | 0;
  mid = mid + Math.imul(al4, bh5) | 0;
  mid = mid + Math.imul(ah4, bl5) | 0;
  hi2 = hi2 + Math.imul(ah4, bh5) | 0;
  lo3 = lo3 + Math.imul(al3, bl6) | 0;
  mid = mid + Math.imul(al3, bh6) | 0;
  mid = mid + Math.imul(ah3, bl6) | 0;
  hi2 = hi2 + Math.imul(ah3, bh6) | 0;
  lo3 = lo3 + Math.imul(al2, bl7) | 0;
  mid = mid + Math.imul(al2, bh7) | 0;
  mid = mid + Math.imul(ah2, bl7) | 0;
  hi2 = hi2 + Math.imul(ah2, bh7) | 0;
  lo3 = lo3 + Math.imul(al1, bl8) | 0;
  mid = mid + Math.imul(al1, bh8) | 0;
  mid = mid + Math.imul(ah1, bl8) | 0;
  hi2 = hi2 + Math.imul(ah1, bh8) | 0;
  lo3 = lo3 + Math.imul(al0, bl9) | 0;
  mid = mid + Math.imul(al0, bh9) | 0;
  mid = mid + Math.imul(ah0, bl9) | 0;
  hi2 = hi2 + Math.imul(ah0, bh9) | 0;
  var w9 = (c5 + lo3 | 0) + ((mid & 8191) << 13) | 0;
  c5 = (hi2 + (mid >>> 13) | 0) + (w9 >>> 26) | 0;
  w9 &= 67108863;
  lo3 = Math.imul(al9, bl1);
  mid = Math.imul(al9, bh1);
  mid = mid + Math.imul(ah9, bl1) | 0;
  hi2 = Math.imul(ah9, bh1);
  lo3 = lo3 + Math.imul(al8, bl2) | 0;
  mid = mid + Math.imul(al8, bh2) | 0;
  mid = mid + Math.imul(ah8, bl2) | 0;
  hi2 = hi2 + Math.imul(ah8, bh2) | 0;
  lo3 = lo3 + Math.imul(al7, bl3) | 0;
  mid = mid + Math.imul(al7, bh3) | 0;
  mid = mid + Math.imul(ah7, bl3) | 0;
  hi2 = hi2 + Math.imul(ah7, bh3) | 0;
  lo3 = lo3 + Math.imul(al6, bl4) | 0;
  mid = mid + Math.imul(al6, bh4) | 0;
  mid = mid + Math.imul(ah6, bl4) | 0;
  hi2 = hi2 + Math.imul(ah6, bh4) | 0;
  lo3 = lo3 + Math.imul(al5, bl5) | 0;
  mid = mid + Math.imul(al5, bh5) | 0;
  mid = mid + Math.imul(ah5, bl5) | 0;
  hi2 = hi2 + Math.imul(ah5, bh5) | 0;
  lo3 = lo3 + Math.imul(al4, bl6) | 0;
  mid = mid + Math.imul(al4, bh6) | 0;
  mid = mid + Math.imul(ah4, bl6) | 0;
  hi2 = hi2 + Math.imul(ah4, bh6) | 0;
  lo3 = lo3 + Math.imul(al3, bl7) | 0;
  mid = mid + Math.imul(al3, bh7) | 0;
  mid = mid + Math.imul(ah3, bl7) | 0;
  hi2 = hi2 + Math.imul(ah3, bh7) | 0;
  lo3 = lo3 + Math.imul(al2, bl8) | 0;
  mid = mid + Math.imul(al2, bh8) | 0;
  mid = mid + Math.imul(ah2, bl8) | 0;
  hi2 = hi2 + Math.imul(ah2, bh8) | 0;
  lo3 = lo3 + Math.imul(al1, bl9) | 0;
  mid = mid + Math.imul(al1, bh9) | 0;
  mid = mid + Math.imul(ah1, bl9) | 0;
  hi2 = hi2 + Math.imul(ah1, bh9) | 0;
  var w10 = (c5 + lo3 | 0) + ((mid & 8191) << 13) | 0;
  c5 = (hi2 + (mid >>> 13) | 0) + (w10 >>> 26) | 0;
  w10 &= 67108863;
  lo3 = Math.imul(al9, bl2);
  mid = Math.imul(al9, bh2);
  mid = mid + Math.imul(ah9, bl2) | 0;
  hi2 = Math.imul(ah9, bh2);
  lo3 = lo3 + Math.imul(al8, bl3) | 0;
  mid = mid + Math.imul(al8, bh3) | 0;
  mid = mid + Math.imul(ah8, bl3) | 0;
  hi2 = hi2 + Math.imul(ah8, bh3) | 0;
  lo3 = lo3 + Math.imul(al7, bl4) | 0;
  mid = mid + Math.imul(al7, bh4) | 0;
  mid = mid + Math.imul(ah7, bl4) | 0;
  hi2 = hi2 + Math.imul(ah7, bh4) | 0;
  lo3 = lo3 + Math.imul(al6, bl5) | 0;
  mid = mid + Math.imul(al6, bh5) | 0;
  mid = mid + Math.imul(ah6, bl5) | 0;
  hi2 = hi2 + Math.imul(ah6, bh5) | 0;
  lo3 = lo3 + Math.imul(al5, bl6) | 0;
  mid = mid + Math.imul(al5, bh6) | 0;
  mid = mid + Math.imul(ah5, bl6) | 0;
  hi2 = hi2 + Math.imul(ah5, bh6) | 0;
  lo3 = lo3 + Math.imul(al4, bl7) | 0;
  mid = mid + Math.imul(al4, bh7) | 0;
  mid = mid + Math.imul(ah4, bl7) | 0;
  hi2 = hi2 + Math.imul(ah4, bh7) | 0;
  lo3 = lo3 + Math.imul(al3, bl8) | 0;
  mid = mid + Math.imul(al3, bh8) | 0;
  mid = mid + Math.imul(ah3, bl8) | 0;
  hi2 = hi2 + Math.imul(ah3, bh8) | 0;
  lo3 = lo3 + Math.imul(al2, bl9) | 0;
  mid = mid + Math.imul(al2, bh9) | 0;
  mid = mid + Math.imul(ah2, bl9) | 0;
  hi2 = hi2 + Math.imul(ah2, bh9) | 0;
  var w11 = (c5 + lo3 | 0) + ((mid & 8191) << 13) | 0;
  c5 = (hi2 + (mid >>> 13) | 0) + (w11 >>> 26) | 0;
  w11 &= 67108863;
  lo3 = Math.imul(al9, bl3);
  mid = Math.imul(al9, bh3);
  mid = mid + Math.imul(ah9, bl3) | 0;
  hi2 = Math.imul(ah9, bh3);
  lo3 = lo3 + Math.imul(al8, bl4) | 0;
  mid = mid + Math.imul(al8, bh4) | 0;
  mid = mid + Math.imul(ah8, bl4) | 0;
  hi2 = hi2 + Math.imul(ah8, bh4) | 0;
  lo3 = lo3 + Math.imul(al7, bl5) | 0;
  mid = mid + Math.imul(al7, bh5) | 0;
  mid = mid + Math.imul(ah7, bl5) | 0;
  hi2 = hi2 + Math.imul(ah7, bh5) | 0;
  lo3 = lo3 + Math.imul(al6, bl6) | 0;
  mid = mid + Math.imul(al6, bh6) | 0;
  mid = mid + Math.imul(ah6, bl6) | 0;
  hi2 = hi2 + Math.imul(ah6, bh6) | 0;
  lo3 = lo3 + Math.imul(al5, bl7) | 0;
  mid = mid + Math.imul(al5, bh7) | 0;
  mid = mid + Math.imul(ah5, bl7) | 0;
  hi2 = hi2 + Math.imul(ah5, bh7) | 0;
  lo3 = lo3 + Math.imul(al4, bl8) | 0;
  mid = mid + Math.imul(al4, bh8) | 0;
  mid = mid + Math.imul(ah4, bl8) | 0;
  hi2 = hi2 + Math.imul(ah4, bh8) | 0;
  lo3 = lo3 + Math.imul(al3, bl9) | 0;
  mid = mid + Math.imul(al3, bh9) | 0;
  mid = mid + Math.imul(ah3, bl9) | 0;
  hi2 = hi2 + Math.imul(ah3, bh9) | 0;
  var w122 = (c5 + lo3 | 0) + ((mid & 8191) << 13) | 0;
  c5 = (hi2 + (mid >>> 13) | 0) + (w122 >>> 26) | 0;
  w122 &= 67108863;
  lo3 = Math.imul(al9, bl4);
  mid = Math.imul(al9, bh4);
  mid = mid + Math.imul(ah9, bl4) | 0;
  hi2 = Math.imul(ah9, bh4);
  lo3 = lo3 + Math.imul(al8, bl5) | 0;
  mid = mid + Math.imul(al8, bh5) | 0;
  mid = mid + Math.imul(ah8, bl5) | 0;
  hi2 = hi2 + Math.imul(ah8, bh5) | 0;
  lo3 = lo3 + Math.imul(al7, bl6) | 0;
  mid = mid + Math.imul(al7, bh6) | 0;
  mid = mid + Math.imul(ah7, bl6) | 0;
  hi2 = hi2 + Math.imul(ah7, bh6) | 0;
  lo3 = lo3 + Math.imul(al6, bl7) | 0;
  mid = mid + Math.imul(al6, bh7) | 0;
  mid = mid + Math.imul(ah6, bl7) | 0;
  hi2 = hi2 + Math.imul(ah6, bh7) | 0;
  lo3 = lo3 + Math.imul(al5, bl8) | 0;
  mid = mid + Math.imul(al5, bh8) | 0;
  mid = mid + Math.imul(ah5, bl8) | 0;
  hi2 = hi2 + Math.imul(ah5, bh8) | 0;
  lo3 = lo3 + Math.imul(al4, bl9) | 0;
  mid = mid + Math.imul(al4, bh9) | 0;
  mid = mid + Math.imul(ah4, bl9) | 0;
  hi2 = hi2 + Math.imul(ah4, bh9) | 0;
  var w13 = (c5 + lo3 | 0) + ((mid & 8191) << 13) | 0;
  c5 = (hi2 + (mid >>> 13) | 0) + (w13 >>> 26) | 0;
  w13 &= 67108863;
  lo3 = Math.imul(al9, bl5);
  mid = Math.imul(al9, bh5);
  mid = mid + Math.imul(ah9, bl5) | 0;
  hi2 = Math.imul(ah9, bh5);
  lo3 = lo3 + Math.imul(al8, bl6) | 0;
  mid = mid + Math.imul(al8, bh6) | 0;
  mid = mid + Math.imul(ah8, bl6) | 0;
  hi2 = hi2 + Math.imul(ah8, bh6) | 0;
  lo3 = lo3 + Math.imul(al7, bl7) | 0;
  mid = mid + Math.imul(al7, bh7) | 0;
  mid = mid + Math.imul(ah7, bl7) | 0;
  hi2 = hi2 + Math.imul(ah7, bh7) | 0;
  lo3 = lo3 + Math.imul(al6, bl8) | 0;
  mid = mid + Math.imul(al6, bh8) | 0;
  mid = mid + Math.imul(ah6, bl8) | 0;
  hi2 = hi2 + Math.imul(ah6, bh8) | 0;
  lo3 = lo3 + Math.imul(al5, bl9) | 0;
  mid = mid + Math.imul(al5, bh9) | 0;
  mid = mid + Math.imul(ah5, bl9) | 0;
  hi2 = hi2 + Math.imul(ah5, bh9) | 0;
  var w14 = (c5 + lo3 | 0) + ((mid & 8191) << 13) | 0;
  c5 = (hi2 + (mid >>> 13) | 0) + (w14 >>> 26) | 0;
  w14 &= 67108863;
  lo3 = Math.imul(al9, bl6);
  mid = Math.imul(al9, bh6);
  mid = mid + Math.imul(ah9, bl6) | 0;
  hi2 = Math.imul(ah9, bh6);
  lo3 = lo3 + Math.imul(al8, bl7) | 0;
  mid = mid + Math.imul(al8, bh7) | 0;
  mid = mid + Math.imul(ah8, bl7) | 0;
  hi2 = hi2 + Math.imul(ah8, bh7) | 0;
  lo3 = lo3 + Math.imul(al7, bl8) | 0;
  mid = mid + Math.imul(al7, bh8) | 0;
  mid = mid + Math.imul(ah7, bl8) | 0;
  hi2 = hi2 + Math.imul(ah7, bh8) | 0;
  lo3 = lo3 + Math.imul(al6, bl9) | 0;
  mid = mid + Math.imul(al6, bh9) | 0;
  mid = mid + Math.imul(ah6, bl9) | 0;
  hi2 = hi2 + Math.imul(ah6, bh9) | 0;
  var w15 = (c5 + lo3 | 0) + ((mid & 8191) << 13) | 0;
  c5 = (hi2 + (mid >>> 13) | 0) + (w15 >>> 26) | 0;
  w15 &= 67108863;
  lo3 = Math.imul(al9, bl7);
  mid = Math.imul(al9, bh7);
  mid = mid + Math.imul(ah9, bl7) | 0;
  hi2 = Math.imul(ah9, bh7);
  lo3 = lo3 + Math.imul(al8, bl8) | 0;
  mid = mid + Math.imul(al8, bh8) | 0;
  mid = mid + Math.imul(ah8, bl8) | 0;
  hi2 = hi2 + Math.imul(ah8, bh8) | 0;
  lo3 = lo3 + Math.imul(al7, bl9) | 0;
  mid = mid + Math.imul(al7, bh9) | 0;
  mid = mid + Math.imul(ah7, bl9) | 0;
  hi2 = hi2 + Math.imul(ah7, bh9) | 0;
  var w16 = (c5 + lo3 | 0) + ((mid & 8191) << 13) | 0;
  c5 = (hi2 + (mid >>> 13) | 0) + (w16 >>> 26) | 0;
  w16 &= 67108863;
  lo3 = Math.imul(al9, bl8);
  mid = Math.imul(al9, bh8);
  mid = mid + Math.imul(ah9, bl8) | 0;
  hi2 = Math.imul(ah9, bh8);
  lo3 = lo3 + Math.imul(al8, bl9) | 0;
  mid = mid + Math.imul(al8, bh9) | 0;
  mid = mid + Math.imul(ah8, bl9) | 0;
  hi2 = hi2 + Math.imul(ah8, bh9) | 0;
  var w17 = (c5 + lo3 | 0) + ((mid & 8191) << 13) | 0;
  c5 = (hi2 + (mid >>> 13) | 0) + (w17 >>> 26) | 0;
  w17 &= 67108863;
  lo3 = Math.imul(al9, bl9);
  mid = Math.imul(al9, bh9);
  mid = mid + Math.imul(ah9, bl9) | 0;
  hi2 = Math.imul(ah9, bh9);
  var w18 = (c5 + lo3 | 0) + ((mid & 8191) << 13) | 0;
  c5 = (hi2 + (mid >>> 13) | 0) + (w18 >>> 26) | 0;
  w18 &= 67108863;
  o2[0] = w0;
  o2[1] = w12;
  o2[2] = w2;
  o2[3] = w3;
  o2[4] = w4;
  o2[5] = w5;
  o2[6] = w6;
  o2[7] = w7;
  o2[8] = w8;
  o2[9] = w9;
  o2[10] = w10;
  o2[11] = w11;
  o2[12] = w122;
  o2[13] = w13;
  o2[14] = w14;
  o2[15] = w15;
  o2[16] = w16;
  o2[17] = w17;
  o2[18] = w18;
  if (c5 !== 0) {
    o2[19] = c5;
    out.length++;
  }
  return out;
};
if (!Math.imul) {
  comb10MulTo = smallMulTo;
}
function bigMulTo(self2, num, out) {
  out.negative = num.negative ^ self2.negative;
  out.length = self2.length + num.length;
  var carry = 0;
  var hncarry = 0;
  for (var k6 = 0; k6 < out.length - 1; k6++) {
    var ncarry = hncarry;
    hncarry = 0;
    var rword = carry & 67108863;
    var maxJ = Math.min(k6, num.length - 1);
    for (var j2 = Math.max(0, k6 - self2.length + 1); j2 <= maxJ; j2++) {
      var i = k6 - j2;
      var a = self2.words[i] | 0;
      var b2 = num.words[j2] | 0;
      var r = a * b2;
      var lo3 = r & 67108863;
      ncarry = ncarry + (r / 67108864 | 0) | 0;
      lo3 = lo3 + rword | 0;
      rword = lo3 & 67108863;
      ncarry = ncarry + (lo3 >>> 26) | 0;
      hncarry += ncarry >>> 26;
      ncarry &= 67108863;
    }
    out.words[k6] = rword;
    carry = ncarry;
    ncarry = hncarry;
  }
  if (carry !== 0) {
    out.words[k6] = carry;
  } else {
    out.length--;
  }
  return out._strip();
}
function jumboMulTo(self2, num, out) {
  return bigMulTo(self2, num, out);
}
BN.prototype.mulTo = function mulTo(num, out) {
  var res;
  var len = this.length + num.length;
  if (this.length === 10 && num.length === 10) {
    res = comb10MulTo(this, num, out);
  } else if (len < 63) {
    res = smallMulTo(this, num, out);
  } else if (len < 1024) {
    res = bigMulTo(this, num, out);
  } else {
    res = jumboMulTo(this, num, out);
  }
  return res;
};
function FFTM(x, y4) {
  this.x = x;
  this.y = y4;
}
FFTM.prototype.makeRBT = function makeRBT(N4) {
  var t = new Array(N4);
  var l = BN.prototype._countBits(N4) - 1;
  for (var i = 0; i < N4; i++) {
    t[i] = this.revBin(i, l, N4);
  }
  return t;
};
FFTM.prototype.revBin = function revBin(x, l, N4) {
  if (x === 0 || x === N4 - 1)
    return x;
  var rb = 0;
  for (var i = 0; i < l; i++) {
    rb |= (x & 1) << l - i - 1;
    x >>= 1;
  }
  return rb;
};
FFTM.prototype.permute = function permute(rbt, rws, iws, rtws, itws, N4) {
  for (var i = 0; i < N4; i++) {
    rtws[i] = rws[rbt[i]];
    itws[i] = iws[rbt[i]];
  }
};
FFTM.prototype.transform = function transform(rws, iws, rtws, itws, N4, rbt) {
  this.permute(rbt, rws, iws, rtws, itws, N4);
  for (var s = 1; s < N4; s <<= 1) {
    var l = s << 1;
    var rtwdf = Math.cos(2 * Math.PI / l);
    var itwdf = Math.sin(2 * Math.PI / l);
    for (var p3 = 0; p3 < N4; p3 += l) {
      var rtwdf_ = rtwdf;
      var itwdf_ = itwdf;
      for (var j2 = 0; j2 < s; j2++) {
        var re2 = rtws[p3 + j2];
        var ie = itws[p3 + j2];
        var ro = rtws[p3 + j2 + s];
        var io = itws[p3 + j2 + s];
        var rx = rtwdf_ * ro - itwdf_ * io;
        io = rtwdf_ * io + itwdf_ * ro;
        ro = rx;
        rtws[p3 + j2] = re2 + ro;
        itws[p3 + j2] = ie + io;
        rtws[p3 + j2 + s] = re2 - ro;
        itws[p3 + j2 + s] = ie - io;
        if (j2 !== l) {
          rx = rtwdf * rtwdf_ - itwdf * itwdf_;
          itwdf_ = rtwdf * itwdf_ + itwdf * rtwdf_;
          rtwdf_ = rx;
        }
      }
    }
  }
};
FFTM.prototype.guessLen13b = function guessLen13b(n, m3) {
  var N4 = Math.max(m3, n) | 1;
  var odd = N4 & 1;
  var i = 0;
  for (N4 = N4 / 2 | 0; N4; N4 = N4 >>> 1) {
    i++;
  }
  return 1 << i + 1 + odd;
};
FFTM.prototype.conjugate = function conjugate(rws, iws, N4) {
  if (N4 <= 1)
    return;
  for (var i = 0; i < N4 / 2; i++) {
    var t = rws[i];
    rws[i] = rws[N4 - i - 1];
    rws[N4 - i - 1] = t;
    t = iws[i];
    iws[i] = -iws[N4 - i - 1];
    iws[N4 - i - 1] = -t;
  }
};
FFTM.prototype.normalize13b = function normalize13b(ws3, N4) {
  var carry = 0;
  for (var i = 0; i < N4 / 2; i++) {
    var w2 = Math.round(ws3[2 * i + 1] / N4) * 8192 + Math.round(ws3[2 * i] / N4) + carry;
    ws3[i] = w2 & 67108863;
    if (w2 < 67108864) {
      carry = 0;
    } else {
      carry = w2 / 67108864 | 0;
    }
  }
  return ws3;
};
FFTM.prototype.convert13b = function convert13b(ws3, len, rws, N4) {
  var carry = 0;
  for (var i = 0; i < len; i++) {
    carry = carry + (ws3[i] | 0);
    rws[2 * i] = carry & 8191;
    carry = carry >>> 13;
    rws[2 * i + 1] = carry & 8191;
    carry = carry >>> 13;
  }
  for (i = 2 * len; i < N4; ++i) {
    rws[i] = 0;
  }
  assert3(carry === 0);
  assert3((carry & ~8191) === 0);
};
FFTM.prototype.stub = function stub(N4) {
  var ph = new Array(N4);
  for (var i = 0; i < N4; i++) {
    ph[i] = 0;
  }
  return ph;
};
FFTM.prototype.mulp = function mulp(x, y4, out) {
  var N4 = 2 * this.guessLen13b(x.length, y4.length);
  var rbt = this.makeRBT(N4);
  var _2 = this.stub(N4);
  var rws = new Array(N4);
  var rwst = new Array(N4);
  var iwst = new Array(N4);
  var nrws = new Array(N4);
  var nrwst = new Array(N4);
  var niwst = new Array(N4);
  var rmws = out.words;
  rmws.length = N4;
  this.convert13b(x.words, x.length, rws, N4);
  this.convert13b(y4.words, y4.length, nrws, N4);
  this.transform(rws, _2, rwst, iwst, N4, rbt);
  this.transform(nrws, _2, nrwst, niwst, N4, rbt);
  for (var i = 0; i < N4; i++) {
    var rx = rwst[i] * nrwst[i] - iwst[i] * niwst[i];
    iwst[i] = rwst[i] * niwst[i] + iwst[i] * nrwst[i];
    rwst[i] = rx;
  }
  this.conjugate(rwst, iwst, N4);
  this.transform(rwst, iwst, rmws, _2, N4, rbt);
  this.conjugate(rmws, _2, N4);
  this.normalize13b(rmws, N4);
  out.negative = x.negative ^ y4.negative;
  out.length = x.length + y4.length;
  return out._strip();
};
BN.prototype.mul = function mul(num) {
  var out = new BN(null);
  out.words = new Array(this.length + num.length);
  return this.mulTo(num, out);
};
BN.prototype.mulf = function mulf(num) {
  var out = new BN(null);
  out.words = new Array(this.length + num.length);
  return jumboMulTo(this, num, out);
};
BN.prototype.imul = function imul(num) {
  return this.clone().mulTo(num, this);
};
BN.prototype.imuln = function imuln(num) {
  var isNegNum = num < 0;
  if (isNegNum)
    num = -num;
  assert3(typeof num === "number");
  assert3(num < 67108864);
  var carry = 0;
  for (var i = 0; i < this.length; i++) {
    var w2 = (this.words[i] | 0) * num;
    var lo3 = (w2 & 67108863) + (carry & 67108863);
    carry >>= 26;
    carry += w2 / 67108864 | 0;
    carry += lo3 >>> 26;
    this.words[i] = lo3 & 67108863;
  }
  if (carry !== 0) {
    this.words[i] = carry;
    this.length++;
  }
  return isNegNum ? this.ineg() : this;
};
BN.prototype.muln = function muln(num) {
  return this.clone().imuln(num);
};
BN.prototype.sqr = function sqr() {
  return this.mul(this);
};
BN.prototype.isqr = function isqr() {
  return this.imul(this.clone());
};
BN.prototype.pow = function pow(num) {
  var w2 = toBitArray(num);
  if (w2.length === 0)
    return new BN(1);
  var res = this;
  for (var i = 0; i < w2.length; i++, res = res.sqr()) {
    if (w2[i] !== 0)
      break;
  }
  if (++i < w2.length) {
    for (var q = res.sqr(); i < w2.length; i++, q = q.sqr()) {
      if (w2[i] === 0)
        continue;
      res = res.mul(q);
    }
  }
  return res;
};
BN.prototype.iushln = function iushln(bits) {
  assert3(typeof bits === "number" && bits >= 0);
  var r = bits % 26;
  var s = (bits - r) / 26;
  var carryMask = 67108863 >>> 26 - r << 26 - r;
  var i;
  if (r !== 0) {
    var carry = 0;
    for (i = 0; i < this.length; i++) {
      var newCarry = this.words[i] & carryMask;
      var c5 = (this.words[i] | 0) - newCarry << r;
      this.words[i] = c5 | carry;
      carry = newCarry >>> 26 - r;
    }
    if (carry) {
      this.words[i] = carry;
      this.length++;
    }
  }
  if (s !== 0) {
    for (i = this.length - 1; i >= 0; i--) {
      this.words[i + s] = this.words[i];
    }
    for (i = 0; i < s; i++) {
      this.words[i] = 0;
    }
    this.length += s;
  }
  return this._strip();
};
BN.prototype.ishln = function ishln(bits) {
  assert3(this.negative === 0);
  return this.iushln(bits);
};
BN.prototype.iushrn = function iushrn(bits, hint, extended) {
  assert3(typeof bits === "number" && bits >= 0);
  var h;
  if (hint) {
    h = (hint - hint % 26) / 26;
  } else {
    h = 0;
  }
  var r = bits % 26;
  var s = Math.min((bits - r) / 26, this.length);
  var mask = 67108863 ^ 67108863 >>> r << r;
  var maskedWords = extended;
  h -= s;
  h = Math.max(0, h);
  if (maskedWords) {
    for (var i = 0; i < s; i++) {
      maskedWords.words[i] = this.words[i];
    }
    maskedWords.length = s;
  }
  if (s === 0) {
  } else if (this.length > s) {
    this.length -= s;
    for (i = 0; i < this.length; i++) {
      this.words[i] = this.words[i + s];
    }
  } else {
    this.words[0] = 0;
    this.length = 1;
  }
  var carry = 0;
  for (i = this.length - 1; i >= 0 && (carry !== 0 || i >= h); i--) {
    var word = this.words[i] | 0;
    this.words[i] = carry << 26 - r | word >>> r;
    carry = word & mask;
  }
  if (maskedWords && carry !== 0) {
    maskedWords.words[maskedWords.length++] = carry;
  }
  if (this.length === 0) {
    this.words[0] = 0;
    this.length = 1;
  }
  return this._strip();
};
BN.prototype.ishrn = function ishrn(bits, hint, extended) {
  assert3(this.negative === 0);
  return this.iushrn(bits, hint, extended);
};
BN.prototype.shln = function shln(bits) {
  return this.clone().ishln(bits);
};
BN.prototype.ushln = function ushln(bits) {
  return this.clone().iushln(bits);
};
BN.prototype.shrn = function shrn(bits) {
  return this.clone().ishrn(bits);
};
BN.prototype.ushrn = function ushrn(bits) {
  return this.clone().iushrn(bits);
};
BN.prototype.testn = function testn(bit) {
  assert3(typeof bit === "number" && bit >= 0);
  var r = bit % 26;
  var s = (bit - r) / 26;
  var q = 1 << r;
  if (this.length <= s)
    return false;
  var w2 = this.words[s];
  return !!(w2 & q);
};
BN.prototype.imaskn = function imaskn(bits) {
  assert3(typeof bits === "number" && bits >= 0);
  var r = bits % 26;
  var s = (bits - r) / 26;
  assert3(this.negative === 0, "imaskn works only with positive numbers");
  if (this.length <= s) {
    return this;
  }
  if (r !== 0) {
    s++;
  }
  this.length = Math.min(s, this.length);
  if (r !== 0) {
    var mask = 67108863 ^ 67108863 >>> r << r;
    this.words[this.length - 1] &= mask;
  }
  return this._strip();
};
BN.prototype.maskn = function maskn(bits) {
  return this.clone().imaskn(bits);
};
BN.prototype.iaddn = function iaddn(num) {
  assert3(typeof num === "number");
  assert3(num < 67108864);
  if (num < 0)
    return this.isubn(-num);
  if (this.negative !== 0) {
    if (this.length === 1 && (this.words[0] | 0) <= num) {
      this.words[0] = num - (this.words[0] | 0);
      this.negative = 0;
      return this;
    }
    this.negative = 0;
    this.isubn(num);
    this.negative = 1;
    return this;
  }
  return this._iaddn(num);
};
BN.prototype._iaddn = function _iaddn(num) {
  this.words[0] += num;
  for (var i = 0; i < this.length && this.words[i] >= 67108864; i++) {
    this.words[i] -= 67108864;
    if (i === this.length - 1) {
      this.words[i + 1] = 1;
    } else {
      this.words[i + 1]++;
    }
  }
  this.length = Math.max(this.length, i + 1);
  return this;
};
BN.prototype.isubn = function isubn(num) {
  assert3(typeof num === "number");
  assert3(num < 67108864);
  if (num < 0)
    return this.iaddn(-num);
  if (this.negative !== 0) {
    this.negative = 0;
    this.iaddn(num);
    this.negative = 1;
    return this;
  }
  this.words[0] -= num;
  if (this.length === 1 && this.words[0] < 0) {
    this.words[0] = -this.words[0];
    this.negative = 1;
  } else {
    for (var i = 0; i < this.length && this.words[i] < 0; i++) {
      this.words[i] += 67108864;
      this.words[i + 1] -= 1;
    }
  }
  return this._strip();
};
BN.prototype.addn = function addn(num) {
  return this.clone().iaddn(num);
};
BN.prototype.subn = function subn(num) {
  return this.clone().isubn(num);
};
BN.prototype.iabs = function iabs() {
  this.negative = 0;
  return this;
};
BN.prototype.abs = function abs() {
  return this.clone().iabs();
};
BN.prototype._ishlnsubmul = function _ishlnsubmul(num, mul4, shift) {
  var len = num.length + shift;
  var i;
  this._expand(len);
  var w2;
  var carry = 0;
  for (i = 0; i < num.length; i++) {
    w2 = (this.words[i + shift] | 0) + carry;
    var right = (num.words[i] | 0) * mul4;
    w2 -= right & 67108863;
    carry = (w2 >> 26) - (right / 67108864 | 0);
    this.words[i + shift] = w2 & 67108863;
  }
  for (; i < this.length - shift; i++) {
    w2 = (this.words[i + shift] | 0) + carry;
    carry = w2 >> 26;
    this.words[i + shift] = w2 & 67108863;
  }
  if (carry === 0)
    return this._strip();
  assert3(carry === -1);
  carry = 0;
  for (i = 0; i < this.length; i++) {
    w2 = -(this.words[i] | 0) + carry;
    carry = w2 >> 26;
    this.words[i] = w2 & 67108863;
  }
  this.negative = 1;
  return this._strip();
};
BN.prototype._wordDiv = function _wordDiv(num, mode) {
  var shift = this.length - num.length;
  var a = this.clone();
  var b2 = num;
  var bhi = b2.words[b2.length - 1] | 0;
  var bhiBits = this._countBits(bhi);
  shift = 26 - bhiBits;
  if (shift !== 0) {
    b2 = b2.ushln(shift);
    a.iushln(shift);
    bhi = b2.words[b2.length - 1] | 0;
  }
  var m3 = a.length - b2.length;
  var q;
  if (mode !== "mod") {
    q = new BN(null);
    q.length = m3 + 1;
    q.words = new Array(q.length);
    for (var i = 0; i < q.length; i++) {
      q.words[i] = 0;
    }
  }
  var diff3 = a.clone()._ishlnsubmul(b2, 1, m3);
  if (diff3.negative === 0) {
    a = diff3;
    if (q) {
      q.words[m3] = 1;
    }
  }
  for (var j2 = m3 - 1; j2 >= 0; j2--) {
    var qj = (a.words[b2.length + j2] | 0) * 67108864 + (a.words[b2.length + j2 - 1] | 0);
    qj = Math.min(qj / bhi | 0, 67108863);
    a._ishlnsubmul(b2, qj, j2);
    while (a.negative !== 0) {
      qj--;
      a.negative = 0;
      a._ishlnsubmul(b2, 1, j2);
      if (!a.isZero()) {
        a.negative ^= 1;
      }
    }
    if (q) {
      q.words[j2] = qj;
    }
  }
  if (q) {
    q._strip();
  }
  a._strip();
  if (mode !== "div" && shift !== 0) {
    a.iushrn(shift);
  }
  return {
    div: q || null,
    mod: a
  };
};
BN.prototype.divmod = function divmod(num, mode, positive) {
  assert3(!num.isZero());
  if (this.isZero()) {
    return {
      div: new BN(0),
      mod: new BN(0)
    };
  }
  var div2, mod2, res;
  if (this.negative !== 0 && num.negative === 0) {
    res = this.neg().divmod(num, mode);
    if (mode !== "mod") {
      div2 = res.div.neg();
    }
    if (mode !== "div") {
      mod2 = res.mod.neg();
      if (positive && mod2.negative !== 0) {
        mod2.iadd(num);
      }
    }
    return {
      div: div2,
      mod: mod2
    };
  }
  if (this.negative === 0 && num.negative !== 0) {
    res = this.divmod(num.neg(), mode);
    if (mode !== "mod") {
      div2 = res.div.neg();
    }
    return {
      div: div2,
      mod: res.mod
    };
  }
  if ((this.negative & num.negative) !== 0) {
    res = this.neg().divmod(num.neg(), mode);
    if (mode !== "div") {
      mod2 = res.mod.neg();
      if (positive && mod2.negative !== 0) {
        mod2.isub(num);
      }
    }
    return {
      div: res.div,
      mod: mod2
    };
  }
  if (num.length > this.length || this.cmp(num) < 0) {
    return {
      div: new BN(0),
      mod: this
    };
  }
  if (num.length === 1) {
    if (mode === "div") {
      return {
        div: this.divn(num.words[0]),
        mod: null
      };
    }
    if (mode === "mod") {
      return {
        div: null,
        mod: new BN(this.modrn(num.words[0]))
      };
    }
    return {
      div: this.divn(num.words[0]),
      mod: new BN(this.modrn(num.words[0]))
    };
  }
  return this._wordDiv(num, mode);
};
BN.prototype.div = function div(num) {
  return this.divmod(num, "div", false).div;
};
BN.prototype.mod = function mod(num) {
  return this.divmod(num, "mod", false).mod;
};
BN.prototype.umod = function umod(num) {
  return this.divmod(num, "mod", true).mod;
};
BN.prototype.divRound = function divRound(num) {
  var dm = this.divmod(num);
  if (dm.mod.isZero())
    return dm.div;
  var mod2 = dm.div.negative !== 0 ? dm.mod.isub(num) : dm.mod;
  var half = num.ushrn(1);
  var r2 = num.andln(1);
  var cmp2 = mod2.cmp(half);
  if (cmp2 < 0 || r2 === 1 && cmp2 === 0)
    return dm.div;
  return dm.div.negative !== 0 ? dm.div.isubn(1) : dm.div.iaddn(1);
};
BN.prototype.modrn = function modrn(num) {
  var isNegNum = num < 0;
  if (isNegNum)
    num = -num;
  assert3(num <= 67108863);
  var p3 = (1 << 26) % num;
  var acc = 0;
  for (var i = this.length - 1; i >= 0; i--) {
    acc = (p3 * acc + (this.words[i] | 0)) % num;
  }
  return isNegNum ? -acc : acc;
};
BN.prototype.modn = function modn(num) {
  return this.modrn(num);
};
BN.prototype.idivn = function idivn(num) {
  var isNegNum = num < 0;
  if (isNegNum)
    num = -num;
  assert3(num <= 67108863);
  var carry = 0;
  for (var i = this.length - 1; i >= 0; i--) {
    var w2 = (this.words[i] | 0) + carry * 67108864;
    this.words[i] = w2 / num | 0;
    carry = w2 % num;
  }
  this._strip();
  return isNegNum ? this.ineg() : this;
};
BN.prototype.divn = function divn(num) {
  return this.clone().idivn(num);
};
BN.prototype.egcd = function egcd(p3) {
  assert3(p3.negative === 0);
  assert3(!p3.isZero());
  var x = this;
  var y4 = p3.clone();
  if (x.negative !== 0) {
    x = x.umod(p3);
  } else {
    x = x.clone();
  }
  var A4 = new BN(1);
  var B3 = new BN(0);
  var C = new BN(0);
  var D6 = new BN(1);
  var g2 = 0;
  while (x.isEven() && y4.isEven()) {
    x.iushrn(1);
    y4.iushrn(1);
    ++g2;
  }
  var yp = y4.clone();
  var xp = x.clone();
  while (!x.isZero()) {
    for (var i = 0, im = 1; (x.words[0] & im) === 0 && i < 26; ++i, im <<= 1)
      ;
    if (i > 0) {
      x.iushrn(i);
      while (i-- > 0) {
        if (A4.isOdd() || B3.isOdd()) {
          A4.iadd(yp);
          B3.isub(xp);
        }
        A4.iushrn(1);
        B3.iushrn(1);
      }
    }
    for (var j2 = 0, jm = 1; (y4.words[0] & jm) === 0 && j2 < 26; ++j2, jm <<= 1)
      ;
    if (j2 > 0) {
      y4.iushrn(j2);
      while (j2-- > 0) {
        if (C.isOdd() || D6.isOdd()) {
          C.iadd(yp);
          D6.isub(xp);
        }
        C.iushrn(1);
        D6.iushrn(1);
      }
    }
    if (x.cmp(y4) >= 0) {
      x.isub(y4);
      A4.isub(C);
      B3.isub(D6);
    } else {
      y4.isub(x);
      C.isub(A4);
      D6.isub(B3);
    }
  }
  return {
    a: C,
    b: D6,
    gcd: y4.iushln(g2)
  };
};
BN.prototype._invmp = function _invmp(p3) {
  assert3(p3.negative === 0);
  assert3(!p3.isZero());
  var a = this;
  var b2 = p3.clone();
  if (a.negative !== 0) {
    a = a.umod(p3);
  } else {
    a = a.clone();
  }
  var x12 = new BN(1);
  var x2 = new BN(0);
  var delta = b2.clone();
  while (a.cmpn(1) > 0 && b2.cmpn(1) > 0) {
    for (var i = 0, im = 1; (a.words[0] & im) === 0 && i < 26; ++i, im <<= 1)
      ;
    if (i > 0) {
      a.iushrn(i);
      while (i-- > 0) {
        if (x12.isOdd()) {
          x12.iadd(delta);
        }
        x12.iushrn(1);
      }
    }
    for (var j2 = 0, jm = 1; (b2.words[0] & jm) === 0 && j2 < 26; ++j2, jm <<= 1)
      ;
    if (j2 > 0) {
      b2.iushrn(j2);
      while (j2-- > 0) {
        if (x2.isOdd()) {
          x2.iadd(delta);
        }
        x2.iushrn(1);
      }
    }
    if (a.cmp(b2) >= 0) {
      a.isub(b2);
      x12.isub(x2);
    } else {
      b2.isub(a);
      x2.isub(x12);
    }
  }
  var res;
  if (a.cmpn(1) === 0) {
    res = x12;
  } else {
    res = x2;
  }
  if (res.cmpn(0) < 0) {
    res.iadd(p3);
  }
  return res;
};
BN.prototype.gcd = function gcd(num) {
  if (this.isZero())
    return num.abs();
  if (num.isZero())
    return this.abs();
  var a = this.clone();
  var b2 = num.clone();
  a.negative = 0;
  b2.negative = 0;
  for (var shift = 0; a.isEven() && b2.isEven(); shift++) {
    a.iushrn(1);
    b2.iushrn(1);
  }
  do {
    while (a.isEven()) {
      a.iushrn(1);
    }
    while (b2.isEven()) {
      b2.iushrn(1);
    }
    var r = a.cmp(b2);
    if (r < 0) {
      var t = a;
      a = b2;
      b2 = t;
    } else if (r === 0 || b2.cmpn(1) === 0) {
      break;
    }
    a.isub(b2);
  } while (true);
  return b2.iushln(shift);
};
BN.prototype.invm = function invm(num) {
  return this.egcd(num).a.umod(num);
};
BN.prototype.isEven = function isEven() {
  return (this.words[0] & 1) === 0;
};
BN.prototype.isOdd = function isOdd() {
  return (this.words[0] & 1) === 1;
};
BN.prototype.andln = function andln(num) {
  return this.words[0] & num;
};
BN.prototype.bincn = function bincn(bit) {
  assert3(typeof bit === "number");
  var r = bit % 26;
  var s = (bit - r) / 26;
  var q = 1 << r;
  if (this.length <= s) {
    this._expand(s + 1);
    this.words[s] |= q;
    return this;
  }
  var carry = q;
  for (var i = s; carry !== 0 && i < this.length; i++) {
    var w2 = this.words[i] | 0;
    w2 += carry;
    carry = w2 >>> 26;
    w2 &= 67108863;
    this.words[i] = w2;
  }
  if (carry !== 0) {
    this.words[i] = carry;
    this.length++;
  }
  return this;
};
BN.prototype.isZero = function isZero() {
  return this.length === 1 && this.words[0] === 0;
};
BN.prototype.cmpn = function cmpn(num) {
  var negative = num < 0;
  if (this.negative !== 0 && !negative)
    return -1;
  if (this.negative === 0 && negative)
    return 1;
  this._strip();
  var res;
  if (this.length > 1) {
    res = 1;
  } else {
    if (negative) {
      num = -num;
    }
    assert3(num <= 67108863, "Number is too big");
    var w2 = this.words[0] | 0;
    res = w2 === num ? 0 : w2 < num ? -1 : 1;
  }
  if (this.negative !== 0)
    return -res | 0;
  return res;
};
BN.prototype.cmp = function cmp(num) {
  if (this.negative !== 0 && num.negative === 0)
    return -1;
  if (this.negative === 0 && num.negative !== 0)
    return 1;
  var res = this.ucmp(num);
  if (this.negative !== 0)
    return -res | 0;
  return res;
};
BN.prototype.ucmp = function ucmp(num) {
  if (this.length > num.length)
    return 1;
  if (this.length < num.length)
    return -1;
  var res = 0;
  for (var i = this.length - 1; i >= 0; i--) {
    var a = this.words[i] | 0;
    var b2 = num.words[i] | 0;
    if (a === b2)
      continue;
    if (a < b2) {
      res = -1;
    } else if (a > b2) {
      res = 1;
    }
    break;
  }
  return res;
};
BN.prototype.gtn = function gtn(num) {
  return this.cmpn(num) === 1;
};
BN.prototype.gt = function gt(num) {
  return this.cmp(num) === 1;
};
BN.prototype.gten = function gten(num) {
  return this.cmpn(num) >= 0;
};
BN.prototype.gte = function gte(num) {
  return this.cmp(num) >= 0;
};
BN.prototype.ltn = function ltn(num) {
  return this.cmpn(num) === -1;
};
BN.prototype.lt = function lt(num) {
  return this.cmp(num) === -1;
};
BN.prototype.lten = function lten(num) {
  return this.cmpn(num) <= 0;
};
BN.prototype.lte = function lte(num) {
  return this.cmp(num) <= 0;
};
BN.prototype.eqn = function eqn(num) {
  return this.cmpn(num) === 0;
};
BN.prototype.eq = function eq(num) {
  return this.cmp(num) === 0;
};
BN.red = function red2(num) {
  return new Red(num);
};
BN.prototype.toRed = function toRed(ctx) {
  assert3(!this.red, "Already a number in reduction context");
  assert3(this.negative === 0, "red works only with positives");
  return ctx.convertTo(this)._forceRed(ctx);
};
BN.prototype.fromRed = function fromRed() {
  assert3(this.red, "fromRed works only with numbers in reduction context");
  return this.red.convertFrom(this);
};
BN.prototype._forceRed = function _forceRed(ctx) {
  this.red = ctx;
  return this;
};
BN.prototype.forceRed = function forceRed(ctx) {
  assert3(!this.red, "Already a number in reduction context");
  return this._forceRed(ctx);
};
BN.prototype.redAdd = function redAdd(num) {
  assert3(this.red, "redAdd works only with red numbers");
  return this.red.add(this, num);
};
BN.prototype.redIAdd = function redIAdd(num) {
  assert3(this.red, "redIAdd works only with red numbers");
  return this.red.iadd(this, num);
};
BN.prototype.redSub = function redSub(num) {
  assert3(this.red, "redSub works only with red numbers");
  return this.red.sub(this, num);
};
BN.prototype.redISub = function redISub(num) {
  assert3(this.red, "redISub works only with red numbers");
  return this.red.isub(this, num);
};
BN.prototype.redShl = function redShl(num) {
  assert3(this.red, "redShl works only with red numbers");
  return this.red.shl(this, num);
};
BN.prototype.redMul = function redMul(num) {
  assert3(this.red, "redMul works only with red numbers");
  this.red._verify2(this, num);
  return this.red.mul(this, num);
};
BN.prototype.redIMul = function redIMul(num) {
  assert3(this.red, "redMul works only with red numbers");
  this.red._verify2(this, num);
  return this.red.imul(this, num);
};
BN.prototype.redSqr = function redSqr() {
  assert3(this.red, "redSqr works only with red numbers");
  this.red._verify1(this);
  return this.red.sqr(this);
};
BN.prototype.redISqr = function redISqr() {
  assert3(this.red, "redISqr works only with red numbers");
  this.red._verify1(this);
  return this.red.isqr(this);
};
BN.prototype.redSqrt = function redSqrt() {
  assert3(this.red, "redSqrt works only with red numbers");
  this.red._verify1(this);
  return this.red.sqrt(this);
};
BN.prototype.redInvm = function redInvm() {
  assert3(this.red, "redInvm works only with red numbers");
  this.red._verify1(this);
  return this.red.invm(this);
};
BN.prototype.redNeg = function redNeg() {
  assert3(this.red, "redNeg works only with red numbers");
  this.red._verify1(this);
  return this.red.neg(this);
};
BN.prototype.redPow = function redPow(num) {
  assert3(this.red && !num.red, "redPow(normalNum)");
  this.red._verify1(this);
  return this.red.pow(this, num);
};
var primes = {
  k256: null,
  p224: null,
  p192: null,
  p25519: null
};
function MPrime(name, p3) {
  this.name = name;
  this.p = new BN(p3, 16);
  this.n = this.p.bitLength();
  this.k = new BN(1).iushln(this.n).isub(this.p);
  this.tmp = this._tmp();
}
MPrime.prototype._tmp = function _tmp() {
  var tmp = new BN(null);
  tmp.words = new Array(Math.ceil(this.n / 13));
  return tmp;
};
MPrime.prototype.ireduce = function ireduce(num) {
  var r = num;
  var rlen;
  do {
    this.split(r, this.tmp);
    r = this.imulK(r);
    r = r.iadd(this.tmp);
    rlen = r.bitLength();
  } while (rlen > this.n);
  var cmp2 = rlen < this.n ? -1 : r.ucmp(this.p);
  if (cmp2 === 0) {
    r.words[0] = 0;
    r.length = 1;
  } else if (cmp2 > 0) {
    r.isub(this.p);
  } else {
    if (r.strip !== void 0) {
      r.strip();
    } else {
      r._strip();
    }
  }
  return r;
};
MPrime.prototype.split = function split(input, out) {
  input.iushrn(this.n, 0, out);
};
MPrime.prototype.imulK = function imulK(num) {
  return num.imul(this.k);
};
function K256() {
  MPrime.call(this, "k256", "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f");
}
inherits2(K256, MPrime);
K256.prototype.split = function split2(input, output) {
  var mask = 4194303;
  var outLen = Math.min(input.length, 9);
  for (var i = 0; i < outLen; i++) {
    output.words[i] = input.words[i];
  }
  output.length = outLen;
  if (input.length <= 9) {
    input.words[0] = 0;
    input.length = 1;
    return;
  }
  var prev = input.words[9];
  output.words[output.length++] = prev & mask;
  for (i = 10; i < input.length; i++) {
    var next = input.words[i] | 0;
    input.words[i - 10] = (next & mask) << 4 | prev >>> 22;
    prev = next;
  }
  prev >>>= 22;
  input.words[i - 10] = prev;
  if (prev === 0 && input.length > 10) {
    input.length -= 10;
  } else {
    input.length -= 9;
  }
};
K256.prototype.imulK = function imulK2(num) {
  num.words[num.length] = 0;
  num.words[num.length + 1] = 0;
  num.length += 2;
  var lo3 = 0;
  for (var i = 0; i < num.length; i++) {
    var w2 = num.words[i] | 0;
    lo3 += w2 * 977;
    num.words[i] = lo3 & 67108863;
    lo3 = w2 * 64 + (lo3 / 67108864 | 0);
  }
  if (num.words[num.length - 1] === 0) {
    num.length--;
    if (num.words[num.length - 1] === 0) {
      num.length--;
    }
  }
  return num;
};
function P224() {
  MPrime.call(this, "p224", "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001");
}
inherits2(P224, MPrime);
function P192() {
  MPrime.call(this, "p192", "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff");
}
inherits2(P192, MPrime);
function P25519() {
  MPrime.call(this, "25519", "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed");
}
inherits2(P25519, MPrime);
P25519.prototype.imulK = function imulK3(num) {
  var carry = 0;
  for (var i = 0; i < num.length; i++) {
    var hi2 = (num.words[i] | 0) * 19 + carry;
    var lo3 = hi2 & 67108863;
    hi2 >>>= 26;
    num.words[i] = lo3;
    carry = hi2;
  }
  if (carry !== 0) {
    num.words[num.length++] = carry;
  }
  return num;
};
BN._prime = function prime(name) {
  if (primes[name])
    return primes[name];
  var prime2;
  if (name === "k256") {
    prime2 = new K256();
  } else if (name === "p224") {
    prime2 = new P224();
  } else if (name === "p192") {
    prime2 = new P192();
  } else if (name === "p25519") {
    prime2 = new P25519();
  } else {
    throw new Error("Unknown prime " + name);
  }
  primes[name] = prime2;
  return prime2;
};
function Red(m3) {
  if (typeof m3 === "string") {
    var prime2 = BN._prime(m3);
    this.m = prime2.p;
    this.prime = prime2;
  } else {
    assert3(m3.gtn(1), "modulus must be greater than 1");
    this.m = m3;
    this.prime = null;
  }
}
Red.prototype._verify1 = function _verify1(a) {
  assert3(a.negative === 0, "red works only with positives");
  assert3(a.red, "red works only with red numbers");
};
Red.prototype._verify2 = function _verify2(a, b2) {
  assert3((a.negative | b2.negative) === 0, "red works only with positives");
  assert3(a.red && a.red === b2.red, "red works only with red numbers");
};
Red.prototype.imod = function imod(a) {
  if (this.prime)
    return this.prime.ireduce(a)._forceRed(this);
  move(a, a.umod(this.m)._forceRed(this));
  return a;
};
Red.prototype.neg = function neg2(a) {
  if (a.isZero()) {
    return a.clone();
  }
  return this.m.sub(a)._forceRed(this);
};
Red.prototype.add = function add2(a, b2) {
  this._verify2(a, b2);
  var res = a.add(b2);
  if (res.cmp(this.m) >= 0) {
    res.isub(this.m);
  }
  return res._forceRed(this);
};
Red.prototype.iadd = function iadd2(a, b2) {
  this._verify2(a, b2);
  var res = a.iadd(b2);
  if (res.cmp(this.m) >= 0) {
    res.isub(this.m);
  }
  return res;
};
Red.prototype.sub = function sub2(a, b2) {
  this._verify2(a, b2);
  var res = a.sub(b2);
  if (res.cmpn(0) < 0) {
    res.iadd(this.m);
  }
  return res._forceRed(this);
};
Red.prototype.isub = function isub2(a, b2) {
  this._verify2(a, b2);
  var res = a.isub(b2);
  if (res.cmpn(0) < 0) {
    res.iadd(this.m);
  }
  return res;
};
Red.prototype.shl = function shl(a, num) {
  this._verify1(a);
  return this.imod(a.ushln(num));
};
Red.prototype.imul = function imul2(a, b2) {
  this._verify2(a, b2);
  return this.imod(a.imul(b2));
};
Red.prototype.mul = function mul2(a, b2) {
  this._verify2(a, b2);
  return this.imod(a.mul(b2));
};
Red.prototype.isqr = function isqr2(a) {
  return this.imul(a, a.clone());
};
Red.prototype.sqr = function sqr2(a) {
  return this.mul(a, a);
};
Red.prototype.sqrt = function sqrt(a) {
  if (a.isZero())
    return a.clone();
  var mod3 = this.m.andln(3);
  assert3(mod3 % 2 === 1);
  if (mod3 === 3) {
    var pow3 = this.m.add(new BN(1)).iushrn(2);
    return this.pow(a, pow3);
  }
  var q = this.m.subn(1);
  var s = 0;
  while (!q.isZero() && q.andln(1) === 0) {
    s++;
    q.iushrn(1);
  }
  assert3(!q.isZero());
  var one = new BN(1).toRed(this);
  var nOne = one.redNeg();
  var lpow = this.m.subn(1).iushrn(1);
  var z = this.m.bitLength();
  z = new BN(2 * z * z).toRed(this);
  while (this.pow(z, lpow).cmp(nOne) !== 0) {
    z.redIAdd(nOne);
  }
  var c5 = this.pow(z, q);
  var r = this.pow(a, q.addn(1).iushrn(1));
  var t = this.pow(a, q);
  var m3 = s;
  while (t.cmp(one) !== 0) {
    var tmp = t;
    for (var i = 0; tmp.cmp(one) !== 0; i++) {
      tmp = tmp.redSqr();
    }
    assert3(i < m3);
    var b2 = this.pow(c5, new BN(1).iushln(m3 - i - 1));
    r = r.redMul(b2);
    c5 = b2.redSqr();
    t = t.redMul(c5);
    m3 = i;
  }
  return r;
};
Red.prototype.invm = function invm2(a) {
  var inv = a._invmp(this.m);
  if (inv.negative !== 0) {
    inv.negative = 0;
    return this.imod(inv).redNeg();
  } else {
    return this.imod(inv);
  }
};
Red.prototype.pow = function pow2(a, num) {
  if (num.isZero())
    return new BN(1).toRed(this);
  if (num.cmpn(1) === 0)
    return a.clone();
  var windowSize = 4;
  var wnd = new Array(1 << windowSize);
  wnd[0] = new BN(1).toRed(this);
  wnd[1] = a;
  for (var i = 2; i < wnd.length; i++) {
    wnd[i] = this.mul(wnd[i - 1], a);
  }
  var res = wnd[0];
  var current = 0;
  var currentLen = 0;
  var start = num.bitLength() % 26;
  if (start === 0) {
    start = 26;
  }
  for (i = num.length - 1; i >= 0; i--) {
    var word = num.words[i];
    for (var j2 = start - 1; j2 >= 0; j2--) {
      var bit = word >> j2 & 1;
      if (res !== wnd[0]) {
        res = this.sqr(res);
      }
      if (bit === 0 && current === 0) {
        currentLen = 0;
        continue;
      }
      current <<= 1;
      current |= bit;
      currentLen++;
      if (currentLen !== windowSize && (i !== 0 || j2 !== 0))
        continue;
      res = this.mul(res, wnd[current]);
      currentLen = 0;
      current = 0;
    }
    start = 26;
  }
  return res;
};
Red.prototype.convertTo = function convertTo(num) {
  var r = num.umod(this.m);
  return r === num ? r.clone() : r;
};
Red.prototype.convertFrom = function convertFrom(num) {
  var res = num.clone();
  res.red = null;
  return res;
};
BN.mont = function mont(num) {
  return new Mont(num);
};
function Mont(m3) {
  Red.call(this, m3);
  this.shift = this.m.bitLength();
  if (this.shift % 26 !== 0) {
    this.shift += 26 - this.shift % 26;
  }
  this.r = new BN(1).iushln(this.shift);
  this.r2 = this.imod(this.r.sqr());
  this.rinv = this.r._invmp(this.m);
  this.minv = this.rinv.mul(this.r).isubn(1).div(this.m);
  this.minv = this.minv.umod(this.r);
  this.minv = this.r.sub(this.minv);
}
inherits2(Mont, Red);
Mont.prototype.convertTo = function convertTo2(num) {
  return this.imod(num.ushln(this.shift));
};
Mont.prototype.convertFrom = function convertFrom2(num) {
  var r = this.imod(num.mul(this.rinv));
  r.red = null;
  return r;
};
Mont.prototype.imul = function imul3(a, b2) {
  if (a.isZero() || b2.isZero()) {
    a.words[0] = 0;
    a.length = 1;
    return a;
  }
  var t = a.imul(b2);
  var c5 = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
  var u = t.isub(c5).iushrn(this.shift);
  var res = u;
  if (u.cmp(this.m) >= 0) {
    res = u.isub(this.m);
  } else if (u.cmpn(0) < 0) {
    res = u.iadd(this.m);
  }
  return res._forceRed(this);
};
Mont.prototype.mul = function mul3(a, b2) {
  if (a.isZero() || b2.isZero())
    return new BN(0)._forceRed(this);
  var t = a.mul(b2);
  var c5 = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
  var u = t.isub(c5).iushrn(this.shift);
  var res = u;
  if (u.cmp(this.m) >= 0) {
    res = u.isub(this.m);
  } else if (u.cmpn(0) < 0) {
    res = u.iadd(this.m);
  }
  return res._forceRed(this);
};
Mont.prototype.invm = function invm3(a) {
  var res = this.imod(a._invmp(this.m).mul(this.r2));
  return res._forceRed(this);
};

// deno:https://deno.land/std@0.147.0/node/_crypto/crypto_browserify/asn1.js/base/reporter.js
function Reporter(options) {
  this._reporterState = {
    obj: null,
    path: [],
    options: options || {},
    errors: []
  };
}
Reporter.prototype.isError = function isError2(obj2) {
  return obj2 instanceof ReporterError;
};
Reporter.prototype.save = function save() {
  const state = this._reporterState;
  return { obj: state.obj, pathLen: state.path.length };
};
Reporter.prototype.restore = function restore(data) {
  const state = this._reporterState;
  state.obj = data.obj;
  state.path = state.path.slice(0, data.pathLen);
};
Reporter.prototype.enterKey = function enterKey(key2) {
  return this._reporterState.path.push(key2);
};
Reporter.prototype.exitKey = function exitKey(index) {
  const state = this._reporterState;
  state.path = state.path.slice(0, index - 1);
};
Reporter.prototype.leaveKey = function leaveKey(index, key2, value) {
  const state = this._reporterState;
  this.exitKey(index);
  if (state.obj !== null) {
    state.obj[key2] = value;
  }
};
Reporter.prototype.path = function path3() {
  return this._reporterState.path.join("/");
};
Reporter.prototype.enterObject = function enterObject() {
  const state = this._reporterState;
  const prev = state.obj;
  state.obj = {};
  return prev;
};
Reporter.prototype.leaveObject = function leaveObject(prev) {
  const state = this._reporterState;
  const now = state.obj;
  state.obj = prev;
  return now;
};
Reporter.prototype.error = function error(msg) {
  let err;
  const state = this._reporterState;
  const inherited = msg instanceof ReporterError;
  if (inherited) {
    err = msg;
  } else {
    err = new ReporterError(state.path.map(function(elem) {
      return "[" + JSON.stringify(elem) + "]";
    }).join(""), msg.message || msg, msg.stack);
  }
  if (!state.options.partial) {
    throw err;
  }
  if (!inherited) {
    state.errors.push(err);
  }
  return err;
};
Reporter.prototype.wrapResult = function wrapResult(result) {
  const state = this._reporterState;
  if (!state.options.partial) {
    return result;
  }
  return {
    result: this.isError(result) ? null : result,
    errors: state.errors
  };
};
function ReporterError(path6, msg) {
  this.path = path6;
  this.rethrow(msg);
}
ReporterError.prototype = Object.create(Error.prototype, {
  constructor: {
    value: ReporterError,
    enumerable: false,
    writable: true,
    configurable: true
  }
});
ReporterError.prototype.rethrow = function rethrow(msg) {
  this.message = msg + " at: " + (this.path || "(shallow)");
  if (Error.captureStackTrace) {
    Error.captureStackTrace(this, ReporterError);
  }
  if (!this.stack) {
    try {
      throw new Error(this.message);
    } catch (e) {
      this.stack = e.stack;
    }
  }
  return this;
};

// deno:https://deno.land/std@0.147.0/node/_crypto/crypto_browserify/asn1.js/base/buffer.js
function DecoderBuffer(base3, options) {
  Reporter.call(this, options);
  if (!Buffer3.isBuffer(base3)) {
    this.error("Input not Buffer");
    return;
  }
  this.base = base3;
  this.offset = 0;
  this.length = base3.length;
}
DecoderBuffer.prototype = Object.create(Reporter.prototype, {
  constructor: {
    value: DecoderBuffer,
    enumerable: false,
    writable: true,
    configurable: true
  }
});
DecoderBuffer.isDecoderBuffer = function isDecoderBuffer(data) {
  if (data instanceof DecoderBuffer) {
    return true;
  }
  const isCompatible = typeof data === "object" && Buffer3.isBuffer(data.base) && data.constructor.name === "DecoderBuffer" && typeof data.offset === "number" && typeof data.length === "number" && typeof data.save === "function" && typeof data.restore === "function" && typeof data.isEmpty === "function" && typeof data.readUInt8 === "function" && typeof data.skip === "function" && typeof data.raw === "function";
  return isCompatible;
};
DecoderBuffer.prototype.save = function save2() {
  return { offset: this.offset, reporter: Reporter.prototype.save.call(this) };
};
DecoderBuffer.prototype.restore = function restore2(save3) {
  const res = new DecoderBuffer(this.base);
  res.offset = save3.offset;
  res.length = this.offset;
  this.offset = save3.offset;
  Reporter.prototype.restore.call(this, save3.reporter);
  return res;
};
DecoderBuffer.prototype.isEmpty = function isEmpty() {
  return this.offset === this.length;
};
DecoderBuffer.prototype.readUInt8 = function readUInt82(fail3) {
  if (this.offset + 1 <= this.length) {
    return this.base.readUInt8(this.offset++, true);
  } else {
    return this.error(fail3 || "DecoderBuffer overrun");
  }
};
DecoderBuffer.prototype.skip = function skip(bytes, fail3) {
  if (!(this.offset + bytes <= this.length)) {
    return this.error(fail3 || "DecoderBuffer overrun");
  }
  const res = new DecoderBuffer(this.base);
  res._reporterState = this._reporterState;
  res.offset = this.offset;
  res.length = this.offset + bytes;
  this.offset += bytes;
  return res;
};
DecoderBuffer.prototype.raw = function raw(save3) {
  return this.base.slice(save3 ? save3.offset : this.offset, this.length);
};
function EncoderBuffer(value, reporter) {
  if (Array.isArray(value)) {
    this.length = 0;
    this.value = value.map(function(item) {
      if (!EncoderBuffer.isEncoderBuffer(item)) {
        item = new EncoderBuffer(item, reporter);
      }
      this.length += item.length;
      return item;
    }, this);
  } else if (typeof value === "number") {
    if (!(0 <= value && value <= 255)) {
      return reporter.error("non-byte EncoderBuffer value");
    }
    this.value = value;
    this.length = 1;
  } else if (typeof value === "string") {
    this.value = value;
    this.length = Buffer3.byteLength(value);
  } else if (Buffer3.isBuffer(value)) {
    this.value = value;
    this.length = value.length;
  } else {
    return reporter.error("Unsupported type: " + typeof value);
  }
}
EncoderBuffer.isEncoderBuffer = function isEncoderBuffer(data) {
  if (data instanceof EncoderBuffer) {
    return true;
  }
  const isCompatible = typeof data === "object" && data.constructor.name === "EncoderBuffer" && typeof data.length === "number" && typeof data.join === "function";
  return isCompatible;
};
EncoderBuffer.prototype.join = function join6(out, offset) {
  if (!out) {
    out = Buffer3.alloc(this.length);
  }
  if (!offset) {
    offset = 0;
  }
  if (this.length === 0) {
    return out;
  }
  if (Array.isArray(this.value)) {
    this.value.forEach(function(item) {
      item.join(out, offset);
      offset += item.length;
    });
  } else {
    if (typeof this.value === "number") {
      out[offset] = this.value;
    } else if (typeof this.value === "string") {
      out.write(this.value, offset);
    } else if (Buffer3.isBuffer(this.value)) {
      this.value.copy(out, offset);
    }
    offset += this.length;
  }
  return out;
};

// deno:https://deno.land/std@0.147.0/node/_crypto/crypto_browserify/asn1.js/base/node.js
var tags = [
  "seq",
  "seqof",
  "set",
  "setof",
  "objid",
  "bool",
  "gentime",
  "utctime",
  "null_",
  "enum",
  "int",
  "objDesc",
  "bitstr",
  "bmpstr",
  "charstr",
  "genstr",
  "graphstr",
  "ia5str",
  "iso646str",
  "numstr",
  "octstr",
  "printstr",
  "t61str",
  "unistr",
  "utf8str",
  "videostr"
];
var methods = [
  "key",
  "obj",
  "use",
  "optional",
  "explicit",
  "implicit",
  "def",
  "choice",
  "any",
  "contains"
].concat(tags);
var overrided = [
  "_peekTag",
  "_decodeTag",
  "_use",
  "_decodeStr",
  "_decodeObjid",
  "_decodeTime",
  "_decodeNull",
  "_decodeInt",
  "_decodeBool",
  "_decodeList",
  "_encodeComposite",
  "_encodeStr",
  "_encodeObjid",
  "_encodeTime",
  "_encodeNull",
  "_encodeInt",
  "_encodeBool"
];
function Node(enc, parent, name) {
  const state = {};
  this._baseState = state;
  state.name = name;
  state.enc = enc;
  state.parent = parent || null;
  state.children = null;
  state.tag = null;
  state.args = null;
  state.reverseArgs = null;
  state.choice = null;
  state.optional = false;
  state.any = false;
  state.obj = false;
  state.use = null;
  state.useDecoder = null;
  state.key = null;
  state["default"] = null;
  state.explicit = null;
  state.implicit = null;
  state.contains = null;
  if (!state.parent) {
    state.children = [];
    this._wrap();
  }
}
var stateProps = [
  "enc",
  "parent",
  "children",
  "tag",
  "args",
  "reverseArgs",
  "choice",
  "optional",
  "any",
  "obj",
  "use",
  "alteredUse",
  "key",
  "default",
  "explicit",
  "implicit",
  "contains"
];
Node.prototype.clone = function clone2() {
  const state = this._baseState;
  const cstate = {};
  stateProps.forEach(function(prop) {
    cstate[prop] = state[prop];
  });
  const res = new this.constructor(cstate.parent);
  res._baseState = cstate;
  return res;
};
Node.prototype._wrap = function wrap2() {
  const state = this._baseState;
  methods.forEach(function(method) {
    this[method] = function _wrappedMethod() {
      const clone3 = new this.constructor(this);
      state.children.push(clone3);
      return clone3[method].apply(clone3, arguments);
    };
  }, this);
};
Node.prototype._init = function init2(body) {
  const state = this._baseState;
  assert(state.parent === null);
  body.call(this);
  state.children = state.children.filter(function(child) {
    return child._baseState.parent === this;
  }, this);
  assertEquals(state.children.length, 1, "Root node can have only one child");
};
Node.prototype._useArgs = function useArgs(args) {
  const state = this._baseState;
  const children = args.filter(function(arg) {
    return arg instanceof this.constructor;
  }, this);
  args = args.filter(function(arg) {
    return !(arg instanceof this.constructor);
  }, this);
  if (children.length !== 0) {
    assert(state.children === null);
    state.children = children;
    children.forEach(function(child) {
      child._baseState.parent = this;
    }, this);
  }
  if (args.length !== 0) {
    assert(state.args === null);
    state.args = args;
    state.reverseArgs = args.map(function(arg) {
      if (typeof arg !== "object" || arg.constructor !== Object) {
        return arg;
      }
      const res = {};
      Object.keys(arg).forEach(function(key2) {
        if (key2 == (key2 | 0)) {
          key2 |= 0;
        }
        const value = arg[key2];
        res[value] = key2;
      });
      return res;
    });
  }
};
overrided.forEach(function(method) {
  Node.prototype[method] = function _overrided() {
    const state = this._baseState;
    throw new Error(method + " not implemented for encoding: " + state.enc);
  };
});
tags.forEach(function(tag2) {
  Node.prototype[tag2] = function _tagMethod() {
    const state = this._baseState;
    const args = Array.prototype.slice.call(arguments);
    assert(state.tag === null);
    state.tag = tag2;
    this._useArgs(args);
    return this;
  };
});
Node.prototype.use = function use(item) {
  assert(item);
  const state = this._baseState;
  assert(state.use === null);
  state.use = item;
  return this;
};
Node.prototype.optional = function optional() {
  const state = this._baseState;
  state.optional = true;
  return this;
};
Node.prototype.def = function def(val) {
  const state = this._baseState;
  assert(state["default"] === null);
  state["default"] = val;
  state.optional = true;
  return this;
};
Node.prototype.explicit = function explicit(num) {
  const state = this._baseState;
  assert(state.explicit === null && state.implicit === null);
  state.explicit = num;
  return this;
};
Node.prototype.implicit = function implicit(num) {
  const state = this._baseState;
  assert(state.explicit === null && state.implicit === null);
  state.implicit = num;
  return this;
};
Node.prototype.obj = function obj() {
  const state = this._baseState;
  const args = Array.prototype.slice.call(arguments);
  state.obj = true;
  if (args.length !== 0) {
    this._useArgs(args);
  }
  return this;
};
Node.prototype.key = function key(newKey) {
  const state = this._baseState;
  assert(state.key === null);
  state.key = newKey;
  return this;
};
Node.prototype.any = function any() {
  const state = this._baseState;
  state.any = true;
  return this;
};
Node.prototype.choice = function choice(obj2) {
  const state = this._baseState;
  assert(state.choice === null);
  state.choice = obj2;
  this._useArgs(Object.keys(obj2).map(function(key2) {
    return obj2[key2];
  }));
  return this;
};
Node.prototype.contains = function contains(item) {
  const state = this._baseState;
  assert(state.use === null);
  state.contains = item;
  return this;
};
Node.prototype._decode = function decode3(input, options) {
  const state = this._baseState;
  if (state.parent === null) {
    return input.wrapResult(state.children[0]._decode(input, options));
  }
  let result = state["default"];
  let present = true;
  let prevKey = null;
  if (state.key !== null) {
    prevKey = input.enterKey(state.key);
  }
  if (state.optional) {
    let tag2 = null;
    if (state.explicit !== null) {
      tag2 = state.explicit;
    } else if (state.implicit !== null) {
      tag2 = state.implicit;
    } else if (state.tag !== null) {
      tag2 = state.tag;
    }
    if (tag2 === null && !state.any) {
      const save3 = input.save();
      try {
        if (state.choice === null) {
          this._decodeGeneric(state.tag, input, options);
        } else {
          this._decodeChoice(input, options);
        }
        present = true;
      } catch (_e2) {
        present = false;
      }
      input.restore(save3);
    } else {
      present = this._peekTag(input, tag2, state.any);
      if (input.isError(present)) {
        return present;
      }
    }
  }
  let prevObj;
  if (state.obj && present) {
    prevObj = input.enterObject();
  }
  if (present) {
    if (state.explicit !== null) {
      const explicit2 = this._decodeTag(input, state.explicit);
      if (input.isError(explicit2)) {
        return explicit2;
      }
      input = explicit2;
    }
    const start = input.offset;
    if (state.use === null && state.choice === null) {
      let save3;
      if (state.any) {
        save3 = input.save();
      }
      const body = this._decodeTag(input, state.implicit !== null ? state.implicit : state.tag, state.any);
      if (input.isError(body)) {
        return body;
      }
      if (state.any) {
        result = input.raw(save3);
      } else {
        input = body;
      }
    }
    if (options && options.track && state.tag !== null) {
      options.track(input.path(), start, input.length, "tagged");
    }
    if (options && options.track && state.tag !== null) {
      options.track(input.path(), input.offset, input.length, "content");
    }
    if (state.any) {
    } else if (state.choice === null) {
      result = this._decodeGeneric(state.tag, input, options);
    } else {
      result = this._decodeChoice(input, options);
    }
    if (input.isError(result)) {
      return result;
    }
    if (!state.any && state.choice === null && state.children !== null) {
      state.children.forEach(function decodeChildren(child) {
        child._decode(input, options);
      });
    }
    if (state.contains && (state.tag === "octstr" || state.tag === "bitstr")) {
      const data = new DecoderBuffer(result);
      result = this._getUse(state.contains, input._reporterState.obj)._decode(data, options);
    }
  }
  if (state.obj && present) {
    result = input.leaveObject(prevObj);
  }
  if (state.key !== null && (result !== null || present === true)) {
    input.leaveKey(prevKey, state.key, result);
  } else if (prevKey !== null) {
    input.exitKey(prevKey);
  }
  return result;
};
Node.prototype._decodeGeneric = function decodeGeneric(tag2, input, options) {
  const state = this._baseState;
  if (tag2 === "seq" || tag2 === "set") {
    return null;
  }
  if (tag2 === "seqof" || tag2 === "setof") {
    return this._decodeList(input, tag2, state.args[0], options);
  } else if (/str$/.test(tag2)) {
    return this._decodeStr(input, tag2, options);
  } else if (tag2 === "objid" && state.args) {
    return this._decodeObjid(input, state.args[0], state.args[1], options);
  } else if (tag2 === "objid") {
    return this._decodeObjid(input, null, null, options);
  } else if (tag2 === "gentime" || tag2 === "utctime") {
    return this._decodeTime(input, tag2, options);
  } else if (tag2 === "null_") {
    return this._decodeNull(input, options);
  } else if (tag2 === "bool") {
    return this._decodeBool(input, options);
  } else if (tag2 === "objDesc") {
    return this._decodeStr(input, tag2, options);
  } else if (tag2 === "int" || tag2 === "enum") {
    return this._decodeInt(input, state.args && state.args[0], options);
  }
  if (state.use !== null) {
    return this._getUse(state.use, input._reporterState.obj)._decode(input, options);
  } else {
    return input.error("unknown tag: " + tag2);
  }
};
Node.prototype._getUse = function _getUse(entity, obj2) {
  const state = this._baseState;
  state.useDecoder = this._use(entity, obj2);
  assert(state.useDecoder._baseState.parent === null);
  state.useDecoder = state.useDecoder._baseState.children[0];
  if (state.implicit !== state.useDecoder._baseState.implicit) {
    state.useDecoder = state.useDecoder.clone();
    state.useDecoder._baseState.implicit = state.implicit;
  }
  return state.useDecoder;
};
Node.prototype._decodeChoice = function decodeChoice(input, options) {
  const state = this._baseState;
  let result = null;
  let match = false;
  Object.keys(state.choice).some(function(key2) {
    const save3 = input.save();
    const node = state.choice[key2];
    try {
      const value = node._decode(input, options);
      if (input.isError(value)) {
        return false;
      }
      result = { type: key2, value };
      match = true;
    } catch (_e2) {
      input.restore(save3);
      return false;
    }
    return true;
  }, this);
  if (!match) {
    return input.error("Choice not matched");
  }
  return result;
};
Node.prototype._createEncoderBuffer = function createEncoderBuffer(data) {
  return new EncoderBuffer(data, this.reporter);
};
Node.prototype._encode = function encode4(data, reporter, parent) {
  const state = this._baseState;
  if (state["default"] !== null && state["default"] === data) {
    return;
  }
  const result = this._encodeValue(data, reporter, parent);
  if (result === void 0) {
    return;
  }
  if (this._skipDefault(result, reporter, parent)) {
    return;
  }
  return result;
};
Node.prototype._encodeValue = function encode5(data, reporter, parent) {
  const state = this._baseState;
  if (state.parent === null) {
    return state.children[0]._encode(data, reporter || new Reporter());
  }
  let result = null;
  this.reporter = reporter;
  if (state.optional && data === void 0) {
    if (state["default"] !== null) {
      data = state["default"];
    } else {
      return;
    }
  }
  let content = null;
  let primitive = false;
  if (state.any) {
    result = this._createEncoderBuffer(data);
  } else if (state.choice) {
    result = this._encodeChoice(data, reporter);
  } else if (state.contains) {
    content = this._getUse(state.contains, parent)._encode(data, reporter);
    primitive = true;
  } else if (state.children) {
    content = state.children.map(function(child) {
      if (child._baseState.tag === "null_") {
        return child._encode(null, reporter, data);
      }
      if (child._baseState.key === null) {
        return reporter.error("Child should have a key");
      }
      const prevKey = reporter.enterKey(child._baseState.key);
      if (typeof data !== "object") {
        return reporter.error("Child expected, but input is not object");
      }
      const res = child._encode(data[child._baseState.key], reporter, data);
      reporter.leaveKey(prevKey);
      return res;
    }, this).filter(function(child) {
      return child;
    });
    content = this._createEncoderBuffer(content);
  } else {
    if (state.tag === "seqof" || state.tag === "setof") {
      if (!(state.args && state.args.length === 1)) {
        return reporter.error("Too many args for : " + state.tag);
      }
      if (!Array.isArray(data)) {
        return reporter.error("seqof/setof, but data is not Array");
      }
      const child = this.clone();
      child._baseState.implicit = null;
      content = this._createEncoderBuffer(data.map(function(item) {
        const state2 = this._baseState;
        return this._getUse(state2.args[0], data)._encode(item, reporter);
      }, child));
    } else if (state.use !== null) {
      result = this._getUse(state.use, parent)._encode(data, reporter);
    } else {
      content = this._encodePrimitive(state.tag, data);
      primitive = true;
    }
  }
  if (!state.any && state.choice === null) {
    const tag2 = state.implicit !== null ? state.implicit : state.tag;
    const cls = state.implicit === null ? "universal" : "context";
    if (tag2 === null) {
      if (state.use === null) {
        reporter.error("Tag could be omitted only for .use()");
      }
    } else {
      if (state.use === null) {
        result = this._encodeComposite(tag2, primitive, cls, content);
      }
    }
  }
  if (state.explicit !== null) {
    result = this._encodeComposite(state.explicit, false, "context", result);
  }
  return result;
};
Node.prototype._encodeChoice = function encodeChoice(data, reporter) {
  const state = this._baseState;
  const node = state.choice[data.type];
  if (!node) {
    assert(false, data.type + " not found in " + JSON.stringify(Object.keys(state.choice)));
  }
  return node._encode(data.value, reporter);
};
Node.prototype._encodePrimitive = function encodePrimitive(tag2, data) {
  const state = this._baseState;
  if (/str$/.test(tag2)) {
    return this._encodeStr(data, tag2);
  } else if (tag2 === "objid" && state.args) {
    return this._encodeObjid(data, state.reverseArgs[0], state.args[1]);
  } else if (tag2 === "objid") {
    return this._encodeObjid(data, null, null);
  } else if (tag2 === "gentime" || tag2 === "utctime") {
    return this._encodeTime(data, tag2);
  } else if (tag2 === "null_") {
    return this._encodeNull();
  } else if (tag2 === "int" || tag2 === "enum") {
    return this._encodeInt(data, state.args && state.reverseArgs[0]);
  } else if (tag2 === "bool") {
    return this._encodeBool(data);
  } else if (tag2 === "objDesc") {
    return this._encodeStr(data, tag2);
  } else {
    throw new Error("Unsupported tag: " + tag2);
  }
};
Node.prototype._isNumstr = function isNumstr(str) {
  return /^[0-9 ]*$/.test(str);
};
Node.prototype._isPrintstr = function isPrintstr(str) {
  return /^[A-Za-z0-9 '()+,-./:=?]*$/.test(str);
};

// deno:https://deno.land/std@0.147.0/node/_crypto/crypto_browserify/asn1.js/constants/der.js
var der_exports = {};
__export(der_exports, {
  tag: () => tag,
  tagByName: () => tagByName,
  tagClass: () => tagClass,
  tagClassByName: () => tagClassByName
});
function reverse(map) {
  const res = {};
  Object.keys(map).forEach(function(key2) {
    if ((key2 | 0) == key2) {
      key2 = key2 | 0;
    }
    const value = map[key2];
    res[value] = key2;
  });
  return res;
}
var tagClass = {
  0: "universal",
  1: "application",
  2: "context",
  3: "private"
};
var tagClassByName = reverse(tagClass);
var tag = {
  0: "end",
  1: "bool",
  2: "int",
  3: "bitstr",
  4: "octstr",
  5: "null_",
  6: "objid",
  7: "objDesc",
  8: "external",
  9: "real",
  10: "enum",
  11: "embed",
  12: "utf8str",
  13: "relativeOid",
  16: "seq",
  17: "set",
  18: "numstr",
  19: "printstr",
  20: "t61str",
  21: "videostr",
  22: "ia5str",
  23: "utctime",
  24: "gentime",
  25: "graphstr",
  26: "iso646str",
  27: "genstr",
  28: "unistr",
  29: "charstr",
  30: "bmpstr"
};
var tagByName = reverse(tag);

// deno:https://deno.land/std@0.147.0/node/_crypto/crypto_browserify/asn1.js/encoders/der.js
function DEREncoder(entity) {
  this.enc = "der";
  this.name = entity.name;
  this.entity = entity;
  this.tree = new DERNode();
  this.tree._init(entity.body);
}
DEREncoder.prototype.encode = function encode6(data, reporter) {
  return this.tree._encode(data, reporter).join();
};
function DERNode(parent) {
  Node.call(this, "der", parent);
}
DERNode.prototype = Object.create(Node.prototype, {
  constructor: {
    value: DERNode,
    enumerable: false,
    writable: true,
    configurable: true
  }
});
DERNode.prototype._encodeComposite = function encodeComposite(tag2, primitive, cls, content) {
  const encodedTag = encodeTag(tag2, primitive, cls, this.reporter);
  if (content.length < 128) {
    const header2 = Buffer3.alloc(2);
    header2[0] = encodedTag;
    header2[1] = content.length;
    return this._createEncoderBuffer([header2, content]);
  }
  let lenOctets = 1;
  for (let i = content.length; i >= 256; i >>= 8) {
    lenOctets++;
  }
  const header = Buffer3.alloc(1 + 1 + lenOctets);
  header[0] = encodedTag;
  header[1] = 128 | lenOctets;
  for (let i = 1 + lenOctets, j2 = content.length; j2 > 0; i--, j2 >>= 8) {
    header[i] = j2 & 255;
  }
  return this._createEncoderBuffer([header, content]);
};
DERNode.prototype._encodeStr = function encodeStr(str, tag2) {
  if (tag2 === "bitstr") {
    return this._createEncoderBuffer([str.unused | 0, str.data]);
  } else if (tag2 === "bmpstr") {
    const buf = Buffer3.alloc(str.length * 2);
    for (let i = 0; i < str.length; i++) {
      buf.writeUInt16BE(str.charCodeAt(i), i * 2);
    }
    return this._createEncoderBuffer(buf);
  } else if (tag2 === "numstr") {
    if (!this._isNumstr(str)) {
      return this.reporter.error("Encoding of string type: numstr supports only digits and space");
    }
    return this._createEncoderBuffer(str);
  } else if (tag2 === "printstr") {
    if (!this._isPrintstr(str)) {
      return this.reporter.error("Encoding of string type: printstr supports only latin upper and lower case letters, digits, space, apostrophe, left and rigth parenthesis, plus sign, comma, hyphen, dot, slash, colon, equal sign, question mark");
    }
    return this._createEncoderBuffer(str);
  } else if (/str$/.test(tag2)) {
    return this._createEncoderBuffer(str);
  } else if (tag2 === "objDesc") {
    return this._createEncoderBuffer(str);
  } else {
    return this.reporter.error("Encoding of string type: " + tag2 + " unsupported");
  }
};
DERNode.prototype._encodeObjid = function encodeObjid(id, values, relative7) {
  if (typeof id === "string") {
    if (!values) {
      return this.reporter.error("string objid given, but no values map found");
    }
    if (!values.hasOwnProperty(id)) {
      return this.reporter.error("objid not found in values map");
    }
    id = values[id].split(/[\s.]+/g);
    for (let i = 0; i < id.length; i++) {
      id[i] |= 0;
    }
  } else if (Array.isArray(id)) {
    id = id.slice();
    for (let i = 0; i < id.length; i++) {
      id[i] |= 0;
    }
  }
  if (!Array.isArray(id)) {
    return this.reporter.error("objid() should be either array or string, got: " + JSON.stringify(id));
  }
  if (!relative7) {
    if (id[1] >= 40) {
      return this.reporter.error("Second objid identifier OOB");
    }
    id.splice(0, 2, id[0] * 40 + id[1]);
  }
  let size = 0;
  for (let i = 0; i < id.length; i++) {
    let ident = id[i];
    for (size++; ident >= 128; ident >>= 7) {
      size++;
    }
  }
  const objid = Buffer3.alloc(size);
  let offset = objid.length - 1;
  for (let i = id.length - 1; i >= 0; i--) {
    let ident = id[i];
    objid[offset--] = ident & 127;
    while ((ident >>= 7) > 0) {
      objid[offset--] = 128 | ident & 127;
    }
  }
  return this._createEncoderBuffer(objid);
};
function two(num) {
  if (num < 10) {
    return "0" + num;
  } else {
    return num;
  }
}
DERNode.prototype._encodeTime = function encodeTime(time, tag2) {
  let str;
  const date = new Date(time);
  if (tag2 === "gentime") {
    str = [
      two(date.getUTCFullYear()),
      two(date.getUTCMonth() + 1),
      two(date.getUTCDate()),
      two(date.getUTCHours()),
      two(date.getUTCMinutes()),
      two(date.getUTCSeconds()),
      "Z"
    ].join("");
  } else if (tag2 === "utctime") {
    str = [
      two(date.getUTCFullYear() % 100),
      two(date.getUTCMonth() + 1),
      two(date.getUTCDate()),
      two(date.getUTCHours()),
      two(date.getUTCMinutes()),
      two(date.getUTCSeconds()),
      "Z"
    ].join("");
  } else {
    this.reporter.error("Encoding " + tag2 + " time is not supported yet");
  }
  return this._encodeStr(str, "octstr");
};
DERNode.prototype._encodeNull = function encodeNull() {
  return this._createEncoderBuffer("");
};
DERNode.prototype._encodeInt = function encodeInt(num, values) {
  if (typeof num === "string") {
    if (!values) {
      return this.reporter.error("String int or enum given, but no values map");
    }
    if (!values.hasOwnProperty(num)) {
      return this.reporter.error("Values map doesn't contain: " + JSON.stringify(num));
    }
    num = values[num];
  }
  if (typeof num !== "number" && !Buffer3.isBuffer(num)) {
    const numArray = num.toArray();
    if (!num.sign && numArray[0] & 128) {
      numArray.unshift(0);
    }
    num = Buffer3.from(numArray);
  }
  if (Buffer3.isBuffer(num)) {
    let size2 = num.length;
    if (num.length === 0) {
      size2++;
    }
    const out2 = Buffer3.alloc(size2);
    num.copy(out2);
    if (num.length === 0) {
      out2[0] = 0;
    }
    return this._createEncoderBuffer(out2);
  }
  if (num < 128) {
    return this._createEncoderBuffer(num);
  }
  if (num < 256) {
    return this._createEncoderBuffer([0, num]);
  }
  let size = 1;
  for (let i = num; i >= 256; i >>= 8) {
    size++;
  }
  const out = new Array(size);
  for (let i = out.length - 1; i >= 0; i--) {
    out[i] = num & 255;
    num >>= 8;
  }
  if (out[0] & 128) {
    out.unshift(0);
  }
  return this._createEncoderBuffer(Buffer3.from(out));
};
DERNode.prototype._encodeBool = function encodeBool(value) {
  return this._createEncoderBuffer(value ? 255 : 0);
};
DERNode.prototype._use = function use2(entity, obj2) {
  if (typeof entity === "function") {
    entity = entity(obj2);
  }
  return entity._getEncoder("der").tree;
};
DERNode.prototype._skipDefault = function skipDefault(dataBuffer, reporter, parent) {
  const state = this._baseState;
  let i;
  if (state["default"] === null) {
    return false;
  }
  const data = dataBuffer.join();
  if (state.defaultBuffer === void 0) {
    state.defaultBuffer = this._encodeValue(state["default"], reporter, parent).join();
  }
  if (data.length !== state.defaultBuffer.length) {
    return false;
  }
  for (i = 0; i < data.length; i++) {
    if (data[i] !== state.defaultBuffer[i]) {
      return false;
    }
  }
  return true;
};
function encodeTag(tag2, primitive, cls, reporter) {
  let res;
  if (tag2 === "seqof") {
    tag2 = "seq";
  } else if (tag2 === "setof") {
    tag2 = "set";
  }
  if (tagByName.hasOwnProperty(tag2)) {
    res = tagByName[tag2];
  } else if (typeof tag2 === "number" && (tag2 | 0) === tag2) {
    res = tag2;
  } else {
    return reporter.error("Unknown tag: " + tag2);
  }
  if (res >= 31) {
    return reporter.error("Multi-octet tag encoding unsupported");
  }
  if (!primitive) {
    res |= 32;
  }
  res |= tagClassByName[cls || "universal"] << 6;
  return res;
}

// deno:https://deno.land/std@0.147.0/node/_crypto/crypto_browserify/asn1.js/encoders/pem.js
function PEMEncoder(entity) {
  DEREncoder.call(this, entity);
  this.enc = "pem";
}
PEMEncoder.prototype = Object.create(DEREncoder.prototype, {
  constructor: {
    value: PEMEncoder,
    enumerable: false,
    writable: true,
    configurable: true
  }
});
PEMEncoder.prototype.encode = function encode7(data, options) {
  const buf = DEREncoder.prototype.encode.call(this, data);
  const p3 = buf.toString("base64");
  const out = ["-----BEGIN " + options.label + "-----"];
  for (let i = 0; i < p3.length; i += 64) {
    out.push(p3.slice(i, i + 64));
  }
  out.push("-----END " + options.label + "-----");
  return out.join("\n");
};

// deno:https://deno.land/std@0.147.0/node/_crypto/crypto_browserify/asn1.js/decoders/der.js
function DERDecoder(entity) {
  this.enc = "der";
  this.name = entity.name;
  this.entity = entity;
  this.tree = new DERNode2();
  this.tree._init(entity.body);
}
DERDecoder.prototype.decode = function decode4(data, options) {
  if (!DecoderBuffer.isDecoderBuffer(data)) {
    data = new DecoderBuffer(data, options);
  }
  return this.tree._decode(data, options);
};
function DERNode2(parent) {
  Node.call(this, "der", parent);
}
DERNode2.prototype = Object.create(Node.prototype, {
  constructor: {
    value: DERNode2,
    enumerable: false,
    writable: true,
    configurable: true
  }
});
DERNode2.prototype._peekTag = function peekTag(buffer, tag2, any2) {
  if (buffer.isEmpty()) {
    return false;
  }
  const state = buffer.save();
  const decodedTag = derDecodeTag(buffer, 'Failed to peek tag: "' + tag2 + '"');
  if (buffer.isError(decodedTag)) {
    return decodedTag;
  }
  buffer.restore(state);
  return decodedTag.tag === tag2 || decodedTag.tagStr === tag2 || decodedTag.tagStr + "of" === tag2 || any2;
};
DERNode2.prototype._decodeTag = function decodeTag(buffer, tag2, any2) {
  const decodedTag = derDecodeTag(buffer, 'Failed to decode tag of "' + tag2 + '"');
  if (buffer.isError(decodedTag)) {
    return decodedTag;
  }
  let len = derDecodeLen(buffer, decodedTag.primitive, 'Failed to get length of "' + tag2 + '"');
  if (buffer.isError(len)) {
    return len;
  }
  if (!any2 && decodedTag.tag !== tag2 && decodedTag.tagStr !== tag2 && decodedTag.tagStr + "of" !== tag2) {
    return buffer.error('Failed to match tag: "' + tag2 + '"');
  }
  if (decodedTag.primitive || len !== null) {
    return buffer.skip(len, 'Failed to match body of: "' + tag2 + '"');
  }
  const state = buffer.save();
  const res = this._skipUntilEnd(buffer, 'Failed to skip indefinite length body: "' + this.tag + '"');
  if (buffer.isError(res)) {
    return res;
  }
  len = buffer.offset - state.offset;
  buffer.restore(state);
  return buffer.skip(len, 'Failed to match body of: "' + tag2 + '"');
};
DERNode2.prototype._skipUntilEnd = function skipUntilEnd(buffer, fail3) {
  for (; ; ) {
    const tag2 = derDecodeTag(buffer, fail3);
    if (buffer.isError(tag2)) {
      return tag2;
    }
    const len = derDecodeLen(buffer, tag2.primitive, fail3);
    if (buffer.isError(len)) {
      return len;
    }
    let res;
    if (tag2.primitive || len !== null) {
      res = buffer.skip(len);
    } else {
      res = this._skipUntilEnd(buffer, fail3);
    }
    if (buffer.isError(res)) {
      return res;
    }
    if (tag2.tagStr === "end") {
      break;
    }
  }
};
DERNode2.prototype._decodeList = function decodeList(buffer, _tag, decoder, options) {
  const result = [];
  while (!buffer.isEmpty()) {
    const possibleEnd = this._peekTag(buffer, "end");
    if (buffer.isError(possibleEnd)) {
      return possibleEnd;
    }
    const res = decoder.decode(buffer, "der", options);
    if (buffer.isError(res) && possibleEnd) {
      break;
    }
    result.push(res);
  }
  return result;
};
DERNode2.prototype._decodeStr = function decodeStr(buffer, tag2) {
  if (tag2 === "bitstr") {
    const unused = buffer.readUInt8();
    if (buffer.isError(unused)) {
      return unused;
    }
    return { unused, data: buffer.raw() };
  } else if (tag2 === "bmpstr") {
    const raw2 = buffer.raw();
    if (raw2.length % 2 === 1) {
      return buffer.error("Decoding of string type: bmpstr length mismatch");
    }
    let str = "";
    for (let i = 0; i < raw2.length / 2; i++) {
      str += String.fromCharCode(raw2.readUInt16BE(i * 2));
    }
    return str;
  } else if (tag2 === "numstr") {
    const numstr = buffer.raw().toString("ascii");
    if (!this._isNumstr(numstr)) {
      return buffer.error("Decoding of string type: numstr unsupported characters");
    }
    return numstr;
  } else if (tag2 === "octstr") {
    return buffer.raw();
  } else if (tag2 === "objDesc") {
    return buffer.raw();
  } else if (tag2 === "printstr") {
    const printstr = buffer.raw().toString("ascii");
    if (!this._isPrintstr(printstr)) {
      return buffer.error("Decoding of string type: printstr unsupported characters");
    }
    return printstr;
  } else if (/str$/.test(tag2)) {
    return buffer.raw().toString();
  } else {
    return buffer.error("Decoding of string type: " + tag2 + " unsupported");
  }
};
DERNode2.prototype._decodeObjid = function decodeObjid(buffer, values, relative7) {
  let result;
  const identifiers = [];
  let ident = 0;
  let subident = 0;
  while (!buffer.isEmpty()) {
    subident = buffer.readUInt8();
    ident <<= 7;
    ident |= subident & 127;
    if ((subident & 128) === 0) {
      identifiers.push(ident);
      ident = 0;
    }
  }
  if (subident & 128) {
    identifiers.push(ident);
  }
  const first = identifiers[0] / 40 | 0;
  const second = identifiers[0] % 40;
  if (relative7) {
    result = identifiers;
  } else {
    result = [first, second].concat(identifiers.slice(1));
  }
  if (values) {
    let tmp = values[result.join(" ")];
    if (tmp === void 0) {
      tmp = values[result.join(".")];
    }
    if (tmp !== void 0) {
      result = tmp;
    }
  }
  return result;
};
DERNode2.prototype._decodeTime = function decodeTime(buffer, tag2) {
  const str = buffer.raw().toString();
  let year;
  let mon;
  let day;
  let hour;
  let min4;
  let sec;
  if (tag2 === "gentime") {
    year = str.slice(0, 4) | 0;
    mon = str.slice(4, 6) | 0;
    day = str.slice(6, 8) | 0;
    hour = str.slice(8, 10) | 0;
    min4 = str.slice(10, 12) | 0;
    sec = str.slice(12, 14) | 0;
  } else if (tag2 === "utctime") {
    year = str.slice(0, 2) | 0;
    mon = str.slice(2, 4) | 0;
    day = str.slice(4, 6) | 0;
    hour = str.slice(6, 8) | 0;
    min4 = str.slice(8, 10) | 0;
    sec = str.slice(10, 12) | 0;
    if (year < 70) {
      year = 2e3 + year;
    } else {
      year = 1900 + year;
    }
  } else {
    return buffer.error("Decoding " + tag2 + " time is not supported yet");
  }
  return Date.UTC(year, mon - 1, day, hour, min4, sec, 0);
};
DERNode2.prototype._decodeNull = function decodeNull() {
  return null;
};
DERNode2.prototype._decodeBool = function decodeBool(buffer) {
  const res = buffer.readUInt8();
  if (buffer.isError(res)) {
    return res;
  } else {
    return res !== 0;
  }
};
DERNode2.prototype._decodeInt = function decodeInt(buffer, values) {
  const raw2 = buffer.raw();
  let res = new bn_default(raw2);
  if (values) {
    res = values[res.toString(10)] || res;
  }
  return res;
};
DERNode2.prototype._use = function use3(entity, obj2) {
  if (typeof entity === "function") {
    entity = entity(obj2);
  }
  return entity._getDecoder("der").tree;
};
function derDecodeTag(buf, fail3) {
  let tag2 = buf.readUInt8(fail3);
  if (buf.isError(tag2)) {
    return tag2;
  }
  const cls = tagClass[tag2 >> 6];
  const primitive = (tag2 & 32) === 0;
  if ((tag2 & 31) === 31) {
    let oct = tag2;
    tag2 = 0;
    while ((oct & 128) === 128) {
      oct = buf.readUInt8(fail3);
      if (buf.isError(oct)) {
        return oct;
      }
      tag2 <<= 7;
      tag2 |= oct & 127;
    }
  } else {
    tag2 &= 31;
  }
  const tagStr = tag[tag2];
  return {
    cls,
    primitive,
    tag: tag2,
    tagStr
  };
}
function derDecodeLen(buf, primitive, fail3) {
  let len = buf.readUInt8(fail3);
  if (buf.isError(len)) {
    return len;
  }
  if (!primitive && len === 128) {
    return null;
  }
  if ((len & 128) === 0) {
    return len;
  }
  const num = len & 127;
  if (num > 4) {
    return buf.error("length octect is too long");
  }
  len = 0;
  for (let i = 0; i < num; i++) {
    len <<= 8;
    const j2 = buf.readUInt8(fail3);
    if (buf.isError(j2)) {
      return j2;
    }
    len |= j2;
  }
  return len;
}

// deno:https://deno.land/std@0.147.0/node/_crypto/crypto_browserify/asn1.js/decoders/pem.js
function PEMDecoder(entity) {
  DERDecoder.call(this, entity);
  this.enc = "pem";
}
PEMDecoder.prototype = Object.create(DERDecoder.prototype, {
  constructor: {
    value: PEMDecoder,
    enumerable: false,
    writable: true,
    configurable: true
  }
});
PEMDecoder.prototype.decode = function decode5(data, options) {
  const lines = data.toString().split(/[\r\n]+/g);
  const label = options.label.toUpperCase();
  const re2 = /^-----(BEGIN|END) ([^-]+)-----$/;
  let start = -1;
  let end = -1;
  for (let i = 0; i < lines.length; i++) {
    const match = lines[i].match(re2);
    if (match === null) {
      continue;
    }
    if (match[2] !== label) {
      continue;
    }
    if (start === -1) {
      if (match[1] !== "BEGIN") {
        break;
      }
      start = i;
    } else {
      if (match[1] !== "END") {
        break;
      }
      end = i;
      break;
    }
  }
  if (start === -1 || end === -1) {
    throw new Error("PEM section not found for: " + label);
  }
  const base64 = lines.slice(start + 1, end).join("");
  base64.replace(/[^a-z0-9+/=]+/gi, "");
  const input = Buffer3.from(base64, "base64");
  return DERDecoder.prototype.decode.call(this, input, options);
};

// deno:https://deno.land/std@0.147.0/node/_crypto/crypto_browserify/asn1.js/mod.js
var base = {
  DecoderBuffer,
  EncoderBuffer,
  Node,
  Reporter
};
var encoders = { der: DEREncoder, pem: PEMEncoder };
var decoders = { der: DERDecoder, pem: PEMDecoder };
var constants4 = { der: der_exports };
function define(name, body) {
  return new Entity(name, body);
}
function Entity(name, body) {
  this.name = name;
  this.body = body;
  this.decoders = {};
  this.encoders = {};
}
Entity.prototype._createNamed = function createNamed(Base) {
  const name = this.name;
  function Generated(entity) {
    this._initNamed(entity, name);
  }
  Generated.prototype = Object.create(Base.prototype, {
    constructor: {
      value: Generated,
      enumerable: false,
      writable: true,
      configurable: true
    }
  });
  Generated.prototype._initNamed = function _initNamed(entity, name2) {
    Base.call(this, entity, name2);
  };
  return new Generated(this);
};
Entity.prototype._getDecoder = function _getDecoder(enc) {
  enc = enc || "der";
  if (!this.decoders.hasOwnProperty(enc)) {
    this.decoders[enc] = this._createNamed(decoders[enc]);
  }
  return this.decoders[enc];
};
Entity.prototype.decode = function decode6(data, enc, options) {
  return this._getDecoder(enc).decode(data, options);
};
Entity.prototype._getEncoder = function _getEncoder(enc) {
  enc = enc || "der";
  if (!this.encoders.hasOwnProperty(enc)) {
    this.encoders[enc] = this._createNamed(encoders[enc]);
  }
  return this.encoders[enc];
};
Entity.prototype.encode = function encode8(data, enc, reporter) {
  return this._getEncoder(enc).encode(data, reporter);
};
var mod_default = {
  base,
  bignum: bn_default,
  constants: constants4,
  decoders,
  define,
  encoders
};

// deno:https://deno.land/std@0.147.0/node/_crypto/crypto_browserify/parse_asn1/certificate.js
var Time = define("Time", function() {
  this.choice({
    utcTime: this.utctime(),
    generalTime: this.gentime()
  });
});
var AttributeTypeValue = define("AttributeTypeValue", function() {
  this.seq().obj(this.key("type").objid(), this.key("value").any());
});
var AlgorithmIdentifier = define("AlgorithmIdentifier", function() {
  this.seq().obj(this.key("algorithm").objid(), this.key("parameters").optional(), this.key("curve").objid().optional());
});
var SubjectPublicKeyInfo = define("SubjectPublicKeyInfo", function() {
  this.seq().obj(this.key("algorithm").use(AlgorithmIdentifier), this.key("subjectPublicKey").bitstr());
});
var RelativeDistinguishedName = define("RelativeDistinguishedName", function() {
  this.setof(AttributeTypeValue);
});
var RDNSequence = define("RDNSequence", function() {
  this.seqof(RelativeDistinguishedName);
});
var Name = define("Name", function() {
  this.choice({
    rdnSequence: this.use(RDNSequence)
  });
});
var Validity = define("Validity", function() {
  this.seq().obj(this.key("notBefore").use(Time), this.key("notAfter").use(Time));
});
var Extension = define("Extension", function() {
  this.seq().obj(this.key("extnID").objid(), this.key("critical").bool().def(false), this.key("extnValue").octstr());
});
var TBSCertificate = define("TBSCertificate", function() {
  this.seq().obj(this.key("version").explicit(0).int().optional(), this.key("serialNumber").int(), this.key("signature").use(AlgorithmIdentifier), this.key("issuer").use(Name), this.key("validity").use(Validity), this.key("subject").use(Name), this.key("subjectPublicKeyInfo").use(SubjectPublicKeyInfo), this.key("issuerUniqueID").implicit(1).bitstr().optional(), this.key("subjectUniqueID").implicit(2).bitstr().optional(), this.key("extensions").explicit(3).seqof(Extension).optional());
});
var X509Certificate = define("X509Certificate", function() {
  this.seq().obj(this.key("tbsCertificate").use(TBSCertificate), this.key("signatureAlgorithm").use(AlgorithmIdentifier), this.key("signatureValue").bitstr());
});
var certificate_default = X509Certificate;

// deno:https://deno.land/std@0.147.0/node/_crypto/crypto_browserify/parse_asn1/asn1.js
var RSAPrivateKey = mod_default.define("RSAPrivateKey", function() {
  this.seq().obj(this.key("version").int(), this.key("modulus").int(), this.key("publicExponent").int(), this.key("privateExponent").int(), this.key("prime1").int(), this.key("prime2").int(), this.key("exponent1").int(), this.key("exponent2").int(), this.key("coefficient").int());
});
var RSAPublicKey = mod_default.define("RSAPublicKey", function() {
  this.seq().obj(this.key("modulus").int(), this.key("publicExponent").int());
});
var PublicKey = mod_default.define("SubjectPublicKeyInfo", function() {
  this.seq().obj(this.key("algorithm").use(AlgorithmIdentifier2), this.key("subjectPublicKey").bitstr());
});
var AlgorithmIdentifier2 = mod_default.define("AlgorithmIdentifier", function() {
  this.seq().obj(this.key("algorithm").objid(), this.key("none").null_().optional(), this.key("curve").objid().optional(), this.key("params").seq().obj(this.key("p").int(), this.key("q").int(), this.key("g").int()).optional());
});
var PrivateKey = mod_default.define("PrivateKeyInfo", function() {
  this.seq().obj(this.key("version").int(), this.key("algorithm").use(AlgorithmIdentifier2), this.key("subjectPrivateKey").octstr());
});
var EncryptedPrivateKey = mod_default.define("EncryptedPrivateKeyInfo", function() {
  this.seq().obj(this.key("algorithm").seq().obj(this.key("id").objid(), this.key("decrypt").seq().obj(this.key("kde").seq().obj(this.key("id").objid(), this.key("kdeparams").seq().obj(this.key("salt").octstr(), this.key("iters").int())), this.key("cipher").seq().obj(this.key("algo").objid(), this.key("iv").octstr()))), this.key("subjectPrivateKey").octstr());
});
var DSAPrivateKey = mod_default.define("DSAPrivateKey", function() {
  this.seq().obj(this.key("version").int(), this.key("p").int(), this.key("q").int(), this.key("g").int(), this.key("pub_key").int(), this.key("priv_key").int());
});
var DSAparam = mod_default.define("DSAparam", function() {
  this.int();
});
var ECPrivateKey = mod_default.define("ECPrivateKey", function() {
  this.seq().obj(this.key("version").int(), this.key("privateKey").octstr(), this.key("parameters").optional().explicit(0).use(ECParameters), this.key("publicKey").optional().explicit(1).bitstr());
});
var ECParameters = mod_default.define("ECParameters", function() {
  this.choice({
    namedCurve: this.objid()
  });
});
var signature = mod_default.define("signature", function() {
  this.seq().obj(this.key("r").int(), this.key("s").int());
});

// deno:https://deno.land/std@0.147.0/node/_crypto/crypto_browserify/parse_asn1/fix_proc.js
var findProc = /Proc-Type: 4,ENCRYPTED[\n\r]+DEK-Info: AES-((?:128)|(?:192)|(?:256))-CBC,([0-9A-H]+)[\n\r]+([0-9A-z\n\r+/=]+)[\n\r]+/m;
var startRegex = /^-----BEGIN ((?:.*? KEY)|CERTIFICATE)-----/m;
var fullRegex = /^-----BEGIN ((?:.*? KEY)|CERTIFICATE)-----([0-9A-z\n\r+/=]+)-----END \1-----$/m;
function fix_proc_default(okey, password) {
  const key2 = okey.toString();
  const match = key2.match(findProc);
  let decrypted;
  if (!match) {
    const match2 = key2.match(fullRegex);
    decrypted = Buffer3.from(match2[2].replace(/[\r\n]/g, ""), "base64");
  } else {
    const suite = "aes" + match[1];
    const iv = Buffer3.from(match[2], "hex");
    const cipherText = Buffer3.from(match[3].replace(/[\r\n]/g, ""), "base64");
    const cipherKey = evp_bytes_to_key_default(password, iv.slice(0, 8), parseInt(match[1], 10)).key;
    const out = [];
    const cipher = createDecipheriv(suite, cipherKey, iv);
    out.push(cipher.update(cipherText));
    out.push(cipher.final());
    decrypted = Buffer3.concat(out);
  }
  const tag2 = key2.match(startRegex)[1];
  return {
    tag: tag2,
    data: decrypted
  };
}

// deno:https://deno.land/std@0.147.0/node/_crypto/crypto_browserify/parse_asn1/mod.js
var aesid = {
  "2.16.840.1.101.3.4.1.1": "aes-128-ecb",
  "2.16.840.1.101.3.4.1.2": "aes-128-cbc",
  "2.16.840.1.101.3.4.1.3": "aes-128-ofb",
  "2.16.840.1.101.3.4.1.4": "aes-128-cfb",
  "2.16.840.1.101.3.4.1.21": "aes-192-ecb",
  "2.16.840.1.101.3.4.1.22": "aes-192-cbc",
  "2.16.840.1.101.3.4.1.23": "aes-192-ofb",
  "2.16.840.1.101.3.4.1.24": "aes-192-cfb",
  "2.16.840.1.101.3.4.1.41": "aes-256-ecb",
  "2.16.840.1.101.3.4.1.42": "aes-256-cbc",
  "2.16.840.1.101.3.4.1.43": "aes-256-ofb",
  "2.16.840.1.101.3.4.1.44": "aes-256-cfb"
};
function parseKeys(buffer) {
  let password;
  if (typeof buffer === "object" && !Buffer3.isBuffer(buffer)) {
    password = buffer.passphrase;
    buffer = buffer.key;
  }
  if (typeof buffer === "string") {
    buffer = Buffer3.from(buffer);
  }
  const stripped = fix_proc_default(buffer, password);
  const type = stripped.tag;
  let data = stripped.data;
  let subtype, ndata;
  switch (type) {
    case "CERTIFICATE":
      ndata = certificate_default.decode(data, "der").tbsCertificate.subjectPublicKeyInfo;
    case "PUBLIC KEY":
      if (!ndata) {
        ndata = PublicKey.decode(data, "der");
      }
      subtype = ndata.algorithm.algorithm.join(".");
      switch (subtype) {
        case "1.2.840.113549.1.1.1":
          return RSAPublicKey.decode(ndata.subjectPublicKey.data, "der");
        case "1.2.840.10045.2.1":
          ndata.subjectPrivateKey = ndata.subjectPublicKey;
          return {
            type: "ec",
            data: ndata
          };
        case "1.2.840.10040.4.1":
          ndata.algorithm.params.pub_key = DSAparam.decode(ndata.subjectPublicKey.data, "der");
          return {
            type: "dsa",
            data: ndata.algorithm.params
          };
        default:
          throw new Error("unknown key id " + subtype);
      }
    case "ENCRYPTED PRIVATE KEY":
      data = EncryptedPrivateKey.decode(data, "der");
      data = decrypt3(data, password);
    case "PRIVATE KEY":
      ndata = PrivateKey.decode(data, "der");
      subtype = ndata.algorithm.algorithm.join(".");
      switch (subtype) {
        case "1.2.840.113549.1.1.1":
          return RSAPrivateKey.decode(ndata.subjectPrivateKey, "der");
        case "1.2.840.10045.2.1":
          return {
            curve: ndata.algorithm.curve,
            privateKey: ECPrivateKey.decode(ndata.subjectPrivateKey, "der").privateKey
          };
        case "1.2.840.10040.4.1":
          ndata.algorithm.params.priv_key = DSAparam.decode(ndata.subjectPrivateKey, "der");
          return {
            type: "dsa",
            params: ndata.algorithm.params
          };
        default:
          throw new Error("unknown key id " + subtype);
      }
    case "RSA PUBLIC KEY":
      return RSAPublicKey.decode(data, "der");
    case "RSA PRIVATE KEY":
      return RSAPrivateKey.decode(data, "der");
    case "DSA PRIVATE KEY":
      return {
        type: "dsa",
        params: DSAPrivateKey.decode(data, "der")
      };
    case "EC PRIVATE KEY":
      data = ECPrivateKey.decode(data, "der");
      return {
        curve: data.parameters.value,
        privateKey: data.privateKey
      };
    default:
      throw new Error("unknown key type " + type);
  }
}
var mod_default2 = parseKeys;
parseKeys.signature = signature;
function decrypt3(data, password) {
  const salt = data.algorithm.decrypt.kde.kdeparams.salt;
  const iters = parseInt(data.algorithm.decrypt.kde.kdeparams.iters.toString(), 10);
  const algo = aesid[data.algorithm.decrypt.cipher.algo.join(".")];
  const iv = data.algorithm.decrypt.cipher.iv;
  const cipherText = data.subjectPrivateKey;
  const keylen = parseInt(algo.split("-")[1], 10) / 8;
  const key2 = pbkdf2Sync(password, salt, iters, keylen, "sha1");
  const cipher = createDecipheriv(algo, key2, iv);
  const out = [];
  out.push(cipher.update(cipherText));
  out.push(cipher.final());
  return Buffer3.concat(out);
}

// deno:https://deno.land/std@0.147.0/node/_crypto/crypto_browserify/randombytes.ts
var MAX_BYTES = 65536;
var MAX_UINT322 = 4294967295;
function randomBytes2(size, cb) {
  if (size > MAX_UINT322) {
    throw new RangeError("requested too many random bytes");
  }
  const bytes = Buffer3.allocUnsafe(size);
  if (size > 0) {
    if (size > MAX_BYTES) {
      for (let generated = 0; generated < size; generated += MAX_BYTES) {
        globalThis.crypto.getRandomValues(bytes.slice(generated, generated + MAX_BYTES));
      }
    } else {
      globalThis.crypto.getRandomValues(bytes);
    }
  }
  if (typeof cb === "function") {
    return nextTick2(function() {
      cb(null, bytes);
    });
  }
  return bytes;
}

// deno:https://deno.land/std@0.147.0/node/_crypto/crypto_browserify/public_encrypt/mgf.js
function mgf_default(seed, len) {
  let t = Buffer3.alloc(0);
  let i = 0;
  let c5;
  while (t.length < len) {
    c5 = i2ops(i++);
    t = Buffer3.concat([t, createHash("sha1").update(seed).update(c5).digest()]);
  }
  return t.slice(0, len);
}
function i2ops(c5) {
  const out = Buffer3.allocUnsafe(4);
  out.writeUInt32BE(c5, 0);
  return out;
}

// deno:https://deno.land/std@0.147.0/node/_crypto/crypto_browserify/public_encrypt/xor.js
function xor3(a, b2) {
  const len = a.length;
  let i = -1;
  while (++i < len) {
    a[i] ^= b2[i];
  }
  return a;
}

// deno:https://deno.land/std@0.147.0/node/_crypto/crypto_browserify/public_encrypt/with_public.js
function withPublic(paddedMsg, key2) {
  return Buffer3.from(paddedMsg.toRed(BN.mont(key2.modulus)).redPow(new BN(key2.publicExponent)).fromRed().toArray());
}

// deno:https://deno.land/std@0.147.0/node/_crypto/crypto_browserify/browserify_rsa.js
function blind(priv) {
  const r = getr(priv);
  const blinder = r.toRed(BN.mont(priv.modulus)).redPow(new BN(priv.publicExponent)).fromRed();
  return { blinder, unblinder: r.invm(priv.modulus) };
}
function getr(priv) {
  const len = priv.modulus.byteLength();
  let r;
  do {
    r = new BN(randomBytes2(len));
  } while (r.cmp(priv.modulus) >= 0 || !r.umod(priv.prime1) || !r.umod(priv.prime2));
  return r;
}
function crt(msg, priv) {
  const blinds = blind(priv);
  const len = priv.modulus.byteLength();
  const blinded = new BN(msg).mul(blinds.blinder).umod(priv.modulus);
  const c1 = blinded.toRed(BN.mont(priv.prime1));
  const c22 = blinded.toRed(BN.mont(priv.prime2));
  const qinv = priv.coefficient;
  const p3 = priv.prime1;
  const q = priv.prime2;
  const m13 = c1.redPow(priv.exponent1).fromRed();
  const m22 = c22.redPow(priv.exponent2).fromRed();
  const h = m13.isub(m22).imul(qinv).umod(p3).imul(q);
  return m22.iadd(h).imul(blinds.unblinder).umod(priv.modulus).toArrayLike(Buffer3, "be", len);
}
crt.getr = getr;
var browserify_rsa_default = crt;

// deno:https://deno.land/std@0.147.0/node/_crypto/crypto_browserify/public_encrypt/public_encrypt.js
function publicEncrypt(publicKey, msg, reverse2) {
  let padding;
  if (publicKey.padding) {
    padding = publicKey.padding;
  } else if (reverse2) {
    padding = 1;
  } else {
    padding = 4;
  }
  const key2 = mod_default2(publicKey);
  let paddedMsg;
  if (padding === 4) {
    paddedMsg = oaep(key2, msg);
  } else if (padding === 1) {
    paddedMsg = pkcs1(key2, msg, reverse2);
  } else if (padding === 3) {
    paddedMsg = new BN(msg);
    if (paddedMsg.cmp(key2.modulus) >= 0) {
      throw new Error("data too long for modulus");
    }
  } else {
    throw new Error("unknown padding");
  }
  if (reverse2) {
    return browserify_rsa_default(paddedMsg, key2);
  } else {
    return withPublic(paddedMsg, key2);
  }
}
function oaep(key2, msg) {
  const k6 = key2.modulus.byteLength();
  const mLen = msg.length;
  const iHash = createHash("sha1").update(Buffer3.alloc(0)).digest();
  const hLen = iHash.length;
  const hLen2 = 2 * hLen;
  if (mLen > k6 - hLen2 - 2) {
    throw new Error("message too long");
  }
  const ps = Buffer3.alloc(k6 - mLen - hLen2 - 2);
  const dblen = k6 - hLen - 1;
  const seed = randomBytes2(hLen);
  const maskedDb = xor3(Buffer3.concat([iHash, ps, Buffer3.alloc(1, 1), msg], dblen), mgf_default(seed, dblen));
  const maskedSeed = xor3(seed, mgf_default(maskedDb, hLen));
  return new BN(Buffer3.concat([Buffer3.alloc(1), maskedSeed, maskedDb], k6));
}
function pkcs1(key2, msg, reverse2) {
  const mLen = msg.length;
  const k6 = key2.modulus.byteLength();
  if (mLen > k6 - 11) {
    throw new Error("message too long");
  }
  let ps;
  if (reverse2) {
    ps = Buffer3.alloc(k6 - mLen - 3, 255);
  } else {
    ps = nonZero(k6 - mLen - 3);
  }
  return new BN(Buffer3.concat([
    Buffer3.from([
      0,
      reverse2 ? 1 : 2
    ]),
    ps,
    Buffer3.alloc(1),
    msg
  ], k6));
}
function nonZero(len) {
  const out = Buffer3.allocUnsafe(len);
  let i = 0;
  let cache = randomBytes2(len * 2);
  let cur = 0;
  let num;
  while (i < len) {
    if (cur === cache.length) {
      cache = randomBytes2(len * 2);
      cur = 0;
    }
    num = cache[cur++];
    if (num) {
      out[i++] = num;
    }
  }
  return out;
}

// deno:https://deno.land/std@0.147.0/node/_crypto/crypto_browserify/public_encrypt/private_decrypt.js
function privateDecrypt(privateKey, enc, reverse2) {
  let padding;
  if (privateKey.padding) {
    padding = privateKey.padding;
  } else if (reverse2) {
    padding = 1;
  } else {
    padding = 4;
  }
  const key2 = mod_default2(privateKey);
  const k6 = key2.modulus.byteLength();
  if (enc.length > k6 || new BN(enc).cmp(key2.modulus) >= 0) {
    throw new Error("decryption error");
  }
  let msg;
  if (reverse2) {
    msg = withPublic(new BN(enc), key2);
  } else {
    msg = browserify_rsa_default(enc, key2);
  }
  const zBuffer = Buffer3.alloc(k6 - msg.length);
  msg = Buffer3.concat([zBuffer, msg], k6);
  if (padding === 4) {
    return oaep2(key2, msg);
  } else if (padding === 1) {
    return pkcs12(key2, msg, reverse2);
  } else if (padding === 3) {
    return msg;
  } else {
    throw new Error("unknown padding");
  }
}
function oaep2(key2, msg) {
  const k6 = key2.modulus.byteLength();
  const iHash = createHash("sha1").update(Buffer3.alloc(0)).digest();
  const hLen = iHash.length;
  if (msg[0] !== 0) {
    throw new Error("decryption error");
  }
  const maskedSeed = msg.slice(1, hLen + 1);
  const maskedDb = msg.slice(hLen + 1);
  const seed = xor3(maskedSeed, mgf_default(maskedDb, hLen));
  const db = xor3(maskedDb, mgf_default(seed, k6 - hLen - 1));
  if (compare3(iHash, db.slice(0, hLen))) {
    throw new Error("decryption error");
  }
  let i = hLen;
  while (db[i] === 0) {
    i++;
  }
  if (db[i++] !== 1) {
    throw new Error("decryption error");
  }
  return db.slice(i);
}
function pkcs12(_key, msg, reverse2) {
  const p13 = msg.slice(0, 2);
  let i = 2;
  let status = 0;
  while (msg[i++] !== 0) {
    if (i >= msg.length) {
      status++;
      break;
    }
  }
  const ps = msg.slice(2, i - 1);
  if (p13.toString("hex") !== "0002" && !reverse2 || p13.toString("hex") !== "0001" && reverse2) {
    status++;
  }
  if (ps.length < 8) {
    status++;
  }
  if (status) {
    throw new Error("decryption error");
  }
  return msg.slice(i);
}
function compare3(a, b2) {
  a = Buffer3.from(a);
  b2 = Buffer3.from(b2);
  let dif = 0;
  let len = a.length;
  if (a.length !== b2.length) {
    dif++;
    len = Math.min(a.length, b2.length);
  }
  let i = -1;
  while (++i < len) {
    dif += a[i] ^ b2[i];
  }
  return dif;
}

// deno:https://deno.land/std@0.147.0/node/_crypto/crypto_browserify/public_encrypt/mod.js
function privateEncrypt(key2, buf) {
  return publicEncrypt(key2, buf, true);
}
function publicDecrypt(key2, buf) {
  return privateDecrypt(key2, buf, true);
}

// deno:https://deno.land/std@0.147.0/node/internal/crypto/cipher.ts
var Cipheriv = class extends transform_default {
  constructor(_cipher, _key, _iv, _options) {
    super();
    notImplemented("crypto.Cipheriv");
  }
  final(_outputEncoding) {
    notImplemented("crypto.Cipheriv.prototype.final");
  }
  getAuthTag() {
    notImplemented("crypto.Cipheriv.prototype.getAuthTag");
  }
  setAAD(_buffer, _options) {
    notImplemented("crypto.Cipheriv.prototype.setAAD");
  }
  setAutoPadding(_autoPadding) {
    notImplemented("crypto.Cipheriv.prototype.setAutoPadding");
  }
  update(_data, _inputEncoding, _outputEncoding) {
    notImplemented("crypto.Cipheriv.prototype.update");
  }
};
var Decipheriv = class extends transform_default {
  constructor(_cipher, _key, _iv, _options) {
    super();
    notImplemented("crypto.Decipheriv");
  }
  final(_outputEncoding) {
    notImplemented("crypto.Decipheriv.prototype.final");
  }
  setAAD(_buffer, _options) {
    notImplemented("crypto.Decipheriv.prototype.setAAD");
  }
  setAuthTag(_buffer, _encoding) {
    notImplemented("crypto.Decipheriv.prototype.setAuthTag");
  }
  setAutoPadding(_autoPadding) {
    notImplemented("crypto.Decipheriv.prototype.setAutoPadding");
  }
  update(_data, _inputEncoding, _outputEncoding) {
    notImplemented("crypto.Decipheriv.prototype.update");
  }
};
function getCipherInfo(nameOrNid, options) {
  if (typeof nameOrNid !== "string" && typeof nameOrNid !== "number") {
    throw new ERR_INVALID_ARG_TYPE("nameOrNid", ["string", "number"], nameOrNid);
  }
  if (typeof nameOrNid === "number") {
    validateInt32(nameOrNid, "nameOrNid");
  }
  let keyLength, ivLength;
  if (options !== void 0) {
    validateObject(options, "options");
    ({ keyLength, ivLength } = options);
    if (keyLength !== void 0) {
      validateInt32(keyLength, "options.keyLength");
    }
    if (ivLength !== void 0) {
      validateInt32(ivLength, "options.ivLength");
    }
  }
  notImplemented("crypto.getCipherInfo");
}

// deno:https://deno.land/std@0.147.0/node/internal/crypto/sig.ts
var Sign = class extends writable_default {
  constructor(algorithm, _options) {
    validateString(algorithm, "algorithm");
    super();
    notImplemented("crypto.Sign");
  }
  sign(_privateKey, _outputEncoding) {
    notImplemented("crypto.Sign.prototype.sign");
  }
  update(_data, _inputEncoding) {
    notImplemented("crypto.Sign.prototype.update");
  }
};
var Verify = class extends writable_default {
  constructor(algorithm, _options) {
    validateString(algorithm, "algorithm");
    super();
    notImplemented("crypto.Verify");
  }
  update(_data, _inputEncoding) {
    notImplemented("crypto.Sign.prototype.update");
  }
  verify(_object, _signature, _signatureEncoding) {
    notImplemented("crypto.Sign.prototype.sign");
  }
};
function signOneShot(_algorithm, _data, _key, _callback) {
  notImplemented("crypto.sign");
}
function verifyOneShot(_algorithm, _data, _key, _signature, _callback) {
  notImplemented("crypto.verify");
}

// deno:https://deno.land/std@0.147.0/node/internal/crypto/x509.ts
var X509Certificate2 = class {
  constructor(buffer) {
    if (typeof buffer === "string") {
      buffer = Buffer3.from(buffer);
    }
    if (!isArrayBufferView(buffer)) {
      throw new ERR_INVALID_ARG_TYPE("buffer", ["string", "Buffer", "TypedArray", "DataView"], buffer);
    }
    notImplemented("crypto.X509Certificate");
  }
  get ca() {
    notImplemented("crypto.X509Certificate.prototype.ca");
    return false;
  }
  checkEmail(_email, _options) {
    notImplemented("crypto.X509Certificate.prototype.checkEmail");
  }
  checkHost(_name, _options) {
    notImplemented("crypto.X509Certificate.prototype.checkHost");
  }
  checkIP(_ip) {
    notImplemented("crypto.X509Certificate.prototype.checkIP");
  }
  checkIssued(_otherCert) {
    notImplemented("crypto.X509Certificate.prototype.checkIssued");
  }
  checkPrivateKey(_privateKey) {
    notImplemented("crypto.X509Certificate.prototype.checkPrivateKey");
  }
  get fingerprint() {
    notImplemented("crypto.X509Certificate.prototype.fingerprint");
    return "";
  }
  get fingerprint256() {
    notImplemented("crypto.X509Certificate.prototype.fingerprint256");
    return "";
  }
  get fingerprint512() {
    notImplemented("crypto.X509Certificate.prototype.fingerprint512");
    return "";
  }
  get infoAccess() {
    notImplemented("crypto.X509Certificate.prototype.infoAccess");
    return "";
  }
  get issuer() {
    notImplemented("crypto.X509Certificate.prototype.issuer");
    return "";
  }
  get issuerCertificate() {
    notImplemented("crypto.X509Certificate.prototype.issuerCertificate");
    return {};
  }
  get keyUsage() {
    notImplemented("crypto.X509Certificate.prototype.keyUsage");
    return [];
  }
  get publicKey() {
    notImplemented("crypto.X509Certificate.prototype.publicKey");
    return {};
  }
  get raw() {
    notImplemented("crypto.X509Certificate.prototype.raw");
    return {};
  }
  get serialNumber() {
    notImplemented("crypto.X509Certificate.prototype.serialNumber");
    return "";
  }
  get subject() {
    notImplemented("crypto.X509Certificate.prototype.subject");
    return "";
  }
  get subjectAltName() {
    notImplemented("crypto.X509Certificate.prototype.subjectAltName");
    return "";
  }
  toJSON() {
    return this.toString();
  }
  toLegacyObject() {
    notImplemented("crypto.X509Certificate.prototype.toLegacyObject");
  }
  toString() {
    notImplemented("crypto.X509Certificate.prototype.toString");
  }
  get validFrom() {
    notImplemented("crypto.X509Certificate.prototype.validFrom");
    return "";
  }
  get validTo() {
    notImplemented("crypto.X509Certificate.prototype.validTo");
    return "";
  }
  verify(_publicKey) {
    notImplemented("crypto.X509Certificate.prototype.verify");
  }
};

// deno:https://deno.land/std@0.147.0/node/internal/crypto/certificate.ts
var Certificate = class {
  static exportChallenge(_spkac, _encoding) {
    notImplemented("crypto.Certificate.exportChallenge");
  }
  static exportPublicKey(_spkac, _encoding) {
    notImplemented("crypto.Certificate.exportPublicKey");
  }
  static verifySpkac(_spkac, _encoding) {
    notImplemented("crypto.Certificate.verifySpkac");
  }
};
var certificate_default2 = Certificate;

// deno:https://deno.land/std@0.147.0/node/crypto.ts
var webcrypto = globalThis.crypto;
var fipsForced = getOptionValue("--force-fips");
function createCipheriv(cipher, key2, iv, options) {
  return new Cipheriv(cipher, key2, iv, options);
}
function createDecipheriv2(algorithm, key2, iv, options) {
  return new Decipheriv(algorithm, key2, iv, options);
}
function createDiffieHellman(sizeOrKey, keyEncoding, generator, generatorEncoding) {
  return new DiffieHellman(sizeOrKey, keyEncoding, generator, generatorEncoding);
}
function createDiffieHellmanGroup(name) {
  return new DiffieHellmanGroup(name);
}
function createECDH(curve) {
  return new ECDH(curve);
}
function createHmac(hmac, key2, options) {
  return new Hmac(hmac, key2, options);
}
function createSign2(algorithm, options) {
  return new Sign(algorithm, options);
}
function createVerify(algorithm, options) {
  return new Verify(algorithm, options);
}
function setFipsForced(val) {
  if (val) {
    return;
  }
  throw new ERR_CRYPTO_FIPS_FORCED();
}
function getFipsForced() {
  return 1;
}
Object.defineProperty(crypto, "defaultCipherList", {
  value: getOptionValue("--tls-cipher-list")
});
var getDiffieHellman = createDiffieHellmanGroup;
var getFips = fipsForced ? getFipsForced : getFipsCrypto;
var setFips = fipsForced ? setFipsForced : setFipsCrypto;
var sign = signOneShot;
var verify = verifyOneShot;
var crypto_default = {
  Certificate: certificate_default2,
  checkPrime,
  checkPrimeSync,
  Cipheriv,
  constants: crypto,
  createCipheriv,
  createDecipheriv: createDecipheriv2,
  createDiffieHellman,
  createDiffieHellmanGroup,
  createECDH,
  createHash,
  createHmac,
  createPrivateKey,
  createPublicKey,
  createSecretKey,
  createSign: createSign2,
  createVerify,
  Decipheriv,
  DiffieHellman,
  diffieHellman,
  DiffieHellmanGroup,
  ECDH,
  generateKey,
  generateKeyPair,
  generateKeyPairSync,
  generateKeySync,
  generatePrime,
  generatePrimeSync,
  getCipherInfo,
  getCiphers,
  getCurves,
  getDiffieHellman,
  getFips,
  getHashes,
  Hash,
  hkdf,
  hkdfSync,
  Hmac,
  KeyObject,
  pbkdf2,
  pbkdf2Sync,
  privateDecrypt,
  privateEncrypt,
  publicDecrypt,
  publicEncrypt,
  randomBytes,
  randomFill,
  randomFillSync,
  randomInt,
  randomUUID,
  scrypt,
  scryptSync,
  secureHeapUsed,
  setEngine,
  setFips,
  Sign,
  sign,
  timingSafeEqual,
  Verify,
  verify,
  webcrypto,
  X509Certificate: X509Certificate2
};

// deno:https://esm.sh/v86/node_buffer.js
var yr = Object.create;
var N = Object.defineProperty;
var wr = Object.getOwnPropertyDescriptor;
var xr = Object.getOwnPropertyNames;
var Br = Object.getPrototypeOf;
var Er = Object.prototype.hasOwnProperty;
var dr = (i) => N(i, "__esModule", { value: true });
var k = (i, r) => () => (r || i((r = { exports: {} }).exports, r), r.exports);
var gr = (i, r, t) => {
  if (r && typeof r == "object" || typeof r == "function")
    for (let n of xr(r))
      !Er.call(i, n) && n !== "default" && N(i, n, { get: () => r[n], enumerable: !(t = wr(r, n)) || t.enumerable });
  return i;
};
var H = (i) => gr(dr(N(i != null ? yr(Br(i)) : {}, "default", i && i.__esModule && "default" in i ? { get: () => i.default, enumerable: true } : { value: i, enumerable: true })), i);
var J = k((_2) => {
  "use strict";
  _2.byteLength = Ir2;
  _2.toByteArray = Ar;
  _2.fromByteArray = Rr2;
  var B3 = [], w2 = [], mr = typeof Uint8Array != "undefined" ? Uint8Array : Array, b2 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
  for (m3 = 0, V3 = b2.length; m3 < V3; ++m3)
    B3[m3] = b2[m3], w2[b2.charCodeAt(m3)] = m3;
  var m3, V3;
  w2["-".charCodeAt(0)] = 62;
  w2["_".charCodeAt(0)] = 63;
  function z(i) {
    var r = i.length;
    if (r % 4 > 0)
      throw new Error("Invalid string. Length must be a multiple of 4");
    var t = i.indexOf("=");
    t === -1 && (t = r);
    var n = t === r ? 0 : 4 - t % 4;
    return [t, n];
  }
  function Ir2(i) {
    var r = z(i), t = r[0], n = r[1];
    return (t + n) * 3 / 4 - n;
  }
  function Fr3(i, r, t) {
    return (r + t) * 3 / 4 - t;
  }
  function Ar(i) {
    var r, t = z(i), n = t[0], e = t[1], o2 = new mr(Fr3(i, n, e)), u = 0, f = e > 0 ? n - 4 : n, c5;
    for (c5 = 0; c5 < f; c5 += 4)
      r = w2[i.charCodeAt(c5)] << 18 | w2[i.charCodeAt(c5 + 1)] << 12 | w2[i.charCodeAt(c5 + 2)] << 6 | w2[i.charCodeAt(c5 + 3)], o2[u++] = r >> 16 & 255, o2[u++] = r >> 8 & 255, o2[u++] = r & 255;
    return e === 2 && (r = w2[i.charCodeAt(c5)] << 2 | w2[i.charCodeAt(c5 + 1)] >> 4, o2[u++] = r & 255), e === 1 && (r = w2[i.charCodeAt(c5)] << 10 | w2[i.charCodeAt(c5 + 1)] << 4 | w2[i.charCodeAt(c5 + 2)] >> 2, o2[u++] = r >> 8 & 255, o2[u++] = r & 255), o2;
  }
  function Ur3(i) {
    return B3[i >> 18 & 63] + B3[i >> 12 & 63] + B3[i >> 6 & 63] + B3[i & 63];
  }
  function Tr2(i, r, t) {
    for (var n, e = [], o2 = r; o2 < t; o2 += 3)
      n = (i[o2] << 16 & 16711680) + (i[o2 + 1] << 8 & 65280) + (i[o2 + 2] & 255), e.push(Ur3(n));
    return e.join("");
  }
  function Rr2(i) {
    for (var r, t = i.length, n = t % 3, e = [], o2 = 16383, u = 0, f = t - n; u < f; u += o2)
      e.push(Tr2(i, u, u + o2 > f ? f : u + o2));
    return n === 1 ? (r = i[t - 1], e.push(B3[r >> 2] + B3[r << 4 & 63] + "==")) : n === 2 && (r = (i[t - 2] << 8) + i[t - 1], e.push(B3[r >> 10] + B3[r >> 4 & 63] + B3[r << 2 & 63] + "=")), e.join("");
  }
});
var K = k((D6) => {
  D6.read = function(i, r, t, n, e) {
    var o2, u, f = e * 8 - n - 1, c5 = (1 << f) - 1, l = c5 >> 1, s = -7, p3 = t ? e - 1 : 0, F4 = t ? -1 : 1, x = i[r + p3];
    for (p3 += F4, o2 = x & (1 << -s) - 1, x >>= -s, s += f; s > 0; o2 = o2 * 256 + i[r + p3], p3 += F4, s -= 8)
      ;
    for (u = o2 & (1 << -s) - 1, o2 >>= -s, s += n; s > 0; u = u * 256 + i[r + p3], p3 += F4, s -= 8)
      ;
    if (o2 === 0)
      o2 = 1 - l;
    else {
      if (o2 === c5)
        return u ? NaN : (x ? -1 : 1) * (1 / 0);
      u = u + Math.pow(2, n), o2 = o2 - l;
    }
    return (x ? -1 : 1) * u * Math.pow(2, o2 - n);
  };
  D6.write = function(i, r, t, n, e, o2) {
    var u, f, c5, l = o2 * 8 - e - 1, s = (1 << l) - 1, p3 = s >> 1, F4 = e === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, x = n ? 0 : o2 - 1, M4 = n ? 1 : -1, ar = r < 0 || r === 0 && 1 / r < 0 ? 1 : 0;
    for (r = Math.abs(r), isNaN(r) || r === 1 / 0 ? (f = isNaN(r) ? 1 : 0, u = s) : (u = Math.floor(Math.log(r) / Math.LN2), r * (c5 = Math.pow(2, -u)) < 1 && (u--, c5 *= 2), u + p3 >= 1 ? r += F4 / c5 : r += F4 * Math.pow(2, 1 - p3), r * c5 >= 2 && (u++, c5 /= 2), u + p3 >= s ? (f = 0, u = s) : u + p3 >= 1 ? (f = (r * c5 - 1) * Math.pow(2, e), u = u + p3) : (f = r * Math.pow(2, p3 - 1) * Math.pow(2, e), u = 0)); e >= 8; i[t + x] = f & 255, x += M4, f /= 256, e -= 8)
      ;
    for (u = u << e | f, l += e; l > 0; i[t + x] = u & 255, x += M4, u /= 256, l -= 8)
      ;
    i[t + x - M4] |= ar * 128;
  };
});
var X = k((R3) => {
  "use strict";
  var $4 = J(), A4 = K(), Z5 = typeof Symbol == "function" && typeof Symbol.for == "function" ? Symbol.for("nodejs.util.inspect.custom") : null;
  R3.Buffer = h;
  R3.SlowBuffer = Nr2;
  R3.INSPECT_MAX_BYTES = 50;
  var S3 = 2147483647;
  R3.kMaxLength = S3;
  h.TYPED_ARRAY_SUPPORT = Cr2();
  !h.TYPED_ARRAY_SUPPORT && typeof console != "undefined" && typeof console.error == "function" && console.error("This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support.");
  function Cr2() {
    try {
      let i = new Uint8Array(1), r = { foo: function() {
        return 42;
      } };
      return Object.setPrototypeOf(r, Uint8Array.prototype), Object.setPrototypeOf(i, r), i.foo() === 42;
    } catch (i) {
      return false;
    }
  }
  Object.defineProperty(h.prototype, "parent", { enumerable: true, get: function() {
    if (!!h.isBuffer(this))
      return this.buffer;
  } });
  Object.defineProperty(h.prototype, "offset", { enumerable: true, get: function() {
    if (!!h.isBuffer(this))
      return this.byteOffset;
  } });
  function d4(i) {
    if (i > S3)
      throw new RangeError('The value "' + i + '" is invalid for option "size"');
    let r = new Uint8Array(i);
    return Object.setPrototypeOf(r, h.prototype), r;
  }
  function h(i, r, t) {
    if (typeof i == "number") {
      if (typeof r == "string")
        throw new TypeError('The "string" argument must be of type string. Received type number');
      return P2(i);
    }
    return Q3(i, r, t);
  }
  h.poolSize = 8192;
  function Q3(i, r, t) {
    if (typeof i == "string")
      return Sr(i, r);
    if (ArrayBuffer.isView(i))
      return Lr4(i);
    if (i == null)
      throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof i);
    if (E2(i, ArrayBuffer) || i && E2(i.buffer, ArrayBuffer) || typeof SharedArrayBuffer != "undefined" && (E2(i, SharedArrayBuffer) || i && E2(i.buffer, SharedArrayBuffer)))
      return G4(i, r, t);
    if (typeof i == "number")
      throw new TypeError('The "value" argument must not be of type number. Received type number');
    let n = i.valueOf && i.valueOf();
    if (n != null && n !== i)
      return h.from(n, r, t);
    let e = Mr(i);
    if (e)
      return e;
    if (typeof Symbol != "undefined" && Symbol.toPrimitive != null && typeof i[Symbol.toPrimitive] == "function")
      return h.from(i[Symbol.toPrimitive]("string"), r, t);
    throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof i);
  }
  h.from = function(i, r, t) {
    return Q3(i, r, t);
  };
  Object.setPrototypeOf(h.prototype, Uint8Array.prototype);
  Object.setPrototypeOf(h, Uint8Array);
  function v2(i) {
    if (typeof i != "number")
      throw new TypeError('"size" argument must be of type number');
    if (i < 0)
      throw new RangeError('The value "' + i + '" is invalid for option "size"');
  }
  function _r2(i, r, t) {
    return v2(i), i <= 0 ? d4(i) : r !== void 0 ? typeof t == "string" ? d4(i).fill(r, t) : d4(i).fill(r) : d4(i);
  }
  h.alloc = function(i, r, t) {
    return _r2(i, r, t);
  };
  function P2(i) {
    return v2(i), d4(i < 0 ? 0 : Y4(i) | 0);
  }
  h.allocUnsafe = function(i) {
    return P2(i);
  };
  h.allocUnsafeSlow = function(i) {
    return P2(i);
  };
  function Sr(i, r) {
    if ((typeof r != "string" || r === "") && (r = "utf8"), !h.isEncoding(r))
      throw new TypeError("Unknown encoding: " + r);
    let t = rr(i, r) | 0, n = d4(t), e = n.write(i, r);
    return e !== t && (n = n.slice(0, e)), n;
  }
  function O(i) {
    let r = i.length < 0 ? 0 : Y4(i.length) | 0, t = d4(r);
    for (let n = 0; n < r; n += 1)
      t[n] = i[n] & 255;
    return t;
  }
  function Lr4(i) {
    if (E2(i, Uint8Array)) {
      let r = new Uint8Array(i);
      return G4(r.buffer, r.byteOffset, r.byteLength);
    }
    return O(i);
  }
  function G4(i, r, t) {
    if (r < 0 || i.byteLength < r)
      throw new RangeError('"offset" is outside of buffer bounds');
    if (i.byteLength < r + (t || 0))
      throw new RangeError('"length" is outside of buffer bounds');
    let n;
    return r === void 0 && t === void 0 ? n = new Uint8Array(i) : t === void 0 ? n = new Uint8Array(i, r) : n = new Uint8Array(i, r, t), Object.setPrototypeOf(n, h.prototype), n;
  }
  function Mr(i) {
    if (h.isBuffer(i)) {
      let r = Y4(i.length) | 0, t = d4(r);
      return t.length === 0 || i.copy(t, 0, 0, r), t;
    }
    if (i.length !== void 0)
      return typeof i.length != "number" || j2(i.length) ? d4(0) : O(i);
    if (i.type === "Buffer" && Array.isArray(i.data))
      return O(i.data);
  }
  function Y4(i) {
    if (i >= S3)
      throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + S3.toString(16) + " bytes");
    return i | 0;
  }
  function Nr2(i) {
    return +i != i && (i = 0), h.alloc(+i);
  }
  h.isBuffer = function(r) {
    return r != null && r._isBuffer === true && r !== h.prototype;
  };
  h.compare = function(r, t) {
    if (E2(r, Uint8Array) && (r = h.from(r, r.offset, r.byteLength)), E2(t, Uint8Array) && (t = h.from(t, t.offset, t.byteLength)), !h.isBuffer(r) || !h.isBuffer(t))
      throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');
    if (r === t)
      return 0;
    let n = r.length, e = t.length;
    for (let o2 = 0, u = Math.min(n, e); o2 < u; ++o2)
      if (r[o2] !== t[o2]) {
        n = r[o2], e = t[o2];
        break;
      }
    return n < e ? -1 : e < n ? 1 : 0;
  };
  h.isEncoding = function(r) {
    switch (String(r).toLowerCase()) {
      case "hex":
      case "utf8":
      case "utf-8":
      case "ascii":
      case "latin1":
      case "binary":
      case "base64":
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return true;
      default:
        return false;
    }
  };
  h.concat = function(r, t) {
    if (!Array.isArray(r))
      throw new TypeError('"list" argument must be an Array of Buffers');
    if (r.length === 0)
      return h.alloc(0);
    let n;
    if (t === void 0)
      for (t = 0, n = 0; n < r.length; ++n)
        t += r[n].length;
    let e = h.allocUnsafe(t), o2 = 0;
    for (n = 0; n < r.length; ++n) {
      let u = r[n];
      if (E2(u, Uint8Array))
        o2 + u.length > e.length ? (h.isBuffer(u) || (u = h.from(u)), u.copy(e, o2)) : Uint8Array.prototype.set.call(e, u, o2);
      else if (h.isBuffer(u))
        u.copy(e, o2);
      else
        throw new TypeError('"list" argument must be an Array of Buffers');
      o2 += u.length;
    }
    return e;
  };
  function rr(i, r) {
    if (h.isBuffer(i))
      return i.length;
    if (ArrayBuffer.isView(i) || E2(i, ArrayBuffer))
      return i.byteLength;
    if (typeof i != "string")
      throw new TypeError('The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof i);
    let t = i.length, n = arguments.length > 2 && arguments[2] === true;
    if (!n && t === 0)
      return 0;
    let e = false;
    for (; ; )
      switch (r) {
        case "ascii":
        case "latin1":
        case "binary":
          return t;
        case "utf8":
        case "utf-8":
          return W4(i).length;
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return t * 2;
        case "hex":
          return t >>> 1;
        case "base64":
          return lr(i).length;
        default:
          if (e)
            return n ? -1 : W4(i).length;
          r = ("" + r).toLowerCase(), e = true;
      }
  }
  h.byteLength = rr;
  function kr2(i, r, t) {
    let n = false;
    if ((r === void 0 || r < 0) && (r = 0), r > this.length || ((t === void 0 || t > this.length) && (t = this.length), t <= 0) || (t >>>= 0, r >>>= 0, t <= r))
      return "";
    for (i || (i = "utf8"); ; )
      switch (i) {
        case "hex":
          return jr3(this, r, t);
        case "utf8":
        case "utf-8":
          return nr(this, r, t);
        case "ascii":
          return qr2(this, r, t);
        case "latin1":
        case "binary":
          return Wr2(this, r, t);
        case "base64":
          return Gr2(this, r, t);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return Xr2(this, r, t);
        default:
          if (n)
            throw new TypeError("Unknown encoding: " + i);
          i = (i + "").toLowerCase(), n = true;
      }
  }
  h.prototype._isBuffer = true;
  function I3(i, r, t) {
    let n = i[r];
    i[r] = i[t], i[t] = n;
  }
  h.prototype.swap16 = function() {
    let r = this.length;
    if (r % 2 != 0)
      throw new RangeError("Buffer size must be a multiple of 16-bits");
    for (let t = 0; t < r; t += 2)
      I3(this, t, t + 1);
    return this;
  };
  h.prototype.swap32 = function() {
    let r = this.length;
    if (r % 4 != 0)
      throw new RangeError("Buffer size must be a multiple of 32-bits");
    for (let t = 0; t < r; t += 4)
      I3(this, t, t + 3), I3(this, t + 1, t + 2);
    return this;
  };
  h.prototype.swap64 = function() {
    let r = this.length;
    if (r % 8 != 0)
      throw new RangeError("Buffer size must be a multiple of 64-bits");
    for (let t = 0; t < r; t += 8)
      I3(this, t, t + 7), I3(this, t + 1, t + 6), I3(this, t + 2, t + 5), I3(this, t + 3, t + 4);
    return this;
  };
  h.prototype.toString = function() {
    let r = this.length;
    return r === 0 ? "" : arguments.length === 0 ? nr(this, 0, r) : kr2.apply(this, arguments);
  };
  h.prototype.toLocaleString = h.prototype.toString;
  h.prototype.equals = function(r) {
    if (!h.isBuffer(r))
      throw new TypeError("Argument must be a Buffer");
    return this === r ? true : h.compare(this, r) === 0;
  };
  h.prototype.inspect = function() {
    let r = "", t = R3.INSPECT_MAX_BYTES;
    return r = this.toString("hex", 0, t).replace(/(.{2})/g, "$1 ").trim(), this.length > t && (r += " ... "), "<Buffer " + r + ">";
  };
  Z5 && (h.prototype[Z5] = h.prototype.inspect);
  h.prototype.compare = function(r, t, n, e, o2) {
    if (E2(r, Uint8Array) && (r = h.from(r, r.offset, r.byteLength)), !h.isBuffer(r))
      throw new TypeError('The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof r);
    if (t === void 0 && (t = 0), n === void 0 && (n = r ? r.length : 0), e === void 0 && (e = 0), o2 === void 0 && (o2 = this.length), t < 0 || n > r.length || e < 0 || o2 > this.length)
      throw new RangeError("out of range index");
    if (e >= o2 && t >= n)
      return 0;
    if (e >= o2)
      return -1;
    if (t >= n)
      return 1;
    if (t >>>= 0, n >>>= 0, e >>>= 0, o2 >>>= 0, this === r)
      return 0;
    let u = o2 - e, f = n - t, c5 = Math.min(u, f), l = this.slice(e, o2), s = r.slice(t, n);
    for (let p3 = 0; p3 < c5; ++p3)
      if (l[p3] !== s[p3]) {
        u = l[p3], f = s[p3];
        break;
      }
    return u < f ? -1 : f < u ? 1 : 0;
  };
  function tr(i, r, t, n, e) {
    if (i.length === 0)
      return -1;
    if (typeof t == "string" ? (n = t, t = 0) : t > 2147483647 ? t = 2147483647 : t < -2147483648 && (t = -2147483648), t = +t, j2(t) && (t = e ? 0 : i.length - 1), t < 0 && (t = i.length + t), t >= i.length) {
      if (e)
        return -1;
      t = i.length - 1;
    } else if (t < 0)
      if (e)
        t = 0;
      else
        return -1;
    if (typeof r == "string" && (r = h.from(r, n)), h.isBuffer(r))
      return r.length === 0 ? -1 : ir2(i, r, t, n, e);
    if (typeof r == "number")
      return r = r & 255, typeof Uint8Array.prototype.indexOf == "function" ? e ? Uint8Array.prototype.indexOf.call(i, r, t) : Uint8Array.prototype.lastIndexOf.call(i, r, t) : ir2(i, [r], t, n, e);
    throw new TypeError("val must be string, number or Buffer");
  }
  function ir2(i, r, t, n, e) {
    let o2 = 1, u = i.length, f = r.length;
    if (n !== void 0 && (n = String(n).toLowerCase(), n === "ucs2" || n === "ucs-2" || n === "utf16le" || n === "utf-16le")) {
      if (i.length < 2 || r.length < 2)
        return -1;
      o2 = 2, u /= 2, f /= 2, t /= 2;
    }
    function c5(s, p3) {
      return o2 === 1 ? s[p3] : s.readUInt16BE(p3 * o2);
    }
    let l;
    if (e) {
      let s = -1;
      for (l = t; l < u; l++)
        if (c5(i, l) === c5(r, s === -1 ? 0 : l - s)) {
          if (s === -1 && (s = l), l - s + 1 === f)
            return s * o2;
        } else
          s !== -1 && (l -= l - s), s = -1;
    } else
      for (t + f > u && (t = u - f), l = t; l >= 0; l--) {
        let s = true;
        for (let p3 = 0; p3 < f; p3++)
          if (c5(i, l + p3) !== c5(r, p3)) {
            s = false;
            break;
          }
        if (s)
          return l;
      }
    return -1;
  }
  h.prototype.includes = function(r, t, n) {
    return this.indexOf(r, t, n) !== -1;
  };
  h.prototype.indexOf = function(r, t, n) {
    return tr(this, r, t, n, true);
  };
  h.prototype.lastIndexOf = function(r, t, n) {
    return tr(this, r, t, n, false);
  };
  function br(i, r, t, n) {
    t = Number(t) || 0;
    let e = i.length - t;
    n ? (n = Number(n), n > e && (n = e)) : n = e;
    let o2 = r.length;
    n > o2 / 2 && (n = o2 / 2);
    let u;
    for (u = 0; u < n; ++u) {
      let f = parseInt(r.substr(u * 2, 2), 16);
      if (j2(f))
        return u;
      i[t + u] = f;
    }
    return u;
  }
  function Dr(i, r, t, n) {
    return L4(W4(r, i.length - t), i, t, n);
  }
  function $r3(i, r, t, n) {
    return L4(Jr(r), i, t, n);
  }
  function Pr2(i, r, t, n) {
    return L4(lr(r), i, t, n);
  }
  function Or2(i, r, t, n) {
    return L4(Kr(r, i.length - t), i, t, n);
  }
  h.prototype.write = function(r, t, n, e) {
    if (t === void 0)
      e = "utf8", n = this.length, t = 0;
    else if (n === void 0 && typeof t == "string")
      e = t, n = this.length, t = 0;
    else if (isFinite(t))
      t = t >>> 0, isFinite(n) ? (n = n >>> 0, e === void 0 && (e = "utf8")) : (e = n, n = void 0);
    else
      throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");
    let o2 = this.length - t;
    if ((n === void 0 || n > o2) && (n = o2), r.length > 0 && (n < 0 || t < 0) || t > this.length)
      throw new RangeError("Attempt to write outside buffer bounds");
    e || (e = "utf8");
    let u = false;
    for (; ; )
      switch (e) {
        case "hex":
          return br(this, r, t, n);
        case "utf8":
        case "utf-8":
          return Dr(this, r, t, n);
        case "ascii":
        case "latin1":
        case "binary":
          return $r3(this, r, t, n);
        case "base64":
          return Pr2(this, r, t, n);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return Or2(this, r, t, n);
        default:
          if (u)
            throw new TypeError("Unknown encoding: " + e);
          e = ("" + e).toLowerCase(), u = true;
      }
  };
  h.prototype.toJSON = function() {
    return { type: "Buffer", data: Array.prototype.slice.call(this._arr || this, 0) };
  };
  function Gr2(i, r, t) {
    return r === 0 && t === i.length ? $4.fromByteArray(i) : $4.fromByteArray(i.slice(r, t));
  }
  function nr(i, r, t) {
    t = Math.min(i.length, t);
    let n = [], e = r;
    for (; e < t; ) {
      let o2 = i[e], u = null, f = o2 > 239 ? 4 : o2 > 223 ? 3 : o2 > 191 ? 2 : 1;
      if (e + f <= t) {
        let c5, l, s, p3;
        switch (f) {
          case 1:
            o2 < 128 && (u = o2);
            break;
          case 2:
            c5 = i[e + 1], (c5 & 192) == 128 && (p3 = (o2 & 31) << 6 | c5 & 63, p3 > 127 && (u = p3));
            break;
          case 3:
            c5 = i[e + 1], l = i[e + 2], (c5 & 192) == 128 && (l & 192) == 128 && (p3 = (o2 & 15) << 12 | (c5 & 63) << 6 | l & 63, p3 > 2047 && (p3 < 55296 || p3 > 57343) && (u = p3));
            break;
          case 4:
            c5 = i[e + 1], l = i[e + 2], s = i[e + 3], (c5 & 192) == 128 && (l & 192) == 128 && (s & 192) == 128 && (p3 = (o2 & 15) << 18 | (c5 & 63) << 12 | (l & 63) << 6 | s & 63, p3 > 65535 && p3 < 1114112 && (u = p3));
        }
      }
      u === null ? (u = 65533, f = 1) : u > 65535 && (u -= 65536, n.push(u >>> 10 & 1023 | 55296), u = 56320 | u & 1023), n.push(u), e += f;
    }
    return Yr2(n);
  }
  var er = 4096;
  function Yr2(i) {
    let r = i.length;
    if (r <= er)
      return String.fromCharCode.apply(String, i);
    let t = "", n = 0;
    for (; n < r; )
      t += String.fromCharCode.apply(String, i.slice(n, n += er));
    return t;
  }
  function qr2(i, r, t) {
    let n = "";
    t = Math.min(i.length, t);
    for (let e = r; e < t; ++e)
      n += String.fromCharCode(i[e] & 127);
    return n;
  }
  function Wr2(i, r, t) {
    let n = "";
    t = Math.min(i.length, t);
    for (let e = r; e < t; ++e)
      n += String.fromCharCode(i[e]);
    return n;
  }
  function jr3(i, r, t) {
    let n = i.length;
    (!r || r < 0) && (r = 0), (!t || t < 0 || t > n) && (t = n);
    let e = "";
    for (let o2 = r; o2 < t; ++o2)
      e += Zr3[i[o2]];
    return e;
  }
  function Xr2(i, r, t) {
    let n = i.slice(r, t), e = "";
    for (let o2 = 0; o2 < n.length - 1; o2 += 2)
      e += String.fromCharCode(n[o2] + n[o2 + 1] * 256);
    return e;
  }
  h.prototype.slice = function(r, t) {
    let n = this.length;
    r = ~~r, t = t === void 0 ? n : ~~t, r < 0 ? (r += n, r < 0 && (r = 0)) : r > n && (r = n), t < 0 ? (t += n, t < 0 && (t = 0)) : t > n && (t = n), t < r && (t = r);
    let e = this.subarray(r, t);
    return Object.setPrototypeOf(e, h.prototype), e;
  };
  function a(i, r, t) {
    if (i % 1 != 0 || i < 0)
      throw new RangeError("offset is not uint");
    if (i + r > t)
      throw new RangeError("Trying to access beyond buffer length");
  }
  h.prototype.readUintLE = h.prototype.readUIntLE = function(r, t, n) {
    r = r >>> 0, t = t >>> 0, n || a(r, t, this.length);
    let e = this[r], o2 = 1, u = 0;
    for (; ++u < t && (o2 *= 256); )
      e += this[r + u] * o2;
    return e;
  };
  h.prototype.readUintBE = h.prototype.readUIntBE = function(r, t, n) {
    r = r >>> 0, t = t >>> 0, n || a(r, t, this.length);
    let e = this[r + --t], o2 = 1;
    for (; t > 0 && (o2 *= 256); )
      e += this[r + --t] * o2;
    return e;
  };
  h.prototype.readUint8 = h.prototype.readUInt8 = function(r, t) {
    return r = r >>> 0, t || a(r, 1, this.length), this[r];
  };
  h.prototype.readUint16LE = h.prototype.readUInt16LE = function(r, t) {
    return r = r >>> 0, t || a(r, 2, this.length), this[r] | this[r + 1] << 8;
  };
  h.prototype.readUint16BE = h.prototype.readUInt16BE = function(r, t) {
    return r = r >>> 0, t || a(r, 2, this.length), this[r] << 8 | this[r + 1];
  };
  h.prototype.readUint32LE = h.prototype.readUInt32LE = function(r, t) {
    return r = r >>> 0, t || a(r, 4, this.length), (this[r] | this[r + 1] << 8 | this[r + 2] << 16) + this[r + 3] * 16777216;
  };
  h.prototype.readUint32BE = h.prototype.readUInt32BE = function(r, t) {
    return r = r >>> 0, t || a(r, 4, this.length), this[r] * 16777216 + (this[r + 1] << 16 | this[r + 2] << 8 | this[r + 3]);
  };
  h.prototype.readBigUInt64LE = g2(function(r) {
    r = r >>> 0, T4(r, "offset");
    let t = this[r], n = this[r + 7];
    (t === void 0 || n === void 0) && C(r, this.length - 8);
    let e = t + this[++r] * 2 ** 8 + this[++r] * 2 ** 16 + this[++r] * 2 ** 24, o2 = this[++r] + this[++r] * 2 ** 8 + this[++r] * 2 ** 16 + n * 2 ** 24;
    return BigInt(e) + (BigInt(o2) << BigInt(32));
  });
  h.prototype.readBigUInt64BE = g2(function(r) {
    r = r >>> 0, T4(r, "offset");
    let t = this[r], n = this[r + 7];
    (t === void 0 || n === void 0) && C(r, this.length - 8);
    let e = t * 2 ** 24 + this[++r] * 2 ** 16 + this[++r] * 2 ** 8 + this[++r], o2 = this[++r] * 2 ** 24 + this[++r] * 2 ** 16 + this[++r] * 2 ** 8 + n;
    return (BigInt(e) << BigInt(32)) + BigInt(o2);
  });
  h.prototype.readIntLE = function(r, t, n) {
    r = r >>> 0, t = t >>> 0, n || a(r, t, this.length);
    let e = this[r], o2 = 1, u = 0;
    for (; ++u < t && (o2 *= 256); )
      e += this[r + u] * o2;
    return o2 *= 128, e >= o2 && (e -= Math.pow(2, 8 * t)), e;
  };
  h.prototype.readIntBE = function(r, t, n) {
    r = r >>> 0, t = t >>> 0, n || a(r, t, this.length);
    let e = t, o2 = 1, u = this[r + --e];
    for (; e > 0 && (o2 *= 256); )
      u += this[r + --e] * o2;
    return o2 *= 128, u >= o2 && (u -= Math.pow(2, 8 * t)), u;
  };
  h.prototype.readInt8 = function(r, t) {
    return r = r >>> 0, t || a(r, 1, this.length), this[r] & 128 ? (255 - this[r] + 1) * -1 : this[r];
  };
  h.prototype.readInt16LE = function(r, t) {
    r = r >>> 0, t || a(r, 2, this.length);
    let n = this[r] | this[r + 1] << 8;
    return n & 32768 ? n | 4294901760 : n;
  };
  h.prototype.readInt16BE = function(r, t) {
    r = r >>> 0, t || a(r, 2, this.length);
    let n = this[r + 1] | this[r] << 8;
    return n & 32768 ? n | 4294901760 : n;
  };
  h.prototype.readInt32LE = function(r, t) {
    return r = r >>> 0, t || a(r, 4, this.length), this[r] | this[r + 1] << 8 | this[r + 2] << 16 | this[r + 3] << 24;
  };
  h.prototype.readInt32BE = function(r, t) {
    return r = r >>> 0, t || a(r, 4, this.length), this[r] << 24 | this[r + 1] << 16 | this[r + 2] << 8 | this[r + 3];
  };
  h.prototype.readBigInt64LE = g2(function(r) {
    r = r >>> 0, T4(r, "offset");
    let t = this[r], n = this[r + 7];
    (t === void 0 || n === void 0) && C(r, this.length - 8);
    let e = this[r + 4] + this[r + 5] * 2 ** 8 + this[r + 6] * 2 ** 16 + (n << 24);
    return (BigInt(e) << BigInt(32)) + BigInt(t + this[++r] * 2 ** 8 + this[++r] * 2 ** 16 + this[++r] * 2 ** 24);
  });
  h.prototype.readBigInt64BE = g2(function(r) {
    r = r >>> 0, T4(r, "offset");
    let t = this[r], n = this[r + 7];
    (t === void 0 || n === void 0) && C(r, this.length - 8);
    let e = (t << 24) + this[++r] * 2 ** 16 + this[++r] * 2 ** 8 + this[++r];
    return (BigInt(e) << BigInt(32)) + BigInt(this[++r] * 2 ** 24 + this[++r] * 2 ** 16 + this[++r] * 2 ** 8 + n);
  });
  h.prototype.readFloatLE = function(r, t) {
    return r = r >>> 0, t || a(r, 4, this.length), A4.read(this, r, true, 23, 4);
  };
  h.prototype.readFloatBE = function(r, t) {
    return r = r >>> 0, t || a(r, 4, this.length), A4.read(this, r, false, 23, 4);
  };
  h.prototype.readDoubleLE = function(r, t) {
    return r = r >>> 0, t || a(r, 8, this.length), A4.read(this, r, true, 52, 8);
  };
  h.prototype.readDoubleBE = function(r, t) {
    return r = r >>> 0, t || a(r, 8, this.length), A4.read(this, r, false, 52, 8);
  };
  function y4(i, r, t, n, e, o2) {
    if (!h.isBuffer(i))
      throw new TypeError('"buffer" argument must be a Buffer instance');
    if (r > e || r < o2)
      throw new RangeError('"value" argument is out of bounds');
    if (t + n > i.length)
      throw new RangeError("Index out of range");
  }
  h.prototype.writeUintLE = h.prototype.writeUIntLE = function(r, t, n, e) {
    if (r = +r, t = t >>> 0, n = n >>> 0, !e) {
      let f = Math.pow(2, 8 * n) - 1;
      y4(this, r, t, n, f, 0);
    }
    let o2 = 1, u = 0;
    for (this[t] = r & 255; ++u < n && (o2 *= 256); )
      this[t + u] = r / o2 & 255;
    return t + n;
  };
  h.prototype.writeUintBE = h.prototype.writeUIntBE = function(r, t, n, e) {
    if (r = +r, t = t >>> 0, n = n >>> 0, !e) {
      let f = Math.pow(2, 8 * n) - 1;
      y4(this, r, t, n, f, 0);
    }
    let o2 = n - 1, u = 1;
    for (this[t + o2] = r & 255; --o2 >= 0 && (u *= 256); )
      this[t + o2] = r / u & 255;
    return t + n;
  };
  h.prototype.writeUint8 = h.prototype.writeUInt8 = function(r, t, n) {
    return r = +r, t = t >>> 0, n || y4(this, r, t, 1, 255, 0), this[t] = r & 255, t + 1;
  };
  h.prototype.writeUint16LE = h.prototype.writeUInt16LE = function(r, t, n) {
    return r = +r, t = t >>> 0, n || y4(this, r, t, 2, 65535, 0), this[t] = r & 255, this[t + 1] = r >>> 8, t + 2;
  };
  h.prototype.writeUint16BE = h.prototype.writeUInt16BE = function(r, t, n) {
    return r = +r, t = t >>> 0, n || y4(this, r, t, 2, 65535, 0), this[t] = r >>> 8, this[t + 1] = r & 255, t + 2;
  };
  h.prototype.writeUint32LE = h.prototype.writeUInt32LE = function(r, t, n) {
    return r = +r, t = t >>> 0, n || y4(this, r, t, 4, 4294967295, 0), this[t + 3] = r >>> 24, this[t + 2] = r >>> 16, this[t + 1] = r >>> 8, this[t] = r & 255, t + 4;
  };
  h.prototype.writeUint32BE = h.prototype.writeUInt32BE = function(r, t, n) {
    return r = +r, t = t >>> 0, n || y4(this, r, t, 4, 4294967295, 0), this[t] = r >>> 24, this[t + 1] = r >>> 16, this[t + 2] = r >>> 8, this[t + 3] = r & 255, t + 4;
  };
  function or2(i, r, t, n, e) {
    sr(r, n, e, i, t, 7);
    let o2 = Number(r & BigInt(4294967295));
    i[t++] = o2, o2 = o2 >> 8, i[t++] = o2, o2 = o2 >> 8, i[t++] = o2, o2 = o2 >> 8, i[t++] = o2;
    let u = Number(r >> BigInt(32) & BigInt(4294967295));
    return i[t++] = u, u = u >> 8, i[t++] = u, u = u >> 8, i[t++] = u, u = u >> 8, i[t++] = u, t;
  }
  function ur2(i, r, t, n, e) {
    sr(r, n, e, i, t, 7);
    let o2 = Number(r & BigInt(4294967295));
    i[t + 7] = o2, o2 = o2 >> 8, i[t + 6] = o2, o2 = o2 >> 8, i[t + 5] = o2, o2 = o2 >> 8, i[t + 4] = o2;
    let u = Number(r >> BigInt(32) & BigInt(4294967295));
    return i[t + 3] = u, u = u >> 8, i[t + 2] = u, u = u >> 8, i[t + 1] = u, u = u >> 8, i[t] = u, t + 8;
  }
  h.prototype.writeBigUInt64LE = g2(function(r, t = 0) {
    return or2(this, r, t, BigInt(0), BigInt("0xffffffffffffffff"));
  });
  h.prototype.writeBigUInt64BE = g2(function(r, t = 0) {
    return ur2(this, r, t, BigInt(0), BigInt("0xffffffffffffffff"));
  });
  h.prototype.writeIntLE = function(r, t, n, e) {
    if (r = +r, t = t >>> 0, !e) {
      let c5 = Math.pow(2, 8 * n - 1);
      y4(this, r, t, n, c5 - 1, -c5);
    }
    let o2 = 0, u = 1, f = 0;
    for (this[t] = r & 255; ++o2 < n && (u *= 256); )
      r < 0 && f === 0 && this[t + o2 - 1] !== 0 && (f = 1), this[t + o2] = (r / u >> 0) - f & 255;
    return t + n;
  };
  h.prototype.writeIntBE = function(r, t, n, e) {
    if (r = +r, t = t >>> 0, !e) {
      let c5 = Math.pow(2, 8 * n - 1);
      y4(this, r, t, n, c5 - 1, -c5);
    }
    let o2 = n - 1, u = 1, f = 0;
    for (this[t + o2] = r & 255; --o2 >= 0 && (u *= 256); )
      r < 0 && f === 0 && this[t + o2 + 1] !== 0 && (f = 1), this[t + o2] = (r / u >> 0) - f & 255;
    return t + n;
  };
  h.prototype.writeInt8 = function(r, t, n) {
    return r = +r, t = t >>> 0, n || y4(this, r, t, 1, 127, -128), r < 0 && (r = 255 + r + 1), this[t] = r & 255, t + 1;
  };
  h.prototype.writeInt16LE = function(r, t, n) {
    return r = +r, t = t >>> 0, n || y4(this, r, t, 2, 32767, -32768), this[t] = r & 255, this[t + 1] = r >>> 8, t + 2;
  };
  h.prototype.writeInt16BE = function(r, t, n) {
    return r = +r, t = t >>> 0, n || y4(this, r, t, 2, 32767, -32768), this[t] = r >>> 8, this[t + 1] = r & 255, t + 2;
  };
  h.prototype.writeInt32LE = function(r, t, n) {
    return r = +r, t = t >>> 0, n || y4(this, r, t, 4, 2147483647, -2147483648), this[t] = r & 255, this[t + 1] = r >>> 8, this[t + 2] = r >>> 16, this[t + 3] = r >>> 24, t + 4;
  };
  h.prototype.writeInt32BE = function(r, t, n) {
    return r = +r, t = t >>> 0, n || y4(this, r, t, 4, 2147483647, -2147483648), r < 0 && (r = 4294967295 + r + 1), this[t] = r >>> 24, this[t + 1] = r >>> 16, this[t + 2] = r >>> 8, this[t + 3] = r & 255, t + 4;
  };
  h.prototype.writeBigInt64LE = g2(function(r, t = 0) {
    return or2(this, r, t, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
  });
  h.prototype.writeBigInt64BE = g2(function(r, t = 0) {
    return ur2(this, r, t, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
  });
  function hr(i, r, t, n, e, o2) {
    if (t + n > i.length)
      throw new RangeError("Index out of range");
    if (t < 0)
      throw new RangeError("Index out of range");
  }
  function fr(i, r, t, n, e) {
    return r = +r, t = t >>> 0, e || hr(i, r, t, 4, 34028234663852886e22, -34028234663852886e22), A4.write(i, r, t, n, 23, 4), t + 4;
  }
  h.prototype.writeFloatLE = function(r, t, n) {
    return fr(this, r, t, true, n);
  };
  h.prototype.writeFloatBE = function(r, t, n) {
    return fr(this, r, t, false, n);
  };
  function cr(i, r, t, n, e) {
    return r = +r, t = t >>> 0, e || hr(i, r, t, 8, 17976931348623157e292, -17976931348623157e292), A4.write(i, r, t, n, 52, 8), t + 8;
  }
  h.prototype.writeDoubleLE = function(r, t, n) {
    return cr(this, r, t, true, n);
  };
  h.prototype.writeDoubleBE = function(r, t, n) {
    return cr(this, r, t, false, n);
  };
  h.prototype.copy = function(r, t, n, e) {
    if (!h.isBuffer(r))
      throw new TypeError("argument should be a Buffer");
    if (n || (n = 0), !e && e !== 0 && (e = this.length), t >= r.length && (t = r.length), t || (t = 0), e > 0 && e < n && (e = n), e === n || r.length === 0 || this.length === 0)
      return 0;
    if (t < 0)
      throw new RangeError("targetStart out of bounds");
    if (n < 0 || n >= this.length)
      throw new RangeError("Index out of range");
    if (e < 0)
      throw new RangeError("sourceEnd out of bounds");
    e > this.length && (e = this.length), r.length - t < e - n && (e = r.length - t + n);
    let o2 = e - n;
    return this === r && typeof Uint8Array.prototype.copyWithin == "function" ? this.copyWithin(t, n, e) : Uint8Array.prototype.set.call(r, this.subarray(n, e), t), o2;
  };
  h.prototype.fill = function(r, t, n, e) {
    if (typeof r == "string") {
      if (typeof t == "string" ? (e = t, t = 0, n = this.length) : typeof n == "string" && (e = n, n = this.length), e !== void 0 && typeof e != "string")
        throw new TypeError("encoding must be a string");
      if (typeof e == "string" && !h.isEncoding(e))
        throw new TypeError("Unknown encoding: " + e);
      if (r.length === 1) {
        let u = r.charCodeAt(0);
        (e === "utf8" && u < 128 || e === "latin1") && (r = u);
      }
    } else
      typeof r == "number" ? r = r & 255 : typeof r == "boolean" && (r = Number(r));
    if (t < 0 || this.length < t || this.length < n)
      throw new RangeError("Out of range index");
    if (n <= t)
      return this;
    t = t >>> 0, n = n === void 0 ? this.length : n >>> 0, r || (r = 0);
    let o2;
    if (typeof r == "number")
      for (o2 = t; o2 < n; ++o2)
        this[o2] = r;
    else {
      let u = h.isBuffer(r) ? r : h.from(r, e), f = u.length;
      if (f === 0)
        throw new TypeError('The value "' + r + '" is invalid for argument "value"');
      for (o2 = 0; o2 < n - t; ++o2)
        this[o2 + t] = u[o2 % f];
    }
    return this;
  };
  var U2 = {};
  function q(i, r, t) {
    U2[i] = class extends t {
      constructor() {
        super();
        Object.defineProperty(this, "message", { value: r.apply(this, arguments), writable: true, configurable: true }), this.name = `${this.name} [${i}]`, this.stack, delete this.name;
      }
      get code() {
        return i;
      }
      set code(e) {
        Object.defineProperty(this, "code", { configurable: true, enumerable: true, value: e, writable: true });
      }
      toString() {
        return `${this.name} [${i}]: ${this.message}`;
      }
    };
  }
  q("ERR_BUFFER_OUT_OF_BOUNDS", function(i) {
    return i ? `${i} is outside of buffer bounds` : "Attempt to access memory outside buffer bounds";
  }, RangeError);
  q("ERR_INVALID_ARG_TYPE", function(i, r) {
    return `The "${i}" argument must be of type number. Received type ${typeof r}`;
  }, TypeError);
  q("ERR_OUT_OF_RANGE", function(i, r, t) {
    let n = `The value of "${i}" is out of range.`, e = t;
    return Number.isInteger(t) && Math.abs(t) > 2 ** 32 ? e = pr2(String(t)) : typeof t == "bigint" && (e = String(t), (t > BigInt(2) ** BigInt(32) || t < -(BigInt(2) ** BigInt(32))) && (e = pr2(e)), e += "n"), n += ` It must be ${r}. Received ${e}`, n;
  }, RangeError);
  function pr2(i) {
    let r = "", t = i.length, n = i[0] === "-" ? 1 : 0;
    for (; t >= n + 4; t -= 3)
      r = `_${i.slice(t - 3, t)}${r}`;
    return `${i.slice(0, t)}${r}`;
  }
  function Hr(i, r, t) {
    T4(r, "offset"), (i[r] === void 0 || i[r + t] === void 0) && C(r, i.length - (t + 1));
  }
  function sr(i, r, t, n, e, o2) {
    if (i > t || i < r) {
      let u = typeof r == "bigint" ? "n" : "", f;
      throw o2 > 3 ? r === 0 || r === BigInt(0) ? f = `>= 0${u} and < 2${u} ** ${(o2 + 1) * 8}${u}` : f = `>= -(2${u} ** ${(o2 + 1) * 8 - 1}${u}) and < 2 ** ${(o2 + 1) * 8 - 1}${u}` : f = `>= ${r}${u} and <= ${t}${u}`, new U2.ERR_OUT_OF_RANGE("value", f, i);
    }
    Hr(n, e, o2);
  }
  function T4(i, r) {
    if (typeof i != "number")
      throw new U2.ERR_INVALID_ARG_TYPE(r, "number", i);
  }
  function C(i, r, t) {
    throw Math.floor(i) !== i ? (T4(i, t), new U2.ERR_OUT_OF_RANGE(t || "offset", "an integer", i)) : r < 0 ? new U2.ERR_BUFFER_OUT_OF_BOUNDS() : new U2.ERR_OUT_OF_RANGE(t || "offset", `>= ${t ? 1 : 0} and <= ${r}`, i);
  }
  var Vr2 = /[^+/0-9A-Za-z-_]/g;
  function zr(i) {
    if (i = i.split("=")[0], i = i.trim().replace(Vr2, ""), i.length < 2)
      return "";
    for (; i.length % 4 != 0; )
      i = i + "=";
    return i;
  }
  function W4(i, r) {
    r = r || 1 / 0;
    let t, n = i.length, e = null, o2 = [];
    for (let u = 0; u < n; ++u) {
      if (t = i.charCodeAt(u), t > 55295 && t < 57344) {
        if (!e) {
          if (t > 56319) {
            (r -= 3) > -1 && o2.push(239, 191, 189);
            continue;
          } else if (u + 1 === n) {
            (r -= 3) > -1 && o2.push(239, 191, 189);
            continue;
          }
          e = t;
          continue;
        }
        if (t < 56320) {
          (r -= 3) > -1 && o2.push(239, 191, 189), e = t;
          continue;
        }
        t = (e - 55296 << 10 | t - 56320) + 65536;
      } else
        e && (r -= 3) > -1 && o2.push(239, 191, 189);
      if (e = null, t < 128) {
        if ((r -= 1) < 0)
          break;
        o2.push(t);
      } else if (t < 2048) {
        if ((r -= 2) < 0)
          break;
        o2.push(t >> 6 | 192, t & 63 | 128);
      } else if (t < 65536) {
        if ((r -= 3) < 0)
          break;
        o2.push(t >> 12 | 224, t >> 6 & 63 | 128, t & 63 | 128);
      } else if (t < 1114112) {
        if ((r -= 4) < 0)
          break;
        o2.push(t >> 18 | 240, t >> 12 & 63 | 128, t >> 6 & 63 | 128, t & 63 | 128);
      } else
        throw new Error("Invalid code point");
    }
    return o2;
  }
  function Jr(i) {
    let r = [];
    for (let t = 0; t < i.length; ++t)
      r.push(i.charCodeAt(t) & 255);
    return r;
  }
  function Kr(i, r) {
    let t, n, e, o2 = [];
    for (let u = 0; u < i.length && !((r -= 2) < 0); ++u)
      t = i.charCodeAt(u), n = t >> 8, e = t % 256, o2.push(e), o2.push(n);
    return o2;
  }
  function lr(i) {
    return $4.toByteArray(zr(i));
  }
  function L4(i, r, t, n) {
    let e;
    for (e = 0; e < n && !(e + t >= r.length || e >= i.length); ++e)
      r[e + t] = i[e];
    return e;
  }
  function E2(i, r) {
    return i instanceof r || i != null && i.constructor != null && i.constructor.name != null && i.constructor.name === r.name;
  }
  function j2(i) {
    return i !== i;
  }
  var Zr3 = function() {
    let i = "0123456789abcdef", r = new Array(256);
    for (let t = 0; t < 16; ++t) {
      let n = t * 16;
      for (let e = 0; e < 16; ++e)
        r[n + e] = i[t] + i[e];
    }
    return r;
  }();
  function g2(i) {
    return typeof BigInt == "undefined" ? Qr2 : i;
  }
  function Qr2() {
    throw new Error("BigInt not supported");
  }
});
var vr = H(X());
var rt = H(X());
var { Buffer: ut, SlowBuffer: ht, INSPECT_MAX_BYTES: ft, kMaxLength: ct } = vr;
var export_default = rt.default;

// deno:https://esm.sh/v86/crypto-browserify@3.12.0/deno/crypto-browserify.bundle.js
var __global$ = globalThis || (typeof window !== "undefined" ? window : self);
var __setImmediate$ = (cb, ...args) => setTimeout(cb, 0, ...args);
var p1 = Object.create;
var Ls = Object.defineProperty;
var b1 = Object.getOwnPropertyDescriptor;
var m1 = Object.getOwnPropertyNames;
var g1 = Object.getPrototypeOf;
var y1 = Object.prototype.hasOwnProperty;
var Ke = ((t) => typeof require != "undefined" ? require : typeof Proxy != "undefined" ? new Proxy(t, { get: (e, r) => (typeof require != "undefined" ? require : e)[r] }) : t)(function(t) {
  if (typeof require != "undefined")
    return require.apply(this, arguments);
  throw new Error('Dynamic require of "' + t + '" is not supported');
});
var k2 = (t, e) => () => (e || t((e = { exports: {} }).exports, e), e.exports);
var _1 = (t, e, r, n) => {
  if (e && typeof e == "object" || typeof e == "function")
    for (let i of m1(e))
      !y1.call(t, i) && i !== r && Ls(t, i, { get: () => e[i], enumerable: !(n = b1(e, i)) || n.enumerable });
  return t;
};
var Os = (t, e, r) => (r = t != null ? p1(g1(t)) : {}, _1(e || !t || !t.__esModule ? Ls(r, "default", { value: t, enumerable: true }) : r, t));
var Ae = k2((ya, Us) => {
  var Gf = export_default, er = Gf.Buffer;
  function zs(t, e) {
    for (var r in t)
      e[r] = t[r];
  }
  er.from && er.alloc && er.allocUnsafe && er.allocUnsafeSlow ? Us.exports = Gf : (zs(Gf, ya), ya.Buffer = ii);
  function ii(t, e, r) {
    return er(t, e, r);
  }
  ii.prototype = Object.create(er.prototype);
  zs(er, ii);
  ii.from = function(t, e, r) {
    if (typeof t == "number")
      throw new TypeError("Argument must not be a number");
    return er(t, e, r);
  };
  ii.alloc = function(t, e, r) {
    if (typeof t != "number")
      throw new TypeError("Argument must be a number");
    var n = er(t);
    return e !== void 0 ? typeof r == "string" ? n.fill(e, r) : n.fill(e) : n.fill(0), n;
  };
  ii.allocUnsafe = function(t) {
    if (typeof t != "number")
      throw new TypeError("Argument must be a number");
    return er(t);
  };
  ii.allocUnsafeSlow = function(t) {
    if (typeof t != "number")
      throw new TypeError("Argument must be a number");
    return Gf.SlowBuffer(t);
  };
});
var fi = k2((U82, wa) => {
  "use strict";
  var _a3 = 65536, w12 = 4294967295;
  function x12() {
    throw new Error(`Secure random number generation is not supported by this browser.
Use Chrome, Firefox or Internet Explorer 11`);
  }
  var M1 = Ae().Buffer, Xf = __global$.crypto || __global$.msCrypto;
  Xf && Xf.getRandomValues ? wa.exports = S1 : wa.exports = x12;
  function S1(t, e) {
    if (t > w12)
      throw new RangeError("requested too many random bytes");
    var r = M1.allocUnsafe(t);
    if (t > 0)
      if (t > _a3)
        for (var n = 0; n < t; n += _a3)
          Xf.getRandomValues(r.slice(n, n + _a3));
      else
        Xf.getRandomValues(r);
    return typeof e == "function" ? process_default.nextTick(function() {
      e(null, r);
    }) : r;
  }
});
var qe = k2((H8, xa) => {
  typeof Object.create == "function" ? xa.exports = function(e, r) {
    r && (e.super_ = r, e.prototype = Object.create(r.prototype, { constructor: { value: e, enumerable: false, writable: true, configurable: true } }));
  } : xa.exports = function(e, r) {
    if (r) {
      e.super_ = r;
      var n = function() {
      };
      n.prototype = r.prototype, e.prototype = new n(), e.prototype.constructor = e;
    }
  };
});
var Ma = k2((F8, Hs) => {
  Hs.exports = events_default.EventEmitter;
});
var Ws = k2((K8, js) => {
  "use strict";
  function Fs(t, e) {
    var r = Object.keys(t);
    if (Object.getOwnPropertySymbols) {
      var n = Object.getOwnPropertySymbols(t);
      e && (n = n.filter(function(i) {
        return Object.getOwnPropertyDescriptor(t, i).enumerable;
      })), r.push.apply(r, n);
    }
    return r;
  }
  function E1(t) {
    for (var e = 1; e < arguments.length; e++) {
      var r = arguments[e] != null ? arguments[e] : {};
      e % 2 ? Fs(Object(r), true).forEach(function(n) {
        A1(t, n, r[n]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(r)) : Fs(Object(r)).forEach(function(n) {
        Object.defineProperty(t, n, Object.getOwnPropertyDescriptor(r, n));
      });
    }
    return t;
  }
  function A1(t, e, r) {
    return e in t ? Object.defineProperty(t, e, { value: r, enumerable: true, configurable: true, writable: true }) : t[e] = r, t;
  }
  function q1(t, e) {
    if (!(t instanceof e))
      throw new TypeError("Cannot call a class as a function");
  }
  function Ks(t, e) {
    for (var r = 0; r < e.length; r++) {
      var n = e[r];
      n.enumerable = n.enumerable || false, n.configurable = true, "value" in n && (n.writable = true), Object.defineProperty(t, n.key, n);
    }
  }
  function B1(t, e, r) {
    return e && Ks(t.prototype, e), r && Ks(t, r), t;
  }
  var R1 = export_default, Yf = R1.Buffer, I1 = util_default, Sa = I1.inspect, k1 = Sa && Sa.custom || "inspect";
  function D1(t, e, r) {
    Yf.prototype.copy.call(t, e, r);
  }
  js.exports = function() {
    function t() {
      q1(this, t), this.head = null, this.tail = null, this.length = 0;
    }
    return B1(t, [{ key: "push", value: function(r) {
      var n = { data: r, next: null };
      this.length > 0 ? this.tail.next = n : this.head = n, this.tail = n, ++this.length;
    } }, { key: "unshift", value: function(r) {
      var n = { data: r, next: this.head };
      this.length === 0 && (this.tail = n), this.head = n, ++this.length;
    } }, { key: "shift", value: function() {
      if (this.length !== 0) {
        var r = this.head.data;
        return this.length === 1 ? this.head = this.tail = null : this.head = this.head.next, --this.length, r;
      }
    } }, { key: "clear", value: function() {
      this.head = this.tail = null, this.length = 0;
    } }, { key: "join", value: function(r) {
      if (this.length === 0)
        return "";
      for (var n = this.head, i = "" + n.data; n = n.next; )
        i += r + n.data;
      return i;
    } }, { key: "concat", value: function(r) {
      if (this.length === 0)
        return Yf.alloc(0);
      for (var n = Yf.allocUnsafe(r >>> 0), i = this.head, o2 = 0; i; )
        D1(i.data, n, o2), o2 += i.data.length, i = i.next;
      return n;
    } }, { key: "consume", value: function(r, n) {
      var i;
      return r < this.head.data.length ? (i = this.head.data.slice(0, r), this.head.data = this.head.data.slice(r)) : r === this.head.data.length ? i = this.shift() : i = n ? this._getString(r) : this._getBuffer(r), i;
    } }, { key: "first", value: function() {
      return this.head.data;
    } }, { key: "_getString", value: function(r) {
      var n = this.head, i = 1, o2 = n.data;
      for (r -= o2.length; n = n.next; ) {
        var p3 = n.data, y4 = r > p3.length ? p3.length : r;
        if (y4 === p3.length ? o2 += p3 : o2 += p3.slice(0, r), r -= y4, r === 0) {
          y4 === p3.length ? (++i, n.next ? this.head = n.next : this.head = this.tail = null) : (this.head = n, n.data = p3.slice(y4));
          break;
        }
        ++i;
      }
      return this.length -= i, o2;
    } }, { key: "_getBuffer", value: function(r) {
      var n = Yf.allocUnsafe(r), i = this.head, o2 = 1;
      for (i.data.copy(n), r -= i.data.length; i = i.next; ) {
        var p3 = i.data, y4 = r > p3.length ? p3.length : r;
        if (p3.copy(n, n.length - r, 0, y4), r -= y4, r === 0) {
          y4 === p3.length ? (++o2, i.next ? this.head = i.next : this.head = this.tail = null) : (this.head = i, i.data = p3.slice(y4));
          break;
        }
        ++o2;
      }
      return this.length -= o2, n;
    } }, { key: k1, value: function(r, n) {
      return Sa(this, E1({}, n, { depth: 0, customInspect: false }));
    } }]), t;
  }();
});
var Aa = k2((j8, Zs) => {
  "use strict";
  function P1(t, e) {
    var r = this, n = this._readableState && this._readableState.destroyed, i = this._writableState && this._writableState.destroyed;
    return n || i ? (e ? e(t) : t && (this._writableState ? this._writableState.errorEmitted || (this._writableState.errorEmitted = true, process_default.nextTick(Ea, this, t)) : process_default.nextTick(Ea, this, t)), this) : (this._readableState && (this._readableState.destroyed = true), this._writableState && (this._writableState.destroyed = true), this._destroy(t || null, function(o2) {
      !e && o2 ? r._writableState ? r._writableState.errorEmitted ? process_default.nextTick(Jf, r) : (r._writableState.errorEmitted = true, process_default.nextTick(Vs, r, o2)) : process_default.nextTick(Vs, r, o2) : e ? (process_default.nextTick(Jf, r), e(o2)) : process_default.nextTick(Jf, r);
    }), this);
  }
  function Vs(t, e) {
    Ea(t, e), Jf(t);
  }
  function Jf(t) {
    t._writableState && !t._writableState.emitClose || t._readableState && !t._readableState.emitClose || t.emit("close");
  }
  function T1() {
    this._readableState && (this._readableState.destroyed = false, this._readableState.reading = false, this._readableState.ended = false, this._readableState.endEmitted = false), this._writableState && (this._writableState.destroyed = false, this._writableState.ended = false, this._writableState.ending = false, this._writableState.finalCalled = false, this._writableState.prefinished = false, this._writableState.finished = false, this._writableState.errorEmitted = false);
  }
  function Ea(t, e) {
    t.emit("error", e);
  }
  function C1(t, e) {
    var r = t._readableState, n = t._writableState;
    r && r.autoDestroy || n && n.autoDestroy ? t.destroy(e) : t.emit("error", e);
  }
  Zs.exports = { destroy: P1, undestroy: T1, errorOrDestroy: C1 };
});
var ni = k2((W8, Ys) => {
  "use strict";
  function N1(t, e) {
    t.prototype = Object.create(e.prototype), t.prototype.constructor = t, t.__proto__ = e;
  }
  var Xs = {};
  function ct4(t, e, r) {
    r || (r = Error);
    function n(o2, p3, y4) {
      return typeof e == "string" ? e : e(o2, p3, y4);
    }
    var i = function(o2) {
      N1(p3, o2);
      function p3(y4, w2, x) {
        return o2.call(this, n(y4, w2, x)) || this;
      }
      return p3;
    }(r);
    i.prototype.name = r.name, i.prototype.code = t, Xs[t] = i;
  }
  function Gs(t, e) {
    if (Array.isArray(t)) {
      var r = t.length;
      return t = t.map(function(n) {
        return String(n);
      }), r > 2 ? "one of ".concat(e, " ").concat(t.slice(0, r - 1).join(", "), ", or ") + t[r - 1] : r === 2 ? "one of ".concat(e, " ").concat(t[0], " or ").concat(t[1]) : "of ".concat(e, " ").concat(t[0]);
    } else
      return "of ".concat(e, " ").concat(String(t));
  }
  function L1(t, e, r) {
    return t.substr(!r || r < 0 ? 0 : +r, e.length) === e;
  }
  function O1(t, e, r) {
    return (r === void 0 || r > t.length) && (r = t.length), t.substring(r - e.length, r) === e;
  }
  function z1(t, e, r) {
    return typeof r != "number" && (r = 0), r + e.length > t.length ? false : t.indexOf(e, r) !== -1;
  }
  ct4("ERR_INVALID_OPT_VALUE", function(t, e) {
    return 'The value "' + e + '" is invalid for option "' + t + '"';
  }, TypeError);
  ct4("ERR_INVALID_ARG_TYPE", function(t, e, r) {
    var n;
    typeof e == "string" && L1(e, "not ") ? (n = "must not be", e = e.replace(/^not /, "")) : n = "must be";
    var i;
    if (O1(t, " argument"))
      i = "The ".concat(t, " ").concat(n, " ").concat(Gs(e, "type"));
    else {
      var o2 = z1(t, ".") ? "property" : "argument";
      i = 'The "'.concat(t, '" ').concat(o2, " ").concat(n, " ").concat(Gs(e, "type"));
    }
    return i += ". Received type ".concat(typeof r), i;
  }, TypeError);
  ct4("ERR_STREAM_PUSH_AFTER_EOF", "stream.push() after EOF");
  ct4("ERR_METHOD_NOT_IMPLEMENTED", function(t) {
    return "The " + t + " method is not implemented";
  });
  ct4("ERR_STREAM_PREMATURE_CLOSE", "Premature close");
  ct4("ERR_STREAM_DESTROYED", function(t) {
    return "Cannot call " + t + " after a stream was destroyed";
  });
  ct4("ERR_MULTIPLE_CALLBACK", "Callback called multiple times");
  ct4("ERR_STREAM_CANNOT_PIPE", "Cannot pipe, not readable");
  ct4("ERR_STREAM_WRITE_AFTER_END", "write after end");
  ct4("ERR_STREAM_NULL_VALUES", "May not write null values to stream", TypeError);
  ct4("ERR_UNKNOWN_ENCODING", function(t) {
    return "Unknown encoding: " + t;
  }, TypeError);
  ct4("ERR_STREAM_UNSHIFT_AFTER_END_EVENT", "stream.unshift() after end event");
  Ys.exports.codes = Xs;
});
var qa = k2((V8, Js) => {
  "use strict";
  var U1 = ni().codes.ERR_INVALID_OPT_VALUE;
  function H1(t, e, r) {
    return t.highWaterMark != null ? t.highWaterMark : e ? t[r] : null;
  }
  function F1(t, e, r, n) {
    var i = H1(e, n, r);
    if (i != null) {
      if (!(isFinite(i) && Math.floor(i) === i) || i < 0) {
        var o2 = n ? r : "highWaterMark";
        throw new U1(o2, i);
      }
      return Math.floor(i);
    }
    return t.objectMode ? 16 : 16 * 1024;
  }
  Js.exports = { getHighWaterMark: F1 };
});
var Qs = k2((Z8, $s) => {
  $s.exports = K1;
  function K1(t, e) {
    if (Ba("noDeprecation"))
      return t;
    var r = false;
    function n() {
      if (!r) {
        if (Ba("throwDeprecation"))
          throw new Error(e);
        Ba("traceDeprecation") ? console.trace(e) : console.warn(e), r = true;
      }
      return t.apply(this, arguments);
    }
    return n;
  }
  function Ba(t) {
    try {
      if (!__global$.localStorage)
        return false;
    } catch {
      return false;
    }
    var e = __global$.localStorage[t];
    return e == null ? false : String(e).toLowerCase() === "true";
  }
});
var ka = k2((G8, no2) => {
  "use strict";
  no2.exports = Le;
  function to2(t) {
    var e = this;
    this.next = null, this.entry = null, this.finish = function() {
      bv(e, t);
    };
  }
  var Di;
  Le.WritableState = df;
  var j1 = { deprecate: Qs() }, ro = Ma(), Qf = export_default.Buffer, W1 = __global$.Uint8Array || function() {
  };
  function V1(t) {
    return Qf.from(t);
  }
  function Z1(t) {
    return Qf.isBuffer(t) || t instanceof W1;
  }
  var Ia = Aa(), G1 = qa(), X1 = G1.getHighWaterMark, Hr = ni().codes, Y1 = Hr.ERR_INVALID_ARG_TYPE, J1 = Hr.ERR_METHOD_NOT_IMPLEMENTED, $1 = Hr.ERR_MULTIPLE_CALLBACK, Q1 = Hr.ERR_STREAM_CANNOT_PIPE, ev = Hr.ERR_STREAM_DESTROYED, tv = Hr.ERR_STREAM_NULL_VALUES, rv = Hr.ERR_STREAM_WRITE_AFTER_END, iv = Hr.ERR_UNKNOWN_ENCODING, Pi = Ia.errorOrDestroy;
  qe()(Le, ro);
  function fv() {
  }
  function df(t, e, r) {
    Di = Di || ai(), t = t || {}, typeof r != "boolean" && (r = e instanceof Di), this.objectMode = !!t.objectMode, r && (this.objectMode = this.objectMode || !!t.writableObjectMode), this.highWaterMark = X1(this, t, "writableHighWaterMark", r), this.finalCalled = false, this.needDrain = false, this.ending = false, this.ended = false, this.finished = false, this.destroyed = false;
    var n = t.decodeStrings === false;
    this.decodeStrings = !n, this.defaultEncoding = t.defaultEncoding || "utf8", this.length = 0, this.writing = false, this.corked = 0, this.sync = true, this.bufferProcessing = false, this.onwrite = function(i) {
      dv(e, i);
    }, this.writecb = null, this.writelen = 0, this.bufferedRequest = null, this.lastBufferedRequest = null, this.pendingcb = 0, this.prefinished = false, this.errorEmitted = false, this.emitClose = t.emitClose !== false, this.autoDestroy = !!t.autoDestroy, this.bufferedRequestCount = 0, this.corkedRequestsFree = new to2(this);
  }
  df.prototype.getBuffer = function() {
    for (var e = this.bufferedRequest, r = []; e; )
      r.push(e), e = e.next;
    return r;
  };
  (function() {
    try {
      Object.defineProperty(df.prototype, "buffer", { get: j1.deprecate(function() {
        return this.getBuffer();
      }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003") });
    } catch {
    }
  })();
  var $f;
  typeof Symbol == "function" && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] == "function" ? ($f = Function.prototype[Symbol.hasInstance], Object.defineProperty(Le, Symbol.hasInstance, { value: function(e) {
    return $f.call(this, e) ? true : this !== Le ? false : e && e._writableState instanceof df;
  } })) : $f = function(e) {
    return e instanceof this;
  };
  function Le(t) {
    Di = Di || ai();
    var e = this instanceof Di;
    if (!e && !$f.call(Le, this))
      return new Le(t);
    this._writableState = new df(t, this, e), this.writable = true, t && (typeof t.write == "function" && (this._write = t.write), typeof t.writev == "function" && (this._writev = t.writev), typeof t.destroy == "function" && (this._destroy = t.destroy), typeof t.final == "function" && (this._final = t.final)), ro.call(this);
  }
  Le.prototype.pipe = function() {
    Pi(this, new Q1());
  };
  function nv(t, e) {
    var r = new rv();
    Pi(t, r), process_default.nextTick(e, r);
  }
  function av(t, e, r, n) {
    var i;
    return r === null ? i = new tv() : typeof r != "string" && !e.objectMode && (i = new Y1("chunk", ["string", "Buffer"], r)), i ? (Pi(t, i), process_default.nextTick(n, i), false) : true;
  }
  Le.prototype.write = function(t, e, r) {
    var n = this._writableState, i = false, o2 = !n.objectMode && Z1(t);
    return o2 && !Qf.isBuffer(t) && (t = V1(t)), typeof e == "function" && (r = e, e = null), o2 ? e = "buffer" : e || (e = n.defaultEncoding), typeof r != "function" && (r = fv), n.ending ? nv(this, r) : (o2 || av(this, n, t, r)) && (n.pendingcb++, i = ov(this, n, o2, t, e, r)), i;
  };
  Le.prototype.cork = function() {
    this._writableState.corked++;
  };
  Le.prototype.uncork = function() {
    var t = this._writableState;
    t.corked && (t.corked--, !t.writing && !t.corked && !t.bufferProcessing && t.bufferedRequest && io(this, t));
  };
  Le.prototype.setDefaultEncoding = function(e) {
    if (typeof e == "string" && (e = e.toLowerCase()), !(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((e + "").toLowerCase()) > -1))
      throw new iv(e);
    return this._writableState.defaultEncoding = e, this;
  };
  Object.defineProperty(Le.prototype, "writableBuffer", { enumerable: false, get: function() {
    return this._writableState && this._writableState.getBuffer();
  } });
  function sv(t, e, r) {
    return !t.objectMode && t.decodeStrings !== false && typeof e == "string" && (e = Qf.from(e, r)), e;
  }
  Object.defineProperty(Le.prototype, "writableHighWaterMark", { enumerable: false, get: function() {
    return this._writableState.highWaterMark;
  } });
  function ov(t, e, r, n, i, o2) {
    if (!r) {
      var p3 = sv(e, n, i);
      n !== p3 && (r = true, i = "buffer", n = p3);
    }
    var y4 = e.objectMode ? 1 : n.length;
    e.length += y4;
    var w2 = e.length < e.highWaterMark;
    if (w2 || (e.needDrain = true), e.writing || e.corked) {
      var x = e.lastBufferedRequest;
      e.lastBufferedRequest = { chunk: n, encoding: i, isBuf: r, callback: o2, next: null }, x ? x.next = e.lastBufferedRequest : e.bufferedRequest = e.lastBufferedRequest, e.bufferedRequestCount += 1;
    } else
      Ra(t, e, false, y4, n, i, o2);
    return w2;
  }
  function Ra(t, e, r, n, i, o2, p3) {
    e.writelen = n, e.writecb = p3, e.writing = true, e.sync = true, e.destroyed ? e.onwrite(new ev("write")) : r ? t._writev(i, e.onwrite) : t._write(i, o2, e.onwrite), e.sync = false;
  }
  function hv(t, e, r, n, i) {
    --e.pendingcb, r ? (process_default.nextTick(i, n), process_default.nextTick(uf, t, e), t._writableState.errorEmitted = true, Pi(t, n)) : (i(n), t._writableState.errorEmitted = true, Pi(t, n), uf(t, e));
  }
  function uv(t) {
    t.writing = false, t.writecb = null, t.length -= t.writelen, t.writelen = 0;
  }
  function dv(t, e) {
    var r = t._writableState, n = r.sync, i = r.writecb;
    if (typeof i != "function")
      throw new $1();
    if (uv(r), e)
      hv(t, r, n, e, i);
    else {
      var o2 = fo(r) || t.destroyed;
      !o2 && !r.corked && !r.bufferProcessing && r.bufferedRequest && io(t, r), n ? process_default.nextTick(eo, t, r, o2, i) : eo(t, r, o2, i);
    }
  }
  function eo(t, e, r, n) {
    r || cv(t, e), e.pendingcb--, n(), uf(t, e);
  }
  function cv(t, e) {
    e.length === 0 && e.needDrain && (e.needDrain = false, t.emit("drain"));
  }
  function io(t, e) {
    e.bufferProcessing = true;
    var r = e.bufferedRequest;
    if (t._writev && r && r.next) {
      var n = e.bufferedRequestCount, i = new Array(n), o2 = e.corkedRequestsFree;
      o2.entry = r;
      for (var p3 = 0, y4 = true; r; )
        i[p3] = r, r.isBuf || (y4 = false), r = r.next, p3 += 1;
      i.allBuffers = y4, Ra(t, e, true, e.length, i, "", o2.finish), e.pendingcb++, e.lastBufferedRequest = null, o2.next ? (e.corkedRequestsFree = o2.next, o2.next = null) : e.corkedRequestsFree = new to2(e), e.bufferedRequestCount = 0;
    } else {
      for (; r; ) {
        var w2 = r.chunk, x = r.encoding, M4 = r.callback, E2 = e.objectMode ? 1 : w2.length;
        if (Ra(t, e, false, E2, w2, x, M4), r = r.next, e.bufferedRequestCount--, e.writing)
          break;
      }
      r === null && (e.lastBufferedRequest = null);
    }
    e.bufferedRequest = r, e.bufferProcessing = false;
  }
  Le.prototype._write = function(t, e, r) {
    r(new J1("_write()"));
  };
  Le.prototype._writev = null;
  Le.prototype.end = function(t, e, r) {
    var n = this._writableState;
    return typeof t == "function" ? (r = t, t = null, e = null) : typeof e == "function" && (r = e, e = null), t != null && this.write(t, e), n.corked && (n.corked = 1, this.uncork()), n.ending || pv(this, n, r), this;
  };
  Object.defineProperty(Le.prototype, "writableLength", { enumerable: false, get: function() {
    return this._writableState.length;
  } });
  function fo(t) {
    return t.ending && t.length === 0 && t.bufferedRequest === null && !t.finished && !t.writing;
  }
  function lv(t, e) {
    t._final(function(r) {
      e.pendingcb--, r && Pi(t, r), e.prefinished = true, t.emit("prefinish"), uf(t, e);
    });
  }
  function vv(t, e) {
    !e.prefinished && !e.finalCalled && (typeof t._final == "function" && !e.destroyed ? (e.pendingcb++, e.finalCalled = true, process_default.nextTick(lv, t, e)) : (e.prefinished = true, t.emit("prefinish")));
  }
  function uf(t, e) {
    var r = fo(e);
    if (r && (vv(t, e), e.pendingcb === 0 && (e.finished = true, t.emit("finish"), e.autoDestroy))) {
      var n = t._readableState;
      (!n || n.autoDestroy && n.endEmitted) && t.destroy();
    }
    return r;
  }
  function pv(t, e, r) {
    e.ending = true, uf(t, e), r && (e.finished ? process_default.nextTick(r) : t.once("finish", r)), e.ended = true, t.writable = false;
  }
  function bv(t, e, r) {
    var n = t.entry;
    for (t.entry = null; n; ) {
      var i = n.callback;
      e.pendingcb--, i(r), n = n.next;
    }
    e.corkedRequestsFree.next = t;
  }
  Object.defineProperty(Le.prototype, "destroyed", { enumerable: false, get: function() {
    return this._writableState === void 0 ? false : this._writableState.destroyed;
  }, set: function(e) {
    !this._writableState || (this._writableState.destroyed = e);
  } });
  Le.prototype.destroy = Ia.destroy;
  Le.prototype._undestroy = Ia.undestroy;
  Le.prototype._destroy = function(t, e) {
    e(t);
  };
});
var ai = k2((X8, so) => {
  "use strict";
  var mv = Object.keys || function(t) {
    var e = [];
    for (var r in t)
      e.push(r);
    return e;
  };
  so.exports = tr;
  var ao = Ta(), Pa = ka();
  qe()(tr, ao);
  for (Da = mv(Pa.prototype), en = 0; en < Da.length; en++)
    tn = Da[en], tr.prototype[tn] || (tr.prototype[tn] = Pa.prototype[tn]);
  var Da, tn, en;
  function tr(t) {
    if (!(this instanceof tr))
      return new tr(t);
    ao.call(this, t), Pa.call(this, t), this.allowHalfOpen = true, t && (t.readable === false && (this.readable = false), t.writable === false && (this.writable = false), t.allowHalfOpen === false && (this.allowHalfOpen = false, this.once("end", gv)));
  }
  Object.defineProperty(tr.prototype, "writableHighWaterMark", { enumerable: false, get: function() {
    return this._writableState.highWaterMark;
  } });
  Object.defineProperty(tr.prototype, "writableBuffer", { enumerable: false, get: function() {
    return this._writableState && this._writableState.getBuffer();
  } });
  Object.defineProperty(tr.prototype, "writableLength", { enumerable: false, get: function() {
    return this._writableState.length;
  } });
  function gv() {
    this._writableState.ended || process_default.nextTick(yv, this);
  }
  function yv(t) {
    t.end();
  }
  Object.defineProperty(tr.prototype, "destroyed", { enumerable: false, get: function() {
    return this._readableState === void 0 || this._writableState === void 0 ? false : this._readableState.destroyed && this._writableState.destroyed;
  }, set: function(e) {
    this._readableState === void 0 || this._writableState === void 0 || (this._readableState.destroyed = e, this._writableState.destroyed = e);
  } });
});
var rn = k2((Y8, uo) => {
  "use strict";
  var oo = ni().codes.ERR_STREAM_PREMATURE_CLOSE;
  function _v(t) {
    var e = false;
    return function() {
      if (!e) {
        e = true;
        for (var r = arguments.length, n = new Array(r), i = 0; i < r; i++)
          n[i] = arguments[i];
        t.apply(this, n);
      }
    };
  }
  function wv() {
  }
  function xv(t) {
    return t.setHeader && typeof t.abort == "function";
  }
  function ho(t, e, r) {
    if (typeof e == "function")
      return ho(t, null, e);
    e || (e = {}), r = _v(r || wv);
    var n = e.readable || e.readable !== false && t.readable, i = e.writable || e.writable !== false && t.writable, o2 = function() {
      t.writable || y4();
    }, p3 = t._writableState && t._writableState.finished, y4 = function() {
      i = false, p3 = true, n || r.call(t);
    }, w2 = t._readableState && t._readableState.endEmitted, x = function() {
      n = false, w2 = true, i || r.call(t);
    }, M4 = function(D6) {
      r.call(t, D6);
    }, E2 = function() {
      var D6;
      if (n && !w2)
        return (!t._readableState || !t._readableState.ended) && (D6 = new oo()), r.call(t, D6);
      if (i && !p3)
        return (!t._writableState || !t._writableState.ended) && (D6 = new oo()), r.call(t, D6);
    }, A4 = function() {
      t.req.on("finish", y4);
    };
    return xv(t) ? (t.on("complete", y4), t.on("abort", E2), t.req ? A4() : t.on("request", A4)) : i && !t._writableState && (t.on("end", o2), t.on("close", o2)), t.on("end", x), t.on("finish", y4), e.error !== false && t.on("error", M4), t.on("close", E2), function() {
      t.removeListener("complete", y4), t.removeListener("abort", E2), t.removeListener("request", A4), t.req && t.req.removeListener("finish", y4), t.removeListener("end", o2), t.removeListener("close", o2), t.removeListener("finish", y4), t.removeListener("end", x), t.removeListener("error", M4), t.removeListener("close", E2);
    };
  }
  uo.exports = ho;
});
var lo = k2((J8, co) => {
  "use strict";
  var fn;
  function Fr3(t, e, r) {
    return e in t ? Object.defineProperty(t, e, { value: r, enumerable: true, configurable: true, writable: true }) : t[e] = r, t;
  }
  var Mv = rn(), Kr = Symbol("lastResolve"), si2 = Symbol("lastReject"), cf = Symbol("error"), nn = Symbol("ended"), oi = Symbol("lastPromise"), Ca = Symbol("handlePromise"), hi2 = Symbol("stream");
  function jr3(t, e) {
    return { value: t, done: e };
  }
  function Sv(t) {
    var e = t[Kr];
    if (e !== null) {
      var r = t[hi2].read();
      r !== null && (t[oi] = null, t[Kr] = null, t[si2] = null, e(jr3(r, false)));
    }
  }
  function Ev(t) {
    process_default.nextTick(Sv, t);
  }
  function Av(t, e) {
    return function(r, n) {
      t.then(function() {
        if (e[nn]) {
          r(jr3(void 0, true));
          return;
        }
        e[Ca](r, n);
      }, n);
    };
  }
  var qv = Object.getPrototypeOf(function() {
  }), Bv = Object.setPrototypeOf((fn = { get stream() {
    return this[hi2];
  }, next: function() {
    var e = this, r = this[cf];
    if (r !== null)
      return Promise.reject(r);
    if (this[nn])
      return Promise.resolve(jr3(void 0, true));
    if (this[hi2].destroyed)
      return new Promise(function(p3, y4) {
        process_default.nextTick(function() {
          e[cf] ? y4(e[cf]) : p3(jr3(void 0, true));
        });
      });
    var n = this[oi], i;
    if (n)
      i = new Promise(Av(n, this));
    else {
      var o2 = this[hi2].read();
      if (o2 !== null)
        return Promise.resolve(jr3(o2, false));
      i = new Promise(this[Ca]);
    }
    return this[oi] = i, i;
  } }, Fr3(fn, Symbol.asyncIterator, function() {
    return this;
  }), Fr3(fn, "return", function() {
    var e = this;
    return new Promise(function(r, n) {
      e[hi2].destroy(null, function(i) {
        if (i) {
          n(i);
          return;
        }
        r(jr3(void 0, true));
      });
    });
  }), fn), qv), Rv = function(e) {
    var r, n = Object.create(Bv, (r = {}, Fr3(r, hi2, { value: e, writable: true }), Fr3(r, Kr, { value: null, writable: true }), Fr3(r, si2, { value: null, writable: true }), Fr3(r, cf, { value: null, writable: true }), Fr3(r, nn, { value: e._readableState.endEmitted, writable: true }), Fr3(r, Ca, { value: function(o2, p3) {
      var y4 = n[hi2].read();
      y4 ? (n[oi] = null, n[Kr] = null, n[si2] = null, o2(jr3(y4, false))) : (n[Kr] = o2, n[si2] = p3);
    }, writable: true }), r));
    return n[oi] = null, Mv(e, function(i) {
      if (i && i.code !== "ERR_STREAM_PREMATURE_CLOSE") {
        var o2 = n[si2];
        o2 !== null && (n[oi] = null, n[Kr] = null, n[si2] = null, o2(i)), n[cf] = i;
        return;
      }
      var p3 = n[Kr];
      p3 !== null && (n[oi] = null, n[Kr] = null, n[si2] = null, p3(jr3(void 0, true))), n[nn] = true;
    }), e.on("readable", Ev.bind(null, n)), n;
  };
  co.exports = Rv;
});
var po = k2(($8, vo) => {
  vo.exports = function() {
    throw new Error("Readable.from is not available in the browser");
  };
});
var Ta = k2((e5, Eo) => {
  "use strict";
  Eo.exports = Ie;
  var Ti;
  Ie.ReadableState = yo;
  var Q8 = events_default.EventEmitter, go = function(e, r) {
    return e.listeners(r).length;
  }, vf = Ma(), an = export_default.Buffer, Iv = __global$.Uint8Array || function() {
  };
  function kv(t) {
    return an.from(t);
  }
  function Dv(t) {
    return an.isBuffer(t) || t instanceof Iv;
  }
  var Na = util_default, Be3;
  Na && Na.debuglog ? Be3 = Na.debuglog("stream") : Be3 = function() {
  };
  var Pv = Ws(), Ka = Aa(), Tv = qa(), Cv = Tv.getHighWaterMark, sn = ni().codes, Nv = sn.ERR_INVALID_ARG_TYPE, Lv = sn.ERR_STREAM_PUSH_AFTER_EOF, Ov = sn.ERR_METHOD_NOT_IMPLEMENTED, zv = sn.ERR_STREAM_UNSHIFT_AFTER_END_EVENT, Ci, La, Oa;
  qe()(Ie, vf);
  var lf = Ka.errorOrDestroy, za = ["error", "close", "destroy", "pause", "resume"];
  function Uv(t, e, r) {
    if (typeof t.prependListener == "function")
      return t.prependListener(e, r);
    !t._events || !t._events[e] ? t.on(e, r) : Array.isArray(t._events[e]) ? t._events[e].unshift(r) : t._events[e] = [r, t._events[e]];
  }
  function yo(t, e, r) {
    Ti = Ti || ai(), t = t || {}, typeof r != "boolean" && (r = e instanceof Ti), this.objectMode = !!t.objectMode, r && (this.objectMode = this.objectMode || !!t.readableObjectMode), this.highWaterMark = Cv(this, t, "readableHighWaterMark", r), this.buffer = new Pv(), this.length = 0, this.pipes = null, this.pipesCount = 0, this.flowing = null, this.ended = false, this.endEmitted = false, this.reading = false, this.sync = true, this.needReadable = false, this.emittedReadable = false, this.readableListening = false, this.resumeScheduled = false, this.paused = true, this.emitClose = t.emitClose !== false, this.autoDestroy = !!t.autoDestroy, this.destroyed = false, this.defaultEncoding = t.defaultEncoding || "utf8", this.awaitDrain = 0, this.readingMore = false, this.decoder = null, this.encoding = null, t.encoding && (Ci || (Ci = string_decoder_default2.StringDecoder), this.decoder = new Ci(t.encoding), this.encoding = t.encoding);
  }
  function Ie(t) {
    if (Ti = Ti || ai(), !(this instanceof Ie))
      return new Ie(t);
    var e = this instanceof Ti;
    this._readableState = new yo(t, this, e), this.readable = true, t && (typeof t.read == "function" && (this._read = t.read), typeof t.destroy == "function" && (this._destroy = t.destroy)), vf.call(this);
  }
  Object.defineProperty(Ie.prototype, "destroyed", { enumerable: false, get: function() {
    return this._readableState === void 0 ? false : this._readableState.destroyed;
  }, set: function(e) {
    !this._readableState || (this._readableState.destroyed = e);
  } });
  Ie.prototype.destroy = Ka.destroy;
  Ie.prototype._undestroy = Ka.undestroy;
  Ie.prototype._destroy = function(t, e) {
    e(t);
  };
  Ie.prototype.push = function(t, e) {
    var r = this._readableState, n;
    return r.objectMode ? n = true : typeof t == "string" && (e = e || r.defaultEncoding, e !== r.encoding && (t = an.from(t, e), e = ""), n = true), _o2(this, t, e, false, n);
  };
  Ie.prototype.unshift = function(t) {
    return _o2(this, t, null, true, false);
  };
  function _o2(t, e, r, n, i) {
    Be3("readableAddChunk", e);
    var o2 = t._readableState;
    if (e === null)
      o2.reading = false, Kv(t, o2);
    else {
      var p3;
      if (i || (p3 = Hv(o2, e)), p3)
        lf(t, p3);
      else if (o2.objectMode || e && e.length > 0)
        if (typeof e != "string" && !o2.objectMode && Object.getPrototypeOf(e) !== an.prototype && (e = kv(e)), n)
          o2.endEmitted ? lf(t, new zv()) : Ua(t, o2, e, true);
        else if (o2.ended)
          lf(t, new Lv());
        else {
          if (o2.destroyed)
            return false;
          o2.reading = false, o2.decoder && !r ? (e = o2.decoder.write(e), o2.objectMode || e.length !== 0 ? Ua(t, o2, e, false) : Fa(t, o2)) : Ua(t, o2, e, false);
        }
      else
        n || (o2.reading = false, Fa(t, o2));
    }
    return !o2.ended && (o2.length < o2.highWaterMark || o2.length === 0);
  }
  function Ua(t, e, r, n) {
    e.flowing && e.length === 0 && !e.sync ? (e.awaitDrain = 0, t.emit("data", r)) : (e.length += e.objectMode ? 1 : r.length, n ? e.buffer.unshift(r) : e.buffer.push(r), e.needReadable && on2(t)), Fa(t, e);
  }
  function Hv(t, e) {
    var r;
    return !Dv(e) && typeof e != "string" && e !== void 0 && !t.objectMode && (r = new Nv("chunk", ["string", "Buffer", "Uint8Array"], e)), r;
  }
  Ie.prototype.isPaused = function() {
    return this._readableState.flowing === false;
  };
  Ie.prototype.setEncoding = function(t) {
    Ci || (Ci = string_decoder_default2.StringDecoder);
    var e = new Ci(t);
    this._readableState.decoder = e, this._readableState.encoding = this._readableState.decoder.encoding;
    for (var r = this._readableState.buffer.head, n = ""; r !== null; )
      n += e.write(r.data), r = r.next;
    return this._readableState.buffer.clear(), n !== "" && this._readableState.buffer.push(n), this._readableState.length = n.length, this;
  };
  var bo = 1073741824;
  function Fv(t) {
    return t >= bo ? t = bo : (t--, t |= t >>> 1, t |= t >>> 2, t |= t >>> 4, t |= t >>> 8, t |= t >>> 16, t++), t;
  }
  function mo(t, e) {
    return t <= 0 || e.length === 0 && e.ended ? 0 : e.objectMode ? 1 : t !== t ? e.flowing && e.length ? e.buffer.head.data.length : e.length : (t > e.highWaterMark && (e.highWaterMark = Fv(t)), t <= e.length ? t : e.ended ? e.length : (e.needReadable = true, 0));
  }
  Ie.prototype.read = function(t) {
    Be3("read", t), t = parseInt(t, 10);
    var e = this._readableState, r = t;
    if (t !== 0 && (e.emittedReadable = false), t === 0 && e.needReadable && ((e.highWaterMark !== 0 ? e.length >= e.highWaterMark : e.length > 0) || e.ended))
      return Be3("read: emitReadable", e.length, e.ended), e.length === 0 && e.ended ? Ha(this) : on2(this), null;
    if (t = mo(t, e), t === 0 && e.ended)
      return e.length === 0 && Ha(this), null;
    var n = e.needReadable;
    Be3("need readable", n), (e.length === 0 || e.length - t < e.highWaterMark) && (n = true, Be3("length less than watermark", n)), e.ended || e.reading ? (n = false, Be3("reading or ended", n)) : n && (Be3("do read"), e.reading = true, e.sync = true, e.length === 0 && (e.needReadable = true), this._read(e.highWaterMark), e.sync = false, e.reading || (t = mo(r, e)));
    var i;
    return t > 0 ? i = Mo2(t, e) : i = null, i === null ? (e.needReadable = e.length <= e.highWaterMark, t = 0) : (e.length -= t, e.awaitDrain = 0), e.length === 0 && (e.ended || (e.needReadable = true), r !== t && e.ended && Ha(this)), i !== null && this.emit("data", i), i;
  };
  function Kv(t, e) {
    if (Be3("onEofChunk"), !e.ended) {
      if (e.decoder) {
        var r = e.decoder.end();
        r && r.length && (e.buffer.push(r), e.length += e.objectMode ? 1 : r.length);
      }
      e.ended = true, e.sync ? on2(t) : (e.needReadable = false, e.emittedReadable || (e.emittedReadable = true, wo(t)));
    }
  }
  function on2(t) {
    var e = t._readableState;
    Be3("emitReadable", e.needReadable, e.emittedReadable), e.needReadable = false, e.emittedReadable || (Be3("emitReadable", e.flowing), e.emittedReadable = true, process_default.nextTick(wo, t));
  }
  function wo(t) {
    var e = t._readableState;
    Be3("emitReadable_", e.destroyed, e.length, e.ended), !e.destroyed && (e.length || e.ended) && (t.emit("readable"), e.emittedReadable = false), e.needReadable = !e.flowing && !e.ended && e.length <= e.highWaterMark, ja(t);
  }
  function Fa(t, e) {
    e.readingMore || (e.readingMore = true, process_default.nextTick(jv, t, e));
  }
  function jv(t, e) {
    for (; !e.reading && !e.ended && (e.length < e.highWaterMark || e.flowing && e.length === 0); ) {
      var r = e.length;
      if (Be3("maybeReadMore read 0"), t.read(0), r === e.length)
        break;
    }
    e.readingMore = false;
  }
  Ie.prototype._read = function(t) {
    lf(this, new Ov("_read()"));
  };
  Ie.prototype.pipe = function(t, e) {
    var r = this, n = this._readableState;
    switch (n.pipesCount) {
      case 0:
        n.pipes = t;
        break;
      case 1:
        n.pipes = [n.pipes, t];
        break;
      default:
        n.pipes.push(t);
        break;
    }
    n.pipesCount += 1, Be3("pipe count=%d opts=%j", n.pipesCount, e);
    var i = (!e || e.end !== false) && t !== process_default.stdout && t !== process_default.stderr, o2 = i ? y4 : C;
    n.endEmitted ? process_default.nextTick(o2) : r.once("end", o2), t.on("unpipe", p3);
    function p3(ge2, L4) {
      Be3("onunpipe"), ge2 === r && L4 && L4.hasUnpiped === false && (L4.hasUnpiped = true, M4());
    }
    function y4() {
      Be3("onend"), t.end();
    }
    var w2 = Wv(r);
    t.on("drain", w2);
    var x = false;
    function M4() {
      Be3("cleanup"), t.removeListener("close", I3), t.removeListener("finish", D6), t.removeListener("drain", w2), t.removeListener("error", A4), t.removeListener("unpipe", p3), r.removeListener("end", y4), r.removeListener("end", C), r.removeListener("data", E2), x = true, n.awaitDrain && (!t._writableState || t._writableState.needDrain) && w2();
    }
    r.on("data", E2);
    function E2(ge2) {
      Be3("ondata");
      var L4 = t.write(ge2);
      Be3("dest.write", L4), L4 === false && ((n.pipesCount === 1 && n.pipes === t || n.pipesCount > 1 && So(n.pipes, t) !== -1) && !x && (Be3("false write response, pause", n.awaitDrain), n.awaitDrain++), r.pause());
    }
    function A4(ge2) {
      Be3("onerror", ge2), C(), t.removeListener("error", A4), go(t, "error") === 0 && lf(t, ge2);
    }
    Uv(t, "error", A4);
    function I3() {
      t.removeListener("finish", D6), C();
    }
    t.once("close", I3);
    function D6() {
      Be3("onfinish"), t.removeListener("close", I3), C();
    }
    t.once("finish", D6);
    function C() {
      Be3("unpipe"), r.unpipe(t);
    }
    return t.emit("pipe", r), n.flowing || (Be3("pipe resume"), r.resume()), t;
  };
  function Wv(t) {
    return function() {
      var r = t._readableState;
      Be3("pipeOnDrain", r.awaitDrain), r.awaitDrain && r.awaitDrain--, r.awaitDrain === 0 && go(t, "data") && (r.flowing = true, ja(t));
    };
  }
  Ie.prototype.unpipe = function(t) {
    var e = this._readableState, r = { hasUnpiped: false };
    if (e.pipesCount === 0)
      return this;
    if (e.pipesCount === 1)
      return t && t !== e.pipes ? this : (t || (t = e.pipes), e.pipes = null, e.pipesCount = 0, e.flowing = false, t && t.emit("unpipe", this, r), this);
    if (!t) {
      var n = e.pipes, i = e.pipesCount;
      e.pipes = null, e.pipesCount = 0, e.flowing = false;
      for (var o2 = 0; o2 < i; o2++)
        n[o2].emit("unpipe", this, { hasUnpiped: false });
      return this;
    }
    var p3 = So(e.pipes, t);
    return p3 === -1 ? this : (e.pipes.splice(p3, 1), e.pipesCount -= 1, e.pipesCount === 1 && (e.pipes = e.pipes[0]), t.emit("unpipe", this, r), this);
  };
  Ie.prototype.on = function(t, e) {
    var r = vf.prototype.on.call(this, t, e), n = this._readableState;
    return t === "data" ? (n.readableListening = this.listenerCount("readable") > 0, n.flowing !== false && this.resume()) : t === "readable" && !n.endEmitted && !n.readableListening && (n.readableListening = n.needReadable = true, n.flowing = false, n.emittedReadable = false, Be3("on readable", n.length, n.reading), n.length ? on2(this) : n.reading || process_default.nextTick(Vv, this)), r;
  };
  Ie.prototype.addListener = Ie.prototype.on;
  Ie.prototype.removeListener = function(t, e) {
    var r = vf.prototype.removeListener.call(this, t, e);
    return t === "readable" && process_default.nextTick(xo2, this), r;
  };
  Ie.prototype.removeAllListeners = function(t) {
    var e = vf.prototype.removeAllListeners.apply(this, arguments);
    return (t === "readable" || t === void 0) && process_default.nextTick(xo2, this), e;
  };
  function xo2(t) {
    var e = t._readableState;
    e.readableListening = t.listenerCount("readable") > 0, e.resumeScheduled && !e.paused ? e.flowing = true : t.listenerCount("data") > 0 && t.resume();
  }
  function Vv(t) {
    Be3("readable nexttick read 0"), t.read(0);
  }
  Ie.prototype.resume = function() {
    var t = this._readableState;
    return t.flowing || (Be3("resume"), t.flowing = !t.readableListening, Zv(this, t)), t.paused = false, this;
  };
  function Zv(t, e) {
    e.resumeScheduled || (e.resumeScheduled = true, process_default.nextTick(Gv, t, e));
  }
  function Gv(t, e) {
    Be3("resume", e.reading), e.reading || t.read(0), e.resumeScheduled = false, t.emit("resume"), ja(t), e.flowing && !e.reading && t.read(0);
  }
  Ie.prototype.pause = function() {
    return Be3("call pause flowing=%j", this._readableState.flowing), this._readableState.flowing !== false && (Be3("pause"), this._readableState.flowing = false, this.emit("pause")), this._readableState.paused = true, this;
  };
  function ja(t) {
    var e = t._readableState;
    for (Be3("flow", e.flowing); e.flowing && t.read() !== null; )
      ;
  }
  Ie.prototype.wrap = function(t) {
    var e = this, r = this._readableState, n = false;
    t.on("end", function() {
      if (Be3("wrapped end"), r.decoder && !r.ended) {
        var p3 = r.decoder.end();
        p3 && p3.length && e.push(p3);
      }
      e.push(null);
    }), t.on("data", function(p3) {
      if (Be3("wrapped data"), r.decoder && (p3 = r.decoder.write(p3)), !(r.objectMode && p3 == null) && !(!r.objectMode && (!p3 || !p3.length))) {
        var y4 = e.push(p3);
        y4 || (n = true, t.pause());
      }
    });
    for (var i in t)
      this[i] === void 0 && typeof t[i] == "function" && (this[i] = function(y4) {
        return function() {
          return t[y4].apply(t, arguments);
        };
      }(i));
    for (var o2 = 0; o2 < za.length; o2++)
      t.on(za[o2], this.emit.bind(this, za[o2]));
    return this._read = function(p3) {
      Be3("wrapped _read", p3), n && (n = false, t.resume());
    }, this;
  };
  typeof Symbol == "function" && (Ie.prototype[Symbol.asyncIterator] = function() {
    return La === void 0 && (La = lo()), La(this);
  });
  Object.defineProperty(Ie.prototype, "readableHighWaterMark", { enumerable: false, get: function() {
    return this._readableState.highWaterMark;
  } });
  Object.defineProperty(Ie.prototype, "readableBuffer", { enumerable: false, get: function() {
    return this._readableState && this._readableState.buffer;
  } });
  Object.defineProperty(Ie.prototype, "readableFlowing", { enumerable: false, get: function() {
    return this._readableState.flowing;
  }, set: function(e) {
    this._readableState && (this._readableState.flowing = e);
  } });
  Ie._fromList = Mo2;
  Object.defineProperty(Ie.prototype, "readableLength", { enumerable: false, get: function() {
    return this._readableState.length;
  } });
  function Mo2(t, e) {
    if (e.length === 0)
      return null;
    var r;
    return e.objectMode ? r = e.buffer.shift() : !t || t >= e.length ? (e.decoder ? r = e.buffer.join("") : e.buffer.length === 1 ? r = e.buffer.first() : r = e.buffer.concat(e.length), e.buffer.clear()) : r = e.buffer.consume(t, e.decoder), r;
  }
  function Ha(t) {
    var e = t._readableState;
    Be3("endReadable", e.endEmitted), e.endEmitted || (e.ended = true, process_default.nextTick(Xv, e, t));
  }
  function Xv(t, e) {
    if (Be3("endReadableNT", t.endEmitted, t.length), !t.endEmitted && t.length === 0 && (t.endEmitted = true, e.readable = false, e.emit("end"), t.autoDestroy)) {
      var r = e._writableState;
      (!r || r.autoDestroy && r.finished) && e.destroy();
    }
  }
  typeof Symbol == "function" && (Ie.from = function(t, e) {
    return Oa === void 0 && (Oa = po()), Oa(Ie, t, e);
  });
  function So(t, e) {
    for (var r = 0, n = t.length; r < n; r++)
      if (t[r] === e)
        return r;
    return -1;
  }
});
var Wa = k2((t5, qo2) => {
  "use strict";
  qo2.exports = cr;
  var hn = ni().codes, Yv = hn.ERR_METHOD_NOT_IMPLEMENTED, Jv = hn.ERR_MULTIPLE_CALLBACK, $v = hn.ERR_TRANSFORM_ALREADY_TRANSFORMING, Qv = hn.ERR_TRANSFORM_WITH_LENGTH_0, un = ai();
  qe()(cr, un);
  function ep(t, e) {
    var r = this._transformState;
    r.transforming = false;
    var n = r.writecb;
    if (n === null)
      return this.emit("error", new Jv());
    r.writechunk = null, r.writecb = null, e != null && this.push(e), n(t);
    var i = this._readableState;
    i.reading = false, (i.needReadable || i.length < i.highWaterMark) && this._read(i.highWaterMark);
  }
  function cr(t) {
    if (!(this instanceof cr))
      return new cr(t);
    un.call(this, t), this._transformState = { afterTransform: ep.bind(this), needTransform: false, transforming: false, writecb: null, writechunk: null, writeencoding: null }, this._readableState.needReadable = true, this._readableState.sync = false, t && (typeof t.transform == "function" && (this._transform = t.transform), typeof t.flush == "function" && (this._flush = t.flush)), this.on("prefinish", tp);
  }
  function tp() {
    var t = this;
    typeof this._flush == "function" && !this._readableState.destroyed ? this._flush(function(e, r) {
      Ao(t, e, r);
    }) : Ao(this, null, null);
  }
  cr.prototype.push = function(t, e) {
    return this._transformState.needTransform = false, un.prototype.push.call(this, t, e);
  };
  cr.prototype._transform = function(t, e, r) {
    r(new Yv("_transform()"));
  };
  cr.prototype._write = function(t, e, r) {
    var n = this._transformState;
    if (n.writecb = r, n.writechunk = t, n.writeencoding = e, !n.transforming) {
      var i = this._readableState;
      (n.needTransform || i.needReadable || i.length < i.highWaterMark) && this._read(i.highWaterMark);
    }
  };
  cr.prototype._read = function(t) {
    var e = this._transformState;
    e.writechunk !== null && !e.transforming ? (e.transforming = true, this._transform(e.writechunk, e.writeencoding, e.afterTransform)) : e.needTransform = true;
  };
  cr.prototype._destroy = function(t, e) {
    un.prototype._destroy.call(this, t, function(r) {
      e(r);
    });
  };
  function Ao(t, e, r) {
    if (e)
      return t.emit("error", e);
    if (r != null && t.push(r), t._writableState.length)
      throw new Qv();
    if (t._transformState.transforming)
      throw new $v();
    return t.push(null);
  }
});
var Io = k2((r5, Ro2) => {
  "use strict";
  Ro2.exports = pf;
  var Bo2 = Wa();
  qe()(pf, Bo2);
  function pf(t) {
    if (!(this instanceof pf))
      return new pf(t);
    Bo2.call(this, t);
  }
  pf.prototype._transform = function(t, e, r) {
    r(null, t);
  };
});
var Co = k2((i5, To2) => {
  "use strict";
  var Va;
  function rp(t) {
    var e = false;
    return function() {
      e || (e = true, t.apply(void 0, arguments));
    };
  }
  var Po = ni().codes, ip = Po.ERR_MISSING_ARGS, fp = Po.ERR_STREAM_DESTROYED;
  function ko2(t) {
    if (t)
      throw t;
  }
  function np(t) {
    return t.setHeader && typeof t.abort == "function";
  }
  function ap(t, e, r, n) {
    n = rp(n);
    var i = false;
    t.on("close", function() {
      i = true;
    }), Va === void 0 && (Va = rn()), Va(t, { readable: e, writable: r }, function(p3) {
      if (p3)
        return n(p3);
      i = true, n();
    });
    var o2 = false;
    return function(p3) {
      if (!i && !o2) {
        if (o2 = true, np(t))
          return t.abort();
        if (typeof t.destroy == "function")
          return t.destroy();
        n(p3 || new fp("pipe"));
      }
    };
  }
  function Do2(t) {
    t();
  }
  function sp(t, e) {
    return t.pipe(e);
  }
  function op(t) {
    return !t.length || typeof t[t.length - 1] != "function" ? ko2 : t.pop();
  }
  function hp() {
    for (var t = arguments.length, e = new Array(t), r = 0; r < t; r++)
      e[r] = arguments[r];
    var n = op(e);
    if (Array.isArray(e[0]) && (e = e[0]), e.length < 2)
      throw new ip("streams");
    var i, o2 = e.map(function(p3, y4) {
      var w2 = y4 < e.length - 1, x = y4 > 0;
      return ap(p3, w2, x, function(M4) {
        i || (i = M4), M4 && o2.forEach(Do2), !w2 && (o2.forEach(Do2), n(i));
      });
    });
    return e.reduce(sp);
  }
  To2.exports = hp;
});
var Za = k2((lt3, No2) => {
  lt3 = No2.exports = Ta();
  lt3.Stream = lt3;
  lt3.Readable = lt3;
  lt3.Writable = ka();
  lt3.Duplex = ai();
  lt3.Transform = Wa();
  lt3.PassThrough = Io();
  lt3.finished = rn();
  lt3.pipeline = Co();
});
var Ga = k2((f5, Oo) => {
  "use strict";
  var dn = Ae().Buffer, Lo2 = Za().Transform, up = qe();
  function dp(t, e) {
    if (!dn.isBuffer(t) && typeof t != "string")
      throw new TypeError(e + " must be a string or a buffer");
  }
  function Wr2(t) {
    Lo2.call(this), this._block = dn.allocUnsafe(t), this._blockSize = t, this._blockOffset = 0, this._length = [0, 0, 0, 0], this._finalized = false;
  }
  up(Wr2, Lo2);
  Wr2.prototype._transform = function(t, e, r) {
    var n = null;
    try {
      this.update(t, e);
    } catch (i) {
      n = i;
    }
    r(n);
  };
  Wr2.prototype._flush = function(t) {
    var e = null;
    try {
      this.push(this.digest());
    } catch (r) {
      e = r;
    }
    t(e);
  };
  Wr2.prototype.update = function(t, e) {
    if (dp(t, "Data"), this._finalized)
      throw new Error("Digest already called");
    dn.isBuffer(t) || (t = dn.from(t, e));
    for (var r = this._block, n = 0; this._blockOffset + t.length - n >= this._blockSize; ) {
      for (var i = this._blockOffset; i < this._blockSize; )
        r[i++] = t[n++];
      this._update(), this._blockOffset = 0;
    }
    for (; n < t.length; )
      r[this._blockOffset++] = t[n++];
    for (var o2 = 0, p3 = t.length * 8; p3 > 0; ++o2)
      this._length[o2] += p3, p3 = this._length[o2] / 4294967296 | 0, p3 > 0 && (this._length[o2] -= 4294967296 * p3);
    return this;
  };
  Wr2.prototype._update = function() {
    throw new Error("_update is not implemented");
  };
  Wr2.prototype.digest = function(t) {
    if (this._finalized)
      throw new Error("Digest already called");
    this._finalized = true;
    var e = this._digest();
    t !== void 0 && (e = e.toString(t)), this._block.fill(0), this._blockOffset = 0;
    for (var r = 0; r < 4; ++r)
      this._length[r] = 0;
    return e;
  };
  Wr2.prototype._digest = function() {
    throw new Error("_digest is not implemented");
  };
  Oo.exports = Wr2;
});
var vn = k2((n5, Uo2) => {
  "use strict";
  var cp = qe(), zo2 = Ga(), lp = Ae().Buffer, vp = new Array(16);
  function cn() {
    zo2.call(this, 64), this._a = 1732584193, this._b = 4023233417, this._c = 2562383102, this._d = 271733878;
  }
  cp(cn, zo2);
  cn.prototype._update = function() {
    for (var t = vp, e = 0; e < 16; ++e)
      t[e] = this._block.readInt32LE(e * 4);
    var r = this._a, n = this._b, i = this._c, o2 = this._d;
    r = Je2(r, n, i, o2, t[0], 3614090360, 7), o2 = Je2(o2, r, n, i, t[1], 3905402710, 12), i = Je2(i, o2, r, n, t[2], 606105819, 17), n = Je2(n, i, o2, r, t[3], 3250441966, 22), r = Je2(r, n, i, o2, t[4], 4118548399, 7), o2 = Je2(o2, r, n, i, t[5], 1200080426, 12), i = Je2(i, o2, r, n, t[6], 2821735955, 17), n = Je2(n, i, o2, r, t[7], 4249261313, 22), r = Je2(r, n, i, o2, t[8], 1770035416, 7), o2 = Je2(o2, r, n, i, t[9], 2336552879, 12), i = Je2(i, o2, r, n, t[10], 4294925233, 17), n = Je2(n, i, o2, r, t[11], 2304563134, 22), r = Je2(r, n, i, o2, t[12], 1804603682, 7), o2 = Je2(o2, r, n, i, t[13], 4254626195, 12), i = Je2(i, o2, r, n, t[14], 2792965006, 17), n = Je2(n, i, o2, r, t[15], 1236535329, 22), r = $e2(r, n, i, o2, t[1], 4129170786, 5), o2 = $e2(o2, r, n, i, t[6], 3225465664, 9), i = $e2(i, o2, r, n, t[11], 643717713, 14), n = $e2(n, i, o2, r, t[0], 3921069994, 20), r = $e2(r, n, i, o2, t[5], 3593408605, 5), o2 = $e2(o2, r, n, i, t[10], 38016083, 9), i = $e2(i, o2, r, n, t[15], 3634488961, 14), n = $e2(n, i, o2, r, t[4], 3889429448, 20), r = $e2(r, n, i, o2, t[9], 568446438, 5), o2 = $e2(o2, r, n, i, t[14], 3275163606, 9), i = $e2(i, o2, r, n, t[3], 4107603335, 14), n = $e2(n, i, o2, r, t[8], 1163531501, 20), r = $e2(r, n, i, o2, t[13], 2850285829, 5), o2 = $e2(o2, r, n, i, t[2], 4243563512, 9), i = $e2(i, o2, r, n, t[7], 1735328473, 14), n = $e2(n, i, o2, r, t[12], 2368359562, 20), r = Qe2(r, n, i, o2, t[5], 4294588738, 4), o2 = Qe2(o2, r, n, i, t[8], 2272392833, 11), i = Qe2(i, o2, r, n, t[11], 1839030562, 16), n = Qe2(n, i, o2, r, t[14], 4259657740, 23), r = Qe2(r, n, i, o2, t[1], 2763975236, 4), o2 = Qe2(o2, r, n, i, t[4], 1272893353, 11), i = Qe2(i, o2, r, n, t[7], 4139469664, 16), n = Qe2(n, i, o2, r, t[10], 3200236656, 23), r = Qe2(r, n, i, o2, t[13], 681279174, 4), o2 = Qe2(o2, r, n, i, t[0], 3936430074, 11), i = Qe2(i, o2, r, n, t[3], 3572445317, 16), n = Qe2(n, i, o2, r, t[6], 76029189, 23), r = Qe2(r, n, i, o2, t[9], 3654602809, 4), o2 = Qe2(o2, r, n, i, t[12], 3873151461, 11), i = Qe2(i, o2, r, n, t[15], 530742520, 16), n = Qe2(n, i, o2, r, t[2], 3299628645, 23), r = et(r, n, i, o2, t[0], 4096336452, 6), o2 = et(o2, r, n, i, t[7], 1126891415, 10), i = et(i, o2, r, n, t[14], 2878612391, 15), n = et(n, i, o2, r, t[5], 4237533241, 21), r = et(r, n, i, o2, t[12], 1700485571, 6), o2 = et(o2, r, n, i, t[3], 2399980690, 10), i = et(i, o2, r, n, t[10], 4293915773, 15), n = et(n, i, o2, r, t[1], 2240044497, 21), r = et(r, n, i, o2, t[8], 1873313359, 6), o2 = et(o2, r, n, i, t[15], 4264355552, 10), i = et(i, o2, r, n, t[6], 2734768916, 15), n = et(n, i, o2, r, t[13], 1309151649, 21), r = et(r, n, i, o2, t[4], 4149444226, 6), o2 = et(o2, r, n, i, t[11], 3174756917, 10), i = et(i, o2, r, n, t[2], 718787259, 15), n = et(n, i, o2, r, t[9], 3951481745, 21), this._a = this._a + r | 0, this._b = this._b + n | 0, this._c = this._c + i | 0, this._d = this._d + o2 | 0;
  };
  cn.prototype._digest = function() {
    this._block[this._blockOffset++] = 128, this._blockOffset > 56 && (this._block.fill(0, this._blockOffset, 64), this._update(), this._blockOffset = 0), this._block.fill(0, this._blockOffset, 56), this._block.writeUInt32LE(this._length[0], 56), this._block.writeUInt32LE(this._length[1], 60), this._update();
    var t = lp.allocUnsafe(16);
    return t.writeInt32LE(this._a, 0), t.writeInt32LE(this._b, 4), t.writeInt32LE(this._c, 8), t.writeInt32LE(this._d, 12), t;
  };
  function ln(t, e) {
    return t << e | t >>> 32 - e;
  }
  function Je2(t, e, r, n, i, o2, p3) {
    return ln(t + (e & r | ~e & n) + i + o2 | 0, p3) + e | 0;
  }
  function $e2(t, e, r, n, i, o2, p3) {
    return ln(t + (e & n | r & ~n) + i + o2 | 0, p3) + e | 0;
  }
  function Qe2(t, e, r, n, i, o2, p3) {
    return ln(t + (e ^ r ^ n) + i + o2 | 0, p3) + e | 0;
  }
  function et(t, e, r, n, i, o2, p3) {
    return ln(t + (r ^ (e | ~n)) + i + o2 | 0, p3) + e | 0;
  }
  Uo2.exports = cn;
});
var bn = k2((a5, Zo2) => {
  "use strict";
  var Xa = export_default.Buffer, pp = qe(), Vo2 = Ga(), bp = new Array(16), bf = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8, 3, 10, 14, 4, 9, 15, 8, 1, 2, 7, 0, 6, 13, 11, 5, 12, 1, 9, 11, 10, 0, 8, 12, 4, 13, 3, 7, 15, 14, 5, 6, 2, 4, 0, 5, 9, 7, 12, 2, 10, 14, 1, 3, 8, 11, 6, 15, 13], mf = [5, 14, 7, 0, 9, 2, 11, 4, 13, 6, 15, 8, 1, 10, 3, 12, 6, 11, 3, 7, 0, 13, 5, 10, 14, 15, 8, 12, 4, 9, 1, 2, 15, 5, 1, 3, 7, 14, 6, 9, 11, 8, 12, 2, 10, 0, 4, 13, 8, 6, 4, 1, 3, 11, 15, 0, 5, 12, 2, 13, 9, 7, 10, 14, 12, 15, 10, 4, 1, 5, 8, 7, 6, 2, 13, 14, 0, 3, 9, 11], gf = [11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8, 7, 6, 8, 13, 11, 9, 7, 15, 7, 12, 15, 9, 11, 7, 13, 12, 11, 13, 6, 7, 14, 9, 13, 15, 14, 8, 13, 6, 5, 12, 7, 5, 11, 12, 14, 15, 14, 15, 9, 8, 9, 14, 5, 6, 8, 6, 5, 12, 9, 15, 5, 11, 6, 8, 13, 12, 5, 12, 13, 14, 11, 8, 5, 6], yf = [8, 9, 9, 11, 13, 15, 15, 5, 7, 7, 8, 11, 14, 14, 12, 6, 9, 13, 15, 7, 12, 8, 9, 11, 7, 7, 12, 7, 6, 15, 13, 11, 9, 7, 15, 11, 8, 6, 6, 14, 12, 13, 5, 14, 13, 13, 7, 5, 15, 5, 8, 11, 14, 14, 6, 14, 6, 9, 12, 9, 12, 5, 15, 8, 8, 5, 12, 9, 12, 5, 14, 6, 8, 13, 6, 5, 15, 13, 11, 11], _f = [0, 1518500249, 1859775393, 2400959708, 2840853838], wf = [1352829926, 1548603684, 1836072691, 2053994217, 0];
  function pn() {
    Vo2.call(this, 64), this._a = 1732584193, this._b = 4023233417, this._c = 2562383102, this._d = 271733878, this._e = 3285377520;
  }
  pp(pn, Vo2);
  pn.prototype._update = function() {
    for (var t = bp, e = 0; e < 16; ++e)
      t[e] = this._block.readInt32LE(e * 4);
    for (var r = this._a | 0, n = this._b | 0, i = this._c | 0, o2 = this._d | 0, p3 = this._e | 0, y4 = this._a | 0, w2 = this._b | 0, x = this._c | 0, M4 = this._d | 0, E2 = this._e | 0, A4 = 0; A4 < 80; A4 += 1) {
      var I3, D6;
      A4 < 16 ? (I3 = Ho2(r, n, i, o2, p3, t[bf[A4]], _f[0], gf[A4]), D6 = Wo2(y4, w2, x, M4, E2, t[mf[A4]], wf[0], yf[A4])) : A4 < 32 ? (I3 = Fo2(r, n, i, o2, p3, t[bf[A4]], _f[1], gf[A4]), D6 = jo(y4, w2, x, M4, E2, t[mf[A4]], wf[1], yf[A4])) : A4 < 48 ? (I3 = Ko2(r, n, i, o2, p3, t[bf[A4]], _f[2], gf[A4]), D6 = Ko2(y4, w2, x, M4, E2, t[mf[A4]], wf[2], yf[A4])) : A4 < 64 ? (I3 = jo(r, n, i, o2, p3, t[bf[A4]], _f[3], gf[A4]), D6 = Fo2(y4, w2, x, M4, E2, t[mf[A4]], wf[3], yf[A4])) : (I3 = Wo2(r, n, i, o2, p3, t[bf[A4]], _f[4], gf[A4]), D6 = Ho2(y4, w2, x, M4, E2, t[mf[A4]], wf[4], yf[A4])), r = p3, p3 = o2, o2 = ui(i, 10), i = n, n = I3, y4 = E2, E2 = M4, M4 = ui(x, 10), x = w2, w2 = D6;
    }
    var C = this._b + i + M4 | 0;
    this._b = this._c + o2 + E2 | 0, this._c = this._d + p3 + y4 | 0, this._d = this._e + r + w2 | 0, this._e = this._a + n + x | 0, this._a = C;
  };
  pn.prototype._digest = function() {
    this._block[this._blockOffset++] = 128, this._blockOffset > 56 && (this._block.fill(0, this._blockOffset, 64), this._update(), this._blockOffset = 0), this._block.fill(0, this._blockOffset, 56), this._block.writeUInt32LE(this._length[0], 56), this._block.writeUInt32LE(this._length[1], 60), this._update();
    var t = Xa.alloc ? Xa.alloc(20) : new Xa(20);
    return t.writeInt32LE(this._a, 0), t.writeInt32LE(this._b, 4), t.writeInt32LE(this._c, 8), t.writeInt32LE(this._d, 12), t.writeInt32LE(this._e, 16), t;
  };
  function ui(t, e) {
    return t << e | t >>> 32 - e;
  }
  function Ho2(t, e, r, n, i, o2, p3, y4) {
    return ui(t + (e ^ r ^ n) + o2 + p3 | 0, y4) + i | 0;
  }
  function Fo2(t, e, r, n, i, o2, p3, y4) {
    return ui(t + (e & r | ~e & n) + o2 + p3 | 0, y4) + i | 0;
  }
  function Ko2(t, e, r, n, i, o2, p3, y4) {
    return ui(t + ((e | ~r) ^ n) + o2 + p3 | 0, y4) + i | 0;
  }
  function jo(t, e, r, n, i, o2, p3, y4) {
    return ui(t + (e & n | r & ~n) + o2 + p3 | 0, y4) + i | 0;
  }
  function Wo2(t, e, r, n, i, o2, p3, y4) {
    return ui(t + (e ^ (r | ~n)) + o2 + p3 | 0, y4) + i | 0;
  }
  Zo2.exports = pn;
});
var di = k2((s5, Xo) => {
  var Go2 = Ae().Buffer;
  function mn(t, e) {
    this._block = Go2.alloc(t), this._finalSize = e, this._blockSize = t, this._len = 0;
  }
  mn.prototype.update = function(t, e) {
    typeof t == "string" && (e = e || "utf8", t = Go2.from(t, e));
    for (var r = this._block, n = this._blockSize, i = t.length, o2 = this._len, p3 = 0; p3 < i; ) {
      for (var y4 = o2 % n, w2 = Math.min(i - p3, n - y4), x = 0; x < w2; x++)
        r[y4 + x] = t[p3 + x];
      o2 += w2, p3 += w2, o2 % n === 0 && this._update(r);
    }
    return this._len += i, this;
  };
  mn.prototype.digest = function(t) {
    var e = this._len % this._blockSize;
    this._block[e] = 128, this._block.fill(0, e + 1), e >= this._finalSize && (this._update(this._block), this._block.fill(0));
    var r = this._len * 8;
    if (r <= 4294967295)
      this._block.writeUInt32BE(r, this._blockSize - 4);
    else {
      var n = (r & 4294967295) >>> 0, i = (r - n) / 4294967296;
      this._block.writeUInt32BE(i, this._blockSize - 8), this._block.writeUInt32BE(n, this._blockSize - 4);
    }
    this._update(this._block);
    var o2 = this._hash();
    return t ? o2.toString(t) : o2;
  };
  mn.prototype._update = function() {
    throw new Error("_update must be implemented by subclass");
  };
  Xo.exports = mn;
});
var $o = k2((o5, Jo2) => {
  var mp = qe(), Yo2 = di(), gp = Ae().Buffer, yp = [1518500249, 1859775393, -1894007588, -899497514], _p = new Array(80);
  function xf() {
    this.init(), this._w = _p, Yo2.call(this, 64, 56);
  }
  mp(xf, Yo2);
  xf.prototype.init = function() {
    return this._a = 1732584193, this._b = 4023233417, this._c = 2562383102, this._d = 271733878, this._e = 3285377520, this;
  };
  function wp(t) {
    return t << 5 | t >>> 27;
  }
  function xp(t) {
    return t << 30 | t >>> 2;
  }
  function Mp(t, e, r, n) {
    return t === 0 ? e & r | ~e & n : t === 2 ? e & r | e & n | r & n : e ^ r ^ n;
  }
  xf.prototype._update = function(t) {
    for (var e = this._w, r = this._a | 0, n = this._b | 0, i = this._c | 0, o2 = this._d | 0, p3 = this._e | 0, y4 = 0; y4 < 16; ++y4)
      e[y4] = t.readInt32BE(y4 * 4);
    for (; y4 < 80; ++y4)
      e[y4] = e[y4 - 3] ^ e[y4 - 8] ^ e[y4 - 14] ^ e[y4 - 16];
    for (var w2 = 0; w2 < 80; ++w2) {
      var x = ~~(w2 / 20), M4 = wp(r) + Mp(x, n, i, o2) + p3 + e[w2] + yp[x] | 0;
      p3 = o2, o2 = i, i = xp(n), n = r, r = M4;
    }
    this._a = r + this._a | 0, this._b = n + this._b | 0, this._c = i + this._c | 0, this._d = o2 + this._d | 0, this._e = p3 + this._e | 0;
  };
  xf.prototype._hash = function() {
    var t = gp.allocUnsafe(20);
    return t.writeInt32BE(this._a | 0, 0), t.writeInt32BE(this._b | 0, 4), t.writeInt32BE(this._c | 0, 8), t.writeInt32BE(this._d | 0, 12), t.writeInt32BE(this._e | 0, 16), t;
  };
  Jo2.exports = xf;
});
var th = k2((h5, eh) => {
  var Sp = qe(), Qo2 = di(), Ep = Ae().Buffer, Ap = [1518500249, 1859775393, -1894007588, -899497514], qp = new Array(80);
  function Mf() {
    this.init(), this._w = qp, Qo2.call(this, 64, 56);
  }
  Sp(Mf, Qo2);
  Mf.prototype.init = function() {
    return this._a = 1732584193, this._b = 4023233417, this._c = 2562383102, this._d = 271733878, this._e = 3285377520, this;
  };
  function Bp(t) {
    return t << 1 | t >>> 31;
  }
  function Rp(t) {
    return t << 5 | t >>> 27;
  }
  function Ip(t) {
    return t << 30 | t >>> 2;
  }
  function kp(t, e, r, n) {
    return t === 0 ? e & r | ~e & n : t === 2 ? e & r | e & n | r & n : e ^ r ^ n;
  }
  Mf.prototype._update = function(t) {
    for (var e = this._w, r = this._a | 0, n = this._b | 0, i = this._c | 0, o2 = this._d | 0, p3 = this._e | 0, y4 = 0; y4 < 16; ++y4)
      e[y4] = t.readInt32BE(y4 * 4);
    for (; y4 < 80; ++y4)
      e[y4] = Bp(e[y4 - 3] ^ e[y4 - 8] ^ e[y4 - 14] ^ e[y4 - 16]);
    for (var w2 = 0; w2 < 80; ++w2) {
      var x = ~~(w2 / 20), M4 = Rp(r) + kp(x, n, i, o2) + p3 + e[w2] + Ap[x] | 0;
      p3 = o2, o2 = i, i = Ip(n), n = r, r = M4;
    }
    this._a = r + this._a | 0, this._b = n + this._b | 0, this._c = i + this._c | 0, this._d = o2 + this._d | 0, this._e = p3 + this._e | 0;
  };
  Mf.prototype._hash = function() {
    var t = Ep.allocUnsafe(20);
    return t.writeInt32BE(this._a | 0, 0), t.writeInt32BE(this._b | 0, 4), t.writeInt32BE(this._c | 0, 8), t.writeInt32BE(this._d | 0, 12), t.writeInt32BE(this._e | 0, 16), t;
  };
  eh.exports = Mf;
});
var Ya = k2((u5, ih) => {
  var Dp = qe(), rh = di(), Pp = Ae().Buffer, Tp = [1116352408, 1899447441, 3049323471, 3921009573, 961987163, 1508970993, 2453635748, 2870763221, 3624381080, 310598401, 607225278, 1426881987, 1925078388, 2162078206, 2614888103, 3248222580, 3835390401, 4022224774, 264347078, 604807628, 770255983, 1249150122, 1555081692, 1996064986, 2554220882, 2821834349, 2952996808, 3210313671, 3336571891, 3584528711, 113926993, 338241895, 666307205, 773529912, 1294757372, 1396182291, 1695183700, 1986661051, 2177026350, 2456956037, 2730485921, 2820302411, 3259730800, 3345764771, 3516065817, 3600352804, 4094571909, 275423344, 430227734, 506948616, 659060556, 883997877, 958139571, 1322822218, 1537002063, 1747873779, 1955562222, 2024104815, 2227730452, 2361852424, 2428436474, 2756734187, 3204031479, 3329325298], Cp = new Array(64);
  function Sf() {
    this.init(), this._w = Cp, rh.call(this, 64, 56);
  }
  Dp(Sf, rh);
  Sf.prototype.init = function() {
    return this._a = 1779033703, this._b = 3144134277, this._c = 1013904242, this._d = 2773480762, this._e = 1359893119, this._f = 2600822924, this._g = 528734635, this._h = 1541459225, this;
  };
  function Np(t, e, r) {
    return r ^ t & (e ^ r);
  }
  function Lp(t, e, r) {
    return t & e | r & (t | e);
  }
  function Op(t) {
    return (t >>> 2 | t << 30) ^ (t >>> 13 | t << 19) ^ (t >>> 22 | t << 10);
  }
  function zp(t) {
    return (t >>> 6 | t << 26) ^ (t >>> 11 | t << 21) ^ (t >>> 25 | t << 7);
  }
  function Up(t) {
    return (t >>> 7 | t << 25) ^ (t >>> 18 | t << 14) ^ t >>> 3;
  }
  function Hp(t) {
    return (t >>> 17 | t << 15) ^ (t >>> 19 | t << 13) ^ t >>> 10;
  }
  Sf.prototype._update = function(t) {
    for (var e = this._w, r = this._a | 0, n = this._b | 0, i = this._c | 0, o2 = this._d | 0, p3 = this._e | 0, y4 = this._f | 0, w2 = this._g | 0, x = this._h | 0, M4 = 0; M4 < 16; ++M4)
      e[M4] = t.readInt32BE(M4 * 4);
    for (; M4 < 64; ++M4)
      e[M4] = Hp(e[M4 - 2]) + e[M4 - 7] + Up(e[M4 - 15]) + e[M4 - 16] | 0;
    for (var E2 = 0; E2 < 64; ++E2) {
      var A4 = x + zp(p3) + Np(p3, y4, w2) + Tp[E2] + e[E2] | 0, I3 = Op(r) + Lp(r, n, i) | 0;
      x = w2, w2 = y4, y4 = p3, p3 = o2 + A4 | 0, o2 = i, i = n, n = r, r = A4 + I3 | 0;
    }
    this._a = r + this._a | 0, this._b = n + this._b | 0, this._c = i + this._c | 0, this._d = o2 + this._d | 0, this._e = p3 + this._e | 0, this._f = y4 + this._f | 0, this._g = w2 + this._g | 0, this._h = x + this._h | 0;
  };
  Sf.prototype._hash = function() {
    var t = Pp.allocUnsafe(32);
    return t.writeInt32BE(this._a, 0), t.writeInt32BE(this._b, 4), t.writeInt32BE(this._c, 8), t.writeInt32BE(this._d, 12), t.writeInt32BE(this._e, 16), t.writeInt32BE(this._f, 20), t.writeInt32BE(this._g, 24), t.writeInt32BE(this._h, 28), t;
  };
  ih.exports = Sf;
});
var nh = k2((d5, fh) => {
  var Fp = qe(), Kp = Ya(), jp = di(), Wp = Ae().Buffer, Vp = new Array(64);
  function gn() {
    this.init(), this._w = Vp, jp.call(this, 64, 56);
  }
  Fp(gn, Kp);
  gn.prototype.init = function() {
    return this._a = 3238371032, this._b = 914150663, this._c = 812702999, this._d = 4144912697, this._e = 4290775857, this._f = 1750603025, this._g = 1694076839, this._h = 3204075428, this;
  };
  gn.prototype._hash = function() {
    var t = Wp.allocUnsafe(28);
    return t.writeInt32BE(this._a, 0), t.writeInt32BE(this._b, 4), t.writeInt32BE(this._c, 8), t.writeInt32BE(this._d, 12), t.writeInt32BE(this._e, 16), t.writeInt32BE(this._f, 20), t.writeInt32BE(this._g, 24), t;
  };
  fh.exports = gn;
});
var Ja = k2((c5, ch) => {
  var Zp = qe(), dh = di(), Gp = Ae().Buffer, ah = [1116352408, 3609767458, 1899447441, 602891725, 3049323471, 3964484399, 3921009573, 2173295548, 961987163, 4081628472, 1508970993, 3053834265, 2453635748, 2937671579, 2870763221, 3664609560, 3624381080, 2734883394, 310598401, 1164996542, 607225278, 1323610764, 1426881987, 3590304994, 1925078388, 4068182383, 2162078206, 991336113, 2614888103, 633803317, 3248222580, 3479774868, 3835390401, 2666613458, 4022224774, 944711139, 264347078, 2341262773, 604807628, 2007800933, 770255983, 1495990901, 1249150122, 1856431235, 1555081692, 3175218132, 1996064986, 2198950837, 2554220882, 3999719339, 2821834349, 766784016, 2952996808, 2566594879, 3210313671, 3203337956, 3336571891, 1034457026, 3584528711, 2466948901, 113926993, 3758326383, 338241895, 168717936, 666307205, 1188179964, 773529912, 1546045734, 1294757372, 1522805485, 1396182291, 2643833823, 1695183700, 2343527390, 1986661051, 1014477480, 2177026350, 1206759142, 2456956037, 344077627, 2730485921, 1290863460, 2820302411, 3158454273, 3259730800, 3505952657, 3345764771, 106217008, 3516065817, 3606008344, 3600352804, 1432725776, 4094571909, 1467031594, 275423344, 851169720, 430227734, 3100823752, 506948616, 1363258195, 659060556, 3750685593, 883997877, 3785050280, 958139571, 3318307427, 1322822218, 3812723403, 1537002063, 2003034995, 1747873779, 3602036899, 1955562222, 1575990012, 2024104815, 1125592928, 2227730452, 2716904306, 2361852424, 442776044, 2428436474, 593698344, 2756734187, 3733110249, 3204031479, 2999351573, 3329325298, 3815920427, 3391569614, 3928383900, 3515267271, 566280711, 3940187606, 3454069534, 4118630271, 4000239992, 116418474, 1914138554, 174292421, 2731055270, 289380356, 3203993006, 460393269, 320620315, 685471733, 587496836, 852142971, 1086792851, 1017036298, 365543100, 1126000580, 2618297676, 1288033470, 3409855158, 1501505948, 4234509866, 1607167915, 987167468, 1816402316, 1246189591], Xp = new Array(160);
  function Ef() {
    this.init(), this._w = Xp, dh.call(this, 128, 112);
  }
  Zp(Ef, dh);
  Ef.prototype.init = function() {
    return this._ah = 1779033703, this._bh = 3144134277, this._ch = 1013904242, this._dh = 2773480762, this._eh = 1359893119, this._fh = 2600822924, this._gh = 528734635, this._hh = 1541459225, this._al = 4089235720, this._bl = 2227873595, this._cl = 4271175723, this._dl = 1595750129, this._el = 2917565137, this._fl = 725511199, this._gl = 4215389547, this._hl = 327033209, this;
  };
  function sh(t, e, r) {
    return r ^ t & (e ^ r);
  }
  function oh(t, e, r) {
    return t & e | r & (t | e);
  }
  function hh(t, e) {
    return (t >>> 28 | e << 4) ^ (e >>> 2 | t << 30) ^ (e >>> 7 | t << 25);
  }
  function uh(t, e) {
    return (t >>> 14 | e << 18) ^ (t >>> 18 | e << 14) ^ (e >>> 9 | t << 23);
  }
  function Yp(t, e) {
    return (t >>> 1 | e << 31) ^ (t >>> 8 | e << 24) ^ t >>> 7;
  }
  function Jp(t, e) {
    return (t >>> 1 | e << 31) ^ (t >>> 8 | e << 24) ^ (t >>> 7 | e << 25);
  }
  function $p(t, e) {
    return (t >>> 19 | e << 13) ^ (e >>> 29 | t << 3) ^ t >>> 6;
  }
  function Qp(t, e) {
    return (t >>> 19 | e << 13) ^ (e >>> 29 | t << 3) ^ (t >>> 6 | e << 26);
  }
  function je2(t, e) {
    return t >>> 0 < e >>> 0 ? 1 : 0;
  }
  Ef.prototype._update = function(t) {
    for (var e = this._w, r = this._ah | 0, n = this._bh | 0, i = this._ch | 0, o2 = this._dh | 0, p3 = this._eh | 0, y4 = this._fh | 0, w2 = this._gh | 0, x = this._hh | 0, M4 = this._al | 0, E2 = this._bl | 0, A4 = this._cl | 0, I3 = this._dl | 0, D6 = this._el | 0, C = this._fl | 0, ge2 = this._gl | 0, L4 = this._hl | 0, ye = 0; ye < 32; ye += 2)
      e[ye] = t.readInt32BE(ye * 4), e[ye + 1] = t.readInt32BE(ye * 4 + 4);
    for (; ye < 160; ye += 2) {
      var Re = e[ye - 30], xe3 = e[ye - 15 * 2 + 1], ke = Yp(Re, xe3), Me = Jp(xe3, Re);
      Re = e[ye - 2 * 2], xe3 = e[ye - 2 * 2 + 1];
      var Ce3 = $p(Re, xe3), Ee2 = Qp(xe3, Re), Ne3 = e[ye - 7 * 2], S3 = e[ye - 7 * 2 + 1], v2 = e[ye - 16 * 2], _2 = e[ye - 16 * 2 + 1], c6 = Me + S3 | 0, f = ke + Ne3 + je2(c6, Me) | 0;
      c6 = c6 + Ee2 | 0, f = f + Ce3 + je2(c6, Ee2) | 0, c6 = c6 + _2 | 0, f = f + v2 + je2(c6, _2) | 0, e[ye] = f, e[ye + 1] = c6;
    }
    for (var a = 0; a < 160; a += 2) {
      f = e[a], c6 = e[a + 1];
      var u = oh(r, n, i), l = oh(M4, E2, A4), d4 = hh(r, M4), h = hh(M4, r), b2 = uh(p3, D6), m3 = uh(D6, p3), s = ah[a], g2 = ah[a + 1], q = sh(p3, y4, w2), R3 = sh(D6, C, ge2), B3 = L4 + m3 | 0, P2 = x + b2 + je2(B3, L4) | 0;
      B3 = B3 + R3 | 0, P2 = P2 + q + je2(B3, R3) | 0, B3 = B3 + g2 | 0, P2 = P2 + s + je2(B3, g2) | 0, B3 = B3 + c6 | 0, P2 = P2 + f + je2(B3, c6) | 0;
      var T4 = h + l | 0, N4 = d4 + u + je2(T4, h) | 0;
      x = w2, L4 = ge2, w2 = y4, ge2 = C, y4 = p3, C = D6, D6 = I3 + B3 | 0, p3 = o2 + P2 + je2(D6, I3) | 0, o2 = i, I3 = A4, i = n, A4 = E2, n = r, E2 = M4, M4 = B3 + T4 | 0, r = P2 + N4 + je2(M4, B3) | 0;
    }
    this._al = this._al + M4 | 0, this._bl = this._bl + E2 | 0, this._cl = this._cl + A4 | 0, this._dl = this._dl + I3 | 0, this._el = this._el + D6 | 0, this._fl = this._fl + C | 0, this._gl = this._gl + ge2 | 0, this._hl = this._hl + L4 | 0, this._ah = this._ah + r + je2(this._al, M4) | 0, this._bh = this._bh + n + je2(this._bl, E2) | 0, this._ch = this._ch + i + je2(this._cl, A4) | 0, this._dh = this._dh + o2 + je2(this._dl, I3) | 0, this._eh = this._eh + p3 + je2(this._el, D6) | 0, this._fh = this._fh + y4 + je2(this._fl, C) | 0, this._gh = this._gh + w2 + je2(this._gl, ge2) | 0, this._hh = this._hh + x + je2(this._hl, L4) | 0;
  };
  Ef.prototype._hash = function() {
    var t = Gp.allocUnsafe(64);
    function e(r, n, i) {
      t.writeInt32BE(r, i), t.writeInt32BE(n, i + 4);
    }
    return e(this._ah, this._al, 0), e(this._bh, this._bl, 8), e(this._ch, this._cl, 16), e(this._dh, this._dl, 24), e(this._eh, this._el, 32), e(this._fh, this._fl, 40), e(this._gh, this._gl, 48), e(this._hh, this._hl, 56), t;
  };
  ch.exports = Ef;
});
var vh = k2((l5, lh) => {
  var e2 = qe(), t2 = Ja(), r2 = di(), i2 = Ae().Buffer, f2 = new Array(160);
  function yn() {
    this.init(), this._w = f2, r2.call(this, 128, 112);
  }
  e2(yn, t2);
  yn.prototype.init = function() {
    return this._ah = 3418070365, this._bh = 1654270250, this._ch = 2438529370, this._dh = 355462360, this._eh = 1731405415, this._fh = 2394180231, this._gh = 3675008525, this._hh = 1203062813, this._al = 3238371032, this._bl = 914150663, this._cl = 812702999, this._dl = 4144912697, this._el = 4290775857, this._fl = 1750603025, this._gl = 1694076839, this._hl = 3204075428, this;
  };
  yn.prototype._hash = function() {
    var t = i2.allocUnsafe(48);
    function e(r, n, i) {
      t.writeInt32BE(r, i), t.writeInt32BE(n, i + 4);
    }
    return e(this._ah, this._al, 0), e(this._bh, this._bl, 8), e(this._ch, this._cl, 16), e(this._dh, this._dl, 24), e(this._eh, this._el, 32), e(this._fh, this._fl, 40), t;
  };
  lh.exports = yn;
});
var _n = k2((lr, ph) => {
  var lr = ph.exports = function(e) {
    e = e.toLowerCase();
    var r = lr[e];
    if (!r)
      throw new Error(e + " is not supported (we accept pull requests)");
    return new r();
  };
  lr.sha = $o();
  lr.sha1 = th();
  lr.sha224 = nh();
  lr.sha256 = Ya();
  lr.sha384 = vh();
  lr.sha512 = Ja();
});
var vr2 = k2((v5, gh) => {
  var bh = Ae().Buffer, mh = stream_default.Transform, n2 = string_decoder_default2.StringDecoder, a2 = qe();
  function Ft(t) {
    mh.call(this), this.hashMode = typeof t == "string", this.hashMode ? this[t] = this._finalOrDigest : this.final = this._finalOrDigest, this._final && (this.__final = this._final, this._final = null), this._decoder = null, this._encoding = null;
  }
  a2(Ft, mh);
  Ft.prototype.update = function(t, e, r) {
    typeof t == "string" && (t = bh.from(t, e));
    var n = this._update(t);
    return this.hashMode ? this : (r && (n = this._toString(n, r)), n);
  };
  Ft.prototype.setAutoPadding = function() {
  };
  Ft.prototype.getAuthTag = function() {
    throw new Error("trying to get auth tag in unsupported state");
  };
  Ft.prototype.setAuthTag = function() {
    throw new Error("trying to set auth tag in unsupported state");
  };
  Ft.prototype.setAAD = function() {
    throw new Error("trying to set aad in unsupported state");
  };
  Ft.prototype._transform = function(t, e, r) {
    var n;
    try {
      this.hashMode ? this._update(t) : this.push(this._update(t));
    } catch (i) {
      n = i;
    } finally {
      r(n);
    }
  };
  Ft.prototype._flush = function(t) {
    var e;
    try {
      this.push(this.__final());
    } catch (r) {
      e = r;
    }
    t(e);
  };
  Ft.prototype._finalOrDigest = function(t) {
    var e = this.__final() || bh.alloc(0);
    return t && (e = this._toString(e, t, true)), e;
  };
  Ft.prototype._toString = function(t, e, r) {
    if (this._decoder || (this._decoder = new n2(e), this._encoding = e), this._encoding !== e)
      throw new Error("can't switch encodings");
    var n = this._decoder.write(t);
    return r && (n += this._decoder.end()), n;
  };
  gh.exports = Ft;
});
var Ni = k2((p5, _h) => {
  "use strict";
  var s2 = qe(), o2 = vn(), h2 = bn(), u2 = _n(), yh = vr2();
  function wn(t) {
    yh.call(this, "digest"), this._hash = t;
  }
  s2(wn, yh);
  wn.prototype._update = function(t) {
    this._hash.update(t);
  };
  wn.prototype._final = function() {
    return this._hash.digest();
  };
  _h.exports = function(e) {
    return e = e.toLowerCase(), e === "md5" ? new o2() : e === "rmd160" || e === "ripemd160" ? new h2() : new wn(u2(e));
  };
});
var Mh = k2((b5, xh) => {
  "use strict";
  var d22 = qe(), ci = Ae().Buffer, wh = vr2(), c22 = ci.alloc(128), Li2 = 64;
  function xn(t, e) {
    wh.call(this, "digest"), typeof e == "string" && (e = ci.from(e)), this._alg = t, this._key = e, e.length > Li2 ? e = t(e) : e.length < Li2 && (e = ci.concat([e, c22], Li2));
    for (var r = this._ipad = ci.allocUnsafe(Li2), n = this._opad = ci.allocUnsafe(Li2), i = 0; i < Li2; i++)
      r[i] = e[i] ^ 54, n[i] = e[i] ^ 92;
    this._hash = [r];
  }
  d22(xn, wh);
  xn.prototype._update = function(t) {
    this._hash.push(t);
  };
  xn.prototype._final = function() {
    var t = this._alg(ci.concat(this._hash));
    return this._alg(ci.concat([this._opad, t]));
  };
  xh.exports = xn;
});
var $a = k2((m5, Sh) => {
  var l2 = vn();
  Sh.exports = function(t) {
    return new l2().update(t).digest();
  };
});
var t0 = k2((g5, Ah) => {
  "use strict";
  var v2 = qe(), p22 = Mh(), Eh = vr2(), Af = Ae().Buffer, b2 = $a(), Qa = bn(), e0 = _n(), m22 = Af.alloc(128);
  function qf(t, e) {
    Eh.call(this, "digest"), typeof e == "string" && (e = Af.from(e));
    var r = t === "sha512" || t === "sha384" ? 128 : 64;
    if (this._alg = t, this._key = e, e.length > r) {
      var n = t === "rmd160" ? new Qa() : e0(t);
      e = n.update(e).digest();
    } else
      e.length < r && (e = Af.concat([e, m22], r));
    for (var i = this._ipad = Af.allocUnsafe(r), o2 = this._opad = Af.allocUnsafe(r), p3 = 0; p3 < r; p3++)
      i[p3] = e[p3] ^ 54, o2[p3] = e[p3] ^ 92;
    this._hash = t === "rmd160" ? new Qa() : e0(t), this._hash.update(i);
  }
  v2(qf, Eh);
  qf.prototype._update = function(t) {
    this._hash.update(t);
  };
  qf.prototype._final = function() {
    var t = this._hash.digest(), e = this._alg === "rmd160" ? new Qa() : e0(this._alg);
    return e.update(this._opad).update(t).digest();
  };
  Ah.exports = function(e, r) {
    return e = e.toLowerCase(), e === "rmd160" || e === "ripemd160" ? new qf("rmd160", r) : e === "md5" ? new p22(b2, r) : new qf(e, r);
  };
});
var r0 = k2((y5, g2) => {
  g2.exports = { sha224WithRSAEncryption: { sign: "rsa", hash: "sha224", id: "302d300d06096086480165030402040500041c" }, "RSA-SHA224": { sign: "ecdsa/rsa", hash: "sha224", id: "302d300d06096086480165030402040500041c" }, sha256WithRSAEncryption: { sign: "rsa", hash: "sha256", id: "3031300d060960864801650304020105000420" }, "RSA-SHA256": { sign: "ecdsa/rsa", hash: "sha256", id: "3031300d060960864801650304020105000420" }, sha384WithRSAEncryption: { sign: "rsa", hash: "sha384", id: "3041300d060960864801650304020205000430" }, "RSA-SHA384": { sign: "ecdsa/rsa", hash: "sha384", id: "3041300d060960864801650304020205000430" }, sha512WithRSAEncryption: { sign: "rsa", hash: "sha512", id: "3051300d060960864801650304020305000440" }, "RSA-SHA512": { sign: "ecdsa/rsa", hash: "sha512", id: "3051300d060960864801650304020305000440" }, "RSA-SHA1": { sign: "rsa", hash: "sha1", id: "3021300906052b0e03021a05000414" }, "ecdsa-with-SHA1": { sign: "ecdsa", hash: "sha1", id: "" }, sha256: { sign: "ecdsa", hash: "sha256", id: "" }, sha224: { sign: "ecdsa", hash: "sha224", id: "" }, sha384: { sign: "ecdsa", hash: "sha384", id: "" }, sha512: { sign: "ecdsa", hash: "sha512", id: "" }, "DSA-SHA": { sign: "dsa", hash: "sha1", id: "" }, "DSA-SHA1": { sign: "dsa", hash: "sha1", id: "" }, DSA: { sign: "dsa", hash: "sha1", id: "" }, "DSA-WITH-SHA224": { sign: "dsa", hash: "sha224", id: "" }, "DSA-SHA224": { sign: "dsa", hash: "sha224", id: "" }, "DSA-WITH-SHA256": { sign: "dsa", hash: "sha256", id: "" }, "DSA-SHA256": { sign: "dsa", hash: "sha256", id: "" }, "DSA-WITH-SHA384": { sign: "dsa", hash: "sha384", id: "" }, "DSA-SHA384": { sign: "dsa", hash: "sha384", id: "" }, "DSA-WITH-SHA512": { sign: "dsa", hash: "sha512", id: "" }, "DSA-SHA512": { sign: "dsa", hash: "sha512", id: "" }, "DSA-RIPEMD160": { sign: "dsa", hash: "rmd160", id: "" }, ripemd160WithRSA: { sign: "rsa", hash: "rmd160", id: "3021300906052b2403020105000414" }, "RSA-RIPEMD160": { sign: "rsa", hash: "rmd160", id: "3021300906052b2403020105000414" }, md5WithRSAEncryption: { sign: "rsa", hash: "md5", id: "3020300c06082a864886f70d020505000410" }, "RSA-MD5": { sign: "rsa", hash: "md5", id: "3020300c06082a864886f70d020505000410" } };
});
var Bh = k2((_5, qh) => {
  qh.exports = r0();
});
var i0 = k2((w5, Rh) => {
  var y22 = Math.pow(2, 30) - 1;
  Rh.exports = function(t, e) {
    if (typeof t != "number")
      throw new TypeError("Iterations not a number");
    if (t < 0)
      throw new TypeError("Bad iterations");
    if (typeof e != "number")
      throw new TypeError("Key length not a number");
    if (e < 0 || e > y22 || e !== e)
      throw new TypeError("Bad key length");
  };
});
var f0 = k2((x5, kh) => {
  var Mn;
  process_default && process_default.browser ? Mn = "utf-8" : process_default && process_default.version ? (Ih = parseInt(process_default.version.split(".")[0].slice(1), 10), Mn = Ih >= 6 ? "utf-8" : "binary") : Mn = "utf-8";
  var Ih;
  kh.exports = Mn;
});
var a0 = k2((M5, Dh) => {
  var n0 = Ae().Buffer;
  Dh.exports = function(t, e, r) {
    if (n0.isBuffer(t))
      return t;
    if (typeof t == "string")
      return n0.from(t, e);
    if (ArrayBuffer.isView(t))
      return n0.from(t.buffer);
    throw new TypeError(r + " must be a string, a Buffer, a typed array or a DataView");
  };
});
var s0 = k2((S5, Nh) => {
  var _2 = $a(), w2 = bn(), x2 = _n(), li = Ae().Buffer, M22 = i0(), Ph = f0(), Th = a0(), S22 = li.alloc(128), Sn = { md5: 16, sha1: 20, sha224: 28, sha256: 32, sha384: 48, sha512: 64, rmd160: 20, ripemd160: 20 };
  function Ch(t, e, r) {
    var n = E2(t), i = t === "sha512" || t === "sha384" ? 128 : 64;
    e.length > i ? e = n(e) : e.length < i && (e = li.concat([e, S22], i));
    for (var o2 = li.allocUnsafe(i + Sn[t]), p3 = li.allocUnsafe(i + Sn[t]), y4 = 0; y4 < i; y4++)
      o2[y4] = e[y4] ^ 54, p3[y4] = e[y4] ^ 92;
    var w3 = li.allocUnsafe(i + r + 4);
    o2.copy(w3, 0, 0, i), this.ipad1 = w3, this.ipad2 = o2, this.opad = p3, this.alg = t, this.blocksize = i, this.hash = n, this.size = Sn[t];
  }
  Ch.prototype.run = function(t, e) {
    t.copy(e, this.blocksize);
    var r = this.hash(e);
    return r.copy(this.opad, this.blocksize), this.hash(this.opad);
  };
  function E2(t) {
    function e(n) {
      return x2(t).update(n).digest();
    }
    function r(n) {
      return new w2().update(n).digest();
    }
    return t === "rmd160" || t === "ripemd160" ? r : t === "md5" ? _2 : e;
  }
  function A22(t, e, r, n, i) {
    M22(r, n), t = Th(t, Ph, "Password"), e = Th(e, Ph, "Salt"), i = i || "sha1";
    var o2 = new Ch(i, t, e.length), p3 = li.allocUnsafe(n), y4 = li.allocUnsafe(e.length + 4);
    e.copy(y4, 0, 0, e.length);
    for (var w3 = 0, x = Sn[i], M4 = Math.ceil(n / x), E3 = 1; E3 <= M4; E3++) {
      y4.writeUInt32BE(E3, e.length);
      for (var A4 = o2.run(y4, o2.ipad1), I3 = A4, D6 = 1; D6 < r; D6++) {
        I3 = o2.run(I3, o2.ipad2);
        for (var C = 0; C < x; C++)
          A4[C] ^= I3[C];
      }
      A4.copy(p3, w3), w3 += x;
    }
    return p3;
  }
  Nh.exports = A22;
});
var Kh = k2((E5, Fh) => {
  var Uh = Ae().Buffer, q2 = i0(), Lh = f0(), Oh = s0(), zh = a0(), En, Bf = __global$.crypto && __global$.crypto.subtle, B22 = { sha: "SHA-1", "sha-1": "SHA-1", sha1: "SHA-1", sha256: "SHA-256", "sha-256": "SHA-256", sha384: "SHA-384", "sha-384": "SHA-384", "sha-512": "SHA-512", sha512: "SHA-512" }, o0 = [];
  function R22(t) {
    if (process_default && !process_default.browser || !Bf || !Bf.importKey || !Bf.deriveBits)
      return Promise.resolve(false);
    if (o0[t] !== void 0)
      return o0[t];
    En = En || Uh.alloc(8);
    var e = Hh(En, En, 10, 128, t).then(function() {
      return true;
    }).catch(function() {
      return false;
    });
    return o0[t] = e, e;
  }
  var vi;
  function h0() {
    return vi || (process_default && process_default.nextTick ? vi = process_default.nextTick : __global$.queueMicrotask ? vi = __global$.queueMicrotask : __setImmediate$ ? vi = __setImmediate$ : vi = __global$.setTimeout, vi);
  }
  function Hh(t, e, r, n, i) {
    return Bf.importKey("raw", t, { name: "PBKDF2" }, false, ["deriveBits"]).then(function(o2) {
      return Bf.deriveBits({ name: "PBKDF2", salt: e, iterations: r, hash: { name: i } }, o2, n << 3);
    }).then(function(o2) {
      return Uh.from(o2);
    });
  }
  function I22(t, e) {
    t.then(function(r) {
      h0()(function() {
        e(null, r);
      });
    }, function(r) {
      h0()(function() {
        e(r);
      });
    });
  }
  Fh.exports = function(t, e, r, n, i, o2) {
    typeof i == "function" && (o2 = i, i = void 0), i = i || "sha1";
    var p3 = B22[i.toLowerCase()];
    if (!p3 || typeof __global$.Promise != "function") {
      h0()(function() {
        var y4;
        try {
          y4 = Oh(t, e, r, n, i);
        } catch (w2) {
          return o2(w2);
        }
        o2(null, y4);
      });
      return;
    }
    if (q2(r, n), t = zh(t, Lh, "Password"), e = zh(e, Lh, "Salt"), typeof o2 != "function")
      throw new Error("No callback provided to pbkdf2");
    I22(R22(p3).then(function(y4) {
      return y4 ? Hh(t, e, r, n, p3) : Oh(t, e, r, n, i);
    }), o2);
  };
});
var d0 = k2((u0) => {
  u0.pbkdf2 = Kh();
  u0.pbkdf2Sync = s0();
});
var c0 = k2((vt) => {
  "use strict";
  vt.readUInt32BE = function(e, r) {
    var n = e[0 + r] << 24 | e[1 + r] << 16 | e[2 + r] << 8 | e[3 + r];
    return n >>> 0;
  };
  vt.writeUInt32BE = function(e, r, n) {
    e[0 + n] = r >>> 24, e[1 + n] = r >>> 16 & 255, e[2 + n] = r >>> 8 & 255, e[3 + n] = r & 255;
  };
  vt.ip = function(e, r, n, i) {
    for (var o2 = 0, p3 = 0, y4 = 6; y4 >= 0; y4 -= 2) {
      for (var w2 = 0; w2 <= 24; w2 += 8)
        o2 <<= 1, o2 |= r >>> w2 + y4 & 1;
      for (var w2 = 0; w2 <= 24; w2 += 8)
        o2 <<= 1, o2 |= e >>> w2 + y4 & 1;
    }
    for (var y4 = 6; y4 >= 0; y4 -= 2) {
      for (var w2 = 1; w2 <= 25; w2 += 8)
        p3 <<= 1, p3 |= r >>> w2 + y4 & 1;
      for (var w2 = 1; w2 <= 25; w2 += 8)
        p3 <<= 1, p3 |= e >>> w2 + y4 & 1;
    }
    n[i + 0] = o2 >>> 0, n[i + 1] = p3 >>> 0;
  };
  vt.rip = function(e, r, n, i) {
    for (var o2 = 0, p3 = 0, y4 = 0; y4 < 4; y4++)
      for (var w2 = 24; w2 >= 0; w2 -= 8)
        o2 <<= 1, o2 |= r >>> w2 + y4 & 1, o2 <<= 1, o2 |= e >>> w2 + y4 & 1;
    for (var y4 = 4; y4 < 8; y4++)
      for (var w2 = 24; w2 >= 0; w2 -= 8)
        p3 <<= 1, p3 |= r >>> w2 + y4 & 1, p3 <<= 1, p3 |= e >>> w2 + y4 & 1;
    n[i + 0] = o2 >>> 0, n[i + 1] = p3 >>> 0;
  };
  vt.pc1 = function(e, r, n, i) {
    for (var o2 = 0, p3 = 0, y4 = 7; y4 >= 5; y4--) {
      for (var w2 = 0; w2 <= 24; w2 += 8)
        o2 <<= 1, o2 |= r >> w2 + y4 & 1;
      for (var w2 = 0; w2 <= 24; w2 += 8)
        o2 <<= 1, o2 |= e >> w2 + y4 & 1;
    }
    for (var w2 = 0; w2 <= 24; w2 += 8)
      o2 <<= 1, o2 |= r >> w2 + y4 & 1;
    for (var y4 = 1; y4 <= 3; y4++) {
      for (var w2 = 0; w2 <= 24; w2 += 8)
        p3 <<= 1, p3 |= r >> w2 + y4 & 1;
      for (var w2 = 0; w2 <= 24; w2 += 8)
        p3 <<= 1, p3 |= e >> w2 + y4 & 1;
    }
    for (var w2 = 0; w2 <= 24; w2 += 8)
      p3 <<= 1, p3 |= e >> w2 + y4 & 1;
    n[i + 0] = o2 >>> 0, n[i + 1] = p3 >>> 0;
  };
  vt.r28shl = function(e, r) {
    return e << r & 268435455 | e >>> 28 - r;
  };
  var An = [14, 11, 17, 4, 27, 23, 25, 0, 13, 22, 7, 18, 5, 9, 16, 24, 2, 20, 12, 21, 1, 8, 15, 26, 15, 4, 25, 19, 9, 1, 26, 16, 5, 11, 23, 8, 12, 7, 17, 0, 22, 3, 10, 14, 6, 20, 27, 24];
  vt.pc2 = function(e, r, n, i) {
    for (var o2 = 0, p3 = 0, y4 = An.length >>> 1, w2 = 0; w2 < y4; w2++)
      o2 <<= 1, o2 |= e >>> An[w2] & 1;
    for (var w2 = y4; w2 < An.length; w2++)
      p3 <<= 1, p3 |= r >>> An[w2] & 1;
    n[i + 0] = o2 >>> 0, n[i + 1] = p3 >>> 0;
  };
  vt.expand = function(e, r, n) {
    var i = 0, o2 = 0;
    i = (e & 1) << 5 | e >>> 27;
    for (var p3 = 23; p3 >= 15; p3 -= 4)
      i <<= 6, i |= e >>> p3 & 63;
    for (var p3 = 11; p3 >= 3; p3 -= 4)
      o2 |= e >>> p3 & 63, o2 <<= 6;
    o2 |= (e & 31) << 1 | e >>> 31, r[n + 0] = i >>> 0, r[n + 1] = o2 >>> 0;
  };
  var jh = [14, 0, 4, 15, 13, 7, 1, 4, 2, 14, 15, 2, 11, 13, 8, 1, 3, 10, 10, 6, 6, 12, 12, 11, 5, 9, 9, 5, 0, 3, 7, 8, 4, 15, 1, 12, 14, 8, 8, 2, 13, 4, 6, 9, 2, 1, 11, 7, 15, 5, 12, 11, 9, 3, 7, 14, 3, 10, 10, 0, 5, 6, 0, 13, 15, 3, 1, 13, 8, 4, 14, 7, 6, 15, 11, 2, 3, 8, 4, 14, 9, 12, 7, 0, 2, 1, 13, 10, 12, 6, 0, 9, 5, 11, 10, 5, 0, 13, 14, 8, 7, 10, 11, 1, 10, 3, 4, 15, 13, 4, 1, 2, 5, 11, 8, 6, 12, 7, 6, 12, 9, 0, 3, 5, 2, 14, 15, 9, 10, 13, 0, 7, 9, 0, 14, 9, 6, 3, 3, 4, 15, 6, 5, 10, 1, 2, 13, 8, 12, 5, 7, 14, 11, 12, 4, 11, 2, 15, 8, 1, 13, 1, 6, 10, 4, 13, 9, 0, 8, 6, 15, 9, 3, 8, 0, 7, 11, 4, 1, 15, 2, 14, 12, 3, 5, 11, 10, 5, 14, 2, 7, 12, 7, 13, 13, 8, 14, 11, 3, 5, 0, 6, 6, 15, 9, 0, 10, 3, 1, 4, 2, 7, 8, 2, 5, 12, 11, 1, 12, 10, 4, 14, 15, 9, 10, 3, 6, 15, 9, 0, 0, 6, 12, 10, 11, 1, 7, 13, 13, 8, 15, 9, 1, 4, 3, 5, 14, 11, 5, 12, 2, 7, 8, 2, 4, 14, 2, 14, 12, 11, 4, 2, 1, 12, 7, 4, 10, 7, 11, 13, 6, 1, 8, 5, 5, 0, 3, 15, 15, 10, 13, 3, 0, 9, 14, 8, 9, 6, 4, 11, 2, 8, 1, 12, 11, 7, 10, 1, 13, 14, 7, 2, 8, 13, 15, 6, 9, 15, 12, 0, 5, 9, 6, 10, 3, 4, 0, 5, 14, 3, 12, 10, 1, 15, 10, 4, 15, 2, 9, 7, 2, 12, 6, 9, 8, 5, 0, 6, 13, 1, 3, 13, 4, 14, 14, 0, 7, 11, 5, 3, 11, 8, 9, 4, 14, 3, 15, 2, 5, 12, 2, 9, 8, 5, 12, 15, 3, 10, 7, 11, 0, 14, 4, 1, 10, 7, 1, 6, 13, 0, 11, 8, 6, 13, 4, 13, 11, 0, 2, 11, 14, 7, 15, 4, 0, 9, 8, 1, 13, 10, 3, 14, 12, 3, 9, 5, 7, 12, 5, 2, 10, 15, 6, 8, 1, 6, 1, 6, 4, 11, 11, 13, 13, 8, 12, 1, 3, 4, 7, 10, 14, 7, 10, 9, 15, 5, 6, 0, 8, 15, 0, 14, 5, 2, 9, 3, 2, 12, 13, 1, 2, 15, 8, 13, 4, 8, 6, 10, 15, 3, 11, 7, 1, 4, 10, 12, 9, 5, 3, 6, 14, 11, 5, 0, 0, 14, 12, 9, 7, 2, 7, 2, 11, 1, 4, 14, 1, 7, 9, 4, 12, 10, 14, 8, 2, 13, 0, 15, 6, 12, 10, 9, 13, 0, 15, 3, 3, 5, 5, 6, 8, 11];
  vt.substitute = function(e, r) {
    for (var n = 0, i = 0; i < 4; i++) {
      var o2 = e >>> 18 - i * 6 & 63, p3 = jh[i * 64 + o2];
      n <<= 4, n |= p3;
    }
    for (var i = 0; i < 4; i++) {
      var o2 = r >>> 18 - i * 6 & 63, p3 = jh[4 * 64 + i * 64 + o2];
      n <<= 4, n |= p3;
    }
    return n >>> 0;
  };
  var Wh = [16, 25, 12, 11, 3, 20, 4, 15, 31, 17, 9, 6, 27, 14, 1, 22, 30, 24, 8, 18, 0, 5, 29, 23, 13, 19, 2, 26, 10, 21, 28, 7];
  vt.permute = function(e) {
    for (var r = 0, n = 0; n < Wh.length; n++)
      r <<= 1, r |= e >>> Wh[n] & 1;
    return r >>> 0;
  };
  vt.padSplit = function(e, r, n) {
    for (var i = e.toString(2); i.length < r; )
      i = "0" + i;
    for (var o2 = [], p3 = 0; p3 < r; p3 += n)
      o2.push(i.slice(p3, p3 + n));
    return o2.join(" ");
  };
});
var ot = k2((B5, Zh) => {
  Zh.exports = Vh;
  function Vh(t, e) {
    if (!t)
      throw new Error(e || "Assertion failed");
  }
  Vh.equal = function(e, r, n) {
    if (e != r)
      throw new Error(n || "Assertion failed: " + e + " != " + r);
  };
});
var qn = k2((R5, Gh) => {
  "use strict";
  var k22 = ot();
  function pt2(t) {
    this.options = t, this.type = this.options.type, this.blockSize = 8, this._init(), this.buffer = new Array(this.blockSize), this.bufferOff = 0;
  }
  Gh.exports = pt2;
  pt2.prototype._init = function() {
  };
  pt2.prototype.update = function(e) {
    return e.length === 0 ? [] : this.type === "decrypt" ? this._updateDecrypt(e) : this._updateEncrypt(e);
  };
  pt2.prototype._buffer = function(e, r) {
    for (var n = Math.min(this.buffer.length - this.bufferOff, e.length - r), i = 0; i < n; i++)
      this.buffer[this.bufferOff + i] = e[r + i];
    return this.bufferOff += n, n;
  };
  pt2.prototype._flushBuffer = function(e, r) {
    return this._update(this.buffer, 0, e, r), this.bufferOff = 0, this.blockSize;
  };
  pt2.prototype._updateEncrypt = function(e) {
    var r = 0, n = 0, i = (this.bufferOff + e.length) / this.blockSize | 0, o2 = new Array(i * this.blockSize);
    this.bufferOff !== 0 && (r += this._buffer(e, r), this.bufferOff === this.buffer.length && (n += this._flushBuffer(o2, n)));
    for (var p3 = e.length - (e.length - r) % this.blockSize; r < p3; r += this.blockSize)
      this._update(e, r, o2, n), n += this.blockSize;
    for (; r < e.length; r++, this.bufferOff++)
      this.buffer[this.bufferOff] = e[r];
    return o2;
  };
  pt2.prototype._updateDecrypt = function(e) {
    for (var r = 0, n = 0, i = Math.ceil((this.bufferOff + e.length) / this.blockSize) - 1, o2 = new Array(i * this.blockSize); i > 0; i--)
      r += this._buffer(e, r), n += this._flushBuffer(o2, n);
    return r += this._buffer(e, r), o2;
  };
  pt2.prototype.final = function(e) {
    var r;
    e && (r = this.update(e));
    var n;
    return this.type === "encrypt" ? n = this._finalEncrypt() : n = this._finalDecrypt(), r ? r.concat(n) : n;
  };
  pt2.prototype._pad = function(e, r) {
    if (r === 0)
      return false;
    for (; r < e.length; )
      e[r++] = 0;
    return true;
  };
  pt2.prototype._finalEncrypt = function() {
    if (!this._pad(this.buffer, this.bufferOff))
      return [];
    var e = new Array(this.blockSize);
    return this._update(this.buffer, 0, e, 0), e;
  };
  pt2.prototype._unpad = function(e) {
    return e;
  };
  pt2.prototype._finalDecrypt = function() {
    k22.equal(this.bufferOff, this.blockSize, "Not enough data to decrypt");
    var e = new Array(this.blockSize);
    return this._flushBuffer(e, 0), this._unpad(e);
  };
});
var l0 = k2((I5, Jh) => {
  "use strict";
  var Xh = ot(), D22 = qe(), He2 = c0(), Yh = qn();
  function P2() {
    this.tmp = new Array(2), this.keys = null;
  }
  function rr(t) {
    Yh.call(this, t);
    var e = new P2();
    this._desState = e, this.deriveKeys(e, t.key);
  }
  D22(rr, Yh);
  Jh.exports = rr;
  rr.create = function(e) {
    return new rr(e);
  };
  var T22 = [1, 1, 2, 2, 2, 2, 2, 2, 1, 2, 2, 2, 2, 2, 2, 1];
  rr.prototype.deriveKeys = function(e, r) {
    e.keys = new Array(16 * 2), Xh.equal(r.length, this.blockSize, "Invalid key length");
    var n = He2.readUInt32BE(r, 0), i = He2.readUInt32BE(r, 4);
    He2.pc1(n, i, e.tmp, 0), n = e.tmp[0], i = e.tmp[1];
    for (var o2 = 0; o2 < e.keys.length; o2 += 2) {
      var p3 = T22[o2 >>> 1];
      n = He2.r28shl(n, p3), i = He2.r28shl(i, p3), He2.pc2(n, i, e.keys, o2);
    }
  };
  rr.prototype._update = function(e, r, n, i) {
    var o2 = this._desState, p3 = He2.readUInt32BE(e, r), y4 = He2.readUInt32BE(e, r + 4);
    He2.ip(p3, y4, o2.tmp, 0), p3 = o2.tmp[0], y4 = o2.tmp[1], this.type === "encrypt" ? this._encrypt(o2, p3, y4, o2.tmp, 0) : this._decrypt(o2, p3, y4, o2.tmp, 0), p3 = o2.tmp[0], y4 = o2.tmp[1], He2.writeUInt32BE(n, p3, i), He2.writeUInt32BE(n, y4, i + 4);
  };
  rr.prototype._pad = function(e, r) {
    for (var n = e.length - r, i = r; i < e.length; i++)
      e[i] = n;
    return true;
  };
  rr.prototype._unpad = function(e) {
    for (var r = e[e.length - 1], n = e.length - r; n < e.length; n++)
      Xh.equal(e[n], r);
    return e.slice(0, e.length - r);
  };
  rr.prototype._encrypt = function(e, r, n, i, o2) {
    for (var p3 = r, y4 = n, w2 = 0; w2 < e.keys.length; w2 += 2) {
      var x = e.keys[w2], M4 = e.keys[w2 + 1];
      He2.expand(y4, e.tmp, 0), x ^= e.tmp[0], M4 ^= e.tmp[1];
      var E2 = He2.substitute(x, M4), A4 = He2.permute(E2), I3 = y4;
      y4 = (p3 ^ A4) >>> 0, p3 = I3;
    }
    He2.rip(y4, p3, i, o2);
  };
  rr.prototype._decrypt = function(e, r, n, i, o2) {
    for (var p3 = n, y4 = r, w2 = e.keys.length - 2; w2 >= 0; w2 -= 2) {
      var x = e.keys[w2], M4 = e.keys[w2 + 1];
      He2.expand(p3, e.tmp, 0), x ^= e.tmp[0], M4 ^= e.tmp[1];
      var E2 = He2.substitute(x, M4), A4 = He2.permute(E2), I3 = p3;
      p3 = (y4 ^ A4) >>> 0, y4 = I3;
    }
    He2.rip(p3, y4, i, o2);
  };
});
var Qh = k2(($h) => {
  "use strict";
  var C2 = ot(), N22 = qe(), Bn = {};
  function L22(t) {
    C2.equal(t.length, 8, "Invalid IV length"), this.iv = new Array(8);
    for (var e = 0; e < this.iv.length; e++)
      this.iv[e] = t[e];
  }
  function O2(t) {
    function e(o2) {
      t.call(this, o2), this._cbcInit();
    }
    N22(e, t);
    for (var r = Object.keys(Bn), n = 0; n < r.length; n++) {
      var i = r[n];
      e.prototype[i] = Bn[i];
    }
    return e.create = function(p3) {
      return new e(p3);
    }, e;
  }
  $h.instantiate = O2;
  Bn._cbcInit = function() {
    var e = new L22(this.options.iv);
    this._cbcState = e;
  };
  Bn._update = function(e, r, n, i) {
    var o2 = this._cbcState, p3 = this.constructor.super_.prototype, y4 = o2.iv;
    if (this.type === "encrypt") {
      for (var w2 = 0; w2 < this.blockSize; w2++)
        y4[w2] ^= e[r + w2];
      p3._update.call(this, y4, 0, n, i);
      for (var w2 = 0; w2 < this.blockSize; w2++)
        y4[w2] = n[i + w2];
    } else {
      p3._update.call(this, e, r, n, i);
      for (var w2 = 0; w2 < this.blockSize; w2++)
        n[i + w2] ^= y4[w2];
      for (var w2 = 0; w2 < this.blockSize; w2++)
        y4[w2] = e[r + w2];
    }
  };
});
var ru = k2((D52, tu) => {
  "use strict";
  var z2 = ot(), U2 = qe(), eu = qn(), Vr2 = l0();
  function H22(t, e) {
    z2.equal(e.length, 24, "Invalid key length");
    var r = e.slice(0, 8), n = e.slice(8, 16), i = e.slice(16, 24);
    t === "encrypt" ? this.ciphers = [Vr2.create({ type: "encrypt", key: r }), Vr2.create({ type: "decrypt", key: n }), Vr2.create({ type: "encrypt", key: i })] : this.ciphers = [Vr2.create({ type: "decrypt", key: i }), Vr2.create({ type: "encrypt", key: n }), Vr2.create({ type: "decrypt", key: r })];
  }
  function pi(t) {
    eu.call(this, t);
    var e = new H22(this.type, this.options.key);
    this._edeState = e;
  }
  U2(pi, eu);
  tu.exports = pi;
  pi.create = function(e) {
    return new pi(e);
  };
  pi.prototype._update = function(e, r, n, i) {
    var o2 = this._edeState;
    o2.ciphers[0]._update(e, r, n, i), o2.ciphers[1]._update(n, i, n, i), o2.ciphers[2]._update(n, i, n, i);
  };
  pi.prototype._pad = Vr2.prototype._pad;
  pi.prototype._unpad = Vr2.prototype._unpad;
});
var iu = k2((Oi2) => {
  "use strict";
  Oi2.utils = c0();
  Oi2.Cipher = qn();
  Oi2.DES = l0();
  Oi2.CBC = Qh();
  Oi2.EDE = ru();
});
var au = k2((T5, nu) => {
  var fu = vr2(), pr2 = iu(), F22 = qe(), bi = Ae().Buffer, Rf = { "des-ede3-cbc": pr2.CBC.instantiate(pr2.EDE), "des-ede3": pr2.EDE, "des-ede-cbc": pr2.CBC.instantiate(pr2.EDE), "des-ede": pr2.EDE, "des-cbc": pr2.CBC.instantiate(pr2.DES), "des-ecb": pr2.DES };
  Rf.des = Rf["des-cbc"];
  Rf.des3 = Rf["des-ede3-cbc"];
  nu.exports = Rn;
  F22(Rn, fu);
  function Rn(t) {
    fu.call(this);
    var e = t.mode.toLowerCase(), r = Rf[e], n;
    t.decrypt ? n = "decrypt" : n = "encrypt";
    var i = t.key;
    bi.isBuffer(i) || (i = bi.from(i)), (e === "des-ede" || e === "des-ede-cbc") && (i = bi.concat([i, i.slice(0, 8)]));
    var o2 = t.iv;
    bi.isBuffer(o2) || (o2 = bi.from(o2)), this._des = r.create({ key: i, iv: o2, type: n });
  }
  Rn.prototype._update = function(t) {
    return bi.from(this._des.update(t));
  };
  Rn.prototype._final = function() {
    return bi.from(this._des.final());
  };
});
var su = k2((v0) => {
  v0.encrypt = function(t, e) {
    return t._cipher.encryptBlock(e);
  };
  v0.decrypt = function(t, e) {
    return t._cipher.decryptBlock(e);
  };
});
var zi = k2((N5, ou) => {
  ou.exports = function(e, r) {
    for (var n = Math.min(e.length, r.length), i = new Buffer3(n), o2 = 0; o2 < n; ++o2)
      i[o2] = e[o2] ^ r[o2];
    return i;
  };
});
var uu = k2((p0) => {
  var hu = zi();
  p0.encrypt = function(t, e) {
    var r = hu(e, t._prev);
    return t._prev = t._cipher.encryptBlock(r), t._prev;
  };
  p0.decrypt = function(t, e) {
    var r = t._prev;
    t._prev = e;
    var n = t._cipher.decryptBlock(e);
    return hu(n, r);
  };
});
var lu = k2((cu) => {
  var If = Ae().Buffer, K22 = zi();
  function du(t, e, r) {
    var n = e.length, i = K22(e, t._cache);
    return t._cache = t._cache.slice(n), t._prev = If.concat([t._prev, r ? e : i]), i;
  }
  cu.encrypt = function(t, e, r) {
    for (var n = If.allocUnsafe(0), i; e.length; )
      if (t._cache.length === 0 && (t._cache = t._cipher.encryptBlock(t._prev), t._prev = If.allocUnsafe(0)), t._cache.length <= e.length)
        i = t._cache.length, n = If.concat([n, du(t, e.slice(0, i), r)]), e = e.slice(i);
      else {
        n = If.concat([n, du(t, e, r)]);
        break;
      }
    return n;
  };
});
var pu = k2((vu) => {
  var b0 = Ae().Buffer;
  function j2(t, e, r) {
    var n = t._cipher.encryptBlock(t._prev), i = n[0] ^ e;
    return t._prev = b0.concat([t._prev.slice(1), b0.from([r ? e : i])]), i;
  }
  vu.encrypt = function(t, e, r) {
    for (var n = e.length, i = b0.allocUnsafe(n), o2 = -1; ++o2 < n; )
      i[o2] = j2(t, e[o2], r);
    return i;
  };
});
var mu = k2((bu) => {
  var In = Ae().Buffer;
  function W22(t, e, r) {
    for (var n, i = -1, o2 = 8, p3 = 0, y4, w2; ++i < o2; )
      n = t._cipher.encryptBlock(t._prev), y4 = e & 1 << 7 - i ? 128 : 0, w2 = n[0] ^ y4, p3 += (w2 & 128) >> i % 8, t._prev = V22(t._prev, r ? y4 : w2);
    return p3;
  }
  function V22(t, e) {
    var r = t.length, n = -1, i = In.allocUnsafe(t.length);
    for (t = In.concat([t, In.from([e])]); ++n < r; )
      i[n] = t[n] << 1 | t[n + 1] >> 7;
    return i;
  }
  bu.encrypt = function(t, e, r) {
    for (var n = e.length, i = In.allocUnsafe(n), o2 = -1; ++o2 < n; )
      i[o2] = W22(t, e[o2], r);
    return i;
  };
});
var yu = k2((gu) => {
  var Z22 = zi();
  function G22(t) {
    return t._prev = t._cipher.encryptBlock(t._prev), t._prev;
  }
  gu.encrypt = function(t, e) {
    for (; t._cache.length < e.length; )
      t._cache = Buffer3.concat([t._cache, G22(t)]);
    var r = t._cache.slice(0, e.length);
    return t._cache = t._cache.slice(e.length), Z22(e, r);
  };
});
var m0 = k2((F5, _u) => {
  function X22(t) {
    for (var e = t.length, r; e--; )
      if (r = t.readUInt8(e), r === 255)
        t.writeUInt8(0, e);
      else {
        r++, t.writeUInt8(r, e);
        break;
      }
  }
  _u.exports = X22;
});
var y0 = k2((xu) => {
  var Y22 = zi(), wu = Ae().Buffer, J22 = m0();
  function $22(t) {
    var e = t._cipher.encryptBlockRaw(t._prev);
    return J22(t._prev), e;
  }
  var g0 = 16;
  xu.encrypt = function(t, e) {
    var r = Math.ceil(e.length / g0), n = t._cache.length;
    t._cache = wu.concat([t._cache, wu.allocUnsafe(r * g0)]);
    for (var i = 0; i < r; i++) {
      var o2 = $22(t), p3 = n + i * g0;
      t._cache.writeUInt32BE(o2[0], p3 + 0), t._cache.writeUInt32BE(o2[1], p3 + 4), t._cache.writeUInt32BE(o2[2], p3 + 8), t._cache.writeUInt32BE(o2[3], p3 + 12);
    }
    var y4 = t._cache.slice(0, e.length);
    return t._cache = t._cache.slice(e.length), Y22(e, y4);
  };
});
var _0 = k2((j5, Q22) => {
  Q22.exports = { "aes-128-ecb": { cipher: "AES", key: 128, iv: 0, mode: "ECB", type: "block" }, "aes-192-ecb": { cipher: "AES", key: 192, iv: 0, mode: "ECB", type: "block" }, "aes-256-ecb": { cipher: "AES", key: 256, iv: 0, mode: "ECB", type: "block" }, "aes-128-cbc": { cipher: "AES", key: 128, iv: 16, mode: "CBC", type: "block" }, "aes-192-cbc": { cipher: "AES", key: 192, iv: 16, mode: "CBC", type: "block" }, "aes-256-cbc": { cipher: "AES", key: 256, iv: 16, mode: "CBC", type: "block" }, aes128: { cipher: "AES", key: 128, iv: 16, mode: "CBC", type: "block" }, aes192: { cipher: "AES", key: 192, iv: 16, mode: "CBC", type: "block" }, aes256: { cipher: "AES", key: 256, iv: 16, mode: "CBC", type: "block" }, "aes-128-cfb": { cipher: "AES", key: 128, iv: 16, mode: "CFB", type: "stream" }, "aes-192-cfb": { cipher: "AES", key: 192, iv: 16, mode: "CFB", type: "stream" }, "aes-256-cfb": { cipher: "AES", key: 256, iv: 16, mode: "CFB", type: "stream" }, "aes-128-cfb8": { cipher: "AES", key: 128, iv: 16, mode: "CFB8", type: "stream" }, "aes-192-cfb8": { cipher: "AES", key: 192, iv: 16, mode: "CFB8", type: "stream" }, "aes-256-cfb8": { cipher: "AES", key: 256, iv: 16, mode: "CFB8", type: "stream" }, "aes-128-cfb1": { cipher: "AES", key: 128, iv: 16, mode: "CFB1", type: "stream" }, "aes-192-cfb1": { cipher: "AES", key: 192, iv: 16, mode: "CFB1", type: "stream" }, "aes-256-cfb1": { cipher: "AES", key: 256, iv: 16, mode: "CFB1", type: "stream" }, "aes-128-ofb": { cipher: "AES", key: 128, iv: 16, mode: "OFB", type: "stream" }, "aes-192-ofb": { cipher: "AES", key: 192, iv: 16, mode: "OFB", type: "stream" }, "aes-256-ofb": { cipher: "AES", key: 256, iv: 16, mode: "OFB", type: "stream" }, "aes-128-ctr": { cipher: "AES", key: 128, iv: 16, mode: "CTR", type: "stream" }, "aes-192-ctr": { cipher: "AES", key: 192, iv: 16, mode: "CTR", type: "stream" }, "aes-256-ctr": { cipher: "AES", key: 256, iv: 16, mode: "CTR", type: "stream" }, "aes-128-gcm": { cipher: "AES", key: 128, iv: 12, mode: "GCM", type: "auth" }, "aes-192-gcm": { cipher: "AES", key: 192, iv: 12, mode: "GCM", type: "auth" }, "aes-256-gcm": { cipher: "AES", key: 256, iv: 12, mode: "GCM", type: "auth" } };
});
var Dn = k2((W5, Mu) => {
  var eb = { ECB: su(), CBC: uu(), CFB: lu(), CFB8: pu(), CFB1: mu(), OFB: yu(), CTR: y0(), GCM: y0() }, kn = _0();
  for (w0 in kn)
    kn[w0].module = eb[kn[w0].mode];
  var w0;
  Mu.exports = kn;
});
var kf = k2((V5, Eu) => {
  var Pn = Ae().Buffer;
  function M0(t) {
    Pn.isBuffer(t) || (t = Pn.from(t));
    for (var e = t.length / 4 | 0, r = new Array(e), n = 0; n < e; n++)
      r[n] = t.readUInt32BE(n * 4);
    return r;
  }
  function x0(t) {
    for (var e = 0; e < t.length; t++)
      t[e] = 0;
  }
  function Su(t, e, r, n, i) {
    for (var o2 = r[0], p3 = r[1], y4 = r[2], w2 = r[3], x = t[0] ^ e[0], M4 = t[1] ^ e[1], E2 = t[2] ^ e[2], A4 = t[3] ^ e[3], I3, D6, C, ge2, L4 = 4, ye = 1; ye < i; ye++)
      I3 = o2[x >>> 24] ^ p3[M4 >>> 16 & 255] ^ y4[E2 >>> 8 & 255] ^ w2[A4 & 255] ^ e[L4++], D6 = o2[M4 >>> 24] ^ p3[E2 >>> 16 & 255] ^ y4[A4 >>> 8 & 255] ^ w2[x & 255] ^ e[L4++], C = o2[E2 >>> 24] ^ p3[A4 >>> 16 & 255] ^ y4[x >>> 8 & 255] ^ w2[M4 & 255] ^ e[L4++], ge2 = o2[A4 >>> 24] ^ p3[x >>> 16 & 255] ^ y4[M4 >>> 8 & 255] ^ w2[E2 & 255] ^ e[L4++], x = I3, M4 = D6, E2 = C, A4 = ge2;
    return I3 = (n[x >>> 24] << 24 | n[M4 >>> 16 & 255] << 16 | n[E2 >>> 8 & 255] << 8 | n[A4 & 255]) ^ e[L4++], D6 = (n[M4 >>> 24] << 24 | n[E2 >>> 16 & 255] << 16 | n[A4 >>> 8 & 255] << 8 | n[x & 255]) ^ e[L4++], C = (n[E2 >>> 24] << 24 | n[A4 >>> 16 & 255] << 16 | n[x >>> 8 & 255] << 8 | n[M4 & 255]) ^ e[L4++], ge2 = (n[A4 >>> 24] << 24 | n[x >>> 16 & 255] << 16 | n[M4 >>> 8 & 255] << 8 | n[E2 & 255]) ^ e[L4++], I3 = I3 >>> 0, D6 = D6 >>> 0, C = C >>> 0, ge2 = ge2 >>> 0, [I3, D6, C, ge2];
  }
  var tb = [0, 1, 2, 4, 8, 16, 32, 64, 128, 27, 54], Ue3 = function() {
    for (var t = new Array(256), e = 0; e < 256; e++)
      e < 128 ? t[e] = e << 1 : t[e] = e << 1 ^ 283;
    for (var r = [], n = [], i = [[], [], [], []], o2 = [[], [], [], []], p3 = 0, y4 = 0, w2 = 0; w2 < 256; ++w2) {
      var x = y4 ^ y4 << 1 ^ y4 << 2 ^ y4 << 3 ^ y4 << 4;
      x = x >>> 8 ^ x & 255 ^ 99, r[p3] = x, n[x] = p3;
      var M4 = t[p3], E2 = t[M4], A4 = t[E2], I3 = t[x] * 257 ^ x * 16843008;
      i[0][p3] = I3 << 24 | I3 >>> 8, i[1][p3] = I3 << 16 | I3 >>> 16, i[2][p3] = I3 << 8 | I3 >>> 24, i[3][p3] = I3, I3 = A4 * 16843009 ^ E2 * 65537 ^ M4 * 257 ^ p3 * 16843008, o2[0][x] = I3 << 24 | I3 >>> 8, o2[1][x] = I3 << 16 | I3 >>> 16, o2[2][x] = I3 << 8 | I3 >>> 24, o2[3][x] = I3, p3 === 0 ? p3 = y4 = 1 : (p3 = M4 ^ t[t[t[A4 ^ M4]]], y4 ^= t[t[y4]]);
    }
    return { SBOX: r, INV_SBOX: n, SUB_MIX: i, INV_SUB_MIX: o2 };
  }();
  function bt(t) {
    this._key = M0(t), this._reset();
  }
  bt.blockSize = 4 * 4;
  bt.keySize = 256 / 8;
  bt.prototype.blockSize = bt.blockSize;
  bt.prototype.keySize = bt.keySize;
  bt.prototype._reset = function() {
    for (var t = this._key, e = t.length, r = e + 6, n = (r + 1) * 4, i = [], o2 = 0; o2 < e; o2++)
      i[o2] = t[o2];
    for (o2 = e; o2 < n; o2++) {
      var p3 = i[o2 - 1];
      o2 % e === 0 ? (p3 = p3 << 8 | p3 >>> 24, p3 = Ue3.SBOX[p3 >>> 24] << 24 | Ue3.SBOX[p3 >>> 16 & 255] << 16 | Ue3.SBOX[p3 >>> 8 & 255] << 8 | Ue3.SBOX[p3 & 255], p3 ^= tb[o2 / e | 0] << 24) : e > 6 && o2 % e === 4 && (p3 = Ue3.SBOX[p3 >>> 24] << 24 | Ue3.SBOX[p3 >>> 16 & 255] << 16 | Ue3.SBOX[p3 >>> 8 & 255] << 8 | Ue3.SBOX[p3 & 255]), i[o2] = i[o2 - e] ^ p3;
    }
    for (var y4 = [], w2 = 0; w2 < n; w2++) {
      var x = n - w2, M4 = i[x - (w2 % 4 ? 0 : 4)];
      w2 < 4 || x <= 4 ? y4[w2] = M4 : y4[w2] = Ue3.INV_SUB_MIX[0][Ue3.SBOX[M4 >>> 24]] ^ Ue3.INV_SUB_MIX[1][Ue3.SBOX[M4 >>> 16 & 255]] ^ Ue3.INV_SUB_MIX[2][Ue3.SBOX[M4 >>> 8 & 255]] ^ Ue3.INV_SUB_MIX[3][Ue3.SBOX[M4 & 255]];
    }
    this._nRounds = r, this._keySchedule = i, this._invKeySchedule = y4;
  };
  bt.prototype.encryptBlockRaw = function(t) {
    return t = M0(t), Su(t, this._keySchedule, Ue3.SUB_MIX, Ue3.SBOX, this._nRounds);
  };
  bt.prototype.encryptBlock = function(t) {
    var e = this.encryptBlockRaw(t), r = Pn.allocUnsafe(16);
    return r.writeUInt32BE(e[0], 0), r.writeUInt32BE(e[1], 4), r.writeUInt32BE(e[2], 8), r.writeUInt32BE(e[3], 12), r;
  };
  bt.prototype.decryptBlock = function(t) {
    t = M0(t);
    var e = t[1];
    t[1] = t[3], t[3] = e;
    var r = Su(t, this._invKeySchedule, Ue3.INV_SUB_MIX, Ue3.INV_SBOX, this._nRounds), n = Pn.allocUnsafe(16);
    return n.writeUInt32BE(r[0], 0), n.writeUInt32BE(r[3], 4), n.writeUInt32BE(r[2], 8), n.writeUInt32BE(r[1], 12), n;
  };
  bt.prototype.scrub = function() {
    x0(this._keySchedule), x0(this._invKeySchedule), x0(this._key);
  };
  Eu.exports.AES = bt;
});
var Bu = k2((Z5, qu) => {
  var Ui = Ae().Buffer, rb = Ui.alloc(16, 0);
  function ib(t) {
    return [t.readUInt32BE(0), t.readUInt32BE(4), t.readUInt32BE(8), t.readUInt32BE(12)];
  }
  function Au(t) {
    var e = Ui.allocUnsafe(16);
    return e.writeUInt32BE(t[0] >>> 0, 0), e.writeUInt32BE(t[1] >>> 0, 4), e.writeUInt32BE(t[2] >>> 0, 8), e.writeUInt32BE(t[3] >>> 0, 12), e;
  }
  function Df(t) {
    this.h = t, this.state = Ui.alloc(16, 0), this.cache = Ui.allocUnsafe(0);
  }
  Df.prototype.ghash = function(t) {
    for (var e = -1; ++e < t.length; )
      this.state[e] ^= t[e];
    this._multiply();
  };
  Df.prototype._multiply = function() {
    for (var t = ib(this.h), e = [0, 0, 0, 0], r, n, i, o2 = -1; ++o2 < 128; ) {
      for (n = (this.state[~~(o2 / 8)] & 1 << 7 - o2 % 8) !== 0, n && (e[0] ^= t[0], e[1] ^= t[1], e[2] ^= t[2], e[3] ^= t[3]), i = (t[3] & 1) !== 0, r = 3; r > 0; r--)
        t[r] = t[r] >>> 1 | (t[r - 1] & 1) << 31;
      t[0] = t[0] >>> 1, i && (t[0] = t[0] ^ 225 << 24);
    }
    this.state = Au(e);
  };
  Df.prototype.update = function(t) {
    this.cache = Ui.concat([this.cache, t]);
    for (var e; this.cache.length >= 16; )
      e = this.cache.slice(0, 16), this.cache = this.cache.slice(16), this.ghash(e);
  };
  Df.prototype.final = function(t, e) {
    return this.cache.length && this.ghash(Ui.concat([this.cache, rb], 16)), this.ghash(Au([0, t, 0, e])), this.state;
  };
  qu.exports = Df;
});
var S0 = k2((G5, ku) => {
  var fb = kf(), ft4 = Ae().Buffer, Ru = vr2(), nb = qe(), Iu = Bu(), ab = zi(), sb = m0();
  function ob(t, e) {
    var r = 0;
    t.length !== e.length && r++;
    for (var n = Math.min(t.length, e.length), i = 0; i < n; ++i)
      r += t[i] ^ e[i];
    return r;
  }
  function hb(t, e, r) {
    if (e.length === 12)
      return t._finID = ft4.concat([e, ft4.from([0, 0, 0, 1])]), ft4.concat([e, ft4.from([0, 0, 0, 2])]);
    var n = new Iu(r), i = e.length, o2 = i % 16;
    n.update(e), o2 && (o2 = 16 - o2, n.update(ft4.alloc(o2, 0))), n.update(ft4.alloc(8, 0));
    var p3 = i * 8, y4 = ft4.alloc(8);
    y4.writeUIntBE(p3, 0, 8), n.update(y4), t._finID = n.state;
    var w2 = ft4.from(t._finID);
    return sb(w2), w2;
  }
  function mi2(t, e, r, n) {
    Ru.call(this);
    var i = ft4.alloc(4, 0);
    this._cipher = new fb.AES(e);
    var o2 = this._cipher.encryptBlock(i);
    this._ghash = new Iu(o2), r = hb(this, r, o2), this._prev = ft4.from(r), this._cache = ft4.allocUnsafe(0), this._secCache = ft4.allocUnsafe(0), this._decrypt = n, this._alen = 0, this._len = 0, this._mode = t, this._authTag = null, this._called = false;
  }
  nb(mi2, Ru);
  mi2.prototype._update = function(t) {
    if (!this._called && this._alen) {
      var e = 16 - this._alen % 16;
      e < 16 && (e = ft4.alloc(e, 0), this._ghash.update(e));
    }
    this._called = true;
    var r = this._mode.encrypt(this, t);
    return this._decrypt ? this._ghash.update(t) : this._ghash.update(r), this._len += t.length, r;
  };
  mi2.prototype._final = function() {
    if (this._decrypt && !this._authTag)
      throw new Error("Unsupported state or unable to authenticate data");
    var t = ab(this._ghash.final(this._alen * 8, this._len * 8), this._cipher.encryptBlock(this._finID));
    if (this._decrypt && ob(t, this._authTag))
      throw new Error("Unsupported state or unable to authenticate data");
    this._authTag = t, this._cipher.scrub();
  };
  mi2.prototype.getAuthTag = function() {
    if (this._decrypt || !ft4.isBuffer(this._authTag))
      throw new Error("Attempting to get auth tag in unsupported state");
    return this._authTag;
  };
  mi2.prototype.setAuthTag = function(e) {
    if (!this._decrypt)
      throw new Error("Attempting to set auth tag in unsupported state");
    this._authTag = e;
  };
  mi2.prototype.setAAD = function(e) {
    if (this._called)
      throw new Error("Attempting to set AAD in unsupported state");
    this._ghash.update(e), this._alen += e.length;
  };
  ku.exports = mi2;
});
var A0 = k2((X5, Pu) => {
  var ub = kf(), E0 = Ae().Buffer, Du = vr2(), db = qe();
  function Tn(t, e, r, n) {
    Du.call(this), this._cipher = new ub.AES(e), this._prev = E0.from(r), this._cache = E0.allocUnsafe(0), this._secCache = E0.allocUnsafe(0), this._decrypt = n, this._mode = t;
  }
  db(Tn, Du);
  Tn.prototype._update = function(t) {
    return this._mode.encrypt(this, t, this._decrypt);
  };
  Tn.prototype._final = function() {
    this._cipher.scrub();
  };
  Pu.exports = Tn;
});
var Pf = k2((Y5, Tu) => {
  var gi = Ae().Buffer, cb = vn();
  function lb(t, e, r, n) {
    if (gi.isBuffer(t) || (t = gi.from(t, "binary")), e && (gi.isBuffer(e) || (e = gi.from(e, "binary")), e.length !== 8))
      throw new RangeError("salt should be Buffer with 8 byte length");
    for (var i = r / 8, o2 = gi.alloc(i), p3 = gi.alloc(n || 0), y4 = gi.alloc(0); i > 0 || n > 0; ) {
      var w2 = new cb();
      w2.update(y4), w2.update(t), e && w2.update(e), y4 = w2.digest();
      var x = 0;
      if (i > 0) {
        var M4 = o2.length - i;
        x = Math.min(i, y4.length), y4.copy(o2, M4, 0, x), i -= x;
      }
      if (x < y4.length && n > 0) {
        var E2 = p3.length - n, A4 = Math.min(n, y4.length - x);
        y4.copy(p3, E2, x, x + A4), n -= A4;
      }
    }
    return y4.fill(0), { key: o2, iv: p3 };
  }
  Tu.exports = lb;
});
var Ou = k2((q0) => {
  var Cu = Dn(), vb = S0(), br = Ae().Buffer, pb = A0(), Nu = vr2(), bb = kf(), mb = Pf(), gb = qe();
  function Tf(t, e, r) {
    Nu.call(this), this._cache = new Cn(), this._cipher = new bb.AES(e), this._prev = br.from(r), this._mode = t, this._autopadding = true;
  }
  gb(Tf, Nu);
  Tf.prototype._update = function(t) {
    this._cache.add(t);
    for (var e, r, n = []; e = this._cache.get(); )
      r = this._mode.encrypt(this, e), n.push(r);
    return br.concat(n);
  };
  var yb = br.alloc(16, 16);
  Tf.prototype._final = function() {
    var t = this._cache.flush();
    if (this._autopadding)
      return t = this._mode.encrypt(this, t), this._cipher.scrub(), t;
    if (!t.equals(yb))
      throw this._cipher.scrub(), new Error("data not multiple of block length");
  };
  Tf.prototype.setAutoPadding = function(t) {
    return this._autopadding = !!t, this;
  };
  function Cn() {
    this.cache = br.allocUnsafe(0);
  }
  Cn.prototype.add = function(t) {
    this.cache = br.concat([this.cache, t]);
  };
  Cn.prototype.get = function() {
    if (this.cache.length > 15) {
      var t = this.cache.slice(0, 16);
      return this.cache = this.cache.slice(16), t;
    }
    return null;
  };
  Cn.prototype.flush = function() {
    for (var t = 16 - this.cache.length, e = br.allocUnsafe(t), r = -1; ++r < t; )
      e.writeUInt8(t, r);
    return br.concat([this.cache, e]);
  };
  function Lu(t, e, r) {
    var n = Cu[t.toLowerCase()];
    if (!n)
      throw new TypeError("invalid suite type");
    if (typeof e == "string" && (e = br.from(e)), e.length !== n.key / 8)
      throw new TypeError("invalid key length " + e.length);
    if (typeof r == "string" && (r = br.from(r)), n.mode !== "GCM" && r.length !== n.iv)
      throw new TypeError("invalid iv length " + r.length);
    return n.type === "stream" ? new pb(n.module, e, r) : n.type === "auth" ? new vb(n.module, e, r) : new Tf(n.module, e, r);
  }
  function _b(t, e) {
    var r = Cu[t.toLowerCase()];
    if (!r)
      throw new TypeError("invalid suite type");
    var n = mb(e, false, r.key, r.iv);
    return Lu(t, n.key, n.iv);
  }
  q0.createCipheriv = Lu;
  q0.createCipher = _b;
});
var Fu = k2((B0) => {
  var wb = S0(), Hi = Ae().Buffer, zu = Dn(), xb = A0(), Uu = vr2(), Mb = kf(), Sb = Pf(), Eb = qe();
  function Cf(t, e, r) {
    Uu.call(this), this._cache = new Nn(), this._last = void 0, this._cipher = new Mb.AES(e), this._prev = Hi.from(r), this._mode = t, this._autopadding = true;
  }
  Eb(Cf, Uu);
  Cf.prototype._update = function(t) {
    this._cache.add(t);
    for (var e, r, n = []; e = this._cache.get(this._autopadding); )
      r = this._mode.decrypt(this, e), n.push(r);
    return Hi.concat(n);
  };
  Cf.prototype._final = function() {
    var t = this._cache.flush();
    if (this._autopadding)
      return Ab(this._mode.decrypt(this, t));
    if (t)
      throw new Error("data not multiple of block length");
  };
  Cf.prototype.setAutoPadding = function(t) {
    return this._autopadding = !!t, this;
  };
  function Nn() {
    this.cache = Hi.allocUnsafe(0);
  }
  Nn.prototype.add = function(t) {
    this.cache = Hi.concat([this.cache, t]);
  };
  Nn.prototype.get = function(t) {
    var e;
    if (t) {
      if (this.cache.length > 16)
        return e = this.cache.slice(0, 16), this.cache = this.cache.slice(16), e;
    } else if (this.cache.length >= 16)
      return e = this.cache.slice(0, 16), this.cache = this.cache.slice(16), e;
    return null;
  };
  Nn.prototype.flush = function() {
    if (this.cache.length)
      return this.cache;
  };
  function Ab(t) {
    var e = t[15];
    if (e < 1 || e > 16)
      throw new Error("unable to decrypt data");
    for (var r = -1; ++r < e; )
      if (t[r + (16 - e)] !== e)
        throw new Error("unable to decrypt data");
    if (e !== 16)
      return t.slice(0, 16 - e);
  }
  function Hu(t, e, r) {
    var n = zu[t.toLowerCase()];
    if (!n)
      throw new TypeError("invalid suite type");
    if (typeof r == "string" && (r = Hi.from(r)), n.mode !== "GCM" && r.length !== n.iv)
      throw new TypeError("invalid iv length " + r.length);
    if (typeof e == "string" && (e = Hi.from(e)), e.length !== n.key / 8)
      throw new TypeError("invalid key length " + e.length);
    return n.type === "stream" ? new xb(n.module, e, r, true) : n.type === "auth" ? new wb(n.module, e, r, true) : new Cf(n.module, e, r);
  }
  function qb(t, e) {
    var r = zu[t.toLowerCase()];
    if (!r)
      throw new TypeError("invalid suite type");
    var n = Sb(e, false, r.key, r.iv);
    return Hu(t, n.key, n.iv);
  }
  B0.createDecipher = qb;
  B0.createDecipheriv = Hu;
});
var Ln = k2((Kt2) => {
  var Ku = Ou(), ju = Fu(), Bb = _0();
  function Rb() {
    return Object.keys(Bb);
  }
  Kt2.createCipher = Kt2.Cipher = Ku.createCipher;
  Kt2.createCipheriv = Kt2.Cipheriv = Ku.createCipheriv;
  Kt2.createDecipher = Kt2.Decipher = ju.createDecipher;
  Kt2.createDecipheriv = Kt2.Decipheriv = ju.createDecipheriv;
  Kt2.listCiphers = Kt2.getCiphers = Rb;
});
var Wu = k2((mr) => {
  mr["des-ecb"] = { key: 8, iv: 0 };
  mr["des-cbc"] = mr.des = { key: 8, iv: 8 };
  mr["des-ede3-cbc"] = mr.des3 = { key: 24, iv: 8 };
  mr["des-ede3"] = { key: 24, iv: 0 };
  mr["des-ede-cbc"] = { key: 16, iv: 8 };
  mr["des-ede"] = { key: 16, iv: 0 };
});
var Yu = k2((jt2) => {
  var Vu = au(), R0 = Ln(), Zr3 = Dn(), gr2 = Wu(), Zu = Pf();
  function Ib(t, e) {
    t = t.toLowerCase();
    var r, n;
    if (Zr3[t])
      r = Zr3[t].key, n = Zr3[t].iv;
    else if (gr2[t])
      r = gr2[t].key * 8, n = gr2[t].iv;
    else
      throw new TypeError("invalid suite type");
    var i = Zu(e, false, r, n);
    return Gu(t, i.key, i.iv);
  }
  function kb(t, e) {
    t = t.toLowerCase();
    var r, n;
    if (Zr3[t])
      r = Zr3[t].key, n = Zr3[t].iv;
    else if (gr2[t])
      r = gr2[t].key * 8, n = gr2[t].iv;
    else
      throw new TypeError("invalid suite type");
    var i = Zu(e, false, r, n);
    return Xu(t, i.key, i.iv);
  }
  function Gu(t, e, r) {
    if (t = t.toLowerCase(), Zr3[t])
      return R0.createCipheriv(t, e, r);
    if (gr2[t])
      return new Vu({ key: e, iv: r, mode: t });
    throw new TypeError("invalid suite type");
  }
  function Xu(t, e, r) {
    if (t = t.toLowerCase(), Zr3[t])
      return R0.createDecipheriv(t, e, r);
    if (gr2[t])
      return new Vu({ key: e, iv: r, mode: t, decrypt: true });
    throw new TypeError("invalid suite type");
  }
  function Db() {
    return Object.keys(gr2).concat(R0.getCiphers());
  }
  jt2.createCipher = jt2.Cipher = Ib;
  jt2.createCipheriv = jt2.Cipheriv = Gu;
  jt2.createDecipher = jt2.Decipher = kb;
  jt2.createDecipheriv = jt2.Decipheriv = Xu;
  jt2.listCiphers = jt2.getCiphers = Db;
});
var Fe = k2((Ju, I0) => {
  (function(t, e) {
    "use strict";
    function r(S3, v2) {
      if (!S3)
        throw new Error(v2 || "Assertion failed");
    }
    function n(S3, v2) {
      S3.super_ = v2;
      var _2 = function() {
      };
      _2.prototype = v2.prototype, S3.prototype = new _2(), S3.prototype.constructor = S3;
    }
    function i(S3, v2, _2) {
      if (i.isBN(S3))
        return S3;
      this.negative = 0, this.words = null, this.length = 0, this.red = null, S3 !== null && ((v2 === "le" || v2 === "be") && (_2 = v2, v2 = 10), this._init(S3 || 0, v2 || 10, _2 || "be"));
    }
    typeof t == "object" ? t.exports = i : e.BN = i, i.BN = i, i.wordSize = 26;
    var o2;
    try {
      typeof document < "u" && typeof window.Buffer < "u" ? o2 = window.Buffer : o2 = export_default.Buffer;
    } catch {
    }
    i.isBN = function(v2) {
      return v2 instanceof i ? true : v2 !== null && typeof v2 == "object" && v2.constructor.wordSize === i.wordSize && Array.isArray(v2.words);
    }, i.max = function(v2, _2) {
      return v2.cmp(_2) > 0 ? v2 : _2;
    }, i.min = function(v2, _2) {
      return v2.cmp(_2) < 0 ? v2 : _2;
    }, i.prototype._init = function(v2, _2, c5) {
      if (typeof v2 == "number")
        return this._initNumber(v2, _2, c5);
      if (typeof v2 == "object")
        return this._initArray(v2, _2, c5);
      _2 === "hex" && (_2 = 16), r(_2 === (_2 | 0) && _2 >= 2 && _2 <= 36), v2 = v2.toString().replace(/\s+/g, "");
      var f = 0;
      v2[0] === "-" && (f++, this.negative = 1), f < v2.length && (_2 === 16 ? this._parseHex(v2, f, c5) : (this._parseBase(v2, _2, f), c5 === "le" && this._initArray(this.toArray(), _2, c5)));
    }, i.prototype._initNumber = function(v2, _2, c5) {
      v2 < 0 && (this.negative = 1, v2 = -v2), v2 < 67108864 ? (this.words = [v2 & 67108863], this.length = 1) : v2 < 4503599627370496 ? (this.words = [v2 & 67108863, v2 / 67108864 & 67108863], this.length = 2) : (r(v2 < 9007199254740992), this.words = [v2 & 67108863, v2 / 67108864 & 67108863, 1], this.length = 3), c5 === "le" && this._initArray(this.toArray(), _2, c5);
    }, i.prototype._initArray = function(v2, _2, c5) {
      if (r(typeof v2.length == "number"), v2.length <= 0)
        return this.words = [0], this.length = 1, this;
      this.length = Math.ceil(v2.length / 3), this.words = new Array(this.length);
      for (var f = 0; f < this.length; f++)
        this.words[f] = 0;
      var a, u, l = 0;
      if (c5 === "be")
        for (f = v2.length - 1, a = 0; f >= 0; f -= 3)
          u = v2[f] | v2[f - 1] << 8 | v2[f - 2] << 16, this.words[a] |= u << l & 67108863, this.words[a + 1] = u >>> 26 - l & 67108863, l += 24, l >= 26 && (l -= 26, a++);
      else if (c5 === "le")
        for (f = 0, a = 0; f < v2.length; f += 3)
          u = v2[f] | v2[f + 1] << 8 | v2[f + 2] << 16, this.words[a] |= u << l & 67108863, this.words[a + 1] = u >>> 26 - l & 67108863, l += 24, l >= 26 && (l -= 26, a++);
      return this.strip();
    };
    function p3(S3, v2) {
      var _2 = S3.charCodeAt(v2);
      return _2 >= 65 && _2 <= 70 ? _2 - 55 : _2 >= 97 && _2 <= 102 ? _2 - 87 : _2 - 48 & 15;
    }
    function y4(S3, v2, _2) {
      var c5 = p3(S3, _2);
      return _2 - 1 >= v2 && (c5 |= p3(S3, _2 - 1) << 4), c5;
    }
    i.prototype._parseHex = function(v2, _2, c5) {
      this.length = Math.ceil((v2.length - _2) / 6), this.words = new Array(this.length);
      for (var f = 0; f < this.length; f++)
        this.words[f] = 0;
      var a = 0, u = 0, l;
      if (c5 === "be")
        for (f = v2.length - 1; f >= _2; f -= 2)
          l = y4(v2, _2, f) << a, this.words[u] |= l & 67108863, a >= 18 ? (a -= 18, u += 1, this.words[u] |= l >>> 26) : a += 8;
      else {
        var d4 = v2.length - _2;
        for (f = d4 % 2 === 0 ? _2 + 1 : _2; f < v2.length; f += 2)
          l = y4(v2, _2, f) << a, this.words[u] |= l & 67108863, a >= 18 ? (a -= 18, u += 1, this.words[u] |= l >>> 26) : a += 8;
      }
      this.strip();
    };
    function w2(S3, v2, _2, c5) {
      for (var f = 0, a = Math.min(S3.length, _2), u = v2; u < a; u++) {
        var l = S3.charCodeAt(u) - 48;
        f *= c5, l >= 49 ? f += l - 49 + 10 : l >= 17 ? f += l - 17 + 10 : f += l;
      }
      return f;
    }
    i.prototype._parseBase = function(v2, _2, c5) {
      this.words = [0], this.length = 1;
      for (var f = 0, a = 1; a <= 67108863; a *= _2)
        f++;
      f--, a = a / _2 | 0;
      for (var u = v2.length - c5, l = u % f, d4 = Math.min(u, u - l) + c5, h = 0, b2 = c5; b2 < d4; b2 += f)
        h = w2(v2, b2, b2 + f, _2), this.imuln(a), this.words[0] + h < 67108864 ? this.words[0] += h : this._iaddn(h);
      if (l !== 0) {
        var m3 = 1;
        for (h = w2(v2, b2, v2.length, _2), b2 = 0; b2 < l; b2++)
          m3 *= _2;
        this.imuln(m3), this.words[0] + h < 67108864 ? this.words[0] += h : this._iaddn(h);
      }
      this.strip();
    }, i.prototype.copy = function(v2) {
      v2.words = new Array(this.length);
      for (var _2 = 0; _2 < this.length; _2++)
        v2.words[_2] = this.words[_2];
      v2.length = this.length, v2.negative = this.negative, v2.red = this.red;
    }, i.prototype.clone = function() {
      var v2 = new i(null);
      return this.copy(v2), v2;
    }, i.prototype._expand = function(v2) {
      for (; this.length < v2; )
        this.words[this.length++] = 0;
      return this;
    }, i.prototype.strip = function() {
      for (; this.length > 1 && this.words[this.length - 1] === 0; )
        this.length--;
      return this._normSign();
    }, i.prototype._normSign = function() {
      return this.length === 1 && this.words[0] === 0 && (this.negative = 0), this;
    }, i.prototype.inspect = function() {
      return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
    };
    var x = ["", "0", "00", "000", "0000", "00000", "000000", "0000000", "00000000", "000000000", "0000000000", "00000000000", "000000000000", "0000000000000", "00000000000000", "000000000000000", "0000000000000000", "00000000000000000", "000000000000000000", "0000000000000000000", "00000000000000000000", "000000000000000000000", "0000000000000000000000", "00000000000000000000000", "000000000000000000000000", "0000000000000000000000000"], M4 = [0, 0, 25, 16, 12, 11, 10, 9, 8, 8, 7, 7, 7, 7, 6, 6, 6, 6, 6, 6, 6, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5], E2 = [0, 0, 33554432, 43046721, 16777216, 48828125, 60466176, 40353607, 16777216, 43046721, 1e7, 19487171, 35831808, 62748517, 7529536, 11390625, 16777216, 24137569, 34012224, 47045881, 64e6, 4084101, 5153632, 6436343, 7962624, 9765625, 11881376, 14348907, 17210368, 20511149, 243e5, 28629151, 33554432, 39135393, 45435424, 52521875, 60466176];
    i.prototype.toString = function(v2, _2) {
      v2 = v2 || 10, _2 = _2 | 0 || 1;
      var c5;
      if (v2 === 16 || v2 === "hex") {
        c5 = "";
        for (var f = 0, a = 0, u = 0; u < this.length; u++) {
          var l = this.words[u], d4 = ((l << f | a) & 16777215).toString(16);
          a = l >>> 24 - f & 16777215, a !== 0 || u !== this.length - 1 ? c5 = x[6 - d4.length] + d4 + c5 : c5 = d4 + c5, f += 2, f >= 26 && (f -= 26, u--);
        }
        for (a !== 0 && (c5 = a.toString(16) + c5); c5.length % _2 !== 0; )
          c5 = "0" + c5;
        return this.negative !== 0 && (c5 = "-" + c5), c5;
      }
      if (v2 === (v2 | 0) && v2 >= 2 && v2 <= 36) {
        var h = M4[v2], b2 = E2[v2];
        c5 = "";
        var m3 = this.clone();
        for (m3.negative = 0; !m3.isZero(); ) {
          var s = m3.modn(b2).toString(v2);
          m3 = m3.idivn(b2), m3.isZero() ? c5 = s + c5 : c5 = x[h - s.length] + s + c5;
        }
        for (this.isZero() && (c5 = "0" + c5); c5.length % _2 !== 0; )
          c5 = "0" + c5;
        return this.negative !== 0 && (c5 = "-" + c5), c5;
      }
      r(false, "Base should be between 2 and 36");
    }, i.prototype.toNumber = function() {
      var v2 = this.words[0];
      return this.length === 2 ? v2 += this.words[1] * 67108864 : this.length === 3 && this.words[2] === 1 ? v2 += 4503599627370496 + this.words[1] * 67108864 : this.length > 2 && r(false, "Number can only safely store up to 53 bits"), this.negative !== 0 ? -v2 : v2;
    }, i.prototype.toJSON = function() {
      return this.toString(16);
    }, i.prototype.toBuffer = function(v2, _2) {
      return r(typeof o2 < "u"), this.toArrayLike(o2, v2, _2);
    }, i.prototype.toArray = function(v2, _2) {
      return this.toArrayLike(Array, v2, _2);
    }, i.prototype.toArrayLike = function(v2, _2, c5) {
      var f = this.byteLength(), a = c5 || Math.max(1, f);
      r(f <= a, "byte array longer than desired length"), r(a > 0, "Requested array length <= 0"), this.strip();
      var u = _2 === "le", l = new v2(a), d4, h, b2 = this.clone();
      if (u) {
        for (h = 0; !b2.isZero(); h++)
          d4 = b2.andln(255), b2.iushrn(8), l[h] = d4;
        for (; h < a; h++)
          l[h] = 0;
      } else {
        for (h = 0; h < a - f; h++)
          l[h] = 0;
        for (h = 0; !b2.isZero(); h++)
          d4 = b2.andln(255), b2.iushrn(8), l[a - h - 1] = d4;
      }
      return l;
    }, Math.clz32 ? i.prototype._countBits = function(v2) {
      return 32 - Math.clz32(v2);
    } : i.prototype._countBits = function(v2) {
      var _2 = v2, c5 = 0;
      return _2 >= 4096 && (c5 += 13, _2 >>>= 13), _2 >= 64 && (c5 += 7, _2 >>>= 7), _2 >= 8 && (c5 += 4, _2 >>>= 4), _2 >= 2 && (c5 += 2, _2 >>>= 2), c5 + _2;
    }, i.prototype._zeroBits = function(v2) {
      if (v2 === 0)
        return 26;
      var _2 = v2, c5 = 0;
      return (_2 & 8191) === 0 && (c5 += 13, _2 >>>= 13), (_2 & 127) === 0 && (c5 += 7, _2 >>>= 7), (_2 & 15) === 0 && (c5 += 4, _2 >>>= 4), (_2 & 3) === 0 && (c5 += 2, _2 >>>= 2), (_2 & 1) === 0 && c5++, c5;
    }, i.prototype.bitLength = function() {
      var v2 = this.words[this.length - 1], _2 = this._countBits(v2);
      return (this.length - 1) * 26 + _2;
    };
    function A4(S3) {
      for (var v2 = new Array(S3.bitLength()), _2 = 0; _2 < v2.length; _2++) {
        var c5 = _2 / 26 | 0, f = _2 % 26;
        v2[_2] = (S3.words[c5] & 1 << f) >>> f;
      }
      return v2;
    }
    i.prototype.zeroBits = function() {
      if (this.isZero())
        return 0;
      for (var v2 = 0, _2 = 0; _2 < this.length; _2++) {
        var c5 = this._zeroBits(this.words[_2]);
        if (v2 += c5, c5 !== 26)
          break;
      }
      return v2;
    }, i.prototype.byteLength = function() {
      return Math.ceil(this.bitLength() / 8);
    }, i.prototype.toTwos = function(v2) {
      return this.negative !== 0 ? this.abs().inotn(v2).iaddn(1) : this.clone();
    }, i.prototype.fromTwos = function(v2) {
      return this.testn(v2 - 1) ? this.notn(v2).iaddn(1).ineg() : this.clone();
    }, i.prototype.isNeg = function() {
      return this.negative !== 0;
    }, i.prototype.neg = function() {
      return this.clone().ineg();
    }, i.prototype.ineg = function() {
      return this.isZero() || (this.negative ^= 1), this;
    }, i.prototype.iuor = function(v2) {
      for (; this.length < v2.length; )
        this.words[this.length++] = 0;
      for (var _2 = 0; _2 < v2.length; _2++)
        this.words[_2] = this.words[_2] | v2.words[_2];
      return this.strip();
    }, i.prototype.ior = function(v2) {
      return r((this.negative | v2.negative) === 0), this.iuor(v2);
    }, i.prototype.or = function(v2) {
      return this.length > v2.length ? this.clone().ior(v2) : v2.clone().ior(this);
    }, i.prototype.uor = function(v2) {
      return this.length > v2.length ? this.clone().iuor(v2) : v2.clone().iuor(this);
    }, i.prototype.iuand = function(v2) {
      var _2;
      this.length > v2.length ? _2 = v2 : _2 = this;
      for (var c5 = 0; c5 < _2.length; c5++)
        this.words[c5] = this.words[c5] & v2.words[c5];
      return this.length = _2.length, this.strip();
    }, i.prototype.iand = function(v2) {
      return r((this.negative | v2.negative) === 0), this.iuand(v2);
    }, i.prototype.and = function(v2) {
      return this.length > v2.length ? this.clone().iand(v2) : v2.clone().iand(this);
    }, i.prototype.uand = function(v2) {
      return this.length > v2.length ? this.clone().iuand(v2) : v2.clone().iuand(this);
    }, i.prototype.iuxor = function(v2) {
      var _2, c5;
      this.length > v2.length ? (_2 = this, c5 = v2) : (_2 = v2, c5 = this);
      for (var f = 0; f < c5.length; f++)
        this.words[f] = _2.words[f] ^ c5.words[f];
      if (this !== _2)
        for (; f < _2.length; f++)
          this.words[f] = _2.words[f];
      return this.length = _2.length, this.strip();
    }, i.prototype.ixor = function(v2) {
      return r((this.negative | v2.negative) === 0), this.iuxor(v2);
    }, i.prototype.xor = function(v2) {
      return this.length > v2.length ? this.clone().ixor(v2) : v2.clone().ixor(this);
    }, i.prototype.uxor = function(v2) {
      return this.length > v2.length ? this.clone().iuxor(v2) : v2.clone().iuxor(this);
    }, i.prototype.inotn = function(v2) {
      r(typeof v2 == "number" && v2 >= 0);
      var _2 = Math.ceil(v2 / 26) | 0, c5 = v2 % 26;
      this._expand(_2), c5 > 0 && _2--;
      for (var f = 0; f < _2; f++)
        this.words[f] = ~this.words[f] & 67108863;
      return c5 > 0 && (this.words[f] = ~this.words[f] & 67108863 >> 26 - c5), this.strip();
    }, i.prototype.notn = function(v2) {
      return this.clone().inotn(v2);
    }, i.prototype.setn = function(v2, _2) {
      r(typeof v2 == "number" && v2 >= 0);
      var c5 = v2 / 26 | 0, f = v2 % 26;
      return this._expand(c5 + 1), _2 ? this.words[c5] = this.words[c5] | 1 << f : this.words[c5] = this.words[c5] & ~(1 << f), this.strip();
    }, i.prototype.iadd = function(v2) {
      var _2;
      if (this.negative !== 0 && v2.negative === 0)
        return this.negative = 0, _2 = this.isub(v2), this.negative ^= 1, this._normSign();
      if (this.negative === 0 && v2.negative !== 0)
        return v2.negative = 0, _2 = this.isub(v2), v2.negative = 1, _2._normSign();
      var c5, f;
      this.length > v2.length ? (c5 = this, f = v2) : (c5 = v2, f = this);
      for (var a = 0, u = 0; u < f.length; u++)
        _2 = (c5.words[u] | 0) + (f.words[u] | 0) + a, this.words[u] = _2 & 67108863, a = _2 >>> 26;
      for (; a !== 0 && u < c5.length; u++)
        _2 = (c5.words[u] | 0) + a, this.words[u] = _2 & 67108863, a = _2 >>> 26;
      if (this.length = c5.length, a !== 0)
        this.words[this.length] = a, this.length++;
      else if (c5 !== this)
        for (; u < c5.length; u++)
          this.words[u] = c5.words[u];
      return this;
    }, i.prototype.add = function(v2) {
      var _2;
      return v2.negative !== 0 && this.negative === 0 ? (v2.negative = 0, _2 = this.sub(v2), v2.negative ^= 1, _2) : v2.negative === 0 && this.negative !== 0 ? (this.negative = 0, _2 = v2.sub(this), this.negative = 1, _2) : this.length > v2.length ? this.clone().iadd(v2) : v2.clone().iadd(this);
    }, i.prototype.isub = function(v2) {
      if (v2.negative !== 0) {
        v2.negative = 0;
        var _2 = this.iadd(v2);
        return v2.negative = 1, _2._normSign();
      } else if (this.negative !== 0)
        return this.negative = 0, this.iadd(v2), this.negative = 1, this._normSign();
      var c5 = this.cmp(v2);
      if (c5 === 0)
        return this.negative = 0, this.length = 1, this.words[0] = 0, this;
      var f, a;
      c5 > 0 ? (f = this, a = v2) : (f = v2, a = this);
      for (var u = 0, l = 0; l < a.length; l++)
        _2 = (f.words[l] | 0) - (a.words[l] | 0) + u, u = _2 >> 26, this.words[l] = _2 & 67108863;
      for (; u !== 0 && l < f.length; l++)
        _2 = (f.words[l] | 0) + u, u = _2 >> 26, this.words[l] = _2 & 67108863;
      if (u === 0 && l < f.length && f !== this)
        for (; l < f.length; l++)
          this.words[l] = f.words[l];
      return this.length = Math.max(this.length, l), f !== this && (this.negative = 1), this.strip();
    }, i.prototype.sub = function(v2) {
      return this.clone().isub(v2);
    };
    function I3(S3, v2, _2) {
      _2.negative = v2.negative ^ S3.negative;
      var c5 = S3.length + v2.length | 0;
      _2.length = c5, c5 = c5 - 1 | 0;
      var f = S3.words[0] | 0, a = v2.words[0] | 0, u = f * a, l = u & 67108863, d4 = u / 67108864 | 0;
      _2.words[0] = l;
      for (var h = 1; h < c5; h++) {
        for (var b2 = d4 >>> 26, m3 = d4 & 67108863, s = Math.min(h, v2.length - 1), g2 = Math.max(0, h - S3.length + 1); g2 <= s; g2++) {
          var q = h - g2 | 0;
          f = S3.words[q] | 0, a = v2.words[g2] | 0, u = f * a + m3, b2 += u / 67108864 | 0, m3 = u & 67108863;
        }
        _2.words[h] = m3 | 0, d4 = b2 | 0;
      }
      return d4 !== 0 ? _2.words[h] = d4 | 0 : _2.length--, _2.strip();
    }
    var D6 = function(v2, _2, c5) {
      var f = v2.words, a = _2.words, u = c5.words, l = 0, d4, h, b2, m3 = f[0] | 0, s = m3 & 8191, g2 = m3 >>> 13, q = f[1] | 0, R3 = q & 8191, B3 = q >>> 13, P2 = f[2] | 0, T4 = P2 & 8191, N4 = P2 >>> 13, ze = f[3] | 0, O = ze & 8191, z = ze >>> 13, Er3 = f[4] | 0, U2 = Er3 & 8191, H3 = Er3 >>> 13, Ar = f[5] | 0, F4 = Ar & 8191, K4 = Ar >>> 13, qr2 = f[6] | 0, j2 = qr2 & 8191, W4 = qr2 >>> 13, Br2 = f[7] | 0, V3 = Br2 & 8191, Z5 = Br2 >>> 13, Rr2 = f[8] | 0, G4 = Rr2 & 8191, X5 = Rr2 >>> 13, Ir2 = f[9] | 0, Y4 = Ir2 & 8191, J3 = Ir2 >>> 13, kr2 = a[0] | 0, $4 = kr2 & 8191, Q3 = kr2 >>> 13, Dr = a[1] | 0, ee2 = Dr & 8191, te = Dr >>> 13, Pr2 = a[2] | 0, re2 = Pr2 & 8191, ie = Pr2 >>> 13, Tr2 = a[3] | 0, fe = Tr2 & 8191, ne = Tr2 >>> 13, Cr2 = a[4] | 0, ae2 = Cr2 & 8191, se = Cr2 >>> 13, Nr2 = a[5] | 0, oe = Nr2 & 8191, he2 = Nr2 >>> 13, Lr4 = a[6] | 0, ue2 = Lr4 & 8191, de4 = Lr4 >>> 13, Or2 = a[7] | 0, ce2 = Or2 & 8191, le2 = Or2 >>> 13, zr = a[8] | 0, ve2 = zr & 8191, pe = zr >>> 13, Ur3 = a[9] | 0, be = Ur3 & 8191, me = Ur3 >>> 13;
      c5.negative = v2.negative ^ _2.negative, c5.length = 19, d4 = Math.imul(s, $4), h = Math.imul(s, Q3), h = h + Math.imul(g2, $4) | 0, b2 = Math.imul(g2, Q3);
      var dr2 = (l + d4 | 0) + ((h & 8191) << 13) | 0;
      l = (b2 + (h >>> 13) | 0) + (dr2 >>> 26) | 0, dr2 &= 67108863, d4 = Math.imul(R3, $4), h = Math.imul(R3, Q3), h = h + Math.imul(B3, $4) | 0, b2 = Math.imul(B3, Q3), d4 = d4 + Math.imul(s, ee2) | 0, h = h + Math.imul(s, te) | 0, h = h + Math.imul(g2, ee2) | 0, b2 = b2 + Math.imul(g2, te) | 0;
      var _e2 = (l + d4 | 0) + ((h & 8191) << 13) | 0;
      l = (b2 + (h >>> 13) | 0) + (_e2 >>> 26) | 0, _e2 &= 67108863, d4 = Math.imul(T4, $4), h = Math.imul(T4, Q3), h = h + Math.imul(N4, $4) | 0, b2 = Math.imul(N4, Q3), d4 = d4 + Math.imul(R3, ee2) | 0, h = h + Math.imul(R3, te) | 0, h = h + Math.imul(B3, ee2) | 0, b2 = b2 + Math.imul(B3, te) | 0, d4 = d4 + Math.imul(s, re2) | 0, h = h + Math.imul(s, ie) | 0, h = h + Math.imul(g2, re2) | 0, b2 = b2 + Math.imul(g2, ie) | 0;
      var we2 = (l + d4 | 0) + ((h & 8191) << 13) | 0;
      l = (b2 + (h >>> 13) | 0) + (we2 >>> 26) | 0, we2 &= 67108863, d4 = Math.imul(O, $4), h = Math.imul(O, Q3), h = h + Math.imul(z, $4) | 0, b2 = Math.imul(z, Q3), d4 = d4 + Math.imul(T4, ee2) | 0, h = h + Math.imul(T4, te) | 0, h = h + Math.imul(N4, ee2) | 0, b2 = b2 + Math.imul(N4, te) | 0, d4 = d4 + Math.imul(R3, re2) | 0, h = h + Math.imul(R3, ie) | 0, h = h + Math.imul(B3, re2) | 0, b2 = b2 + Math.imul(B3, ie) | 0, d4 = d4 + Math.imul(s, fe) | 0, h = h + Math.imul(s, ne) | 0, h = h + Math.imul(g2, fe) | 0, b2 = b2 + Math.imul(g2, ne) | 0;
      var At2 = (l + d4 | 0) + ((h & 8191) << 13) | 0;
      l = (b2 + (h >>> 13) | 0) + (At2 >>> 26) | 0, At2 &= 67108863, d4 = Math.imul(U2, $4), h = Math.imul(U2, Q3), h = h + Math.imul(H3, $4) | 0, b2 = Math.imul(H3, Q3), d4 = d4 + Math.imul(O, ee2) | 0, h = h + Math.imul(O, te) | 0, h = h + Math.imul(z, ee2) | 0, b2 = b2 + Math.imul(z, te) | 0, d4 = d4 + Math.imul(T4, re2) | 0, h = h + Math.imul(T4, ie) | 0, h = h + Math.imul(N4, re2) | 0, b2 = b2 + Math.imul(N4, ie) | 0, d4 = d4 + Math.imul(R3, fe) | 0, h = h + Math.imul(R3, ne) | 0, h = h + Math.imul(B3, fe) | 0, b2 = b2 + Math.imul(B3, ne) | 0, d4 = d4 + Math.imul(s, ae2) | 0, h = h + Math.imul(s, se) | 0, h = h + Math.imul(g2, ae2) | 0, b2 = b2 + Math.imul(g2, se) | 0;
      var qt2 = (l + d4 | 0) + ((h & 8191) << 13) | 0;
      l = (b2 + (h >>> 13) | 0) + (qt2 >>> 26) | 0, qt2 &= 67108863, d4 = Math.imul(F4, $4), h = Math.imul(F4, Q3), h = h + Math.imul(K4, $4) | 0, b2 = Math.imul(K4, Q3), d4 = d4 + Math.imul(U2, ee2) | 0, h = h + Math.imul(U2, te) | 0, h = h + Math.imul(H3, ee2) | 0, b2 = b2 + Math.imul(H3, te) | 0, d4 = d4 + Math.imul(O, re2) | 0, h = h + Math.imul(O, ie) | 0, h = h + Math.imul(z, re2) | 0, b2 = b2 + Math.imul(z, ie) | 0, d4 = d4 + Math.imul(T4, fe) | 0, h = h + Math.imul(T4, ne) | 0, h = h + Math.imul(N4, fe) | 0, b2 = b2 + Math.imul(N4, ne) | 0, d4 = d4 + Math.imul(R3, ae2) | 0, h = h + Math.imul(R3, se) | 0, h = h + Math.imul(B3, ae2) | 0, b2 = b2 + Math.imul(B3, se) | 0, d4 = d4 + Math.imul(s, oe) | 0, h = h + Math.imul(s, he2) | 0, h = h + Math.imul(g2, oe) | 0, b2 = b2 + Math.imul(g2, he2) | 0;
      var Bt = (l + d4 | 0) + ((h & 8191) << 13) | 0;
      l = (b2 + (h >>> 13) | 0) + (Bt >>> 26) | 0, Bt &= 67108863, d4 = Math.imul(j2, $4), h = Math.imul(j2, Q3), h = h + Math.imul(W4, $4) | 0, b2 = Math.imul(W4, Q3), d4 = d4 + Math.imul(F4, ee2) | 0, h = h + Math.imul(F4, te) | 0, h = h + Math.imul(K4, ee2) | 0, b2 = b2 + Math.imul(K4, te) | 0, d4 = d4 + Math.imul(U2, re2) | 0, h = h + Math.imul(U2, ie) | 0, h = h + Math.imul(H3, re2) | 0, b2 = b2 + Math.imul(H3, ie) | 0, d4 = d4 + Math.imul(O, fe) | 0, h = h + Math.imul(O, ne) | 0, h = h + Math.imul(z, fe) | 0, b2 = b2 + Math.imul(z, ne) | 0, d4 = d4 + Math.imul(T4, ae2) | 0, h = h + Math.imul(T4, se) | 0, h = h + Math.imul(N4, ae2) | 0, b2 = b2 + Math.imul(N4, se) | 0, d4 = d4 + Math.imul(R3, oe) | 0, h = h + Math.imul(R3, he2) | 0, h = h + Math.imul(B3, oe) | 0, b2 = b2 + Math.imul(B3, he2) | 0, d4 = d4 + Math.imul(s, ue2) | 0, h = h + Math.imul(s, de4) | 0, h = h + Math.imul(g2, ue2) | 0, b2 = b2 + Math.imul(g2, de4) | 0;
      var Rt2 = (l + d4 | 0) + ((h & 8191) << 13) | 0;
      l = (b2 + (h >>> 13) | 0) + (Rt2 >>> 26) | 0, Rt2 &= 67108863, d4 = Math.imul(V3, $4), h = Math.imul(V3, Q3), h = h + Math.imul(Z5, $4) | 0, b2 = Math.imul(Z5, Q3), d4 = d4 + Math.imul(j2, ee2) | 0, h = h + Math.imul(j2, te) | 0, h = h + Math.imul(W4, ee2) | 0, b2 = b2 + Math.imul(W4, te) | 0, d4 = d4 + Math.imul(F4, re2) | 0, h = h + Math.imul(F4, ie) | 0, h = h + Math.imul(K4, re2) | 0, b2 = b2 + Math.imul(K4, ie) | 0, d4 = d4 + Math.imul(U2, fe) | 0, h = h + Math.imul(U2, ne) | 0, h = h + Math.imul(H3, fe) | 0, b2 = b2 + Math.imul(H3, ne) | 0, d4 = d4 + Math.imul(O, ae2) | 0, h = h + Math.imul(O, se) | 0, h = h + Math.imul(z, ae2) | 0, b2 = b2 + Math.imul(z, se) | 0, d4 = d4 + Math.imul(T4, oe) | 0, h = h + Math.imul(T4, he2) | 0, h = h + Math.imul(N4, oe) | 0, b2 = b2 + Math.imul(N4, he2) | 0, d4 = d4 + Math.imul(R3, ue2) | 0, h = h + Math.imul(R3, de4) | 0, h = h + Math.imul(B3, ue2) | 0, b2 = b2 + Math.imul(B3, de4) | 0, d4 = d4 + Math.imul(s, ce2) | 0, h = h + Math.imul(s, le2) | 0, h = h + Math.imul(g2, ce2) | 0, b2 = b2 + Math.imul(g2, le2) | 0;
      var It2 = (l + d4 | 0) + ((h & 8191) << 13) | 0;
      l = (b2 + (h >>> 13) | 0) + (It2 >>> 26) | 0, It2 &= 67108863, d4 = Math.imul(G4, $4), h = Math.imul(G4, Q3), h = h + Math.imul(X5, $4) | 0, b2 = Math.imul(X5, Q3), d4 = d4 + Math.imul(V3, ee2) | 0, h = h + Math.imul(V3, te) | 0, h = h + Math.imul(Z5, ee2) | 0, b2 = b2 + Math.imul(Z5, te) | 0, d4 = d4 + Math.imul(j2, re2) | 0, h = h + Math.imul(j2, ie) | 0, h = h + Math.imul(W4, re2) | 0, b2 = b2 + Math.imul(W4, ie) | 0, d4 = d4 + Math.imul(F4, fe) | 0, h = h + Math.imul(F4, ne) | 0, h = h + Math.imul(K4, fe) | 0, b2 = b2 + Math.imul(K4, ne) | 0, d4 = d4 + Math.imul(U2, ae2) | 0, h = h + Math.imul(U2, se) | 0, h = h + Math.imul(H3, ae2) | 0, b2 = b2 + Math.imul(H3, se) | 0, d4 = d4 + Math.imul(O, oe) | 0, h = h + Math.imul(O, he2) | 0, h = h + Math.imul(z, oe) | 0, b2 = b2 + Math.imul(z, he2) | 0, d4 = d4 + Math.imul(T4, ue2) | 0, h = h + Math.imul(T4, de4) | 0, h = h + Math.imul(N4, ue2) | 0, b2 = b2 + Math.imul(N4, de4) | 0, d4 = d4 + Math.imul(R3, ce2) | 0, h = h + Math.imul(R3, le2) | 0, h = h + Math.imul(B3, ce2) | 0, b2 = b2 + Math.imul(B3, le2) | 0, d4 = d4 + Math.imul(s, ve2) | 0, h = h + Math.imul(s, pe) | 0, h = h + Math.imul(g2, ve2) | 0, b2 = b2 + Math.imul(g2, pe) | 0;
      var kt2 = (l + d4 | 0) + ((h & 8191) << 13) | 0;
      l = (b2 + (h >>> 13) | 0) + (kt2 >>> 26) | 0, kt2 &= 67108863, d4 = Math.imul(Y4, $4), h = Math.imul(Y4, Q3), h = h + Math.imul(J3, $4) | 0, b2 = Math.imul(J3, Q3), d4 = d4 + Math.imul(G4, ee2) | 0, h = h + Math.imul(G4, te) | 0, h = h + Math.imul(X5, ee2) | 0, b2 = b2 + Math.imul(X5, te) | 0, d4 = d4 + Math.imul(V3, re2) | 0, h = h + Math.imul(V3, ie) | 0, h = h + Math.imul(Z5, re2) | 0, b2 = b2 + Math.imul(Z5, ie) | 0, d4 = d4 + Math.imul(j2, fe) | 0, h = h + Math.imul(j2, ne) | 0, h = h + Math.imul(W4, fe) | 0, b2 = b2 + Math.imul(W4, ne) | 0, d4 = d4 + Math.imul(F4, ae2) | 0, h = h + Math.imul(F4, se) | 0, h = h + Math.imul(K4, ae2) | 0, b2 = b2 + Math.imul(K4, se) | 0, d4 = d4 + Math.imul(U2, oe) | 0, h = h + Math.imul(U2, he2) | 0, h = h + Math.imul(H3, oe) | 0, b2 = b2 + Math.imul(H3, he2) | 0, d4 = d4 + Math.imul(O, ue2) | 0, h = h + Math.imul(O, de4) | 0, h = h + Math.imul(z, ue2) | 0, b2 = b2 + Math.imul(z, de4) | 0, d4 = d4 + Math.imul(T4, ce2) | 0, h = h + Math.imul(T4, le2) | 0, h = h + Math.imul(N4, ce2) | 0, b2 = b2 + Math.imul(N4, le2) | 0, d4 = d4 + Math.imul(R3, ve2) | 0, h = h + Math.imul(R3, pe) | 0, h = h + Math.imul(B3, ve2) | 0, b2 = b2 + Math.imul(B3, pe) | 0, d4 = d4 + Math.imul(s, be) | 0, h = h + Math.imul(s, me) | 0, h = h + Math.imul(g2, be) | 0, b2 = b2 + Math.imul(g2, me) | 0;
      var Dt = (l + d4 | 0) + ((h & 8191) << 13) | 0;
      l = (b2 + (h >>> 13) | 0) + (Dt >>> 26) | 0, Dt &= 67108863, d4 = Math.imul(Y4, ee2), h = Math.imul(Y4, te), h = h + Math.imul(J3, ee2) | 0, b2 = Math.imul(J3, te), d4 = d4 + Math.imul(G4, re2) | 0, h = h + Math.imul(G4, ie) | 0, h = h + Math.imul(X5, re2) | 0, b2 = b2 + Math.imul(X5, ie) | 0, d4 = d4 + Math.imul(V3, fe) | 0, h = h + Math.imul(V3, ne) | 0, h = h + Math.imul(Z5, fe) | 0, b2 = b2 + Math.imul(Z5, ne) | 0, d4 = d4 + Math.imul(j2, ae2) | 0, h = h + Math.imul(j2, se) | 0, h = h + Math.imul(W4, ae2) | 0, b2 = b2 + Math.imul(W4, se) | 0, d4 = d4 + Math.imul(F4, oe) | 0, h = h + Math.imul(F4, he2) | 0, h = h + Math.imul(K4, oe) | 0, b2 = b2 + Math.imul(K4, he2) | 0, d4 = d4 + Math.imul(U2, ue2) | 0, h = h + Math.imul(U2, de4) | 0, h = h + Math.imul(H3, ue2) | 0, b2 = b2 + Math.imul(H3, de4) | 0, d4 = d4 + Math.imul(O, ce2) | 0, h = h + Math.imul(O, le2) | 0, h = h + Math.imul(z, ce2) | 0, b2 = b2 + Math.imul(z, le2) | 0, d4 = d4 + Math.imul(T4, ve2) | 0, h = h + Math.imul(T4, pe) | 0, h = h + Math.imul(N4, ve2) | 0, b2 = b2 + Math.imul(N4, pe) | 0, d4 = d4 + Math.imul(R3, be) | 0, h = h + Math.imul(R3, me) | 0, h = h + Math.imul(B3, be) | 0, b2 = b2 + Math.imul(B3, me) | 0;
      var Pt2 = (l + d4 | 0) + ((h & 8191) << 13) | 0;
      l = (b2 + (h >>> 13) | 0) + (Pt2 >>> 26) | 0, Pt2 &= 67108863, d4 = Math.imul(Y4, re2), h = Math.imul(Y4, ie), h = h + Math.imul(J3, re2) | 0, b2 = Math.imul(J3, ie), d4 = d4 + Math.imul(G4, fe) | 0, h = h + Math.imul(G4, ne) | 0, h = h + Math.imul(X5, fe) | 0, b2 = b2 + Math.imul(X5, ne) | 0, d4 = d4 + Math.imul(V3, ae2) | 0, h = h + Math.imul(V3, se) | 0, h = h + Math.imul(Z5, ae2) | 0, b2 = b2 + Math.imul(Z5, se) | 0, d4 = d4 + Math.imul(j2, oe) | 0, h = h + Math.imul(j2, he2) | 0, h = h + Math.imul(W4, oe) | 0, b2 = b2 + Math.imul(W4, he2) | 0, d4 = d4 + Math.imul(F4, ue2) | 0, h = h + Math.imul(F4, de4) | 0, h = h + Math.imul(K4, ue2) | 0, b2 = b2 + Math.imul(K4, de4) | 0, d4 = d4 + Math.imul(U2, ce2) | 0, h = h + Math.imul(U2, le2) | 0, h = h + Math.imul(H3, ce2) | 0, b2 = b2 + Math.imul(H3, le2) | 0, d4 = d4 + Math.imul(O, ve2) | 0, h = h + Math.imul(O, pe) | 0, h = h + Math.imul(z, ve2) | 0, b2 = b2 + Math.imul(z, pe) | 0, d4 = d4 + Math.imul(T4, be) | 0, h = h + Math.imul(T4, me) | 0, h = h + Math.imul(N4, be) | 0, b2 = b2 + Math.imul(N4, me) | 0;
      var Tt2 = (l + d4 | 0) + ((h & 8191) << 13) | 0;
      l = (b2 + (h >>> 13) | 0) + (Tt2 >>> 26) | 0, Tt2 &= 67108863, d4 = Math.imul(Y4, fe), h = Math.imul(Y4, ne), h = h + Math.imul(J3, fe) | 0, b2 = Math.imul(J3, ne), d4 = d4 + Math.imul(G4, ae2) | 0, h = h + Math.imul(G4, se) | 0, h = h + Math.imul(X5, ae2) | 0, b2 = b2 + Math.imul(X5, se) | 0, d4 = d4 + Math.imul(V3, oe) | 0, h = h + Math.imul(V3, he2) | 0, h = h + Math.imul(Z5, oe) | 0, b2 = b2 + Math.imul(Z5, he2) | 0, d4 = d4 + Math.imul(j2, ue2) | 0, h = h + Math.imul(j2, de4) | 0, h = h + Math.imul(W4, ue2) | 0, b2 = b2 + Math.imul(W4, de4) | 0, d4 = d4 + Math.imul(F4, ce2) | 0, h = h + Math.imul(F4, le2) | 0, h = h + Math.imul(K4, ce2) | 0, b2 = b2 + Math.imul(K4, le2) | 0, d4 = d4 + Math.imul(U2, ve2) | 0, h = h + Math.imul(U2, pe) | 0, h = h + Math.imul(H3, ve2) | 0, b2 = b2 + Math.imul(H3, pe) | 0, d4 = d4 + Math.imul(O, be) | 0, h = h + Math.imul(O, me) | 0, h = h + Math.imul(z, be) | 0, b2 = b2 + Math.imul(z, me) | 0;
      var Ct2 = (l + d4 | 0) + ((h & 8191) << 13) | 0;
      l = (b2 + (h >>> 13) | 0) + (Ct2 >>> 26) | 0, Ct2 &= 67108863, d4 = Math.imul(Y4, ae2), h = Math.imul(Y4, se), h = h + Math.imul(J3, ae2) | 0, b2 = Math.imul(J3, se), d4 = d4 + Math.imul(G4, oe) | 0, h = h + Math.imul(G4, he2) | 0, h = h + Math.imul(X5, oe) | 0, b2 = b2 + Math.imul(X5, he2) | 0, d4 = d4 + Math.imul(V3, ue2) | 0, h = h + Math.imul(V3, de4) | 0, h = h + Math.imul(Z5, ue2) | 0, b2 = b2 + Math.imul(Z5, de4) | 0, d4 = d4 + Math.imul(j2, ce2) | 0, h = h + Math.imul(j2, le2) | 0, h = h + Math.imul(W4, ce2) | 0, b2 = b2 + Math.imul(W4, le2) | 0, d4 = d4 + Math.imul(F4, ve2) | 0, h = h + Math.imul(F4, pe) | 0, h = h + Math.imul(K4, ve2) | 0, b2 = b2 + Math.imul(K4, pe) | 0, d4 = d4 + Math.imul(U2, be) | 0, h = h + Math.imul(U2, me) | 0, h = h + Math.imul(H3, be) | 0, b2 = b2 + Math.imul(H3, me) | 0;
      var Nt2 = (l + d4 | 0) + ((h & 8191) << 13) | 0;
      l = (b2 + (h >>> 13) | 0) + (Nt2 >>> 26) | 0, Nt2 &= 67108863, d4 = Math.imul(Y4, oe), h = Math.imul(Y4, he2), h = h + Math.imul(J3, oe) | 0, b2 = Math.imul(J3, he2), d4 = d4 + Math.imul(G4, ue2) | 0, h = h + Math.imul(G4, de4) | 0, h = h + Math.imul(X5, ue2) | 0, b2 = b2 + Math.imul(X5, de4) | 0, d4 = d4 + Math.imul(V3, ce2) | 0, h = h + Math.imul(V3, le2) | 0, h = h + Math.imul(Z5, ce2) | 0, b2 = b2 + Math.imul(Z5, le2) | 0, d4 = d4 + Math.imul(j2, ve2) | 0, h = h + Math.imul(j2, pe) | 0, h = h + Math.imul(W4, ve2) | 0, b2 = b2 + Math.imul(W4, pe) | 0, d4 = d4 + Math.imul(F4, be) | 0, h = h + Math.imul(F4, me) | 0, h = h + Math.imul(K4, be) | 0, b2 = b2 + Math.imul(K4, me) | 0;
      var Lt2 = (l + d4 | 0) + ((h & 8191) << 13) | 0;
      l = (b2 + (h >>> 13) | 0) + (Lt2 >>> 26) | 0, Lt2 &= 67108863, d4 = Math.imul(Y4, ue2), h = Math.imul(Y4, de4), h = h + Math.imul(J3, ue2) | 0, b2 = Math.imul(J3, de4), d4 = d4 + Math.imul(G4, ce2) | 0, h = h + Math.imul(G4, le2) | 0, h = h + Math.imul(X5, ce2) | 0, b2 = b2 + Math.imul(X5, le2) | 0, d4 = d4 + Math.imul(V3, ve2) | 0, h = h + Math.imul(V3, pe) | 0, h = h + Math.imul(Z5, ve2) | 0, b2 = b2 + Math.imul(Z5, pe) | 0, d4 = d4 + Math.imul(j2, be) | 0, h = h + Math.imul(j2, me) | 0, h = h + Math.imul(W4, be) | 0, b2 = b2 + Math.imul(W4, me) | 0;
      var Ot = (l + d4 | 0) + ((h & 8191) << 13) | 0;
      l = (b2 + (h >>> 13) | 0) + (Ot >>> 26) | 0, Ot &= 67108863, d4 = Math.imul(Y4, ce2), h = Math.imul(Y4, le2), h = h + Math.imul(J3, ce2) | 0, b2 = Math.imul(J3, le2), d4 = d4 + Math.imul(G4, ve2) | 0, h = h + Math.imul(G4, pe) | 0, h = h + Math.imul(X5, ve2) | 0, b2 = b2 + Math.imul(X5, pe) | 0, d4 = d4 + Math.imul(V3, be) | 0, h = h + Math.imul(V3, me) | 0, h = h + Math.imul(Z5, be) | 0, b2 = b2 + Math.imul(Z5, me) | 0;
      var zt2 = (l + d4 | 0) + ((h & 8191) << 13) | 0;
      l = (b2 + (h >>> 13) | 0) + (zt2 >>> 26) | 0, zt2 &= 67108863, d4 = Math.imul(Y4, ve2), h = Math.imul(Y4, pe), h = h + Math.imul(J3, ve2) | 0, b2 = Math.imul(J3, pe), d4 = d4 + Math.imul(G4, be) | 0, h = h + Math.imul(G4, me) | 0, h = h + Math.imul(X5, be) | 0, b2 = b2 + Math.imul(X5, me) | 0;
      var Ut = (l + d4 | 0) + ((h & 8191) << 13) | 0;
      l = (b2 + (h >>> 13) | 0) + (Ut >>> 26) | 0, Ut &= 67108863, d4 = Math.imul(Y4, be), h = Math.imul(Y4, me), h = h + Math.imul(J3, be) | 0, b2 = Math.imul(J3, me);
      var Ht = (l + d4 | 0) + ((h & 8191) << 13) | 0;
      return l = (b2 + (h >>> 13) | 0) + (Ht >>> 26) | 0, Ht &= 67108863, u[0] = dr2, u[1] = _e2, u[2] = we2, u[3] = At2, u[4] = qt2, u[5] = Bt, u[6] = Rt2, u[7] = It2, u[8] = kt2, u[9] = Dt, u[10] = Pt2, u[11] = Tt2, u[12] = Ct2, u[13] = Nt2, u[14] = Lt2, u[15] = Ot, u[16] = zt2, u[17] = Ut, u[18] = Ht, l !== 0 && (u[19] = l, c5.length++), c5;
    };
    Math.imul || (D6 = I3);
    function C(S3, v2, _2) {
      _2.negative = v2.negative ^ S3.negative, _2.length = S3.length + v2.length;
      for (var c5 = 0, f = 0, a = 0; a < _2.length - 1; a++) {
        var u = f;
        f = 0;
        for (var l = c5 & 67108863, d4 = Math.min(a, v2.length - 1), h = Math.max(0, a - S3.length + 1); h <= d4; h++) {
          var b2 = a - h, m3 = S3.words[b2] | 0, s = v2.words[h] | 0, g2 = m3 * s, q = g2 & 67108863;
          u = u + (g2 / 67108864 | 0) | 0, q = q + l | 0, l = q & 67108863, u = u + (q >>> 26) | 0, f += u >>> 26, u &= 67108863;
        }
        _2.words[a] = l, c5 = u, u = f;
      }
      return c5 !== 0 ? _2.words[a] = c5 : _2.length--, _2.strip();
    }
    function ge2(S3, v2, _2) {
      var c5 = new L4();
      return c5.mulp(S3, v2, _2);
    }
    i.prototype.mulTo = function(v2, _2) {
      var c5, f = this.length + v2.length;
      return this.length === 10 && v2.length === 10 ? c5 = D6(this, v2, _2) : f < 63 ? c5 = I3(this, v2, _2) : f < 1024 ? c5 = C(this, v2, _2) : c5 = ge2(this, v2, _2), c5;
    };
    function L4(S3, v2) {
      this.x = S3, this.y = v2;
    }
    L4.prototype.makeRBT = function(v2) {
      for (var _2 = new Array(v2), c5 = i.prototype._countBits(v2) - 1, f = 0; f < v2; f++)
        _2[f] = this.revBin(f, c5, v2);
      return _2;
    }, L4.prototype.revBin = function(v2, _2, c5) {
      if (v2 === 0 || v2 === c5 - 1)
        return v2;
      for (var f = 0, a = 0; a < _2; a++)
        f |= (v2 & 1) << _2 - a - 1, v2 >>= 1;
      return f;
    }, L4.prototype.permute = function(v2, _2, c5, f, a, u) {
      for (var l = 0; l < u; l++)
        f[l] = _2[v2[l]], a[l] = c5[v2[l]];
    }, L4.prototype.transform = function(v2, _2, c5, f, a, u) {
      this.permute(u, v2, _2, c5, f, a);
      for (var l = 1; l < a; l <<= 1)
        for (var d4 = l << 1, h = Math.cos(2 * Math.PI / d4), b2 = Math.sin(2 * Math.PI / d4), m3 = 0; m3 < a; m3 += d4)
          for (var s = h, g2 = b2, q = 0; q < l; q++) {
            var R3 = c5[m3 + q], B3 = f[m3 + q], P2 = c5[m3 + q + l], T4 = f[m3 + q + l], N4 = s * P2 - g2 * T4;
            T4 = s * T4 + g2 * P2, P2 = N4, c5[m3 + q] = R3 + P2, f[m3 + q] = B3 + T4, c5[m3 + q + l] = R3 - P2, f[m3 + q + l] = B3 - T4, q !== d4 && (N4 = h * s - b2 * g2, g2 = h * g2 + b2 * s, s = N4);
          }
    }, L4.prototype.guessLen13b = function(v2, _2) {
      var c5 = Math.max(_2, v2) | 1, f = c5 & 1, a = 0;
      for (c5 = c5 / 2 | 0; c5; c5 = c5 >>> 1)
        a++;
      return 1 << a + 1 + f;
    }, L4.prototype.conjugate = function(v2, _2, c5) {
      if (!(c5 <= 1))
        for (var f = 0; f < c5 / 2; f++) {
          var a = v2[f];
          v2[f] = v2[c5 - f - 1], v2[c5 - f - 1] = a, a = _2[f], _2[f] = -_2[c5 - f - 1], _2[c5 - f - 1] = -a;
        }
    }, L4.prototype.normalize13b = function(v2, _2) {
      for (var c5 = 0, f = 0; f < _2 / 2; f++) {
        var a = Math.round(v2[2 * f + 1] / _2) * 8192 + Math.round(v2[2 * f] / _2) + c5;
        v2[f] = a & 67108863, a < 67108864 ? c5 = 0 : c5 = a / 67108864 | 0;
      }
      return v2;
    }, L4.prototype.convert13b = function(v2, _2, c5, f) {
      for (var a = 0, u = 0; u < _2; u++)
        a = a + (v2[u] | 0), c5[2 * u] = a & 8191, a = a >>> 13, c5[2 * u + 1] = a & 8191, a = a >>> 13;
      for (u = 2 * _2; u < f; ++u)
        c5[u] = 0;
      r(a === 0), r((a & -8192) === 0);
    }, L4.prototype.stub = function(v2) {
      for (var _2 = new Array(v2), c5 = 0; c5 < v2; c5++)
        _2[c5] = 0;
      return _2;
    }, L4.prototype.mulp = function(v2, _2, c5) {
      var f = 2 * this.guessLen13b(v2.length, _2.length), a = this.makeRBT(f), u = this.stub(f), l = new Array(f), d4 = new Array(f), h = new Array(f), b2 = new Array(f), m3 = new Array(f), s = new Array(f), g2 = c5.words;
      g2.length = f, this.convert13b(v2.words, v2.length, l, f), this.convert13b(_2.words, _2.length, b2, f), this.transform(l, u, d4, h, f, a), this.transform(b2, u, m3, s, f, a);
      for (var q = 0; q < f; q++) {
        var R3 = d4[q] * m3[q] - h[q] * s[q];
        h[q] = d4[q] * s[q] + h[q] * m3[q], d4[q] = R3;
      }
      return this.conjugate(d4, h, f), this.transform(d4, h, g2, u, f, a), this.conjugate(g2, u, f), this.normalize13b(g2, f), c5.negative = v2.negative ^ _2.negative, c5.length = v2.length + _2.length, c5.strip();
    }, i.prototype.mul = function(v2) {
      var _2 = new i(null);
      return _2.words = new Array(this.length + v2.length), this.mulTo(v2, _2);
    }, i.prototype.mulf = function(v2) {
      var _2 = new i(null);
      return _2.words = new Array(this.length + v2.length), ge2(this, v2, _2);
    }, i.prototype.imul = function(v2) {
      return this.clone().mulTo(v2, this);
    }, i.prototype.imuln = function(v2) {
      r(typeof v2 == "number"), r(v2 < 67108864);
      for (var _2 = 0, c5 = 0; c5 < this.length; c5++) {
        var f = (this.words[c5] | 0) * v2, a = (f & 67108863) + (_2 & 67108863);
        _2 >>= 26, _2 += f / 67108864 | 0, _2 += a >>> 26, this.words[c5] = a & 67108863;
      }
      return _2 !== 0 && (this.words[c5] = _2, this.length++), this;
    }, i.prototype.muln = function(v2) {
      return this.clone().imuln(v2);
    }, i.prototype.sqr = function() {
      return this.mul(this);
    }, i.prototype.isqr = function() {
      return this.imul(this.clone());
    }, i.prototype.pow = function(v2) {
      var _2 = A4(v2);
      if (_2.length === 0)
        return new i(1);
      for (var c5 = this, f = 0; f < _2.length && _2[f] === 0; f++, c5 = c5.sqr())
        ;
      if (++f < _2.length)
        for (var a = c5.sqr(); f < _2.length; f++, a = a.sqr())
          _2[f] !== 0 && (c5 = c5.mul(a));
      return c5;
    }, i.prototype.iushln = function(v2) {
      r(typeof v2 == "number" && v2 >= 0);
      var _2 = v2 % 26, c5 = (v2 - _2) / 26, f = 67108863 >>> 26 - _2 << 26 - _2, a;
      if (_2 !== 0) {
        var u = 0;
        for (a = 0; a < this.length; a++) {
          var l = this.words[a] & f, d4 = (this.words[a] | 0) - l << _2;
          this.words[a] = d4 | u, u = l >>> 26 - _2;
        }
        u && (this.words[a] = u, this.length++);
      }
      if (c5 !== 0) {
        for (a = this.length - 1; a >= 0; a--)
          this.words[a + c5] = this.words[a];
        for (a = 0; a < c5; a++)
          this.words[a] = 0;
        this.length += c5;
      }
      return this.strip();
    }, i.prototype.ishln = function(v2) {
      return r(this.negative === 0), this.iushln(v2);
    }, i.prototype.iushrn = function(v2, _2, c5) {
      r(typeof v2 == "number" && v2 >= 0);
      var f;
      _2 ? f = (_2 - _2 % 26) / 26 : f = 0;
      var a = v2 % 26, u = Math.min((v2 - a) / 26, this.length), l = 67108863 ^ 67108863 >>> a << a, d4 = c5;
      if (f -= u, f = Math.max(0, f), d4) {
        for (var h = 0; h < u; h++)
          d4.words[h] = this.words[h];
        d4.length = u;
      }
      if (u !== 0)
        if (this.length > u)
          for (this.length -= u, h = 0; h < this.length; h++)
            this.words[h] = this.words[h + u];
        else
          this.words[0] = 0, this.length = 1;
      var b2 = 0;
      for (h = this.length - 1; h >= 0 && (b2 !== 0 || h >= f); h--) {
        var m3 = this.words[h] | 0;
        this.words[h] = b2 << 26 - a | m3 >>> a, b2 = m3 & l;
      }
      return d4 && b2 !== 0 && (d4.words[d4.length++] = b2), this.length === 0 && (this.words[0] = 0, this.length = 1), this.strip();
    }, i.prototype.ishrn = function(v2, _2, c5) {
      return r(this.negative === 0), this.iushrn(v2, _2, c5);
    }, i.prototype.shln = function(v2) {
      return this.clone().ishln(v2);
    }, i.prototype.ushln = function(v2) {
      return this.clone().iushln(v2);
    }, i.prototype.shrn = function(v2) {
      return this.clone().ishrn(v2);
    }, i.prototype.ushrn = function(v2) {
      return this.clone().iushrn(v2);
    }, i.prototype.testn = function(v2) {
      r(typeof v2 == "number" && v2 >= 0);
      var _2 = v2 % 26, c5 = (v2 - _2) / 26, f = 1 << _2;
      if (this.length <= c5)
        return false;
      var a = this.words[c5];
      return !!(a & f);
    }, i.prototype.imaskn = function(v2) {
      r(typeof v2 == "number" && v2 >= 0);
      var _2 = v2 % 26, c5 = (v2 - _2) / 26;
      if (r(this.negative === 0, "imaskn works only with positive numbers"), this.length <= c5)
        return this;
      if (_2 !== 0 && c5++, this.length = Math.min(c5, this.length), _2 !== 0) {
        var f = 67108863 ^ 67108863 >>> _2 << _2;
        this.words[this.length - 1] &= f;
      }
      return this.strip();
    }, i.prototype.maskn = function(v2) {
      return this.clone().imaskn(v2);
    }, i.prototype.iaddn = function(v2) {
      return r(typeof v2 == "number"), r(v2 < 67108864), v2 < 0 ? this.isubn(-v2) : this.negative !== 0 ? this.length === 1 && (this.words[0] | 0) < v2 ? (this.words[0] = v2 - (this.words[0] | 0), this.negative = 0, this) : (this.negative = 0, this.isubn(v2), this.negative = 1, this) : this._iaddn(v2);
    }, i.prototype._iaddn = function(v2) {
      this.words[0] += v2;
      for (var _2 = 0; _2 < this.length && this.words[_2] >= 67108864; _2++)
        this.words[_2] -= 67108864, _2 === this.length - 1 ? this.words[_2 + 1] = 1 : this.words[_2 + 1]++;
      return this.length = Math.max(this.length, _2 + 1), this;
    }, i.prototype.isubn = function(v2) {
      if (r(typeof v2 == "number"), r(v2 < 67108864), v2 < 0)
        return this.iaddn(-v2);
      if (this.negative !== 0)
        return this.negative = 0, this.iaddn(v2), this.negative = 1, this;
      if (this.words[0] -= v2, this.length === 1 && this.words[0] < 0)
        this.words[0] = -this.words[0], this.negative = 1;
      else
        for (var _2 = 0; _2 < this.length && this.words[_2] < 0; _2++)
          this.words[_2] += 67108864, this.words[_2 + 1] -= 1;
      return this.strip();
    }, i.prototype.addn = function(v2) {
      return this.clone().iaddn(v2);
    }, i.prototype.subn = function(v2) {
      return this.clone().isubn(v2);
    }, i.prototype.iabs = function() {
      return this.negative = 0, this;
    }, i.prototype.abs = function() {
      return this.clone().iabs();
    }, i.prototype._ishlnsubmul = function(v2, _2, c5) {
      var f = v2.length + c5, a;
      this._expand(f);
      var u, l = 0;
      for (a = 0; a < v2.length; a++) {
        u = (this.words[a + c5] | 0) + l;
        var d4 = (v2.words[a] | 0) * _2;
        u -= d4 & 67108863, l = (u >> 26) - (d4 / 67108864 | 0), this.words[a + c5] = u & 67108863;
      }
      for (; a < this.length - c5; a++)
        u = (this.words[a + c5] | 0) + l, l = u >> 26, this.words[a + c5] = u & 67108863;
      if (l === 0)
        return this.strip();
      for (r(l === -1), l = 0, a = 0; a < this.length; a++)
        u = -(this.words[a] | 0) + l, l = u >> 26, this.words[a] = u & 67108863;
      return this.negative = 1, this.strip();
    }, i.prototype._wordDiv = function(v2, _2) {
      var c5 = this.length - v2.length, f = this.clone(), a = v2, u = a.words[a.length - 1] | 0, l = this._countBits(u);
      c5 = 26 - l, c5 !== 0 && (a = a.ushln(c5), f.iushln(c5), u = a.words[a.length - 1] | 0);
      var d4 = f.length - a.length, h;
      if (_2 !== "mod") {
        h = new i(null), h.length = d4 + 1, h.words = new Array(h.length);
        for (var b2 = 0; b2 < h.length; b2++)
          h.words[b2] = 0;
      }
      var m3 = f.clone()._ishlnsubmul(a, 1, d4);
      m3.negative === 0 && (f = m3, h && (h.words[d4] = 1));
      for (var s = d4 - 1; s >= 0; s--) {
        var g2 = (f.words[a.length + s] | 0) * 67108864 + (f.words[a.length + s - 1] | 0);
        for (g2 = Math.min(g2 / u | 0, 67108863), f._ishlnsubmul(a, g2, s); f.negative !== 0; )
          g2--, f.negative = 0, f._ishlnsubmul(a, 1, s), f.isZero() || (f.negative ^= 1);
        h && (h.words[s] = g2);
      }
      return h && h.strip(), f.strip(), _2 !== "div" && c5 !== 0 && f.iushrn(c5), { div: h || null, mod: f };
    }, i.prototype.divmod = function(v2, _2, c5) {
      if (r(!v2.isZero()), this.isZero())
        return { div: new i(0), mod: new i(0) };
      var f, a, u;
      return this.negative !== 0 && v2.negative === 0 ? (u = this.neg().divmod(v2, _2), _2 !== "mod" && (f = u.div.neg()), _2 !== "div" && (a = u.mod.neg(), c5 && a.negative !== 0 && a.iadd(v2)), { div: f, mod: a }) : this.negative === 0 && v2.negative !== 0 ? (u = this.divmod(v2.neg(), _2), _2 !== "mod" && (f = u.div.neg()), { div: f, mod: u.mod }) : (this.negative & v2.negative) !== 0 ? (u = this.neg().divmod(v2.neg(), _2), _2 !== "div" && (a = u.mod.neg(), c5 && a.negative !== 0 && a.isub(v2)), { div: u.div, mod: a }) : v2.length > this.length || this.cmp(v2) < 0 ? { div: new i(0), mod: this } : v2.length === 1 ? _2 === "div" ? { div: this.divn(v2.words[0]), mod: null } : _2 === "mod" ? { div: null, mod: new i(this.modn(v2.words[0])) } : { div: this.divn(v2.words[0]), mod: new i(this.modn(v2.words[0])) } : this._wordDiv(v2, _2);
    }, i.prototype.div = function(v2) {
      return this.divmod(v2, "div", false).div;
    }, i.prototype.mod = function(v2) {
      return this.divmod(v2, "mod", false).mod;
    }, i.prototype.umod = function(v2) {
      return this.divmod(v2, "mod", true).mod;
    }, i.prototype.divRound = function(v2) {
      var _2 = this.divmod(v2);
      if (_2.mod.isZero())
        return _2.div;
      var c5 = _2.div.negative !== 0 ? _2.mod.isub(v2) : _2.mod, f = v2.ushrn(1), a = v2.andln(1), u = c5.cmp(f);
      return u < 0 || a === 1 && u === 0 ? _2.div : _2.div.negative !== 0 ? _2.div.isubn(1) : _2.div.iaddn(1);
    }, i.prototype.modn = function(v2) {
      r(v2 <= 67108863);
      for (var _2 = (1 << 26) % v2, c5 = 0, f = this.length - 1; f >= 0; f--)
        c5 = (_2 * c5 + (this.words[f] | 0)) % v2;
      return c5;
    }, i.prototype.idivn = function(v2) {
      r(v2 <= 67108863);
      for (var _2 = 0, c5 = this.length - 1; c5 >= 0; c5--) {
        var f = (this.words[c5] | 0) + _2 * 67108864;
        this.words[c5] = f / v2 | 0, _2 = f % v2;
      }
      return this.strip();
    }, i.prototype.divn = function(v2) {
      return this.clone().idivn(v2);
    }, i.prototype.egcd = function(v2) {
      r(v2.negative === 0), r(!v2.isZero());
      var _2 = this, c5 = v2.clone();
      _2.negative !== 0 ? _2 = _2.umod(v2) : _2 = _2.clone();
      for (var f = new i(1), a = new i(0), u = new i(0), l = new i(1), d4 = 0; _2.isEven() && c5.isEven(); )
        _2.iushrn(1), c5.iushrn(1), ++d4;
      for (var h = c5.clone(), b2 = _2.clone(); !_2.isZero(); ) {
        for (var m3 = 0, s = 1; (_2.words[0] & s) === 0 && m3 < 26; ++m3, s <<= 1)
          ;
        if (m3 > 0)
          for (_2.iushrn(m3); m3-- > 0; )
            (f.isOdd() || a.isOdd()) && (f.iadd(h), a.isub(b2)), f.iushrn(1), a.iushrn(1);
        for (var g2 = 0, q = 1; (c5.words[0] & q) === 0 && g2 < 26; ++g2, q <<= 1)
          ;
        if (g2 > 0)
          for (c5.iushrn(g2); g2-- > 0; )
            (u.isOdd() || l.isOdd()) && (u.iadd(h), l.isub(b2)), u.iushrn(1), l.iushrn(1);
        _2.cmp(c5) >= 0 ? (_2.isub(c5), f.isub(u), a.isub(l)) : (c5.isub(_2), u.isub(f), l.isub(a));
      }
      return { a: u, b: l, gcd: c5.iushln(d4) };
    }, i.prototype._invmp = function(v2) {
      r(v2.negative === 0), r(!v2.isZero());
      var _2 = this, c5 = v2.clone();
      _2.negative !== 0 ? _2 = _2.umod(v2) : _2 = _2.clone();
      for (var f = new i(1), a = new i(0), u = c5.clone(); _2.cmpn(1) > 0 && c5.cmpn(1) > 0; ) {
        for (var l = 0, d4 = 1; (_2.words[0] & d4) === 0 && l < 26; ++l, d4 <<= 1)
          ;
        if (l > 0)
          for (_2.iushrn(l); l-- > 0; )
            f.isOdd() && f.iadd(u), f.iushrn(1);
        for (var h = 0, b2 = 1; (c5.words[0] & b2) === 0 && h < 26; ++h, b2 <<= 1)
          ;
        if (h > 0)
          for (c5.iushrn(h); h-- > 0; )
            a.isOdd() && a.iadd(u), a.iushrn(1);
        _2.cmp(c5) >= 0 ? (_2.isub(c5), f.isub(a)) : (c5.isub(_2), a.isub(f));
      }
      var m3;
      return _2.cmpn(1) === 0 ? m3 = f : m3 = a, m3.cmpn(0) < 0 && m3.iadd(v2), m3;
    }, i.prototype.gcd = function(v2) {
      if (this.isZero())
        return v2.abs();
      if (v2.isZero())
        return this.abs();
      var _2 = this.clone(), c5 = v2.clone();
      _2.negative = 0, c5.negative = 0;
      for (var f = 0; _2.isEven() && c5.isEven(); f++)
        _2.iushrn(1), c5.iushrn(1);
      do {
        for (; _2.isEven(); )
          _2.iushrn(1);
        for (; c5.isEven(); )
          c5.iushrn(1);
        var a = _2.cmp(c5);
        if (a < 0) {
          var u = _2;
          _2 = c5, c5 = u;
        } else if (a === 0 || c5.cmpn(1) === 0)
          break;
        _2.isub(c5);
      } while (true);
      return c5.iushln(f);
    }, i.prototype.invm = function(v2) {
      return this.egcd(v2).a.umod(v2);
    }, i.prototype.isEven = function() {
      return (this.words[0] & 1) === 0;
    }, i.prototype.isOdd = function() {
      return (this.words[0] & 1) === 1;
    }, i.prototype.andln = function(v2) {
      return this.words[0] & v2;
    }, i.prototype.bincn = function(v2) {
      r(typeof v2 == "number");
      var _2 = v2 % 26, c5 = (v2 - _2) / 26, f = 1 << _2;
      if (this.length <= c5)
        return this._expand(c5 + 1), this.words[c5] |= f, this;
      for (var a = f, u = c5; a !== 0 && u < this.length; u++) {
        var l = this.words[u] | 0;
        l += a, a = l >>> 26, l &= 67108863, this.words[u] = l;
      }
      return a !== 0 && (this.words[u] = a, this.length++), this;
    }, i.prototype.isZero = function() {
      return this.length === 1 && this.words[0] === 0;
    }, i.prototype.cmpn = function(v2) {
      var _2 = v2 < 0;
      if (this.negative !== 0 && !_2)
        return -1;
      if (this.negative === 0 && _2)
        return 1;
      this.strip();
      var c5;
      if (this.length > 1)
        c5 = 1;
      else {
        _2 && (v2 = -v2), r(v2 <= 67108863, "Number is too big");
        var f = this.words[0] | 0;
        c5 = f === v2 ? 0 : f < v2 ? -1 : 1;
      }
      return this.negative !== 0 ? -c5 | 0 : c5;
    }, i.prototype.cmp = function(v2) {
      if (this.negative !== 0 && v2.negative === 0)
        return -1;
      if (this.negative === 0 && v2.negative !== 0)
        return 1;
      var _2 = this.ucmp(v2);
      return this.negative !== 0 ? -_2 | 0 : _2;
    }, i.prototype.ucmp = function(v2) {
      if (this.length > v2.length)
        return 1;
      if (this.length < v2.length)
        return -1;
      for (var _2 = 0, c5 = this.length - 1; c5 >= 0; c5--) {
        var f = this.words[c5] | 0, a = v2.words[c5] | 0;
        if (f !== a) {
          f < a ? _2 = -1 : f > a && (_2 = 1);
          break;
        }
      }
      return _2;
    }, i.prototype.gtn = function(v2) {
      return this.cmpn(v2) === 1;
    }, i.prototype.gt = function(v2) {
      return this.cmp(v2) === 1;
    }, i.prototype.gten = function(v2) {
      return this.cmpn(v2) >= 0;
    }, i.prototype.gte = function(v2) {
      return this.cmp(v2) >= 0;
    }, i.prototype.ltn = function(v2) {
      return this.cmpn(v2) === -1;
    }, i.prototype.lt = function(v2) {
      return this.cmp(v2) === -1;
    }, i.prototype.lten = function(v2) {
      return this.cmpn(v2) <= 0;
    }, i.prototype.lte = function(v2) {
      return this.cmp(v2) <= 0;
    }, i.prototype.eqn = function(v2) {
      return this.cmpn(v2) === 0;
    }, i.prototype.eq = function(v2) {
      return this.cmp(v2) === 0;
    }, i.red = function(v2) {
      return new Ee2(v2);
    }, i.prototype.toRed = function(v2) {
      return r(!this.red, "Already a number in reduction context"), r(this.negative === 0, "red works only with positives"), v2.convertTo(this)._forceRed(v2);
    }, i.prototype.fromRed = function() {
      return r(this.red, "fromRed works only with numbers in reduction context"), this.red.convertFrom(this);
    }, i.prototype._forceRed = function(v2) {
      return this.red = v2, this;
    }, i.prototype.forceRed = function(v2) {
      return r(!this.red, "Already a number in reduction context"), this._forceRed(v2);
    }, i.prototype.redAdd = function(v2) {
      return r(this.red, "redAdd works only with red numbers"), this.red.add(this, v2);
    }, i.prototype.redIAdd = function(v2) {
      return r(this.red, "redIAdd works only with red numbers"), this.red.iadd(this, v2);
    }, i.prototype.redSub = function(v2) {
      return r(this.red, "redSub works only with red numbers"), this.red.sub(this, v2);
    }, i.prototype.redISub = function(v2) {
      return r(this.red, "redISub works only with red numbers"), this.red.isub(this, v2);
    }, i.prototype.redShl = function(v2) {
      return r(this.red, "redShl works only with red numbers"), this.red.shl(this, v2);
    }, i.prototype.redMul = function(v2) {
      return r(this.red, "redMul works only with red numbers"), this.red._verify2(this, v2), this.red.mul(this, v2);
    }, i.prototype.redIMul = function(v2) {
      return r(this.red, "redMul works only with red numbers"), this.red._verify2(this, v2), this.red.imul(this, v2);
    }, i.prototype.redSqr = function() {
      return r(this.red, "redSqr works only with red numbers"), this.red._verify1(this), this.red.sqr(this);
    }, i.prototype.redISqr = function() {
      return r(this.red, "redISqr works only with red numbers"), this.red._verify1(this), this.red.isqr(this);
    }, i.prototype.redSqrt = function() {
      return r(this.red, "redSqrt works only with red numbers"), this.red._verify1(this), this.red.sqrt(this);
    }, i.prototype.redInvm = function() {
      return r(this.red, "redInvm works only with red numbers"), this.red._verify1(this), this.red.invm(this);
    }, i.prototype.redNeg = function() {
      return r(this.red, "redNeg works only with red numbers"), this.red._verify1(this), this.red.neg(this);
    }, i.prototype.redPow = function(v2) {
      return r(this.red && !v2.red, "redPow(normalNum)"), this.red._verify1(this), this.red.pow(this, v2);
    };
    var ye = { k256: null, p224: null, p192: null, p25519: null };
    function Re(S3, v2) {
      this.name = S3, this.p = new i(v2, 16), this.n = this.p.bitLength(), this.k = new i(1).iushln(this.n).isub(this.p), this.tmp = this._tmp();
    }
    Re.prototype._tmp = function() {
      var v2 = new i(null);
      return v2.words = new Array(Math.ceil(this.n / 13)), v2;
    }, Re.prototype.ireduce = function(v2) {
      var _2 = v2, c5;
      do
        this.split(_2, this.tmp), _2 = this.imulK(_2), _2 = _2.iadd(this.tmp), c5 = _2.bitLength();
      while (c5 > this.n);
      var f = c5 < this.n ? -1 : _2.ucmp(this.p);
      return f === 0 ? (_2.words[0] = 0, _2.length = 1) : f > 0 ? _2.isub(this.p) : _2.strip !== void 0 ? _2.strip() : _2._strip(), _2;
    }, Re.prototype.split = function(v2, _2) {
      v2.iushrn(this.n, 0, _2);
    }, Re.prototype.imulK = function(v2) {
      return v2.imul(this.k);
    };
    function xe3() {
      Re.call(this, "k256", "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f");
    }
    n(xe3, Re), xe3.prototype.split = function(v2, _2) {
      for (var c5 = 4194303, f = Math.min(v2.length, 9), a = 0; a < f; a++)
        _2.words[a] = v2.words[a];
      if (_2.length = f, v2.length <= 9) {
        v2.words[0] = 0, v2.length = 1;
        return;
      }
      var u = v2.words[9];
      for (_2.words[_2.length++] = u & c5, a = 10; a < v2.length; a++) {
        var l = v2.words[a] | 0;
        v2.words[a - 10] = (l & c5) << 4 | u >>> 22, u = l;
      }
      u >>>= 22, v2.words[a - 10] = u, u === 0 && v2.length > 10 ? v2.length -= 10 : v2.length -= 9;
    }, xe3.prototype.imulK = function(v2) {
      v2.words[v2.length] = 0, v2.words[v2.length + 1] = 0, v2.length += 2;
      for (var _2 = 0, c5 = 0; c5 < v2.length; c5++) {
        var f = v2.words[c5] | 0;
        _2 += f * 977, v2.words[c5] = _2 & 67108863, _2 = f * 64 + (_2 / 67108864 | 0);
      }
      return v2.words[v2.length - 1] === 0 && (v2.length--, v2.words[v2.length - 1] === 0 && v2.length--), v2;
    };
    function ke() {
      Re.call(this, "p224", "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001");
    }
    n(ke, Re);
    function Me() {
      Re.call(this, "p192", "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff");
    }
    n(Me, Re);
    function Ce3() {
      Re.call(this, "25519", "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed");
    }
    n(Ce3, Re), Ce3.prototype.imulK = function(v2) {
      for (var _2 = 0, c5 = 0; c5 < v2.length; c5++) {
        var f = (v2.words[c5] | 0) * 19 + _2, a = f & 67108863;
        f >>>= 26, v2.words[c5] = a, _2 = f;
      }
      return _2 !== 0 && (v2.words[v2.length++] = _2), v2;
    }, i._prime = function(v2) {
      if (ye[v2])
        return ye[v2];
      var _2;
      if (v2 === "k256")
        _2 = new xe3();
      else if (v2 === "p224")
        _2 = new ke();
      else if (v2 === "p192")
        _2 = new Me();
      else if (v2 === "p25519")
        _2 = new Ce3();
      else
        throw new Error("Unknown prime " + v2);
      return ye[v2] = _2, _2;
    };
    function Ee2(S3) {
      if (typeof S3 == "string") {
        var v2 = i._prime(S3);
        this.m = v2.p, this.prime = v2;
      } else
        r(S3.gtn(1), "modulus must be greater than 1"), this.m = S3, this.prime = null;
    }
    Ee2.prototype._verify1 = function(v2) {
      r(v2.negative === 0, "red works only with positives"), r(v2.red, "red works only with red numbers");
    }, Ee2.prototype._verify2 = function(v2, _2) {
      r((v2.negative | _2.negative) === 0, "red works only with positives"), r(v2.red && v2.red === _2.red, "red works only with red numbers");
    }, Ee2.prototype.imod = function(v2) {
      return this.prime ? this.prime.ireduce(v2)._forceRed(this) : v2.umod(this.m)._forceRed(this);
    }, Ee2.prototype.neg = function(v2) {
      return v2.isZero() ? v2.clone() : this.m.sub(v2)._forceRed(this);
    }, Ee2.prototype.add = function(v2, _2) {
      this._verify2(v2, _2);
      var c5 = v2.add(_2);
      return c5.cmp(this.m) >= 0 && c5.isub(this.m), c5._forceRed(this);
    }, Ee2.prototype.iadd = function(v2, _2) {
      this._verify2(v2, _2);
      var c5 = v2.iadd(_2);
      return c5.cmp(this.m) >= 0 && c5.isub(this.m), c5;
    }, Ee2.prototype.sub = function(v2, _2) {
      this._verify2(v2, _2);
      var c5 = v2.sub(_2);
      return c5.cmpn(0) < 0 && c5.iadd(this.m), c5._forceRed(this);
    }, Ee2.prototype.isub = function(v2, _2) {
      this._verify2(v2, _2);
      var c5 = v2.isub(_2);
      return c5.cmpn(0) < 0 && c5.iadd(this.m), c5;
    }, Ee2.prototype.shl = function(v2, _2) {
      return this._verify1(v2), this.imod(v2.ushln(_2));
    }, Ee2.prototype.imul = function(v2, _2) {
      return this._verify2(v2, _2), this.imod(v2.imul(_2));
    }, Ee2.prototype.mul = function(v2, _2) {
      return this._verify2(v2, _2), this.imod(v2.mul(_2));
    }, Ee2.prototype.isqr = function(v2) {
      return this.imul(v2, v2.clone());
    }, Ee2.prototype.sqr = function(v2) {
      return this.mul(v2, v2);
    }, Ee2.prototype.sqrt = function(v2) {
      if (v2.isZero())
        return v2.clone();
      var _2 = this.m.andln(3);
      if (r(_2 % 2 === 1), _2 === 3) {
        var c5 = this.m.add(new i(1)).iushrn(2);
        return this.pow(v2, c5);
      }
      for (var f = this.m.subn(1), a = 0; !f.isZero() && f.andln(1) === 0; )
        a++, f.iushrn(1);
      r(!f.isZero());
      var u = new i(1).toRed(this), l = u.redNeg(), d4 = this.m.subn(1).iushrn(1), h = this.m.bitLength();
      for (h = new i(2 * h * h).toRed(this); this.pow(h, d4).cmp(l) !== 0; )
        h.redIAdd(l);
      for (var b2 = this.pow(h, f), m3 = this.pow(v2, f.addn(1).iushrn(1)), s = this.pow(v2, f), g2 = a; s.cmp(u) !== 0; ) {
        for (var q = s, R3 = 0; q.cmp(u) !== 0; R3++)
          q = q.redSqr();
        r(R3 < g2);
        var B3 = this.pow(b2, new i(1).iushln(g2 - R3 - 1));
        m3 = m3.redMul(B3), b2 = B3.redSqr(), s = s.redMul(b2), g2 = R3;
      }
      return m3;
    }, Ee2.prototype.invm = function(v2) {
      var _2 = v2._invmp(this.m);
      return _2.negative !== 0 ? (_2.negative = 0, this.imod(_2).redNeg()) : this.imod(_2);
    }, Ee2.prototype.pow = function(v2, _2) {
      if (_2.isZero())
        return new i(1).toRed(this);
      if (_2.cmpn(1) === 0)
        return v2.clone();
      var c5 = 4, f = new Array(1 << c5);
      f[0] = new i(1).toRed(this), f[1] = v2;
      for (var a = 2; a < f.length; a++)
        f[a] = this.mul(f[a - 1], v2);
      var u = f[0], l = 0, d4 = 0, h = _2.bitLength() % 26;
      for (h === 0 && (h = 26), a = _2.length - 1; a >= 0; a--) {
        for (var b2 = _2.words[a], m3 = h - 1; m3 >= 0; m3--) {
          var s = b2 >> m3 & 1;
          if (u !== f[0] && (u = this.sqr(u)), s === 0 && l === 0) {
            d4 = 0;
            continue;
          }
          l <<= 1, l |= s, d4++, !(d4 !== c5 && (a !== 0 || m3 !== 0)) && (u = this.mul(u, f[l]), d4 = 0, l = 0);
        }
        h = 26;
      }
      return u;
    }, Ee2.prototype.convertTo = function(v2) {
      var _2 = v2.umod(this.m);
      return _2 === v2 ? _2.clone() : _2;
    }, Ee2.prototype.convertFrom = function(v2) {
      var _2 = v2.clone();
      return _2.red = null, _2;
    }, i.mont = function(v2) {
      return new Ne3(v2);
    };
    function Ne3(S3) {
      Ee2.call(this, S3), this.shift = this.m.bitLength(), this.shift % 26 !== 0 && (this.shift += 26 - this.shift % 26), this.r = new i(1).iushln(this.shift), this.r2 = this.imod(this.r.sqr()), this.rinv = this.r._invmp(this.m), this.minv = this.rinv.mul(this.r).isubn(1).div(this.m), this.minv = this.minv.umod(this.r), this.minv = this.r.sub(this.minv);
    }
    n(Ne3, Ee2), Ne3.prototype.convertTo = function(v2) {
      return this.imod(v2.ushln(this.shift));
    }, Ne3.prototype.convertFrom = function(v2) {
      var _2 = this.imod(v2.mul(this.rinv));
      return _2.red = null, _2;
    }, Ne3.prototype.imul = function(v2, _2) {
      if (v2.isZero() || _2.isZero())
        return v2.words[0] = 0, v2.length = 1, v2;
      var c5 = v2.imul(_2), f = c5.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), a = c5.isub(f).iushrn(this.shift), u = a;
      return a.cmp(this.m) >= 0 ? u = a.isub(this.m) : a.cmpn(0) < 0 && (u = a.iadd(this.m)), u._forceRed(this);
    }, Ne3.prototype.mul = function(v2, _2) {
      if (v2.isZero() || _2.isZero())
        return new i(0)._forceRed(this);
      var c5 = v2.mul(_2), f = c5.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), a = c5.isub(f).iushrn(this.shift), u = a;
      return a.cmp(this.m) >= 0 ? u = a.isub(this.m) : a.cmpn(0) < 0 && (u = a.iadd(this.m)), u._forceRed(this);
    }, Ne3.prototype.invm = function(v2) {
      var _2 = this.imod(v2._invmp(this.m).mul(this.r2));
      return _2._forceRed(this);
    };
  })(typeof I0 > "u" || I0, Ju);
});
var On = k2((rm, P0) => {
  var k0;
  P0.exports = function(e) {
    return k0 || (k0 = new Gr2(null)), k0.generate(e);
  };
  function Gr2(t) {
    this.rand = t;
  }
  P0.exports.Rand = Gr2;
  Gr2.prototype.generate = function(e) {
    return this._rand(e);
  };
  Gr2.prototype._rand = function(e) {
    if (this.rand.getBytes)
      return this.rand.getBytes(e);
    for (var r = new Uint8Array(e), n = 0; n < r.length; n++)
      r[n] = this.rand.getByte();
    return r;
  };
  if (typeof self == "object")
    self.crypto && self.crypto.getRandomValues ? Gr2.prototype._rand = function(e) {
      var r = new Uint8Array(e);
      return self.crypto.getRandomValues(r), r;
    } : self.msCrypto && self.msCrypto.getRandomValues ? Gr2.prototype._rand = function(e) {
      var r = new Uint8Array(e);
      return self.msCrypto.getRandomValues(r), r;
    } : typeof window == "object" && (Gr2.prototype._rand = function() {
      throw new Error("Not implemented yet");
    });
  else
    try {
      if (D0 = crypto_default, typeof D0.randomBytes != "function")
        throw new Error("Not supported");
      Gr2.prototype._rand = function(e) {
        return D0.randomBytes(e);
      };
    } catch {
    }
  var D0;
});
var T0 = k2((im, $u) => {
  var yi = Fe(), Pb = On();
  function _i(t) {
    this.rand = t || new Pb.Rand();
  }
  $u.exports = _i;
  _i.create = function(e) {
    return new _i(e);
  };
  _i.prototype._randbelow = function(e) {
    var r = e.bitLength(), n = Math.ceil(r / 8);
    do
      var i = new yi(this.rand.generate(n));
    while (i.cmp(e) >= 0);
    return i;
  };
  _i.prototype._randrange = function(e, r) {
    var n = r.sub(e);
    return e.add(this._randbelow(n));
  };
  _i.prototype.test = function(e, r, n) {
    var i = e.bitLength(), o2 = yi.mont(e), p3 = new yi(1).toRed(o2);
    r || (r = Math.max(1, i / 48 | 0));
    for (var y4 = e.subn(1), w2 = 0; !y4.testn(w2); w2++)
      ;
    for (var x = e.shrn(w2), M4 = y4.toRed(o2), E2 = true; r > 0; r--) {
      var A4 = this._randrange(new yi(2), y4);
      n && n(A4);
      var I3 = A4.toRed(o2).redPow(x);
      if (!(I3.cmp(p3) === 0 || I3.cmp(M4) === 0)) {
        for (var D6 = 1; D6 < w2; D6++) {
          if (I3 = I3.redSqr(), I3.cmp(p3) === 0)
            return false;
          if (I3.cmp(M4) === 0)
            break;
        }
        if (D6 === w2)
          return false;
      }
    }
    return E2;
  };
  _i.prototype.getDivisor = function(e, r) {
    var n = e.bitLength(), i = yi.mont(e), o2 = new yi(1).toRed(i);
    r || (r = Math.max(1, n / 48 | 0));
    for (var p3 = e.subn(1), y4 = 0; !p3.testn(y4); y4++)
      ;
    for (var w2 = e.shrn(y4), x = p3.toRed(i); r > 0; r--) {
      var M4 = this._randrange(new yi(2), p3), E2 = e.gcd(M4);
      if (E2.cmpn(1) !== 0)
        return E2;
      var A4 = M4.toRed(i).redPow(w2);
      if (!(A4.cmp(o2) === 0 || A4.cmp(x) === 0)) {
        for (var I3 = 1; I3 < y4; I3++) {
          if (A4 = A4.redSqr(), A4.cmp(o2) === 0)
            return A4.fromRed().subn(1).gcd(e);
          if (A4.cmp(x) === 0)
            break;
        }
        if (I3 === y4)
          return A4 = A4.redSqr(), A4.fromRed().subn(1).gcd(e);
      }
    }
    return false;
  };
});
var U0 = k2((om, td) => {
  var Tb = fi();
  td.exports = z0;
  z0.simpleSieve = L0;
  z0.fermatTest = O0;
  var Ge2 = Fe(), Cb = new Ge2(24), Nb = T0(), Qu = new Nb(), Lb = new Ge2(1), N0 = new Ge2(2), Ob = new Ge2(5), fm = new Ge2(16), nm = new Ge2(8), zb = new Ge2(10), Ub = new Ge2(3), am = new Ge2(7), Hb = new Ge2(11), ed = new Ge2(4), sm = new Ge2(12), C0 = null;
  function Fb() {
    if (C0 !== null)
      return C0;
    var t = 1048576, e = [];
    e[0] = 2;
    for (var r = 1, n = 3; n < t; n += 2) {
      for (var i = Math.ceil(Math.sqrt(n)), o2 = 0; o2 < r && e[o2] <= i && n % e[o2] !== 0; o2++)
        ;
      r !== o2 && e[o2] <= i || (e[r++] = n);
    }
    return C0 = e, e;
  }
  function L0(t) {
    for (var e = Fb(), r = 0; r < e.length; r++)
      if (t.modn(e[r]) === 0)
        return t.cmpn(e[r]) === 0;
    return true;
  }
  function O0(t) {
    var e = Ge2.mont(t);
    return N0.toRed(e).redPow(t.subn(1)).fromRed().cmpn(1) === 0;
  }
  function z0(t, e) {
    if (t < 16)
      return e === 2 || e === 5 ? new Ge2([140, 123]) : new Ge2([140, 39]);
    e = new Ge2(e);
    for (var r, n; ; ) {
      for (r = new Ge2(Tb(Math.ceil(t / 8))); r.bitLength() > t; )
        r.ishrn(1);
      if (r.isEven() && r.iadd(Lb), r.testn(1) || r.iadd(N0), e.cmp(N0)) {
        if (!e.cmp(Ob))
          for (; r.mod(zb).cmp(Ub); )
            r.iadd(ed);
      } else
        for (; r.mod(Cb).cmp(Hb); )
          r.iadd(ed);
      if (n = r.shrn(1), L0(n) && L0(r) && O0(n) && O0(r) && Qu.test(n) && Qu.test(r))
        return r;
    }
  }
});
var rd = k2((hm, Kb) => {
  Kb.exports = { modp1: { gen: "02", prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a63a3620ffffffffffffffff" }, modp2: { gen: "02", prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece65381ffffffffffffffff" }, modp5: { gen: "02", prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca237327ffffffffffffffff" }, modp14: { gen: "02", prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aacaa68ffffffffffffffff" }, modp15: { gen: "02", prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a93ad2caffffffffffffffff" }, modp16: { gen: "02", prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a92108011a723c12a787e6d788719a10bdba5b2699c327186af4e23c1a946834b6150bda2583e9ca2ad44ce8dbbbc2db04de8ef92e8efc141fbecaa6287c59474e6bc05d99b2964fa090c3a2233ba186515be7ed1f612970cee2d7afb81bdd762170481cd0069127d5b05aa993b4ea988d8fddc186ffb7dc90a6c08f4df435c934063199ffffffffffffffff" }, modp17: { gen: "02", prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a92108011a723c12a787e6d788719a10bdba5b2699c327186af4e23c1a946834b6150bda2583e9ca2ad44ce8dbbbc2db04de8ef92e8efc141fbecaa6287c59474e6bc05d99b2964fa090c3a2233ba186515be7ed1f612970cee2d7afb81bdd762170481cd0069127d5b05aa993b4ea988d8fddc186ffb7dc90a6c08f4df435c93402849236c3fab4d27c7026c1d4dcb2602646dec9751e763dba37bdf8ff9406ad9e530ee5db382f413001aeb06a53ed9027d831179727b0865a8918da3edbebcf9b14ed44ce6cbaced4bb1bdb7f1447e6cc254b332051512bd7af426fb8f401378cd2bf5983ca01c64b92ecf032ea15d1721d03f482d7ce6e74fef6d55e702f46980c82b5a84031900b1c9e59e7c97fbec7e8f323a97a7e36cc88be0f1d45b7ff585ac54bd407b22b4154aacc8f6d7ebf48e1d814cc5ed20f8037e0a79715eef29be32806a1d58bb7c5da76f550aa3d8a1fbff0eb19ccb1a313d55cda56c9ec2ef29632387fe8d76e3c0468043e8f663f4860ee12bf2d5b0b7474d6e694f91e6dcc4024ffffffffffffffff" }, modp18: { gen: "02", prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a92108011a723c12a787e6d788719a10bdba5b2699c327186af4e23c1a946834b6150bda2583e9ca2ad44ce8dbbbc2db04de8ef92e8efc141fbecaa6287c59474e6bc05d99b2964fa090c3a2233ba186515be7ed1f612970cee2d7afb81bdd762170481cd0069127d5b05aa993b4ea988d8fddc186ffb7dc90a6c08f4df435c93402849236c3fab4d27c7026c1d4dcb2602646dec9751e763dba37bdf8ff9406ad9e530ee5db382f413001aeb06a53ed9027d831179727b0865a8918da3edbebcf9b14ed44ce6cbaced4bb1bdb7f1447e6cc254b332051512bd7af426fb8f401378cd2bf5983ca01c64b92ecf032ea15d1721d03f482d7ce6e74fef6d55e702f46980c82b5a84031900b1c9e59e7c97fbec7e8f323a97a7e36cc88be0f1d45b7ff585ac54bd407b22b4154aacc8f6d7ebf48e1d814cc5ed20f8037e0a79715eef29be32806a1d58bb7c5da76f550aa3d8a1fbff0eb19ccb1a313d55cda56c9ec2ef29632387fe8d76e3c0468043e8f663f4860ee12bf2d5b0b7474d6e694f91e6dbe115974a3926f12fee5e438777cb6a932df8cd8bec4d073b931ba3bc832b68d9dd300741fa7bf8afc47ed2576f6936ba424663aab639c5ae4f5683423b4742bf1c978238f16cbe39d652de3fdb8befc848ad922222e04a4037c0713eb57a81a23f0c73473fc646cea306b4bcbc8862f8385ddfa9d4b7fa2c087e879683303ed5bdd3a062b3cf5b3a278a66d2a13f83f44f82ddf310ee074ab6a364597e899a0255dc164f31cc50846851df9ab48195ded7ea1b1d510bd7ee74d73faf36bc31ecfa268359046f4eb879f924009438b481c6cd7889a002ed5ee382bc9190da6fc026e479558e4475677e9aa9e3050e2765694dfc81f56e880b96e7160c980dd98edd3dfffffffffffffffff" } };
});
var ad = k2((um, nd) => {
  var mt = Fe(), jb = T0(), id = new jb(), Wb = new mt(24), Vb = new mt(11), Zb = new mt(10), Gb = new mt(3), Xb = new mt(7), fd = U0(), Yb = fi();
  nd.exports = yr2;
  function Jb(t, e) {
    return e = e || "utf8", Buffer3.isBuffer(t) || (t = new Buffer3(t, e)), this._pub = new mt(t), this;
  }
  function $b(t, e) {
    return e = e || "utf8", Buffer3.isBuffer(t) || (t = new Buffer3(t, e)), this._priv = new mt(t), this;
  }
  var zn = {};
  function Qb(t, e) {
    var r = e.toString("hex"), n = [r, t.toString(16)].join("_");
    if (n in zn)
      return zn[n];
    var i = 0;
    if (t.isEven() || !fd.simpleSieve || !fd.fermatTest(t) || !id.test(t))
      return i += 1, r === "02" || r === "05" ? i += 8 : i += 4, zn[n] = i, i;
    id.test(t.shrn(1)) || (i += 2);
    var o2;
    switch (r) {
      case "02":
        t.mod(Wb).cmp(Vb) && (i += 8);
        break;
      case "05":
        o2 = t.mod(Zb), o2.cmp(Gb) && o2.cmp(Xb) && (i += 8);
        break;
      default:
        i += 4;
    }
    return zn[n] = i, i;
  }
  function yr2(t, e, r) {
    this.setGenerator(e), this.__prime = new mt(t), this._prime = mt.mont(this.__prime), this._primeLen = t.length, this._pub = void 0, this._priv = void 0, this._primeCode = void 0, r ? (this.setPublicKey = Jb, this.setPrivateKey = $b) : this._primeCode = 8;
  }
  Object.defineProperty(yr2.prototype, "verifyError", { enumerable: true, get: function() {
    return typeof this._primeCode != "number" && (this._primeCode = Qb(this.__prime, this.__gen)), this._primeCode;
  } });
  yr2.prototype.generateKeys = function() {
    return this._priv || (this._priv = new mt(Yb(this._primeLen))), this._pub = this._gen.toRed(this._prime).redPow(this._priv).fromRed(), this.getPublicKey();
  };
  yr2.prototype.computeSecret = function(t) {
    t = new mt(t), t = t.toRed(this._prime);
    var e = t.redPow(this._priv).fromRed(), r = new Buffer3(e.toArray()), n = this.getPrime();
    if (r.length < n.length) {
      var i = new Buffer3(n.length - r.length);
      i.fill(0), r = Buffer3.concat([i, r]);
    }
    return r;
  };
  yr2.prototype.getPublicKey = function(e) {
    return Un(this._pub, e);
  };
  yr2.prototype.getPrivateKey = function(e) {
    return Un(this._priv, e);
  };
  yr2.prototype.getPrime = function(t) {
    return Un(this.__prime, t);
  };
  yr2.prototype.getGenerator = function(t) {
    return Un(this._gen, t);
  };
  yr2.prototype.setGenerator = function(t, e) {
    return e = e || "utf8", Buffer3.isBuffer(t) || (t = new Buffer3(t, e)), this.__gen = t, this._gen = new mt(t), this;
  };
  function Un(t, e) {
    var r = new Buffer3(t.toArray());
    return e ? r.toString(e) : r;
  }
});
var hd = k2((Fi) => {
  var e6 = U0(), sd = rd(), H0 = ad();
  function t6(t) {
    var e = new Buffer3(sd[t].prime, "hex"), r = new Buffer3(sd[t].gen, "hex");
    return new H0(e, r);
  }
  var r6 = { binary: true, hex: true, base64: true };
  function od(t, e, r, n) {
    return Buffer3.isBuffer(e) || r6[e] === void 0 ? od(t, "binary", e, r) : (e = e || "binary", n = n || "binary", r = r || new Buffer3([2]), Buffer3.isBuffer(r) || (r = new Buffer3(r, n)), typeof t == "number" ? new H0(e6(t, r), r, true) : (Buffer3.isBuffer(t) || (t = new Buffer3(t, e)), new H0(t, r, true)));
  }
  Fi.DiffieHellmanGroup = Fi.createDiffieHellmanGroup = Fi.getDiffieHellman = t6;
  Fi.createDiffieHellman = Fi.DiffieHellman = od;
});
var dd = k2((ud, F0) => {
  (function(t, e) {
    "use strict";
    function r(c5, f) {
      if (!c5)
        throw new Error(f || "Assertion failed");
    }
    function n(c5, f) {
      c5.super_ = f;
      var a = function() {
      };
      a.prototype = f.prototype, c5.prototype = new a(), c5.prototype.constructor = c5;
    }
    function i(c5, f, a) {
      if (i.isBN(c5))
        return c5;
      this.negative = 0, this.words = null, this.length = 0, this.red = null, c5 !== null && ((f === "le" || f === "be") && (a = f, f = 10), this._init(c5 || 0, f || 10, a || "be"));
    }
    typeof t == "object" ? t.exports = i : e.BN = i, i.BN = i, i.wordSize = 26;
    var o2;
    try {
      typeof document < "u" && typeof window.Buffer < "u" ? o2 = window.Buffer : o2 = export_default.Buffer;
    } catch {
    }
    i.isBN = function(f) {
      return f instanceof i ? true : f !== null && typeof f == "object" && f.constructor.wordSize === i.wordSize && Array.isArray(f.words);
    }, i.max = function(f, a) {
      return f.cmp(a) > 0 ? f : a;
    }, i.min = function(f, a) {
      return f.cmp(a) < 0 ? f : a;
    }, i.prototype._init = function(f, a, u) {
      if (typeof f == "number")
        return this._initNumber(f, a, u);
      if (typeof f == "object")
        return this._initArray(f, a, u);
      a === "hex" && (a = 16), r(a === (a | 0) && a >= 2 && a <= 36), f = f.toString().replace(/\s+/g, "");
      var l = 0;
      f[0] === "-" && (l++, this.negative = 1), l < f.length && (a === 16 ? this._parseHex(f, l, u) : (this._parseBase(f, a, l), u === "le" && this._initArray(this.toArray(), a, u)));
    }, i.prototype._initNumber = function(f, a, u) {
      f < 0 && (this.negative = 1, f = -f), f < 67108864 ? (this.words = [f & 67108863], this.length = 1) : f < 4503599627370496 ? (this.words = [f & 67108863, f / 67108864 & 67108863], this.length = 2) : (r(f < 9007199254740992), this.words = [f & 67108863, f / 67108864 & 67108863, 1], this.length = 3), u === "le" && this._initArray(this.toArray(), a, u);
    }, i.prototype._initArray = function(f, a, u) {
      if (r(typeof f.length == "number"), f.length <= 0)
        return this.words = [0], this.length = 1, this;
      this.length = Math.ceil(f.length / 3), this.words = new Array(this.length);
      for (var l = 0; l < this.length; l++)
        this.words[l] = 0;
      var d4, h, b2 = 0;
      if (u === "be")
        for (l = f.length - 1, d4 = 0; l >= 0; l -= 3)
          h = f[l] | f[l - 1] << 8 | f[l - 2] << 16, this.words[d4] |= h << b2 & 67108863, this.words[d4 + 1] = h >>> 26 - b2 & 67108863, b2 += 24, b2 >= 26 && (b2 -= 26, d4++);
      else if (u === "le")
        for (l = 0, d4 = 0; l < f.length; l += 3)
          h = f[l] | f[l + 1] << 8 | f[l + 2] << 16, this.words[d4] |= h << b2 & 67108863, this.words[d4 + 1] = h >>> 26 - b2 & 67108863, b2 += 24, b2 >= 26 && (b2 -= 26, d4++);
      return this._strip();
    };
    function p3(c5, f) {
      var a = c5.charCodeAt(f);
      if (a >= 48 && a <= 57)
        return a - 48;
      if (a >= 65 && a <= 70)
        return a - 55;
      if (a >= 97 && a <= 102)
        return a - 87;
      r(false, "Invalid character in " + c5);
    }
    function y4(c5, f, a) {
      var u = p3(c5, a);
      return a - 1 >= f && (u |= p3(c5, a - 1) << 4), u;
    }
    i.prototype._parseHex = function(f, a, u) {
      this.length = Math.ceil((f.length - a) / 6), this.words = new Array(this.length);
      for (var l = 0; l < this.length; l++)
        this.words[l] = 0;
      var d4 = 0, h = 0, b2;
      if (u === "be")
        for (l = f.length - 1; l >= a; l -= 2)
          b2 = y4(f, a, l) << d4, this.words[h] |= b2 & 67108863, d4 >= 18 ? (d4 -= 18, h += 1, this.words[h] |= b2 >>> 26) : d4 += 8;
      else {
        var m3 = f.length - a;
        for (l = m3 % 2 === 0 ? a + 1 : a; l < f.length; l += 2)
          b2 = y4(f, a, l) << d4, this.words[h] |= b2 & 67108863, d4 >= 18 ? (d4 -= 18, h += 1, this.words[h] |= b2 >>> 26) : d4 += 8;
      }
      this._strip();
    };
    function w2(c5, f, a, u) {
      for (var l = 0, d4 = 0, h = Math.min(c5.length, a), b2 = f; b2 < h; b2++) {
        var m3 = c5.charCodeAt(b2) - 48;
        l *= u, m3 >= 49 ? d4 = m3 - 49 + 10 : m3 >= 17 ? d4 = m3 - 17 + 10 : d4 = m3, r(m3 >= 0 && d4 < u, "Invalid character"), l += d4;
      }
      return l;
    }
    i.prototype._parseBase = function(f, a, u) {
      this.words = [0], this.length = 1;
      for (var l = 0, d4 = 1; d4 <= 67108863; d4 *= a)
        l++;
      l--, d4 = d4 / a | 0;
      for (var h = f.length - u, b2 = h % l, m3 = Math.min(h, h - b2) + u, s = 0, g2 = u; g2 < m3; g2 += l)
        s = w2(f, g2, g2 + l, a), this.imuln(d4), this.words[0] + s < 67108864 ? this.words[0] += s : this._iaddn(s);
      if (b2 !== 0) {
        var q = 1;
        for (s = w2(f, g2, f.length, a), g2 = 0; g2 < b2; g2++)
          q *= a;
        this.imuln(q), this.words[0] + s < 67108864 ? this.words[0] += s : this._iaddn(s);
      }
      this._strip();
    }, i.prototype.copy = function(f) {
      f.words = new Array(this.length);
      for (var a = 0; a < this.length; a++)
        f.words[a] = this.words[a];
      f.length = this.length, f.negative = this.negative, f.red = this.red;
    };
    function x(c5, f) {
      c5.words = f.words, c5.length = f.length, c5.negative = f.negative, c5.red = f.red;
    }
    if (i.prototype._move = function(f) {
      x(f, this);
    }, i.prototype.clone = function() {
      var f = new i(null);
      return this.copy(f), f;
    }, i.prototype._expand = function(f) {
      for (; this.length < f; )
        this.words[this.length++] = 0;
      return this;
    }, i.prototype._strip = function() {
      for (; this.length > 1 && this.words[this.length - 1] === 0; )
        this.length--;
      return this._normSign();
    }, i.prototype._normSign = function() {
      return this.length === 1 && this.words[0] === 0 && (this.negative = 0), this;
    }, typeof Symbol < "u" && typeof Symbol.for == "function")
      try {
        i.prototype[Symbol.for("nodejs.util.inspect.custom")] = M4;
      } catch {
        i.prototype.inspect = M4;
      }
    else
      i.prototype.inspect = M4;
    function M4() {
      return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
    }
    var E2 = ["", "0", "00", "000", "0000", "00000", "000000", "0000000", "00000000", "000000000", "0000000000", "00000000000", "000000000000", "0000000000000", "00000000000000", "000000000000000", "0000000000000000", "00000000000000000", "000000000000000000", "0000000000000000000", "00000000000000000000", "000000000000000000000", "0000000000000000000000", "00000000000000000000000", "000000000000000000000000", "0000000000000000000000000"], A4 = [0, 0, 25, 16, 12, 11, 10, 9, 8, 8, 7, 7, 7, 7, 6, 6, 6, 6, 6, 6, 6, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5], I3 = [0, 0, 33554432, 43046721, 16777216, 48828125, 60466176, 40353607, 16777216, 43046721, 1e7, 19487171, 35831808, 62748517, 7529536, 11390625, 16777216, 24137569, 34012224, 47045881, 64e6, 4084101, 5153632, 6436343, 7962624, 9765625, 11881376, 14348907, 17210368, 20511149, 243e5, 28629151, 33554432, 39135393, 45435424, 52521875, 60466176];
    i.prototype.toString = function(f, a) {
      f = f || 10, a = a | 0 || 1;
      var u;
      if (f === 16 || f === "hex") {
        u = "";
        for (var l = 0, d4 = 0, h = 0; h < this.length; h++) {
          var b2 = this.words[h], m3 = ((b2 << l | d4) & 16777215).toString(16);
          d4 = b2 >>> 24 - l & 16777215, l += 2, l >= 26 && (l -= 26, h--), d4 !== 0 || h !== this.length - 1 ? u = E2[6 - m3.length] + m3 + u : u = m3 + u;
        }
        for (d4 !== 0 && (u = d4.toString(16) + u); u.length % a !== 0; )
          u = "0" + u;
        return this.negative !== 0 && (u = "-" + u), u;
      }
      if (f === (f | 0) && f >= 2 && f <= 36) {
        var s = A4[f], g2 = I3[f];
        u = "";
        var q = this.clone();
        for (q.negative = 0; !q.isZero(); ) {
          var R3 = q.modrn(g2).toString(f);
          q = q.idivn(g2), q.isZero() ? u = R3 + u : u = E2[s - R3.length] + R3 + u;
        }
        for (this.isZero() && (u = "0" + u); u.length % a !== 0; )
          u = "0" + u;
        return this.negative !== 0 && (u = "-" + u), u;
      }
      r(false, "Base should be between 2 and 36");
    }, i.prototype.toNumber = function() {
      var f = this.words[0];
      return this.length === 2 ? f += this.words[1] * 67108864 : this.length === 3 && this.words[2] === 1 ? f += 4503599627370496 + this.words[1] * 67108864 : this.length > 2 && r(false, "Number can only safely store up to 53 bits"), this.negative !== 0 ? -f : f;
    }, i.prototype.toJSON = function() {
      return this.toString(16, 2);
    }, o2 && (i.prototype.toBuffer = function(f, a) {
      return this.toArrayLike(o2, f, a);
    }), i.prototype.toArray = function(f, a) {
      return this.toArrayLike(Array, f, a);
    };
    var D6 = function(f, a) {
      return f.allocUnsafe ? f.allocUnsafe(a) : new f(a);
    };
    i.prototype.toArrayLike = function(f, a, u) {
      this._strip();
      var l = this.byteLength(), d4 = u || Math.max(1, l);
      r(l <= d4, "byte array longer than desired length"), r(d4 > 0, "Requested array length <= 0");
      var h = D6(f, d4), b2 = a === "le" ? "LE" : "BE";
      return this["_toArrayLike" + b2](h, l), h;
    }, i.prototype._toArrayLikeLE = function(f, a) {
      for (var u = 0, l = 0, d4 = 0, h = 0; d4 < this.length; d4++) {
        var b2 = this.words[d4] << h | l;
        f[u++] = b2 & 255, u < f.length && (f[u++] = b2 >> 8 & 255), u < f.length && (f[u++] = b2 >> 16 & 255), h === 6 ? (u < f.length && (f[u++] = b2 >> 24 & 255), l = 0, h = 0) : (l = b2 >>> 24, h += 2);
      }
      if (u < f.length)
        for (f[u++] = l; u < f.length; )
          f[u++] = 0;
    }, i.prototype._toArrayLikeBE = function(f, a) {
      for (var u = f.length - 1, l = 0, d4 = 0, h = 0; d4 < this.length; d4++) {
        var b2 = this.words[d4] << h | l;
        f[u--] = b2 & 255, u >= 0 && (f[u--] = b2 >> 8 & 255), u >= 0 && (f[u--] = b2 >> 16 & 255), h === 6 ? (u >= 0 && (f[u--] = b2 >> 24 & 255), l = 0, h = 0) : (l = b2 >>> 24, h += 2);
      }
      if (u >= 0)
        for (f[u--] = l; u >= 0; )
          f[u--] = 0;
    }, Math.clz32 ? i.prototype._countBits = function(f) {
      return 32 - Math.clz32(f);
    } : i.prototype._countBits = function(f) {
      var a = f, u = 0;
      return a >= 4096 && (u += 13, a >>>= 13), a >= 64 && (u += 7, a >>>= 7), a >= 8 && (u += 4, a >>>= 4), a >= 2 && (u += 2, a >>>= 2), u + a;
    }, i.prototype._zeroBits = function(f) {
      if (f === 0)
        return 26;
      var a = f, u = 0;
      return (a & 8191) === 0 && (u += 13, a >>>= 13), (a & 127) === 0 && (u += 7, a >>>= 7), (a & 15) === 0 && (u += 4, a >>>= 4), (a & 3) === 0 && (u += 2, a >>>= 2), (a & 1) === 0 && u++, u;
    }, i.prototype.bitLength = function() {
      var f = this.words[this.length - 1], a = this._countBits(f);
      return (this.length - 1) * 26 + a;
    };
    function C(c5) {
      for (var f = new Array(c5.bitLength()), a = 0; a < f.length; a++) {
        var u = a / 26 | 0, l = a % 26;
        f[a] = c5.words[u] >>> l & 1;
      }
      return f;
    }
    i.prototype.zeroBits = function() {
      if (this.isZero())
        return 0;
      for (var f = 0, a = 0; a < this.length; a++) {
        var u = this._zeroBits(this.words[a]);
        if (f += u, u !== 26)
          break;
      }
      return f;
    }, i.prototype.byteLength = function() {
      return Math.ceil(this.bitLength() / 8);
    }, i.prototype.toTwos = function(f) {
      return this.negative !== 0 ? this.abs().inotn(f).iaddn(1) : this.clone();
    }, i.prototype.fromTwos = function(f) {
      return this.testn(f - 1) ? this.notn(f).iaddn(1).ineg() : this.clone();
    }, i.prototype.isNeg = function() {
      return this.negative !== 0;
    }, i.prototype.neg = function() {
      return this.clone().ineg();
    }, i.prototype.ineg = function() {
      return this.isZero() || (this.negative ^= 1), this;
    }, i.prototype.iuor = function(f) {
      for (; this.length < f.length; )
        this.words[this.length++] = 0;
      for (var a = 0; a < f.length; a++)
        this.words[a] = this.words[a] | f.words[a];
      return this._strip();
    }, i.prototype.ior = function(f) {
      return r((this.negative | f.negative) === 0), this.iuor(f);
    }, i.prototype.or = function(f) {
      return this.length > f.length ? this.clone().ior(f) : f.clone().ior(this);
    }, i.prototype.uor = function(f) {
      return this.length > f.length ? this.clone().iuor(f) : f.clone().iuor(this);
    }, i.prototype.iuand = function(f) {
      var a;
      this.length > f.length ? a = f : a = this;
      for (var u = 0; u < a.length; u++)
        this.words[u] = this.words[u] & f.words[u];
      return this.length = a.length, this._strip();
    }, i.prototype.iand = function(f) {
      return r((this.negative | f.negative) === 0), this.iuand(f);
    }, i.prototype.and = function(f) {
      return this.length > f.length ? this.clone().iand(f) : f.clone().iand(this);
    }, i.prototype.uand = function(f) {
      return this.length > f.length ? this.clone().iuand(f) : f.clone().iuand(this);
    }, i.prototype.iuxor = function(f) {
      var a, u;
      this.length > f.length ? (a = this, u = f) : (a = f, u = this);
      for (var l = 0; l < u.length; l++)
        this.words[l] = a.words[l] ^ u.words[l];
      if (this !== a)
        for (; l < a.length; l++)
          this.words[l] = a.words[l];
      return this.length = a.length, this._strip();
    }, i.prototype.ixor = function(f) {
      return r((this.negative | f.negative) === 0), this.iuxor(f);
    }, i.prototype.xor = function(f) {
      return this.length > f.length ? this.clone().ixor(f) : f.clone().ixor(this);
    }, i.prototype.uxor = function(f) {
      return this.length > f.length ? this.clone().iuxor(f) : f.clone().iuxor(this);
    }, i.prototype.inotn = function(f) {
      r(typeof f == "number" && f >= 0);
      var a = Math.ceil(f / 26) | 0, u = f % 26;
      this._expand(a), u > 0 && a--;
      for (var l = 0; l < a; l++)
        this.words[l] = ~this.words[l] & 67108863;
      return u > 0 && (this.words[l] = ~this.words[l] & 67108863 >> 26 - u), this._strip();
    }, i.prototype.notn = function(f) {
      return this.clone().inotn(f);
    }, i.prototype.setn = function(f, a) {
      r(typeof f == "number" && f >= 0);
      var u = f / 26 | 0, l = f % 26;
      return this._expand(u + 1), a ? this.words[u] = this.words[u] | 1 << l : this.words[u] = this.words[u] & ~(1 << l), this._strip();
    }, i.prototype.iadd = function(f) {
      var a;
      if (this.negative !== 0 && f.negative === 0)
        return this.negative = 0, a = this.isub(f), this.negative ^= 1, this._normSign();
      if (this.negative === 0 && f.negative !== 0)
        return f.negative = 0, a = this.isub(f), f.negative = 1, a._normSign();
      var u, l;
      this.length > f.length ? (u = this, l = f) : (u = f, l = this);
      for (var d4 = 0, h = 0; h < l.length; h++)
        a = (u.words[h] | 0) + (l.words[h] | 0) + d4, this.words[h] = a & 67108863, d4 = a >>> 26;
      for (; d4 !== 0 && h < u.length; h++)
        a = (u.words[h] | 0) + d4, this.words[h] = a & 67108863, d4 = a >>> 26;
      if (this.length = u.length, d4 !== 0)
        this.words[this.length] = d4, this.length++;
      else if (u !== this)
        for (; h < u.length; h++)
          this.words[h] = u.words[h];
      return this;
    }, i.prototype.add = function(f) {
      var a;
      return f.negative !== 0 && this.negative === 0 ? (f.negative = 0, a = this.sub(f), f.negative ^= 1, a) : f.negative === 0 && this.negative !== 0 ? (this.negative = 0, a = f.sub(this), this.negative = 1, a) : this.length > f.length ? this.clone().iadd(f) : f.clone().iadd(this);
    }, i.prototype.isub = function(f) {
      if (f.negative !== 0) {
        f.negative = 0;
        var a = this.iadd(f);
        return f.negative = 1, a._normSign();
      } else if (this.negative !== 0)
        return this.negative = 0, this.iadd(f), this.negative = 1, this._normSign();
      var u = this.cmp(f);
      if (u === 0)
        return this.negative = 0, this.length = 1, this.words[0] = 0, this;
      var l, d4;
      u > 0 ? (l = this, d4 = f) : (l = f, d4 = this);
      for (var h = 0, b2 = 0; b2 < d4.length; b2++)
        a = (l.words[b2] | 0) - (d4.words[b2] | 0) + h, h = a >> 26, this.words[b2] = a & 67108863;
      for (; h !== 0 && b2 < l.length; b2++)
        a = (l.words[b2] | 0) + h, h = a >> 26, this.words[b2] = a & 67108863;
      if (h === 0 && b2 < l.length && l !== this)
        for (; b2 < l.length; b2++)
          this.words[b2] = l.words[b2];
      return this.length = Math.max(this.length, b2), l !== this && (this.negative = 1), this._strip();
    }, i.prototype.sub = function(f) {
      return this.clone().isub(f);
    };
    function ge2(c5, f, a) {
      a.negative = f.negative ^ c5.negative;
      var u = c5.length + f.length | 0;
      a.length = u, u = u - 1 | 0;
      var l = c5.words[0] | 0, d4 = f.words[0] | 0, h = l * d4, b2 = h & 67108863, m3 = h / 67108864 | 0;
      a.words[0] = b2;
      for (var s = 1; s < u; s++) {
        for (var g2 = m3 >>> 26, q = m3 & 67108863, R3 = Math.min(s, f.length - 1), B3 = Math.max(0, s - c5.length + 1); B3 <= R3; B3++) {
          var P2 = s - B3 | 0;
          l = c5.words[P2] | 0, d4 = f.words[B3] | 0, h = l * d4 + q, g2 += h / 67108864 | 0, q = h & 67108863;
        }
        a.words[s] = q | 0, m3 = g2 | 0;
      }
      return m3 !== 0 ? a.words[s] = m3 | 0 : a.length--, a._strip();
    }
    var L4 = function(f, a, u) {
      var l = f.words, d4 = a.words, h = u.words, b2 = 0, m3, s, g2, q = l[0] | 0, R3 = q & 8191, B3 = q >>> 13, P2 = l[1] | 0, T4 = P2 & 8191, N4 = P2 >>> 13, ze = l[2] | 0, O = ze & 8191, z = ze >>> 13, Er3 = l[3] | 0, U2 = Er3 & 8191, H3 = Er3 >>> 13, Ar = l[4] | 0, F4 = Ar & 8191, K4 = Ar >>> 13, qr2 = l[5] | 0, j2 = qr2 & 8191, W4 = qr2 >>> 13, Br2 = l[6] | 0, V3 = Br2 & 8191, Z5 = Br2 >>> 13, Rr2 = l[7] | 0, G4 = Rr2 & 8191, X5 = Rr2 >>> 13, Ir2 = l[8] | 0, Y4 = Ir2 & 8191, J3 = Ir2 >>> 13, kr2 = l[9] | 0, $4 = kr2 & 8191, Q3 = kr2 >>> 13, Dr = d4[0] | 0, ee2 = Dr & 8191, te = Dr >>> 13, Pr2 = d4[1] | 0, re2 = Pr2 & 8191, ie = Pr2 >>> 13, Tr2 = d4[2] | 0, fe = Tr2 & 8191, ne = Tr2 >>> 13, Cr2 = d4[3] | 0, ae2 = Cr2 & 8191, se = Cr2 >>> 13, Nr2 = d4[4] | 0, oe = Nr2 & 8191, he2 = Nr2 >>> 13, Lr4 = d4[5] | 0, ue2 = Lr4 & 8191, de4 = Lr4 >>> 13, Or2 = d4[6] | 0, ce2 = Or2 & 8191, le2 = Or2 >>> 13, zr = d4[7] | 0, ve2 = zr & 8191, pe = zr >>> 13, Ur3 = d4[8] | 0, be = Ur3 & 8191, me = Ur3 >>> 13, dr2 = d4[9] | 0, _e2 = dr2 & 8191, we2 = dr2 >>> 13;
      u.negative = f.negative ^ a.negative, u.length = 19, m3 = Math.imul(R3, ee2), s = Math.imul(R3, te), s = s + Math.imul(B3, ee2) | 0, g2 = Math.imul(B3, te);
      var At2 = (b2 + m3 | 0) + ((s & 8191) << 13) | 0;
      b2 = (g2 + (s >>> 13) | 0) + (At2 >>> 26) | 0, At2 &= 67108863, m3 = Math.imul(T4, ee2), s = Math.imul(T4, te), s = s + Math.imul(N4, ee2) | 0, g2 = Math.imul(N4, te), m3 = m3 + Math.imul(R3, re2) | 0, s = s + Math.imul(R3, ie) | 0, s = s + Math.imul(B3, re2) | 0, g2 = g2 + Math.imul(B3, ie) | 0;
      var qt2 = (b2 + m3 | 0) + ((s & 8191) << 13) | 0;
      b2 = (g2 + (s >>> 13) | 0) + (qt2 >>> 26) | 0, qt2 &= 67108863, m3 = Math.imul(O, ee2), s = Math.imul(O, te), s = s + Math.imul(z, ee2) | 0, g2 = Math.imul(z, te), m3 = m3 + Math.imul(T4, re2) | 0, s = s + Math.imul(T4, ie) | 0, s = s + Math.imul(N4, re2) | 0, g2 = g2 + Math.imul(N4, ie) | 0, m3 = m3 + Math.imul(R3, fe) | 0, s = s + Math.imul(R3, ne) | 0, s = s + Math.imul(B3, fe) | 0, g2 = g2 + Math.imul(B3, ne) | 0;
      var Bt = (b2 + m3 | 0) + ((s & 8191) << 13) | 0;
      b2 = (g2 + (s >>> 13) | 0) + (Bt >>> 26) | 0, Bt &= 67108863, m3 = Math.imul(U2, ee2), s = Math.imul(U2, te), s = s + Math.imul(H3, ee2) | 0, g2 = Math.imul(H3, te), m3 = m3 + Math.imul(O, re2) | 0, s = s + Math.imul(O, ie) | 0, s = s + Math.imul(z, re2) | 0, g2 = g2 + Math.imul(z, ie) | 0, m3 = m3 + Math.imul(T4, fe) | 0, s = s + Math.imul(T4, ne) | 0, s = s + Math.imul(N4, fe) | 0, g2 = g2 + Math.imul(N4, ne) | 0, m3 = m3 + Math.imul(R3, ae2) | 0, s = s + Math.imul(R3, se) | 0, s = s + Math.imul(B3, ae2) | 0, g2 = g2 + Math.imul(B3, se) | 0;
      var Rt2 = (b2 + m3 | 0) + ((s & 8191) << 13) | 0;
      b2 = (g2 + (s >>> 13) | 0) + (Rt2 >>> 26) | 0, Rt2 &= 67108863, m3 = Math.imul(F4, ee2), s = Math.imul(F4, te), s = s + Math.imul(K4, ee2) | 0, g2 = Math.imul(K4, te), m3 = m3 + Math.imul(U2, re2) | 0, s = s + Math.imul(U2, ie) | 0, s = s + Math.imul(H3, re2) | 0, g2 = g2 + Math.imul(H3, ie) | 0, m3 = m3 + Math.imul(O, fe) | 0, s = s + Math.imul(O, ne) | 0, s = s + Math.imul(z, fe) | 0, g2 = g2 + Math.imul(z, ne) | 0, m3 = m3 + Math.imul(T4, ae2) | 0, s = s + Math.imul(T4, se) | 0, s = s + Math.imul(N4, ae2) | 0, g2 = g2 + Math.imul(N4, se) | 0, m3 = m3 + Math.imul(R3, oe) | 0, s = s + Math.imul(R3, he2) | 0, s = s + Math.imul(B3, oe) | 0, g2 = g2 + Math.imul(B3, he2) | 0;
      var It2 = (b2 + m3 | 0) + ((s & 8191) << 13) | 0;
      b2 = (g2 + (s >>> 13) | 0) + (It2 >>> 26) | 0, It2 &= 67108863, m3 = Math.imul(j2, ee2), s = Math.imul(j2, te), s = s + Math.imul(W4, ee2) | 0, g2 = Math.imul(W4, te), m3 = m3 + Math.imul(F4, re2) | 0, s = s + Math.imul(F4, ie) | 0, s = s + Math.imul(K4, re2) | 0, g2 = g2 + Math.imul(K4, ie) | 0, m3 = m3 + Math.imul(U2, fe) | 0, s = s + Math.imul(U2, ne) | 0, s = s + Math.imul(H3, fe) | 0, g2 = g2 + Math.imul(H3, ne) | 0, m3 = m3 + Math.imul(O, ae2) | 0, s = s + Math.imul(O, se) | 0, s = s + Math.imul(z, ae2) | 0, g2 = g2 + Math.imul(z, se) | 0, m3 = m3 + Math.imul(T4, oe) | 0, s = s + Math.imul(T4, he2) | 0, s = s + Math.imul(N4, oe) | 0, g2 = g2 + Math.imul(N4, he2) | 0, m3 = m3 + Math.imul(R3, ue2) | 0, s = s + Math.imul(R3, de4) | 0, s = s + Math.imul(B3, ue2) | 0, g2 = g2 + Math.imul(B3, de4) | 0;
      var kt2 = (b2 + m3 | 0) + ((s & 8191) << 13) | 0;
      b2 = (g2 + (s >>> 13) | 0) + (kt2 >>> 26) | 0, kt2 &= 67108863, m3 = Math.imul(V3, ee2), s = Math.imul(V3, te), s = s + Math.imul(Z5, ee2) | 0, g2 = Math.imul(Z5, te), m3 = m3 + Math.imul(j2, re2) | 0, s = s + Math.imul(j2, ie) | 0, s = s + Math.imul(W4, re2) | 0, g2 = g2 + Math.imul(W4, ie) | 0, m3 = m3 + Math.imul(F4, fe) | 0, s = s + Math.imul(F4, ne) | 0, s = s + Math.imul(K4, fe) | 0, g2 = g2 + Math.imul(K4, ne) | 0, m3 = m3 + Math.imul(U2, ae2) | 0, s = s + Math.imul(U2, se) | 0, s = s + Math.imul(H3, ae2) | 0, g2 = g2 + Math.imul(H3, se) | 0, m3 = m3 + Math.imul(O, oe) | 0, s = s + Math.imul(O, he2) | 0, s = s + Math.imul(z, oe) | 0, g2 = g2 + Math.imul(z, he2) | 0, m3 = m3 + Math.imul(T4, ue2) | 0, s = s + Math.imul(T4, de4) | 0, s = s + Math.imul(N4, ue2) | 0, g2 = g2 + Math.imul(N4, de4) | 0, m3 = m3 + Math.imul(R3, ce2) | 0, s = s + Math.imul(R3, le2) | 0, s = s + Math.imul(B3, ce2) | 0, g2 = g2 + Math.imul(B3, le2) | 0;
      var Dt = (b2 + m3 | 0) + ((s & 8191) << 13) | 0;
      b2 = (g2 + (s >>> 13) | 0) + (Dt >>> 26) | 0, Dt &= 67108863, m3 = Math.imul(G4, ee2), s = Math.imul(G4, te), s = s + Math.imul(X5, ee2) | 0, g2 = Math.imul(X5, te), m3 = m3 + Math.imul(V3, re2) | 0, s = s + Math.imul(V3, ie) | 0, s = s + Math.imul(Z5, re2) | 0, g2 = g2 + Math.imul(Z5, ie) | 0, m3 = m3 + Math.imul(j2, fe) | 0, s = s + Math.imul(j2, ne) | 0, s = s + Math.imul(W4, fe) | 0, g2 = g2 + Math.imul(W4, ne) | 0, m3 = m3 + Math.imul(F4, ae2) | 0, s = s + Math.imul(F4, se) | 0, s = s + Math.imul(K4, ae2) | 0, g2 = g2 + Math.imul(K4, se) | 0, m3 = m3 + Math.imul(U2, oe) | 0, s = s + Math.imul(U2, he2) | 0, s = s + Math.imul(H3, oe) | 0, g2 = g2 + Math.imul(H3, he2) | 0, m3 = m3 + Math.imul(O, ue2) | 0, s = s + Math.imul(O, de4) | 0, s = s + Math.imul(z, ue2) | 0, g2 = g2 + Math.imul(z, de4) | 0, m3 = m3 + Math.imul(T4, ce2) | 0, s = s + Math.imul(T4, le2) | 0, s = s + Math.imul(N4, ce2) | 0, g2 = g2 + Math.imul(N4, le2) | 0, m3 = m3 + Math.imul(R3, ve2) | 0, s = s + Math.imul(R3, pe) | 0, s = s + Math.imul(B3, ve2) | 0, g2 = g2 + Math.imul(B3, pe) | 0;
      var Pt2 = (b2 + m3 | 0) + ((s & 8191) << 13) | 0;
      b2 = (g2 + (s >>> 13) | 0) + (Pt2 >>> 26) | 0, Pt2 &= 67108863, m3 = Math.imul(Y4, ee2), s = Math.imul(Y4, te), s = s + Math.imul(J3, ee2) | 0, g2 = Math.imul(J3, te), m3 = m3 + Math.imul(G4, re2) | 0, s = s + Math.imul(G4, ie) | 0, s = s + Math.imul(X5, re2) | 0, g2 = g2 + Math.imul(X5, ie) | 0, m3 = m3 + Math.imul(V3, fe) | 0, s = s + Math.imul(V3, ne) | 0, s = s + Math.imul(Z5, fe) | 0, g2 = g2 + Math.imul(Z5, ne) | 0, m3 = m3 + Math.imul(j2, ae2) | 0, s = s + Math.imul(j2, se) | 0, s = s + Math.imul(W4, ae2) | 0, g2 = g2 + Math.imul(W4, se) | 0, m3 = m3 + Math.imul(F4, oe) | 0, s = s + Math.imul(F4, he2) | 0, s = s + Math.imul(K4, oe) | 0, g2 = g2 + Math.imul(K4, he2) | 0, m3 = m3 + Math.imul(U2, ue2) | 0, s = s + Math.imul(U2, de4) | 0, s = s + Math.imul(H3, ue2) | 0, g2 = g2 + Math.imul(H3, de4) | 0, m3 = m3 + Math.imul(O, ce2) | 0, s = s + Math.imul(O, le2) | 0, s = s + Math.imul(z, ce2) | 0, g2 = g2 + Math.imul(z, le2) | 0, m3 = m3 + Math.imul(T4, ve2) | 0, s = s + Math.imul(T4, pe) | 0, s = s + Math.imul(N4, ve2) | 0, g2 = g2 + Math.imul(N4, pe) | 0, m3 = m3 + Math.imul(R3, be) | 0, s = s + Math.imul(R3, me) | 0, s = s + Math.imul(B3, be) | 0, g2 = g2 + Math.imul(B3, me) | 0;
      var Tt2 = (b2 + m3 | 0) + ((s & 8191) << 13) | 0;
      b2 = (g2 + (s >>> 13) | 0) + (Tt2 >>> 26) | 0, Tt2 &= 67108863, m3 = Math.imul($4, ee2), s = Math.imul($4, te), s = s + Math.imul(Q3, ee2) | 0, g2 = Math.imul(Q3, te), m3 = m3 + Math.imul(Y4, re2) | 0, s = s + Math.imul(Y4, ie) | 0, s = s + Math.imul(J3, re2) | 0, g2 = g2 + Math.imul(J3, ie) | 0, m3 = m3 + Math.imul(G4, fe) | 0, s = s + Math.imul(G4, ne) | 0, s = s + Math.imul(X5, fe) | 0, g2 = g2 + Math.imul(X5, ne) | 0, m3 = m3 + Math.imul(V3, ae2) | 0, s = s + Math.imul(V3, se) | 0, s = s + Math.imul(Z5, ae2) | 0, g2 = g2 + Math.imul(Z5, se) | 0, m3 = m3 + Math.imul(j2, oe) | 0, s = s + Math.imul(j2, he2) | 0, s = s + Math.imul(W4, oe) | 0, g2 = g2 + Math.imul(W4, he2) | 0, m3 = m3 + Math.imul(F4, ue2) | 0, s = s + Math.imul(F4, de4) | 0, s = s + Math.imul(K4, ue2) | 0, g2 = g2 + Math.imul(K4, de4) | 0, m3 = m3 + Math.imul(U2, ce2) | 0, s = s + Math.imul(U2, le2) | 0, s = s + Math.imul(H3, ce2) | 0, g2 = g2 + Math.imul(H3, le2) | 0, m3 = m3 + Math.imul(O, ve2) | 0, s = s + Math.imul(O, pe) | 0, s = s + Math.imul(z, ve2) | 0, g2 = g2 + Math.imul(z, pe) | 0, m3 = m3 + Math.imul(T4, be) | 0, s = s + Math.imul(T4, me) | 0, s = s + Math.imul(N4, be) | 0, g2 = g2 + Math.imul(N4, me) | 0, m3 = m3 + Math.imul(R3, _e2) | 0, s = s + Math.imul(R3, we2) | 0, s = s + Math.imul(B3, _e2) | 0, g2 = g2 + Math.imul(B3, we2) | 0;
      var Ct2 = (b2 + m3 | 0) + ((s & 8191) << 13) | 0;
      b2 = (g2 + (s >>> 13) | 0) + (Ct2 >>> 26) | 0, Ct2 &= 67108863, m3 = Math.imul($4, re2), s = Math.imul($4, ie), s = s + Math.imul(Q3, re2) | 0, g2 = Math.imul(Q3, ie), m3 = m3 + Math.imul(Y4, fe) | 0, s = s + Math.imul(Y4, ne) | 0, s = s + Math.imul(J3, fe) | 0, g2 = g2 + Math.imul(J3, ne) | 0, m3 = m3 + Math.imul(G4, ae2) | 0, s = s + Math.imul(G4, se) | 0, s = s + Math.imul(X5, ae2) | 0, g2 = g2 + Math.imul(X5, se) | 0, m3 = m3 + Math.imul(V3, oe) | 0, s = s + Math.imul(V3, he2) | 0, s = s + Math.imul(Z5, oe) | 0, g2 = g2 + Math.imul(Z5, he2) | 0, m3 = m3 + Math.imul(j2, ue2) | 0, s = s + Math.imul(j2, de4) | 0, s = s + Math.imul(W4, ue2) | 0, g2 = g2 + Math.imul(W4, de4) | 0, m3 = m3 + Math.imul(F4, ce2) | 0, s = s + Math.imul(F4, le2) | 0, s = s + Math.imul(K4, ce2) | 0, g2 = g2 + Math.imul(K4, le2) | 0, m3 = m3 + Math.imul(U2, ve2) | 0, s = s + Math.imul(U2, pe) | 0, s = s + Math.imul(H3, ve2) | 0, g2 = g2 + Math.imul(H3, pe) | 0, m3 = m3 + Math.imul(O, be) | 0, s = s + Math.imul(O, me) | 0, s = s + Math.imul(z, be) | 0, g2 = g2 + Math.imul(z, me) | 0, m3 = m3 + Math.imul(T4, _e2) | 0, s = s + Math.imul(T4, we2) | 0, s = s + Math.imul(N4, _e2) | 0, g2 = g2 + Math.imul(N4, we2) | 0;
      var Nt2 = (b2 + m3 | 0) + ((s & 8191) << 13) | 0;
      b2 = (g2 + (s >>> 13) | 0) + (Nt2 >>> 26) | 0, Nt2 &= 67108863, m3 = Math.imul($4, fe), s = Math.imul($4, ne), s = s + Math.imul(Q3, fe) | 0, g2 = Math.imul(Q3, ne), m3 = m3 + Math.imul(Y4, ae2) | 0, s = s + Math.imul(Y4, se) | 0, s = s + Math.imul(J3, ae2) | 0, g2 = g2 + Math.imul(J3, se) | 0, m3 = m3 + Math.imul(G4, oe) | 0, s = s + Math.imul(G4, he2) | 0, s = s + Math.imul(X5, oe) | 0, g2 = g2 + Math.imul(X5, he2) | 0, m3 = m3 + Math.imul(V3, ue2) | 0, s = s + Math.imul(V3, de4) | 0, s = s + Math.imul(Z5, ue2) | 0, g2 = g2 + Math.imul(Z5, de4) | 0, m3 = m3 + Math.imul(j2, ce2) | 0, s = s + Math.imul(j2, le2) | 0, s = s + Math.imul(W4, ce2) | 0, g2 = g2 + Math.imul(W4, le2) | 0, m3 = m3 + Math.imul(F4, ve2) | 0, s = s + Math.imul(F4, pe) | 0, s = s + Math.imul(K4, ve2) | 0, g2 = g2 + Math.imul(K4, pe) | 0, m3 = m3 + Math.imul(U2, be) | 0, s = s + Math.imul(U2, me) | 0, s = s + Math.imul(H3, be) | 0, g2 = g2 + Math.imul(H3, me) | 0, m3 = m3 + Math.imul(O, _e2) | 0, s = s + Math.imul(O, we2) | 0, s = s + Math.imul(z, _e2) | 0, g2 = g2 + Math.imul(z, we2) | 0;
      var Lt2 = (b2 + m3 | 0) + ((s & 8191) << 13) | 0;
      b2 = (g2 + (s >>> 13) | 0) + (Lt2 >>> 26) | 0, Lt2 &= 67108863, m3 = Math.imul($4, ae2), s = Math.imul($4, se), s = s + Math.imul(Q3, ae2) | 0, g2 = Math.imul(Q3, se), m3 = m3 + Math.imul(Y4, oe) | 0, s = s + Math.imul(Y4, he2) | 0, s = s + Math.imul(J3, oe) | 0, g2 = g2 + Math.imul(J3, he2) | 0, m3 = m3 + Math.imul(G4, ue2) | 0, s = s + Math.imul(G4, de4) | 0, s = s + Math.imul(X5, ue2) | 0, g2 = g2 + Math.imul(X5, de4) | 0, m3 = m3 + Math.imul(V3, ce2) | 0, s = s + Math.imul(V3, le2) | 0, s = s + Math.imul(Z5, ce2) | 0, g2 = g2 + Math.imul(Z5, le2) | 0, m3 = m3 + Math.imul(j2, ve2) | 0, s = s + Math.imul(j2, pe) | 0, s = s + Math.imul(W4, ve2) | 0, g2 = g2 + Math.imul(W4, pe) | 0, m3 = m3 + Math.imul(F4, be) | 0, s = s + Math.imul(F4, me) | 0, s = s + Math.imul(K4, be) | 0, g2 = g2 + Math.imul(K4, me) | 0, m3 = m3 + Math.imul(U2, _e2) | 0, s = s + Math.imul(U2, we2) | 0, s = s + Math.imul(H3, _e2) | 0, g2 = g2 + Math.imul(H3, we2) | 0;
      var Ot = (b2 + m3 | 0) + ((s & 8191) << 13) | 0;
      b2 = (g2 + (s >>> 13) | 0) + (Ot >>> 26) | 0, Ot &= 67108863, m3 = Math.imul($4, oe), s = Math.imul($4, he2), s = s + Math.imul(Q3, oe) | 0, g2 = Math.imul(Q3, he2), m3 = m3 + Math.imul(Y4, ue2) | 0, s = s + Math.imul(Y4, de4) | 0, s = s + Math.imul(J3, ue2) | 0, g2 = g2 + Math.imul(J3, de4) | 0, m3 = m3 + Math.imul(G4, ce2) | 0, s = s + Math.imul(G4, le2) | 0, s = s + Math.imul(X5, ce2) | 0, g2 = g2 + Math.imul(X5, le2) | 0, m3 = m3 + Math.imul(V3, ve2) | 0, s = s + Math.imul(V3, pe) | 0, s = s + Math.imul(Z5, ve2) | 0, g2 = g2 + Math.imul(Z5, pe) | 0, m3 = m3 + Math.imul(j2, be) | 0, s = s + Math.imul(j2, me) | 0, s = s + Math.imul(W4, be) | 0, g2 = g2 + Math.imul(W4, me) | 0, m3 = m3 + Math.imul(F4, _e2) | 0, s = s + Math.imul(F4, we2) | 0, s = s + Math.imul(K4, _e2) | 0, g2 = g2 + Math.imul(K4, we2) | 0;
      var zt2 = (b2 + m3 | 0) + ((s & 8191) << 13) | 0;
      b2 = (g2 + (s >>> 13) | 0) + (zt2 >>> 26) | 0, zt2 &= 67108863, m3 = Math.imul($4, ue2), s = Math.imul($4, de4), s = s + Math.imul(Q3, ue2) | 0, g2 = Math.imul(Q3, de4), m3 = m3 + Math.imul(Y4, ce2) | 0, s = s + Math.imul(Y4, le2) | 0, s = s + Math.imul(J3, ce2) | 0, g2 = g2 + Math.imul(J3, le2) | 0, m3 = m3 + Math.imul(G4, ve2) | 0, s = s + Math.imul(G4, pe) | 0, s = s + Math.imul(X5, ve2) | 0, g2 = g2 + Math.imul(X5, pe) | 0, m3 = m3 + Math.imul(V3, be) | 0, s = s + Math.imul(V3, me) | 0, s = s + Math.imul(Z5, be) | 0, g2 = g2 + Math.imul(Z5, me) | 0, m3 = m3 + Math.imul(j2, _e2) | 0, s = s + Math.imul(j2, we2) | 0, s = s + Math.imul(W4, _e2) | 0, g2 = g2 + Math.imul(W4, we2) | 0;
      var Ut = (b2 + m3 | 0) + ((s & 8191) << 13) | 0;
      b2 = (g2 + (s >>> 13) | 0) + (Ut >>> 26) | 0, Ut &= 67108863, m3 = Math.imul($4, ce2), s = Math.imul($4, le2), s = s + Math.imul(Q3, ce2) | 0, g2 = Math.imul(Q3, le2), m3 = m3 + Math.imul(Y4, ve2) | 0, s = s + Math.imul(Y4, pe) | 0, s = s + Math.imul(J3, ve2) | 0, g2 = g2 + Math.imul(J3, pe) | 0, m3 = m3 + Math.imul(G4, be) | 0, s = s + Math.imul(G4, me) | 0, s = s + Math.imul(X5, be) | 0, g2 = g2 + Math.imul(X5, me) | 0, m3 = m3 + Math.imul(V3, _e2) | 0, s = s + Math.imul(V3, we2) | 0, s = s + Math.imul(Z5, _e2) | 0, g2 = g2 + Math.imul(Z5, we2) | 0;
      var Ht = (b2 + m3 | 0) + ((s & 8191) << 13) | 0;
      b2 = (g2 + (s >>> 13) | 0) + (Ht >>> 26) | 0, Ht &= 67108863, m3 = Math.imul($4, ve2), s = Math.imul($4, pe), s = s + Math.imul(Q3, ve2) | 0, g2 = Math.imul(Q3, pe), m3 = m3 + Math.imul(Y4, be) | 0, s = s + Math.imul(Y4, me) | 0, s = s + Math.imul(J3, be) | 0, g2 = g2 + Math.imul(J3, me) | 0, m3 = m3 + Math.imul(G4, _e2) | 0, s = s + Math.imul(G4, we2) | 0, s = s + Math.imul(X5, _e2) | 0, g2 = g2 + Math.imul(X5, we2) | 0;
      var ei = (b2 + m3 | 0) + ((s & 8191) << 13) | 0;
      b2 = (g2 + (s >>> 13) | 0) + (ei >>> 26) | 0, ei &= 67108863, m3 = Math.imul($4, be), s = Math.imul($4, me), s = s + Math.imul(Q3, be) | 0, g2 = Math.imul(Q3, me), m3 = m3 + Math.imul(Y4, _e2) | 0, s = s + Math.imul(Y4, we2) | 0, s = s + Math.imul(J3, _e2) | 0, g2 = g2 + Math.imul(J3, we2) | 0;
      var ti = (b2 + m3 | 0) + ((s & 8191) << 13) | 0;
      b2 = (g2 + (s >>> 13) | 0) + (ti >>> 26) | 0, ti &= 67108863, m3 = Math.imul($4, _e2), s = Math.imul($4, we2), s = s + Math.imul(Q3, _e2) | 0, g2 = Math.imul(Q3, we2);
      var ri = (b2 + m3 | 0) + ((s & 8191) << 13) | 0;
      return b2 = (g2 + (s >>> 13) | 0) + (ri >>> 26) | 0, ri &= 67108863, h[0] = At2, h[1] = qt2, h[2] = Bt, h[3] = Rt2, h[4] = It2, h[5] = kt2, h[6] = Dt, h[7] = Pt2, h[8] = Tt2, h[9] = Ct2, h[10] = Nt2, h[11] = Lt2, h[12] = Ot, h[13] = zt2, h[14] = Ut, h[15] = Ht, h[16] = ei, h[17] = ti, h[18] = ri, b2 !== 0 && (h[19] = b2, u.length++), u;
    };
    Math.imul || (L4 = ge2);
    function ye(c5, f, a) {
      a.negative = f.negative ^ c5.negative, a.length = c5.length + f.length;
      for (var u = 0, l = 0, d4 = 0; d4 < a.length - 1; d4++) {
        var h = l;
        l = 0;
        for (var b2 = u & 67108863, m3 = Math.min(d4, f.length - 1), s = Math.max(0, d4 - c5.length + 1); s <= m3; s++) {
          var g2 = d4 - s, q = c5.words[g2] | 0, R3 = f.words[s] | 0, B3 = q * R3, P2 = B3 & 67108863;
          h = h + (B3 / 67108864 | 0) | 0, P2 = P2 + b2 | 0, b2 = P2 & 67108863, h = h + (P2 >>> 26) | 0, l += h >>> 26, h &= 67108863;
        }
        a.words[d4] = b2, u = h, h = l;
      }
      return u !== 0 ? a.words[d4] = u : a.length--, a._strip();
    }
    function Re(c5, f, a) {
      return ye(c5, f, a);
    }
    i.prototype.mulTo = function(f, a) {
      var u, l = this.length + f.length;
      return this.length === 10 && f.length === 10 ? u = L4(this, f, a) : l < 63 ? u = ge2(this, f, a) : l < 1024 ? u = ye(this, f, a) : u = Re(this, f, a), u;
    };
    function xe3(c5, f) {
      this.x = c5, this.y = f;
    }
    xe3.prototype.makeRBT = function(f) {
      for (var a = new Array(f), u = i.prototype._countBits(f) - 1, l = 0; l < f; l++)
        a[l] = this.revBin(l, u, f);
      return a;
    }, xe3.prototype.revBin = function(f, a, u) {
      if (f === 0 || f === u - 1)
        return f;
      for (var l = 0, d4 = 0; d4 < a; d4++)
        l |= (f & 1) << a - d4 - 1, f >>= 1;
      return l;
    }, xe3.prototype.permute = function(f, a, u, l, d4, h) {
      for (var b2 = 0; b2 < h; b2++)
        l[b2] = a[f[b2]], d4[b2] = u[f[b2]];
    }, xe3.prototype.transform = function(f, a, u, l, d4, h) {
      this.permute(h, f, a, u, l, d4);
      for (var b2 = 1; b2 < d4; b2 <<= 1)
        for (var m3 = b2 << 1, s = Math.cos(2 * Math.PI / m3), g2 = Math.sin(2 * Math.PI / m3), q = 0; q < d4; q += m3)
          for (var R3 = s, B3 = g2, P2 = 0; P2 < b2; P2++) {
            var T4 = u[q + P2], N4 = l[q + P2], ze = u[q + P2 + b2], O = l[q + P2 + b2], z = R3 * ze - B3 * O;
            O = R3 * O + B3 * ze, ze = z, u[q + P2] = T4 + ze, l[q + P2] = N4 + O, u[q + P2 + b2] = T4 - ze, l[q + P2 + b2] = N4 - O, P2 !== m3 && (z = s * R3 - g2 * B3, B3 = s * B3 + g2 * R3, R3 = z);
          }
    }, xe3.prototype.guessLen13b = function(f, a) {
      var u = Math.max(a, f) | 1, l = u & 1, d4 = 0;
      for (u = u / 2 | 0; u; u = u >>> 1)
        d4++;
      return 1 << d4 + 1 + l;
    }, xe3.prototype.conjugate = function(f, a, u) {
      if (!(u <= 1))
        for (var l = 0; l < u / 2; l++) {
          var d4 = f[l];
          f[l] = f[u - l - 1], f[u - l - 1] = d4, d4 = a[l], a[l] = -a[u - l - 1], a[u - l - 1] = -d4;
        }
    }, xe3.prototype.normalize13b = function(f, a) {
      for (var u = 0, l = 0; l < a / 2; l++) {
        var d4 = Math.round(f[2 * l + 1] / a) * 8192 + Math.round(f[2 * l] / a) + u;
        f[l] = d4 & 67108863, d4 < 67108864 ? u = 0 : u = d4 / 67108864 | 0;
      }
      return f;
    }, xe3.prototype.convert13b = function(f, a, u, l) {
      for (var d4 = 0, h = 0; h < a; h++)
        d4 = d4 + (f[h] | 0), u[2 * h] = d4 & 8191, d4 = d4 >>> 13, u[2 * h + 1] = d4 & 8191, d4 = d4 >>> 13;
      for (h = 2 * a; h < l; ++h)
        u[h] = 0;
      r(d4 === 0), r((d4 & -8192) === 0);
    }, xe3.prototype.stub = function(f) {
      for (var a = new Array(f), u = 0; u < f; u++)
        a[u] = 0;
      return a;
    }, xe3.prototype.mulp = function(f, a, u) {
      var l = 2 * this.guessLen13b(f.length, a.length), d4 = this.makeRBT(l), h = this.stub(l), b2 = new Array(l), m3 = new Array(l), s = new Array(l), g2 = new Array(l), q = new Array(l), R3 = new Array(l), B3 = u.words;
      B3.length = l, this.convert13b(f.words, f.length, b2, l), this.convert13b(a.words, a.length, g2, l), this.transform(b2, h, m3, s, l, d4), this.transform(g2, h, q, R3, l, d4);
      for (var P2 = 0; P2 < l; P2++) {
        var T4 = m3[P2] * q[P2] - s[P2] * R3[P2];
        s[P2] = m3[P2] * R3[P2] + s[P2] * q[P2], m3[P2] = T4;
      }
      return this.conjugate(m3, s, l), this.transform(m3, s, B3, h, l, d4), this.conjugate(B3, h, l), this.normalize13b(B3, l), u.negative = f.negative ^ a.negative, u.length = f.length + a.length, u._strip();
    }, i.prototype.mul = function(f) {
      var a = new i(null);
      return a.words = new Array(this.length + f.length), this.mulTo(f, a);
    }, i.prototype.mulf = function(f) {
      var a = new i(null);
      return a.words = new Array(this.length + f.length), Re(this, f, a);
    }, i.prototype.imul = function(f) {
      return this.clone().mulTo(f, this);
    }, i.prototype.imuln = function(f) {
      var a = f < 0;
      a && (f = -f), r(typeof f == "number"), r(f < 67108864);
      for (var u = 0, l = 0; l < this.length; l++) {
        var d4 = (this.words[l] | 0) * f, h = (d4 & 67108863) + (u & 67108863);
        u >>= 26, u += d4 / 67108864 | 0, u += h >>> 26, this.words[l] = h & 67108863;
      }
      return u !== 0 && (this.words[l] = u, this.length++), a ? this.ineg() : this;
    }, i.prototype.muln = function(f) {
      return this.clone().imuln(f);
    }, i.prototype.sqr = function() {
      return this.mul(this);
    }, i.prototype.isqr = function() {
      return this.imul(this.clone());
    }, i.prototype.pow = function(f) {
      var a = C(f);
      if (a.length === 0)
        return new i(1);
      for (var u = this, l = 0; l < a.length && a[l] === 0; l++, u = u.sqr())
        ;
      if (++l < a.length)
        for (var d4 = u.sqr(); l < a.length; l++, d4 = d4.sqr())
          a[l] !== 0 && (u = u.mul(d4));
      return u;
    }, i.prototype.iushln = function(f) {
      r(typeof f == "number" && f >= 0);
      var a = f % 26, u = (f - a) / 26, l = 67108863 >>> 26 - a << 26 - a, d4;
      if (a !== 0) {
        var h = 0;
        for (d4 = 0; d4 < this.length; d4++) {
          var b2 = this.words[d4] & l, m3 = (this.words[d4] | 0) - b2 << a;
          this.words[d4] = m3 | h, h = b2 >>> 26 - a;
        }
        h && (this.words[d4] = h, this.length++);
      }
      if (u !== 0) {
        for (d4 = this.length - 1; d4 >= 0; d4--)
          this.words[d4 + u] = this.words[d4];
        for (d4 = 0; d4 < u; d4++)
          this.words[d4] = 0;
        this.length += u;
      }
      return this._strip();
    }, i.prototype.ishln = function(f) {
      return r(this.negative === 0), this.iushln(f);
    }, i.prototype.iushrn = function(f, a, u) {
      r(typeof f == "number" && f >= 0);
      var l;
      a ? l = (a - a % 26) / 26 : l = 0;
      var d4 = f % 26, h = Math.min((f - d4) / 26, this.length), b2 = 67108863 ^ 67108863 >>> d4 << d4, m3 = u;
      if (l -= h, l = Math.max(0, l), m3) {
        for (var s = 0; s < h; s++)
          m3.words[s] = this.words[s];
        m3.length = h;
      }
      if (h !== 0)
        if (this.length > h)
          for (this.length -= h, s = 0; s < this.length; s++)
            this.words[s] = this.words[s + h];
        else
          this.words[0] = 0, this.length = 1;
      var g2 = 0;
      for (s = this.length - 1; s >= 0 && (g2 !== 0 || s >= l); s--) {
        var q = this.words[s] | 0;
        this.words[s] = g2 << 26 - d4 | q >>> d4, g2 = q & b2;
      }
      return m3 && g2 !== 0 && (m3.words[m3.length++] = g2), this.length === 0 && (this.words[0] = 0, this.length = 1), this._strip();
    }, i.prototype.ishrn = function(f, a, u) {
      return r(this.negative === 0), this.iushrn(f, a, u);
    }, i.prototype.shln = function(f) {
      return this.clone().ishln(f);
    }, i.prototype.ushln = function(f) {
      return this.clone().iushln(f);
    }, i.prototype.shrn = function(f) {
      return this.clone().ishrn(f);
    }, i.prototype.ushrn = function(f) {
      return this.clone().iushrn(f);
    }, i.prototype.testn = function(f) {
      r(typeof f == "number" && f >= 0);
      var a = f % 26, u = (f - a) / 26, l = 1 << a;
      if (this.length <= u)
        return false;
      var d4 = this.words[u];
      return !!(d4 & l);
    }, i.prototype.imaskn = function(f) {
      r(typeof f == "number" && f >= 0);
      var a = f % 26, u = (f - a) / 26;
      if (r(this.negative === 0, "imaskn works only with positive numbers"), this.length <= u)
        return this;
      if (a !== 0 && u++, this.length = Math.min(u, this.length), a !== 0) {
        var l = 67108863 ^ 67108863 >>> a << a;
        this.words[this.length - 1] &= l;
      }
      return this._strip();
    }, i.prototype.maskn = function(f) {
      return this.clone().imaskn(f);
    }, i.prototype.iaddn = function(f) {
      return r(typeof f == "number"), r(f < 67108864), f < 0 ? this.isubn(-f) : this.negative !== 0 ? this.length === 1 && (this.words[0] | 0) <= f ? (this.words[0] = f - (this.words[0] | 0), this.negative = 0, this) : (this.negative = 0, this.isubn(f), this.negative = 1, this) : this._iaddn(f);
    }, i.prototype._iaddn = function(f) {
      this.words[0] += f;
      for (var a = 0; a < this.length && this.words[a] >= 67108864; a++)
        this.words[a] -= 67108864, a === this.length - 1 ? this.words[a + 1] = 1 : this.words[a + 1]++;
      return this.length = Math.max(this.length, a + 1), this;
    }, i.prototype.isubn = function(f) {
      if (r(typeof f == "number"), r(f < 67108864), f < 0)
        return this.iaddn(-f);
      if (this.negative !== 0)
        return this.negative = 0, this.iaddn(f), this.negative = 1, this;
      if (this.words[0] -= f, this.length === 1 && this.words[0] < 0)
        this.words[0] = -this.words[0], this.negative = 1;
      else
        for (var a = 0; a < this.length && this.words[a] < 0; a++)
          this.words[a] += 67108864, this.words[a + 1] -= 1;
      return this._strip();
    }, i.prototype.addn = function(f) {
      return this.clone().iaddn(f);
    }, i.prototype.subn = function(f) {
      return this.clone().isubn(f);
    }, i.prototype.iabs = function() {
      return this.negative = 0, this;
    }, i.prototype.abs = function() {
      return this.clone().iabs();
    }, i.prototype._ishlnsubmul = function(f, a, u) {
      var l = f.length + u, d4;
      this._expand(l);
      var h, b2 = 0;
      for (d4 = 0; d4 < f.length; d4++) {
        h = (this.words[d4 + u] | 0) + b2;
        var m3 = (f.words[d4] | 0) * a;
        h -= m3 & 67108863, b2 = (h >> 26) - (m3 / 67108864 | 0), this.words[d4 + u] = h & 67108863;
      }
      for (; d4 < this.length - u; d4++)
        h = (this.words[d4 + u] | 0) + b2, b2 = h >> 26, this.words[d4 + u] = h & 67108863;
      if (b2 === 0)
        return this._strip();
      for (r(b2 === -1), b2 = 0, d4 = 0; d4 < this.length; d4++)
        h = -(this.words[d4] | 0) + b2, b2 = h >> 26, this.words[d4] = h & 67108863;
      return this.negative = 1, this._strip();
    }, i.prototype._wordDiv = function(f, a) {
      var u = this.length - f.length, l = this.clone(), d4 = f, h = d4.words[d4.length - 1] | 0, b2 = this._countBits(h);
      u = 26 - b2, u !== 0 && (d4 = d4.ushln(u), l.iushln(u), h = d4.words[d4.length - 1] | 0);
      var m3 = l.length - d4.length, s;
      if (a !== "mod") {
        s = new i(null), s.length = m3 + 1, s.words = new Array(s.length);
        for (var g2 = 0; g2 < s.length; g2++)
          s.words[g2] = 0;
      }
      var q = l.clone()._ishlnsubmul(d4, 1, m3);
      q.negative === 0 && (l = q, s && (s.words[m3] = 1));
      for (var R3 = m3 - 1; R3 >= 0; R3--) {
        var B3 = (l.words[d4.length + R3] | 0) * 67108864 + (l.words[d4.length + R3 - 1] | 0);
        for (B3 = Math.min(B3 / h | 0, 67108863), l._ishlnsubmul(d4, B3, R3); l.negative !== 0; )
          B3--, l.negative = 0, l._ishlnsubmul(d4, 1, R3), l.isZero() || (l.negative ^= 1);
        s && (s.words[R3] = B3);
      }
      return s && s._strip(), l._strip(), a !== "div" && u !== 0 && l.iushrn(u), { div: s || null, mod: l };
    }, i.prototype.divmod = function(f, a, u) {
      if (r(!f.isZero()), this.isZero())
        return { div: new i(0), mod: new i(0) };
      var l, d4, h;
      return this.negative !== 0 && f.negative === 0 ? (h = this.neg().divmod(f, a), a !== "mod" && (l = h.div.neg()), a !== "div" && (d4 = h.mod.neg(), u && d4.negative !== 0 && d4.iadd(f)), { div: l, mod: d4 }) : this.negative === 0 && f.negative !== 0 ? (h = this.divmod(f.neg(), a), a !== "mod" && (l = h.div.neg()), { div: l, mod: h.mod }) : (this.negative & f.negative) !== 0 ? (h = this.neg().divmod(f.neg(), a), a !== "div" && (d4 = h.mod.neg(), u && d4.negative !== 0 && d4.isub(f)), { div: h.div, mod: d4 }) : f.length > this.length || this.cmp(f) < 0 ? { div: new i(0), mod: this } : f.length === 1 ? a === "div" ? { div: this.divn(f.words[0]), mod: null } : a === "mod" ? { div: null, mod: new i(this.modrn(f.words[0])) } : { div: this.divn(f.words[0]), mod: new i(this.modrn(f.words[0])) } : this._wordDiv(f, a);
    }, i.prototype.div = function(f) {
      return this.divmod(f, "div", false).div;
    }, i.prototype.mod = function(f) {
      return this.divmod(f, "mod", false).mod;
    }, i.prototype.umod = function(f) {
      return this.divmod(f, "mod", true).mod;
    }, i.prototype.divRound = function(f) {
      var a = this.divmod(f);
      if (a.mod.isZero())
        return a.div;
      var u = a.div.negative !== 0 ? a.mod.isub(f) : a.mod, l = f.ushrn(1), d4 = f.andln(1), h = u.cmp(l);
      return h < 0 || d4 === 1 && h === 0 ? a.div : a.div.negative !== 0 ? a.div.isubn(1) : a.div.iaddn(1);
    }, i.prototype.modrn = function(f) {
      var a = f < 0;
      a && (f = -f), r(f <= 67108863);
      for (var u = (1 << 26) % f, l = 0, d4 = this.length - 1; d4 >= 0; d4--)
        l = (u * l + (this.words[d4] | 0)) % f;
      return a ? -l : l;
    }, i.prototype.modn = function(f) {
      return this.modrn(f);
    }, i.prototype.idivn = function(f) {
      var a = f < 0;
      a && (f = -f), r(f <= 67108863);
      for (var u = 0, l = this.length - 1; l >= 0; l--) {
        var d4 = (this.words[l] | 0) + u * 67108864;
        this.words[l] = d4 / f | 0, u = d4 % f;
      }
      return this._strip(), a ? this.ineg() : this;
    }, i.prototype.divn = function(f) {
      return this.clone().idivn(f);
    }, i.prototype.egcd = function(f) {
      r(f.negative === 0), r(!f.isZero());
      var a = this, u = f.clone();
      a.negative !== 0 ? a = a.umod(f) : a = a.clone();
      for (var l = new i(1), d4 = new i(0), h = new i(0), b2 = new i(1), m3 = 0; a.isEven() && u.isEven(); )
        a.iushrn(1), u.iushrn(1), ++m3;
      for (var s = u.clone(), g2 = a.clone(); !a.isZero(); ) {
        for (var q = 0, R3 = 1; (a.words[0] & R3) === 0 && q < 26; ++q, R3 <<= 1)
          ;
        if (q > 0)
          for (a.iushrn(q); q-- > 0; )
            (l.isOdd() || d4.isOdd()) && (l.iadd(s), d4.isub(g2)), l.iushrn(1), d4.iushrn(1);
        for (var B3 = 0, P2 = 1; (u.words[0] & P2) === 0 && B3 < 26; ++B3, P2 <<= 1)
          ;
        if (B3 > 0)
          for (u.iushrn(B3); B3-- > 0; )
            (h.isOdd() || b2.isOdd()) && (h.iadd(s), b2.isub(g2)), h.iushrn(1), b2.iushrn(1);
        a.cmp(u) >= 0 ? (a.isub(u), l.isub(h), d4.isub(b2)) : (u.isub(a), h.isub(l), b2.isub(d4));
      }
      return { a: h, b: b2, gcd: u.iushln(m3) };
    }, i.prototype._invmp = function(f) {
      r(f.negative === 0), r(!f.isZero());
      var a = this, u = f.clone();
      a.negative !== 0 ? a = a.umod(f) : a = a.clone();
      for (var l = new i(1), d4 = new i(0), h = u.clone(); a.cmpn(1) > 0 && u.cmpn(1) > 0; ) {
        for (var b2 = 0, m3 = 1; (a.words[0] & m3) === 0 && b2 < 26; ++b2, m3 <<= 1)
          ;
        if (b2 > 0)
          for (a.iushrn(b2); b2-- > 0; )
            l.isOdd() && l.iadd(h), l.iushrn(1);
        for (var s = 0, g2 = 1; (u.words[0] & g2) === 0 && s < 26; ++s, g2 <<= 1)
          ;
        if (s > 0)
          for (u.iushrn(s); s-- > 0; )
            d4.isOdd() && d4.iadd(h), d4.iushrn(1);
        a.cmp(u) >= 0 ? (a.isub(u), l.isub(d4)) : (u.isub(a), d4.isub(l));
      }
      var q;
      return a.cmpn(1) === 0 ? q = l : q = d4, q.cmpn(0) < 0 && q.iadd(f), q;
    }, i.prototype.gcd = function(f) {
      if (this.isZero())
        return f.abs();
      if (f.isZero())
        return this.abs();
      var a = this.clone(), u = f.clone();
      a.negative = 0, u.negative = 0;
      for (var l = 0; a.isEven() && u.isEven(); l++)
        a.iushrn(1), u.iushrn(1);
      do {
        for (; a.isEven(); )
          a.iushrn(1);
        for (; u.isEven(); )
          u.iushrn(1);
        var d4 = a.cmp(u);
        if (d4 < 0) {
          var h = a;
          a = u, u = h;
        } else if (d4 === 0 || u.cmpn(1) === 0)
          break;
        a.isub(u);
      } while (true);
      return u.iushln(l);
    }, i.prototype.invm = function(f) {
      return this.egcd(f).a.umod(f);
    }, i.prototype.isEven = function() {
      return (this.words[0] & 1) === 0;
    }, i.prototype.isOdd = function() {
      return (this.words[0] & 1) === 1;
    }, i.prototype.andln = function(f) {
      return this.words[0] & f;
    }, i.prototype.bincn = function(f) {
      r(typeof f == "number");
      var a = f % 26, u = (f - a) / 26, l = 1 << a;
      if (this.length <= u)
        return this._expand(u + 1), this.words[u] |= l, this;
      for (var d4 = l, h = u; d4 !== 0 && h < this.length; h++) {
        var b2 = this.words[h] | 0;
        b2 += d4, d4 = b2 >>> 26, b2 &= 67108863, this.words[h] = b2;
      }
      return d4 !== 0 && (this.words[h] = d4, this.length++), this;
    }, i.prototype.isZero = function() {
      return this.length === 1 && this.words[0] === 0;
    }, i.prototype.cmpn = function(f) {
      var a = f < 0;
      if (this.negative !== 0 && !a)
        return -1;
      if (this.negative === 0 && a)
        return 1;
      this._strip();
      var u;
      if (this.length > 1)
        u = 1;
      else {
        a && (f = -f), r(f <= 67108863, "Number is too big");
        var l = this.words[0] | 0;
        u = l === f ? 0 : l < f ? -1 : 1;
      }
      return this.negative !== 0 ? -u | 0 : u;
    }, i.prototype.cmp = function(f) {
      if (this.negative !== 0 && f.negative === 0)
        return -1;
      if (this.negative === 0 && f.negative !== 0)
        return 1;
      var a = this.ucmp(f);
      return this.negative !== 0 ? -a | 0 : a;
    }, i.prototype.ucmp = function(f) {
      if (this.length > f.length)
        return 1;
      if (this.length < f.length)
        return -1;
      for (var a = 0, u = this.length - 1; u >= 0; u--) {
        var l = this.words[u] | 0, d4 = f.words[u] | 0;
        if (l !== d4) {
          l < d4 ? a = -1 : l > d4 && (a = 1);
          break;
        }
      }
      return a;
    }, i.prototype.gtn = function(f) {
      return this.cmpn(f) === 1;
    }, i.prototype.gt = function(f) {
      return this.cmp(f) === 1;
    }, i.prototype.gten = function(f) {
      return this.cmpn(f) >= 0;
    }, i.prototype.gte = function(f) {
      return this.cmp(f) >= 0;
    }, i.prototype.ltn = function(f) {
      return this.cmpn(f) === -1;
    }, i.prototype.lt = function(f) {
      return this.cmp(f) === -1;
    }, i.prototype.lten = function(f) {
      return this.cmpn(f) <= 0;
    }, i.prototype.lte = function(f) {
      return this.cmp(f) <= 0;
    }, i.prototype.eqn = function(f) {
      return this.cmpn(f) === 0;
    }, i.prototype.eq = function(f) {
      return this.cmp(f) === 0;
    }, i.red = function(f) {
      return new v2(f);
    }, i.prototype.toRed = function(f) {
      return r(!this.red, "Already a number in reduction context"), r(this.negative === 0, "red works only with positives"), f.convertTo(this)._forceRed(f);
    }, i.prototype.fromRed = function() {
      return r(this.red, "fromRed works only with numbers in reduction context"), this.red.convertFrom(this);
    }, i.prototype._forceRed = function(f) {
      return this.red = f, this;
    }, i.prototype.forceRed = function(f) {
      return r(!this.red, "Already a number in reduction context"), this._forceRed(f);
    }, i.prototype.redAdd = function(f) {
      return r(this.red, "redAdd works only with red numbers"), this.red.add(this, f);
    }, i.prototype.redIAdd = function(f) {
      return r(this.red, "redIAdd works only with red numbers"), this.red.iadd(this, f);
    }, i.prototype.redSub = function(f) {
      return r(this.red, "redSub works only with red numbers"), this.red.sub(this, f);
    }, i.prototype.redISub = function(f) {
      return r(this.red, "redISub works only with red numbers"), this.red.isub(this, f);
    }, i.prototype.redShl = function(f) {
      return r(this.red, "redShl works only with red numbers"), this.red.shl(this, f);
    }, i.prototype.redMul = function(f) {
      return r(this.red, "redMul works only with red numbers"), this.red._verify2(this, f), this.red.mul(this, f);
    }, i.prototype.redIMul = function(f) {
      return r(this.red, "redMul works only with red numbers"), this.red._verify2(this, f), this.red.imul(this, f);
    }, i.prototype.redSqr = function() {
      return r(this.red, "redSqr works only with red numbers"), this.red._verify1(this), this.red.sqr(this);
    }, i.prototype.redISqr = function() {
      return r(this.red, "redISqr works only with red numbers"), this.red._verify1(this), this.red.isqr(this);
    }, i.prototype.redSqrt = function() {
      return r(this.red, "redSqrt works only with red numbers"), this.red._verify1(this), this.red.sqrt(this);
    }, i.prototype.redInvm = function() {
      return r(this.red, "redInvm works only with red numbers"), this.red._verify1(this), this.red.invm(this);
    }, i.prototype.redNeg = function() {
      return r(this.red, "redNeg works only with red numbers"), this.red._verify1(this), this.red.neg(this);
    }, i.prototype.redPow = function(f) {
      return r(this.red && !f.red, "redPow(normalNum)"), this.red._verify1(this), this.red.pow(this, f);
    };
    var ke = { k256: null, p224: null, p192: null, p25519: null };
    function Me(c5, f) {
      this.name = c5, this.p = new i(f, 16), this.n = this.p.bitLength(), this.k = new i(1).iushln(this.n).isub(this.p), this.tmp = this._tmp();
    }
    Me.prototype._tmp = function() {
      var f = new i(null);
      return f.words = new Array(Math.ceil(this.n / 13)), f;
    }, Me.prototype.ireduce = function(f) {
      var a = f, u;
      do
        this.split(a, this.tmp), a = this.imulK(a), a = a.iadd(this.tmp), u = a.bitLength();
      while (u > this.n);
      var l = u < this.n ? -1 : a.ucmp(this.p);
      return l === 0 ? (a.words[0] = 0, a.length = 1) : l > 0 ? a.isub(this.p) : a.strip !== void 0 ? a.strip() : a._strip(), a;
    }, Me.prototype.split = function(f, a) {
      f.iushrn(this.n, 0, a);
    }, Me.prototype.imulK = function(f) {
      return f.imul(this.k);
    };
    function Ce3() {
      Me.call(this, "k256", "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f");
    }
    n(Ce3, Me), Ce3.prototype.split = function(f, a) {
      for (var u = 4194303, l = Math.min(f.length, 9), d4 = 0; d4 < l; d4++)
        a.words[d4] = f.words[d4];
      if (a.length = l, f.length <= 9) {
        f.words[0] = 0, f.length = 1;
        return;
      }
      var h = f.words[9];
      for (a.words[a.length++] = h & u, d4 = 10; d4 < f.length; d4++) {
        var b2 = f.words[d4] | 0;
        f.words[d4 - 10] = (b2 & u) << 4 | h >>> 22, h = b2;
      }
      h >>>= 22, f.words[d4 - 10] = h, h === 0 && f.length > 10 ? f.length -= 10 : f.length -= 9;
    }, Ce3.prototype.imulK = function(f) {
      f.words[f.length] = 0, f.words[f.length + 1] = 0, f.length += 2;
      for (var a = 0, u = 0; u < f.length; u++) {
        var l = f.words[u] | 0;
        a += l * 977, f.words[u] = a & 67108863, a = l * 64 + (a / 67108864 | 0);
      }
      return f.words[f.length - 1] === 0 && (f.length--, f.words[f.length - 1] === 0 && f.length--), f;
    };
    function Ee2() {
      Me.call(this, "p224", "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001");
    }
    n(Ee2, Me);
    function Ne3() {
      Me.call(this, "p192", "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff");
    }
    n(Ne3, Me);
    function S3() {
      Me.call(this, "25519", "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed");
    }
    n(S3, Me), S3.prototype.imulK = function(f) {
      for (var a = 0, u = 0; u < f.length; u++) {
        var l = (f.words[u] | 0) * 19 + a, d4 = l & 67108863;
        l >>>= 26, f.words[u] = d4, a = l;
      }
      return a !== 0 && (f.words[f.length++] = a), f;
    }, i._prime = function(f) {
      if (ke[f])
        return ke[f];
      var a;
      if (f === "k256")
        a = new Ce3();
      else if (f === "p224")
        a = new Ee2();
      else if (f === "p192")
        a = new Ne3();
      else if (f === "p25519")
        a = new S3();
      else
        throw new Error("Unknown prime " + f);
      return ke[f] = a, a;
    };
    function v2(c5) {
      if (typeof c5 == "string") {
        var f = i._prime(c5);
        this.m = f.p, this.prime = f;
      } else
        r(c5.gtn(1), "modulus must be greater than 1"), this.m = c5, this.prime = null;
    }
    v2.prototype._verify1 = function(f) {
      r(f.negative === 0, "red works only with positives"), r(f.red, "red works only with red numbers");
    }, v2.prototype._verify2 = function(f, a) {
      r((f.negative | a.negative) === 0, "red works only with positives"), r(f.red && f.red === a.red, "red works only with red numbers");
    }, v2.prototype.imod = function(f) {
      return this.prime ? this.prime.ireduce(f)._forceRed(this) : (x(f, f.umod(this.m)._forceRed(this)), f);
    }, v2.prototype.neg = function(f) {
      return f.isZero() ? f.clone() : this.m.sub(f)._forceRed(this);
    }, v2.prototype.add = function(f, a) {
      this._verify2(f, a);
      var u = f.add(a);
      return u.cmp(this.m) >= 0 && u.isub(this.m), u._forceRed(this);
    }, v2.prototype.iadd = function(f, a) {
      this._verify2(f, a);
      var u = f.iadd(a);
      return u.cmp(this.m) >= 0 && u.isub(this.m), u;
    }, v2.prototype.sub = function(f, a) {
      this._verify2(f, a);
      var u = f.sub(a);
      return u.cmpn(0) < 0 && u.iadd(this.m), u._forceRed(this);
    }, v2.prototype.isub = function(f, a) {
      this._verify2(f, a);
      var u = f.isub(a);
      return u.cmpn(0) < 0 && u.iadd(this.m), u;
    }, v2.prototype.shl = function(f, a) {
      return this._verify1(f), this.imod(f.ushln(a));
    }, v2.prototype.imul = function(f, a) {
      return this._verify2(f, a), this.imod(f.imul(a));
    }, v2.prototype.mul = function(f, a) {
      return this._verify2(f, a), this.imod(f.mul(a));
    }, v2.prototype.isqr = function(f) {
      return this.imul(f, f.clone());
    }, v2.prototype.sqr = function(f) {
      return this.mul(f, f);
    }, v2.prototype.sqrt = function(f) {
      if (f.isZero())
        return f.clone();
      var a = this.m.andln(3);
      if (r(a % 2 === 1), a === 3) {
        var u = this.m.add(new i(1)).iushrn(2);
        return this.pow(f, u);
      }
      for (var l = this.m.subn(1), d4 = 0; !l.isZero() && l.andln(1) === 0; )
        d4++, l.iushrn(1);
      r(!l.isZero());
      var h = new i(1).toRed(this), b2 = h.redNeg(), m3 = this.m.subn(1).iushrn(1), s = this.m.bitLength();
      for (s = new i(2 * s * s).toRed(this); this.pow(s, m3).cmp(b2) !== 0; )
        s.redIAdd(b2);
      for (var g2 = this.pow(s, l), q = this.pow(f, l.addn(1).iushrn(1)), R3 = this.pow(f, l), B3 = d4; R3.cmp(h) !== 0; ) {
        for (var P2 = R3, T4 = 0; P2.cmp(h) !== 0; T4++)
          P2 = P2.redSqr();
        r(T4 < B3);
        var N4 = this.pow(g2, new i(1).iushln(B3 - T4 - 1));
        q = q.redMul(N4), g2 = N4.redSqr(), R3 = R3.redMul(g2), B3 = T4;
      }
      return q;
    }, v2.prototype.invm = function(f) {
      var a = f._invmp(this.m);
      return a.negative !== 0 ? (a.negative = 0, this.imod(a).redNeg()) : this.imod(a);
    }, v2.prototype.pow = function(f, a) {
      if (a.isZero())
        return new i(1).toRed(this);
      if (a.cmpn(1) === 0)
        return f.clone();
      var u = 4, l = new Array(1 << u);
      l[0] = new i(1).toRed(this), l[1] = f;
      for (var d4 = 2; d4 < l.length; d4++)
        l[d4] = this.mul(l[d4 - 1], f);
      var h = l[0], b2 = 0, m3 = 0, s = a.bitLength() % 26;
      for (s === 0 && (s = 26), d4 = a.length - 1; d4 >= 0; d4--) {
        for (var g2 = a.words[d4], q = s - 1; q >= 0; q--) {
          var R3 = g2 >> q & 1;
          if (h !== l[0] && (h = this.sqr(h)), R3 === 0 && b2 === 0) {
            m3 = 0;
            continue;
          }
          b2 <<= 1, b2 |= R3, m3++, !(m3 !== u && (d4 !== 0 || q !== 0)) && (h = this.mul(h, l[b2]), m3 = 0, b2 = 0);
        }
        s = 26;
      }
      return h;
    }, v2.prototype.convertTo = function(f) {
      var a = f.umod(this.m);
      return a === f ? a.clone() : a;
    }, v2.prototype.convertFrom = function(f) {
      var a = f.clone();
      return a.red = null, a;
    }, i.mont = function(f) {
      return new _2(f);
    };
    function _2(c5) {
      v2.call(this, c5), this.shift = this.m.bitLength(), this.shift % 26 !== 0 && (this.shift += 26 - this.shift % 26), this.r = new i(1).iushln(this.shift), this.r2 = this.imod(this.r.sqr()), this.rinv = this.r._invmp(this.m), this.minv = this.rinv.mul(this.r).isubn(1).div(this.m), this.minv = this.minv.umod(this.r), this.minv = this.r.sub(this.minv);
    }
    n(_2, v2), _2.prototype.convertTo = function(f) {
      return this.imod(f.ushln(this.shift));
    }, _2.prototype.convertFrom = function(f) {
      var a = this.imod(f.mul(this.rinv));
      return a.red = null, a;
    }, _2.prototype.imul = function(f, a) {
      if (f.isZero() || a.isZero())
        return f.words[0] = 0, f.length = 1, f;
      var u = f.imul(a), l = u.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), d4 = u.isub(l).iushrn(this.shift), h = d4;
      return d4.cmp(this.m) >= 0 ? h = d4.isub(this.m) : d4.cmpn(0) < 0 && (h = d4.iadd(this.m)), h._forceRed(this);
    }, _2.prototype.mul = function(f, a) {
      if (f.isZero() || a.isZero())
        return new i(0)._forceRed(this);
      var u = f.mul(a), l = u.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), d4 = u.isub(l).iushrn(this.shift), h = d4;
      return d4.cmp(this.m) >= 0 ? h = d4.isub(this.m) : d4.cmpn(0) < 0 && (h = d4.iadd(this.m)), h._forceRed(this);
    }, _2.prototype.invm = function(f) {
      var a = this.imod(f._invmp(this.m).mul(this.r2));
      return a._forceRed(this);
    };
  })(typeof F0 > "u" || F0, ud);
});
var Hn = k2((cm, vd) => {
  var Ki2 = dd(), i6 = fi();
  function f6(t) {
    var e = cd(t), r = e.toRed(Ki2.mont(t.modulus)).redPow(new Ki2(t.publicExponent)).fromRed();
    return { blinder: r, unblinder: e.invm(t.modulus) };
  }
  function cd(t) {
    var e = t.modulus.byteLength(), r;
    do
      r = new Ki2(i6(e));
    while (r.cmp(t.modulus) >= 0 || !r.umod(t.prime1) || !r.umod(t.prime2));
    return r;
  }
  function ld(t, e) {
    var r = f6(e), n = e.modulus.byteLength(), i = new Ki2(t).mul(r.blinder).umod(e.modulus), o2 = i.toRed(Ki2.mont(e.prime1)), p3 = i.toRed(Ki2.mont(e.prime2)), y4 = e.coefficient, w2 = e.prime1, x = e.prime2, M4 = o2.redPow(e.exponent1).fromRed(), E2 = p3.redPow(e.exponent2).fromRed(), A4 = M4.isub(E2).imul(y4).umod(w2).imul(x);
    return E2.iadd(A4).imul(r.unblinder).umod(e.modulus).toArrayLike(Buffer3, "be", n);
  }
  ld.getr = cd;
  vd.exports = ld;
});
var pd = k2((lm, n6) => {
  n6.exports = { name: "elliptic", version: "6.5.4", description: "EC cryptography", main: "lib/elliptic.js", files: ["lib"], scripts: { lint: "eslint lib test", "lint:fix": "npm run lint -- --fix", unit: "istanbul test _mocha --reporter=spec test/index.js", test: "npm run lint && npm run unit", version: "grunt dist && git add dist/" }, repository: { type: "git", url: "git@github.com:indutny/elliptic" }, keywords: ["EC", "Elliptic", "curve", "Cryptography"], author: "Fedor Indutny <fedor@indutny.com>", license: "MIT", bugs: { url: "https://github.com/indutny/elliptic/issues" }, homepage: "https://github.com/indutny/elliptic", devDependencies: { brfs: "^2.0.2", coveralls: "^3.1.0", eslint: "^7.6.0", grunt: "^1.2.1", "grunt-browserify": "^5.3.0", "grunt-cli": "^1.3.2", "grunt-contrib-connect": "^3.0.0", "grunt-contrib-copy": "^1.0.0", "grunt-contrib-uglify": "^5.0.0", "grunt-mocha-istanbul": "^5.0.2", "grunt-saucelabs": "^9.0.1", istanbul: "^0.4.5", mocha: "^8.0.1" }, dependencies: { "bn.js": "^4.11.9", brorand: "^1.1.0", "hash.js": "^1.0.0", "hmac-drbg": "^1.0.1", inherits: "^2.0.4", "minimalistic-assert": "^1.0.1", "minimalistic-crypto-utils": "^1.0.1" } };
});
var K0 = k2((gd) => {
  "use strict";
  var Fn = gd;
  function a6(t, e) {
    if (Array.isArray(t))
      return t.slice();
    if (!t)
      return [];
    var r = [];
    if (typeof t != "string") {
      for (var n = 0; n < t.length; n++)
        r[n] = t[n] | 0;
      return r;
    }
    if (e === "hex") {
      t = t.replace(/[^a-z0-9]+/ig, ""), t.length % 2 !== 0 && (t = "0" + t);
      for (var n = 0; n < t.length; n += 2)
        r.push(parseInt(t[n] + t[n + 1], 16));
    } else
      for (var n = 0; n < t.length; n++) {
        var i = t.charCodeAt(n), o2 = i >> 8, p3 = i & 255;
        o2 ? r.push(o2, p3) : r.push(p3);
      }
    return r;
  }
  Fn.toArray = a6;
  function bd(t) {
    return t.length === 1 ? "0" + t : t;
  }
  Fn.zero2 = bd;
  function md(t) {
    for (var e = "", r = 0; r < t.length; r++)
      e += bd(t[r].toString(16));
    return e;
  }
  Fn.toHex = md;
  Fn.encode = function(e, r) {
    return r === "hex" ? md(e) : e;
  };
});
var ht2 = k2((yd) => {
  "use strict";
  var Wt2 = yd, s6 = Fe(), o6 = ot(), Kn = K0();
  Wt2.assert = o6;
  Wt2.toArray = Kn.toArray;
  Wt2.zero2 = Kn.zero2;
  Wt2.toHex = Kn.toHex;
  Wt2.encode = Kn.encode;
  function h6(t, e, r) {
    var n = new Array(Math.max(t.bitLength(), r) + 1);
    n.fill(0);
    for (var i = 1 << e + 1, o2 = t.clone(), p3 = 0; p3 < n.length; p3++) {
      var y4, w2 = o2.andln(i - 1);
      o2.isOdd() ? (w2 > (i >> 1) - 1 ? y4 = (i >> 1) - w2 : y4 = w2, o2.isubn(y4)) : y4 = 0, n[p3] = y4, o2.iushrn(1);
    }
    return n;
  }
  Wt2.getNAF = h6;
  function u6(t, e) {
    var r = [[], []];
    t = t.clone(), e = e.clone();
    for (var n = 0, i = 0, o2; t.cmpn(-n) > 0 || e.cmpn(-i) > 0; ) {
      var p3 = t.andln(3) + n & 3, y4 = e.andln(3) + i & 3;
      p3 === 3 && (p3 = -1), y4 === 3 && (y4 = -1);
      var w2;
      (p3 & 1) === 0 ? w2 = 0 : (o2 = t.andln(7) + n & 7, (o2 === 3 || o2 === 5) && y4 === 2 ? w2 = -p3 : w2 = p3), r[0].push(w2);
      var x;
      (y4 & 1) === 0 ? x = 0 : (o2 = e.andln(7) + i & 7, (o2 === 3 || o2 === 5) && p3 === 2 ? x = -y4 : x = y4), r[1].push(x), 2 * n === w2 + 1 && (n = 1 - n), 2 * i === x + 1 && (i = 1 - i), t.iushrn(1), e.iushrn(1);
    }
    return r;
  }
  Wt2.getJSF = u6;
  function d6(t, e, r) {
    var n = "_" + e;
    t.prototype[e] = function() {
      return this[n] !== void 0 ? this[n] : this[n] = r.call(this);
    };
  }
  Wt2.cachedProperty = d6;
  function c6(t) {
    return typeof t == "string" ? Wt2.toArray(t, "hex") : t;
  }
  Wt2.parseBytes = c6;
  function l6(t) {
    return new s6(t, "hex", "le");
  }
  Wt2.intFromLE = l6;
});
var Lf = k2((bm, _d) => {
  "use strict";
  var wi = Fe(), Nf = ht2(), jn = Nf.getNAF, v6 = Nf.getJSF, Wn = Nf.assert;
  function Xr2(t, e) {
    this.type = t, this.p = new wi(e.p, 16), this.red = e.prime ? wi.red(e.prime) : wi.mont(this.p), this.zero = new wi(0).toRed(this.red), this.one = new wi(1).toRed(this.red), this.two = new wi(2).toRed(this.red), this.n = e.n && new wi(e.n, 16), this.g = e.g && this.pointFromJSON(e.g, e.gRed), this._wnafT1 = new Array(4), this._wnafT2 = new Array(4), this._wnafT3 = new Array(4), this._wnafT4 = new Array(4), this._bitLength = this.n ? this.n.bitLength() : 0;
    var r = this.n && this.p.div(this.n);
    !r || r.cmpn(100) > 0 ? this.redN = null : (this._maxwellTrick = true, this.redN = this.n.toRed(this.red));
  }
  _d.exports = Xr2;
  Xr2.prototype.point = function() {
    throw new Error("Not implemented");
  };
  Xr2.prototype.validate = function() {
    throw new Error("Not implemented");
  };
  Xr2.prototype._fixedNafMul = function(e, r) {
    Wn(e.precomputed);
    var n = e._getDoubles(), i = jn(r, 1, this._bitLength), o2 = (1 << n.step + 1) - (n.step % 2 === 0 ? 2 : 1);
    o2 /= 3;
    var p3 = [], y4, w2;
    for (y4 = 0; y4 < i.length; y4 += n.step) {
      w2 = 0;
      for (var x = y4 + n.step - 1; x >= y4; x--)
        w2 = (w2 << 1) + i[x];
      p3.push(w2);
    }
    for (var M4 = this.jpoint(null, null, null), E2 = this.jpoint(null, null, null), A4 = o2; A4 > 0; A4--) {
      for (y4 = 0; y4 < p3.length; y4++)
        w2 = p3[y4], w2 === A4 ? E2 = E2.mixedAdd(n.points[y4]) : w2 === -A4 && (E2 = E2.mixedAdd(n.points[y4].neg()));
      M4 = M4.add(E2);
    }
    return M4.toP();
  };
  Xr2.prototype._wnafMul = function(e, r) {
    var n = 4, i = e._getNAFPoints(n);
    n = i.wnd;
    for (var o2 = i.points, p3 = jn(r, n, this._bitLength), y4 = this.jpoint(null, null, null), w2 = p3.length - 1; w2 >= 0; w2--) {
      for (var x = 0; w2 >= 0 && p3[w2] === 0; w2--)
        x++;
      if (w2 >= 0 && x++, y4 = y4.dblp(x), w2 < 0)
        break;
      var M4 = p3[w2];
      Wn(M4 !== 0), e.type === "affine" ? M4 > 0 ? y4 = y4.mixedAdd(o2[M4 - 1 >> 1]) : y4 = y4.mixedAdd(o2[-M4 - 1 >> 1].neg()) : M4 > 0 ? y4 = y4.add(o2[M4 - 1 >> 1]) : y4 = y4.add(o2[-M4 - 1 >> 1].neg());
    }
    return e.type === "affine" ? y4.toP() : y4;
  };
  Xr2.prototype._wnafMulAdd = function(e, r, n, i, o2) {
    var p3 = this._wnafT1, y4 = this._wnafT2, w2 = this._wnafT3, x = 0, M4, E2, A4;
    for (M4 = 0; M4 < i; M4++) {
      A4 = r[M4];
      var I3 = A4._getNAFPoints(e);
      p3[M4] = I3.wnd, y4[M4] = I3.points;
    }
    for (M4 = i - 1; M4 >= 1; M4 -= 2) {
      var D6 = M4 - 1, C = M4;
      if (p3[D6] !== 1 || p3[C] !== 1) {
        w2[D6] = jn(n[D6], p3[D6], this._bitLength), w2[C] = jn(n[C], p3[C], this._bitLength), x = Math.max(w2[D6].length, x), x = Math.max(w2[C].length, x);
        continue;
      }
      var ge2 = [r[D6], null, null, r[C]];
      r[D6].y.cmp(r[C].y) === 0 ? (ge2[1] = r[D6].add(r[C]), ge2[2] = r[D6].toJ().mixedAdd(r[C].neg())) : r[D6].y.cmp(r[C].y.redNeg()) === 0 ? (ge2[1] = r[D6].toJ().mixedAdd(r[C]), ge2[2] = r[D6].add(r[C].neg())) : (ge2[1] = r[D6].toJ().mixedAdd(r[C]), ge2[2] = r[D6].toJ().mixedAdd(r[C].neg()));
      var L4 = [-3, -1, -5, -7, 0, 7, 5, 1, 3], ye = v6(n[D6], n[C]);
      for (x = Math.max(ye[0].length, x), w2[D6] = new Array(x), w2[C] = new Array(x), E2 = 0; E2 < x; E2++) {
        var Re = ye[0][E2] | 0, xe3 = ye[1][E2] | 0;
        w2[D6][E2] = L4[(Re + 1) * 3 + (xe3 + 1)], w2[C][E2] = 0, y4[D6] = ge2;
      }
    }
    var ke = this.jpoint(null, null, null), Me = this._wnafT4;
    for (M4 = x; M4 >= 0; M4--) {
      for (var Ce3 = 0; M4 >= 0; ) {
        var Ee2 = true;
        for (E2 = 0; E2 < i; E2++)
          Me[E2] = w2[E2][M4] | 0, Me[E2] !== 0 && (Ee2 = false);
        if (!Ee2)
          break;
        Ce3++, M4--;
      }
      if (M4 >= 0 && Ce3++, ke = ke.dblp(Ce3), M4 < 0)
        break;
      for (E2 = 0; E2 < i; E2++) {
        var Ne3 = Me[E2];
        Ne3 !== 0 && (Ne3 > 0 ? A4 = y4[E2][Ne3 - 1 >> 1] : Ne3 < 0 && (A4 = y4[E2][-Ne3 - 1 >> 1].neg()), A4.type === "affine" ? ke = ke.mixedAdd(A4) : ke = ke.add(A4));
      }
    }
    for (M4 = 0; M4 < i; M4++)
      y4[M4] = null;
    return o2 ? ke : ke.toP();
  };
  function gt2(t, e) {
    this.curve = t, this.type = e, this.precomputed = null;
  }
  Xr2.BasePoint = gt2;
  gt2.prototype.eq = function() {
    throw new Error("Not implemented");
  };
  gt2.prototype.validate = function() {
    return this.curve.validate(this);
  };
  Xr2.prototype.decodePoint = function(e, r) {
    e = Nf.toArray(e, r);
    var n = this.p.byteLength();
    if ((e[0] === 4 || e[0] === 6 || e[0] === 7) && e.length - 1 === 2 * n) {
      e[0] === 6 ? Wn(e[e.length - 1] % 2 === 0) : e[0] === 7 && Wn(e[e.length - 1] % 2 === 1);
      var i = this.point(e.slice(1, 1 + n), e.slice(1 + n, 1 + 2 * n));
      return i;
    } else if ((e[0] === 2 || e[0] === 3) && e.length - 1 === n)
      return this.pointFromX(e.slice(1, 1 + n), e[0] === 3);
    throw new Error("Unknown point format");
  };
  gt2.prototype.encodeCompressed = function(e) {
    return this.encode(e, true);
  };
  gt2.prototype._encode = function(e) {
    var r = this.curve.p.byteLength(), n = this.getX().toArray("be", r);
    return e ? [this.getY().isEven() ? 2 : 3].concat(n) : [4].concat(n, this.getY().toArray("be", r));
  };
  gt2.prototype.encode = function(e, r) {
    return Nf.encode(this._encode(r), e);
  };
  gt2.prototype.precompute = function(e) {
    if (this.precomputed)
      return this;
    var r = { doubles: null, naf: null, beta: null };
    return r.naf = this._getNAFPoints(8), r.doubles = this._getDoubles(4, e), r.beta = this._getBeta(), this.precomputed = r, this;
  };
  gt2.prototype._hasDoubles = function(e) {
    if (!this.precomputed)
      return false;
    var r = this.precomputed.doubles;
    return r ? r.points.length >= Math.ceil((e.bitLength() + 1) / r.step) : false;
  };
  gt2.prototype._getDoubles = function(e, r) {
    if (this.precomputed && this.precomputed.doubles)
      return this.precomputed.doubles;
    for (var n = [this], i = this, o2 = 0; o2 < r; o2 += e) {
      for (var p3 = 0; p3 < e; p3++)
        i = i.dbl();
      n.push(i);
    }
    return { step: e, points: n };
  };
  gt2.prototype._getNAFPoints = function(e) {
    if (this.precomputed && this.precomputed.naf)
      return this.precomputed.naf;
    for (var r = [this], n = (1 << e) - 1, i = n === 1 ? null : this.dbl(), o2 = 1; o2 < n; o2++)
      r[o2] = r[o2 - 1].add(i);
    return { wnd: e, points: r };
  };
  gt2.prototype._getBeta = function() {
    return null;
  };
  gt2.prototype.dblp = function(e) {
    for (var r = this, n = 0; n < e; n++)
      r = r.dbl();
    return r;
  };
});
var xd = k2((mm, wd) => {
  "use strict";
  var p6 = ht2(), Oe = Fe(), j0 = qe(), ji = Lf(), b6 = p6.assert;
  function yt2(t) {
    ji.call(this, "short", t), this.a = new Oe(t.a, 16).toRed(this.red), this.b = new Oe(t.b, 16).toRed(this.red), this.tinv = this.two.redInvm(), this.zeroA = this.a.fromRed().cmpn(0) === 0, this.threeA = this.a.fromRed().sub(this.p).cmpn(-3) === 0, this.endo = this._getEndomorphism(t), this._endoWnafT1 = new Array(4), this._endoWnafT2 = new Array(4);
  }
  j0(yt2, ji);
  wd.exports = yt2;
  yt2.prototype._getEndomorphism = function(e) {
    if (!(!this.zeroA || !this.g || !this.n || this.p.modn(3) !== 1)) {
      var r, n;
      if (e.beta)
        r = new Oe(e.beta, 16).toRed(this.red);
      else {
        var i = this._getEndoRoots(this.p);
        r = i[0].cmp(i[1]) < 0 ? i[0] : i[1], r = r.toRed(this.red);
      }
      if (e.lambda)
        n = new Oe(e.lambda, 16);
      else {
        var o2 = this._getEndoRoots(this.n);
        this.g.mul(o2[0]).x.cmp(this.g.x.redMul(r)) === 0 ? n = o2[0] : (n = o2[1], b6(this.g.mul(n).x.cmp(this.g.x.redMul(r)) === 0));
      }
      var p3;
      return e.basis ? p3 = e.basis.map(function(y4) {
        return { a: new Oe(y4.a, 16), b: new Oe(y4.b, 16) };
      }) : p3 = this._getEndoBasis(n), { beta: r, lambda: n, basis: p3 };
    }
  };
  yt2.prototype._getEndoRoots = function(e) {
    var r = e === this.p ? this.red : Oe.mont(e), n = new Oe(2).toRed(r).redInvm(), i = n.redNeg(), o2 = new Oe(3).toRed(r).redNeg().redSqrt().redMul(n), p3 = i.redAdd(o2).fromRed(), y4 = i.redSub(o2).fromRed();
    return [p3, y4];
  };
  yt2.prototype._getEndoBasis = function(e) {
    for (var r = this.n.ushrn(Math.floor(this.n.bitLength() / 2)), n = e, i = this.n.clone(), o2 = new Oe(1), p3 = new Oe(0), y4 = new Oe(0), w2 = new Oe(1), x, M4, E2, A4, I3, D6, C, ge2 = 0, L4, ye; n.cmpn(0) !== 0; ) {
      var Re = i.div(n);
      L4 = i.sub(Re.mul(n)), ye = y4.sub(Re.mul(o2));
      var xe3 = w2.sub(Re.mul(p3));
      if (!E2 && L4.cmp(r) < 0)
        x = C.neg(), M4 = o2, E2 = L4.neg(), A4 = ye;
      else if (E2 && ++ge2 === 2)
        break;
      C = L4, i = n, n = L4, y4 = o2, o2 = ye, w2 = p3, p3 = xe3;
    }
    I3 = L4.neg(), D6 = ye;
    var ke = E2.sqr().add(A4.sqr()), Me = I3.sqr().add(D6.sqr());
    return Me.cmp(ke) >= 0 && (I3 = x, D6 = M4), E2.negative && (E2 = E2.neg(), A4 = A4.neg()), I3.negative && (I3 = I3.neg(), D6 = D6.neg()), [{ a: E2, b: A4 }, { a: I3, b: D6 }];
  };
  yt2.prototype._endoSplit = function(e) {
    var r = this.endo.basis, n = r[0], i = r[1], o2 = i.b.mul(e).divRound(this.n), p3 = n.b.neg().mul(e).divRound(this.n), y4 = o2.mul(n.a), w2 = p3.mul(i.a), x = o2.mul(n.b), M4 = p3.mul(i.b), E2 = e.sub(y4).sub(w2), A4 = x.add(M4).neg();
    return { k1: E2, k2: A4 };
  };
  yt2.prototype.pointFromX = function(e, r) {
    e = new Oe(e, 16), e.red || (e = e.toRed(this.red));
    var n = e.redSqr().redMul(e).redIAdd(e.redMul(this.a)).redIAdd(this.b), i = n.redSqrt();
    if (i.redSqr().redSub(n).cmp(this.zero) !== 0)
      throw new Error("invalid point");
    var o2 = i.fromRed().isOdd();
    return (r && !o2 || !r && o2) && (i = i.redNeg()), this.point(e, i);
  };
  yt2.prototype.validate = function(e) {
    if (e.inf)
      return true;
    var r = e.x, n = e.y, i = this.a.redMul(r), o2 = r.redSqr().redMul(r).redIAdd(i).redIAdd(this.b);
    return n.redSqr().redISub(o2).cmpn(0) === 0;
  };
  yt2.prototype._endoWnafMulAdd = function(e, r, n) {
    for (var i = this._endoWnafT1, o2 = this._endoWnafT2, p3 = 0; p3 < e.length; p3++) {
      var y4 = this._endoSplit(r[p3]), w2 = e[p3], x = w2._getBeta();
      y4.k1.negative && (y4.k1.ineg(), w2 = w2.neg(true)), y4.k2.negative && (y4.k2.ineg(), x = x.neg(true)), i[p3 * 2] = w2, i[p3 * 2 + 1] = x, o2[p3 * 2] = y4.k1, o2[p3 * 2 + 1] = y4.k2;
    }
    for (var M4 = this._wnafMulAdd(1, i, o2, p3 * 2, n), E2 = 0; E2 < p3 * 2; E2++)
      i[E2] = null, o2[E2] = null;
    return M4;
  };
  function We(t, e, r, n) {
    ji.BasePoint.call(this, t, "affine"), e === null && r === null ? (this.x = null, this.y = null, this.inf = true) : (this.x = new Oe(e, 16), this.y = new Oe(r, 16), n && (this.x.forceRed(this.curve.red), this.y.forceRed(this.curve.red)), this.x.red || (this.x = this.x.toRed(this.curve.red)), this.y.red || (this.y = this.y.toRed(this.curve.red)), this.inf = false);
  }
  j0(We, ji.BasePoint);
  yt2.prototype.point = function(e, r, n) {
    return new We(this, e, r, n);
  };
  yt2.prototype.pointFromJSON = function(e, r) {
    return We.fromJSON(this, e, r);
  };
  We.prototype._getBeta = function() {
    if (!!this.curve.endo) {
      var e = this.precomputed;
      if (e && e.beta)
        return e.beta;
      var r = this.curve.point(this.x.redMul(this.curve.endo.beta), this.y);
      if (e) {
        var n = this.curve, i = function(o2) {
          return n.point(o2.x.redMul(n.endo.beta), o2.y);
        };
        e.beta = r, r.precomputed = { beta: null, naf: e.naf && { wnd: e.naf.wnd, points: e.naf.points.map(i) }, doubles: e.doubles && { step: e.doubles.step, points: e.doubles.points.map(i) } };
      }
      return r;
    }
  };
  We.prototype.toJSON = function() {
    return this.precomputed ? [this.x, this.y, this.precomputed && { doubles: this.precomputed.doubles && { step: this.precomputed.doubles.step, points: this.precomputed.doubles.points.slice(1) }, naf: this.precomputed.naf && { wnd: this.precomputed.naf.wnd, points: this.precomputed.naf.points.slice(1) } }] : [this.x, this.y];
  };
  We.fromJSON = function(e, r, n) {
    typeof r == "string" && (r = JSON.parse(r));
    var i = e.point(r[0], r[1], n);
    if (!r[2])
      return i;
    function o2(y4) {
      return e.point(y4[0], y4[1], n);
    }
    var p3 = r[2];
    return i.precomputed = { beta: null, doubles: p3.doubles && { step: p3.doubles.step, points: [i].concat(p3.doubles.points.map(o2)) }, naf: p3.naf && { wnd: p3.naf.wnd, points: [i].concat(p3.naf.points.map(o2)) } }, i;
  };
  We.prototype.inspect = function() {
    return this.isInfinity() ? "<EC Point Infinity>" : "<EC Point x: " + this.x.fromRed().toString(16, 2) + " y: " + this.y.fromRed().toString(16, 2) + ">";
  };
  We.prototype.isInfinity = function() {
    return this.inf;
  };
  We.prototype.add = function(e) {
    if (this.inf)
      return e;
    if (e.inf)
      return this;
    if (this.eq(e))
      return this.dbl();
    if (this.neg().eq(e))
      return this.curve.point(null, null);
    if (this.x.cmp(e.x) === 0)
      return this.curve.point(null, null);
    var r = this.y.redSub(e.y);
    r.cmpn(0) !== 0 && (r = r.redMul(this.x.redSub(e.x).redInvm()));
    var n = r.redSqr().redISub(this.x).redISub(e.x), i = r.redMul(this.x.redSub(n)).redISub(this.y);
    return this.curve.point(n, i);
  };
  We.prototype.dbl = function() {
    if (this.inf)
      return this;
    var e = this.y.redAdd(this.y);
    if (e.cmpn(0) === 0)
      return this.curve.point(null, null);
    var r = this.curve.a, n = this.x.redSqr(), i = e.redInvm(), o2 = n.redAdd(n).redIAdd(n).redIAdd(r).redMul(i), p3 = o2.redSqr().redISub(this.x.redAdd(this.x)), y4 = o2.redMul(this.x.redSub(p3)).redISub(this.y);
    return this.curve.point(p3, y4);
  };
  We.prototype.getX = function() {
    return this.x.fromRed();
  };
  We.prototype.getY = function() {
    return this.y.fromRed();
  };
  We.prototype.mul = function(e) {
    return e = new Oe(e, 16), this.isInfinity() ? this : this._hasDoubles(e) ? this.curve._fixedNafMul(this, e) : this.curve.endo ? this.curve._endoWnafMulAdd([this], [e]) : this.curve._wnafMul(this, e);
  };
  We.prototype.mulAdd = function(e, r, n) {
    var i = [this, r], o2 = [e, n];
    return this.curve.endo ? this.curve._endoWnafMulAdd(i, o2) : this.curve._wnafMulAdd(1, i, o2, 2);
  };
  We.prototype.jmulAdd = function(e, r, n) {
    var i = [this, r], o2 = [e, n];
    return this.curve.endo ? this.curve._endoWnafMulAdd(i, o2, true) : this.curve._wnafMulAdd(1, i, o2, 2, true);
  };
  We.prototype.eq = function(e) {
    return this === e || this.inf === e.inf && (this.inf || this.x.cmp(e.x) === 0 && this.y.cmp(e.y) === 0);
  };
  We.prototype.neg = function(e) {
    if (this.inf)
      return this;
    var r = this.curve.point(this.x, this.y.redNeg());
    if (e && this.precomputed) {
      var n = this.precomputed, i = function(o2) {
        return o2.neg();
      };
      r.precomputed = { naf: n.naf && { wnd: n.naf.wnd, points: n.naf.points.map(i) }, doubles: n.doubles && { step: n.doubles.step, points: n.doubles.points.map(i) } };
    }
    return r;
  };
  We.prototype.toJ = function() {
    if (this.inf)
      return this.curve.jpoint(null, null, null);
    var e = this.curve.jpoint(this.x, this.y, this.curve.one);
    return e;
  };
  function Xe2(t, e, r, n) {
    ji.BasePoint.call(this, t, "jacobian"), e === null && r === null && n === null ? (this.x = this.curve.one, this.y = this.curve.one, this.z = new Oe(0)) : (this.x = new Oe(e, 16), this.y = new Oe(r, 16), this.z = new Oe(n, 16)), this.x.red || (this.x = this.x.toRed(this.curve.red)), this.y.red || (this.y = this.y.toRed(this.curve.red)), this.z.red || (this.z = this.z.toRed(this.curve.red)), this.zOne = this.z === this.curve.one;
  }
  j0(Xe2, ji.BasePoint);
  yt2.prototype.jpoint = function(e, r, n) {
    return new Xe2(this, e, r, n);
  };
  Xe2.prototype.toP = function() {
    if (this.isInfinity())
      return this.curve.point(null, null);
    var e = this.z.redInvm(), r = e.redSqr(), n = this.x.redMul(r), i = this.y.redMul(r).redMul(e);
    return this.curve.point(n, i);
  };
  Xe2.prototype.neg = function() {
    return this.curve.jpoint(this.x, this.y.redNeg(), this.z);
  };
  Xe2.prototype.add = function(e) {
    if (this.isInfinity())
      return e;
    if (e.isInfinity())
      return this;
    var r = e.z.redSqr(), n = this.z.redSqr(), i = this.x.redMul(r), o2 = e.x.redMul(n), p3 = this.y.redMul(r.redMul(e.z)), y4 = e.y.redMul(n.redMul(this.z)), w2 = i.redSub(o2), x = p3.redSub(y4);
    if (w2.cmpn(0) === 0)
      return x.cmpn(0) !== 0 ? this.curve.jpoint(null, null, null) : this.dbl();
    var M4 = w2.redSqr(), E2 = M4.redMul(w2), A4 = i.redMul(M4), I3 = x.redSqr().redIAdd(E2).redISub(A4).redISub(A4), D6 = x.redMul(A4.redISub(I3)).redISub(p3.redMul(E2)), C = this.z.redMul(e.z).redMul(w2);
    return this.curve.jpoint(I3, D6, C);
  };
  Xe2.prototype.mixedAdd = function(e) {
    if (this.isInfinity())
      return e.toJ();
    if (e.isInfinity())
      return this;
    var r = this.z.redSqr(), n = this.x, i = e.x.redMul(r), o2 = this.y, p3 = e.y.redMul(r).redMul(this.z), y4 = n.redSub(i), w2 = o2.redSub(p3);
    if (y4.cmpn(0) === 0)
      return w2.cmpn(0) !== 0 ? this.curve.jpoint(null, null, null) : this.dbl();
    var x = y4.redSqr(), M4 = x.redMul(y4), E2 = n.redMul(x), A4 = w2.redSqr().redIAdd(M4).redISub(E2).redISub(E2), I3 = w2.redMul(E2.redISub(A4)).redISub(o2.redMul(M4)), D6 = this.z.redMul(y4);
    return this.curve.jpoint(A4, I3, D6);
  };
  Xe2.prototype.dblp = function(e) {
    if (e === 0)
      return this;
    if (this.isInfinity())
      return this;
    if (!e)
      return this.dbl();
    var r;
    if (this.curve.zeroA || this.curve.threeA) {
      var n = this;
      for (r = 0; r < e; r++)
        n = n.dbl();
      return n;
    }
    var i = this.curve.a, o2 = this.curve.tinv, p3 = this.x, y4 = this.y, w2 = this.z, x = w2.redSqr().redSqr(), M4 = y4.redAdd(y4);
    for (r = 0; r < e; r++) {
      var E2 = p3.redSqr(), A4 = M4.redSqr(), I3 = A4.redSqr(), D6 = E2.redAdd(E2).redIAdd(E2).redIAdd(i.redMul(x)), C = p3.redMul(A4), ge2 = D6.redSqr().redISub(C.redAdd(C)), L4 = C.redISub(ge2), ye = D6.redMul(L4);
      ye = ye.redIAdd(ye).redISub(I3);
      var Re = M4.redMul(w2);
      r + 1 < e && (x = x.redMul(I3)), p3 = ge2, w2 = Re, M4 = ye;
    }
    return this.curve.jpoint(p3, M4.redMul(o2), w2);
  };
  Xe2.prototype.dbl = function() {
    return this.isInfinity() ? this : this.curve.zeroA ? this._zeroDbl() : this.curve.threeA ? this._threeDbl() : this._dbl();
  };
  Xe2.prototype._zeroDbl = function() {
    var e, r, n;
    if (this.zOne) {
      var i = this.x.redSqr(), o2 = this.y.redSqr(), p3 = o2.redSqr(), y4 = this.x.redAdd(o2).redSqr().redISub(i).redISub(p3);
      y4 = y4.redIAdd(y4);
      var w2 = i.redAdd(i).redIAdd(i), x = w2.redSqr().redISub(y4).redISub(y4), M4 = p3.redIAdd(p3);
      M4 = M4.redIAdd(M4), M4 = M4.redIAdd(M4), e = x, r = w2.redMul(y4.redISub(x)).redISub(M4), n = this.y.redAdd(this.y);
    } else {
      var E2 = this.x.redSqr(), A4 = this.y.redSqr(), I3 = A4.redSqr(), D6 = this.x.redAdd(A4).redSqr().redISub(E2).redISub(I3);
      D6 = D6.redIAdd(D6);
      var C = E2.redAdd(E2).redIAdd(E2), ge2 = C.redSqr(), L4 = I3.redIAdd(I3);
      L4 = L4.redIAdd(L4), L4 = L4.redIAdd(L4), e = ge2.redISub(D6).redISub(D6), r = C.redMul(D6.redISub(e)).redISub(L4), n = this.y.redMul(this.z), n = n.redIAdd(n);
    }
    return this.curve.jpoint(e, r, n);
  };
  Xe2.prototype._threeDbl = function() {
    var e, r, n;
    if (this.zOne) {
      var i = this.x.redSqr(), o2 = this.y.redSqr(), p3 = o2.redSqr(), y4 = this.x.redAdd(o2).redSqr().redISub(i).redISub(p3);
      y4 = y4.redIAdd(y4);
      var w2 = i.redAdd(i).redIAdd(i).redIAdd(this.curve.a), x = w2.redSqr().redISub(y4).redISub(y4);
      e = x;
      var M4 = p3.redIAdd(p3);
      M4 = M4.redIAdd(M4), M4 = M4.redIAdd(M4), r = w2.redMul(y4.redISub(x)).redISub(M4), n = this.y.redAdd(this.y);
    } else {
      var E2 = this.z.redSqr(), A4 = this.y.redSqr(), I3 = this.x.redMul(A4), D6 = this.x.redSub(E2).redMul(this.x.redAdd(E2));
      D6 = D6.redAdd(D6).redIAdd(D6);
      var C = I3.redIAdd(I3);
      C = C.redIAdd(C);
      var ge2 = C.redAdd(C);
      e = D6.redSqr().redISub(ge2), n = this.y.redAdd(this.z).redSqr().redISub(A4).redISub(E2);
      var L4 = A4.redSqr();
      L4 = L4.redIAdd(L4), L4 = L4.redIAdd(L4), L4 = L4.redIAdd(L4), r = D6.redMul(C.redISub(e)).redISub(L4);
    }
    return this.curve.jpoint(e, r, n);
  };
  Xe2.prototype._dbl = function() {
    var e = this.curve.a, r = this.x, n = this.y, i = this.z, o2 = i.redSqr().redSqr(), p3 = r.redSqr(), y4 = n.redSqr(), w2 = p3.redAdd(p3).redIAdd(p3).redIAdd(e.redMul(o2)), x = r.redAdd(r);
    x = x.redIAdd(x);
    var M4 = x.redMul(y4), E2 = w2.redSqr().redISub(M4.redAdd(M4)), A4 = M4.redISub(E2), I3 = y4.redSqr();
    I3 = I3.redIAdd(I3), I3 = I3.redIAdd(I3), I3 = I3.redIAdd(I3);
    var D6 = w2.redMul(A4).redISub(I3), C = n.redAdd(n).redMul(i);
    return this.curve.jpoint(E2, D6, C);
  };
  Xe2.prototype.trpl = function() {
    if (!this.curve.zeroA)
      return this.dbl().add(this);
    var e = this.x.redSqr(), r = this.y.redSqr(), n = this.z.redSqr(), i = r.redSqr(), o2 = e.redAdd(e).redIAdd(e), p3 = o2.redSqr(), y4 = this.x.redAdd(r).redSqr().redISub(e).redISub(i);
    y4 = y4.redIAdd(y4), y4 = y4.redAdd(y4).redIAdd(y4), y4 = y4.redISub(p3);
    var w2 = y4.redSqr(), x = i.redIAdd(i);
    x = x.redIAdd(x), x = x.redIAdd(x), x = x.redIAdd(x);
    var M4 = o2.redIAdd(y4).redSqr().redISub(p3).redISub(w2).redISub(x), E2 = r.redMul(M4);
    E2 = E2.redIAdd(E2), E2 = E2.redIAdd(E2);
    var A4 = this.x.redMul(w2).redISub(E2);
    A4 = A4.redIAdd(A4), A4 = A4.redIAdd(A4);
    var I3 = this.y.redMul(M4.redMul(x.redISub(M4)).redISub(y4.redMul(w2)));
    I3 = I3.redIAdd(I3), I3 = I3.redIAdd(I3), I3 = I3.redIAdd(I3);
    var D6 = this.z.redAdd(y4).redSqr().redISub(n).redISub(w2);
    return this.curve.jpoint(A4, I3, D6);
  };
  Xe2.prototype.mul = function(e, r) {
    return e = new Oe(e, r), this.curve._wnafMul(this, e);
  };
  Xe2.prototype.eq = function(e) {
    if (e.type === "affine")
      return this.eq(e.toJ());
    if (this === e)
      return true;
    var r = this.z.redSqr(), n = e.z.redSqr();
    if (this.x.redMul(n).redISub(e.x.redMul(r)).cmpn(0) !== 0)
      return false;
    var i = r.redMul(this.z), o2 = n.redMul(e.z);
    return this.y.redMul(o2).redISub(e.y.redMul(i)).cmpn(0) === 0;
  };
  Xe2.prototype.eqXToP = function(e) {
    var r = this.z.redSqr(), n = e.toRed(this.curve.red).redMul(r);
    if (this.x.cmp(n) === 0)
      return true;
    for (var i = e.clone(), o2 = this.curve.redN.redMul(r); ; ) {
      if (i.iadd(this.curve.n), i.cmp(this.curve.p) >= 0)
        return false;
      if (n.redIAdd(o2), this.x.cmp(n) === 0)
        return true;
    }
  };
  Xe2.prototype.inspect = function() {
    return this.isInfinity() ? "<EC JPoint Infinity>" : "<EC JPoint x: " + this.x.toString(16, 2) + " y: " + this.y.toString(16, 2) + " z: " + this.z.toString(16, 2) + ">";
  };
  Xe2.prototype.isInfinity = function() {
    return this.z.cmpn(0) === 0;
  };
});
var Ed = k2((gm, Sd) => {
  "use strict";
  var Wi = Fe(), Md = qe(), Vn = Lf(), m6 = ht2();
  function Vi(t) {
    Vn.call(this, "mont", t), this.a = new Wi(t.a, 16).toRed(this.red), this.b = new Wi(t.b, 16).toRed(this.red), this.i4 = new Wi(4).toRed(this.red).redInvm(), this.two = new Wi(2).toRed(this.red), this.a24 = this.i4.redMul(this.a.redAdd(this.two));
  }
  Md(Vi, Vn);
  Sd.exports = Vi;
  Vi.prototype.validate = function(e) {
    var r = e.normalize().x, n = r.redSqr(), i = n.redMul(r).redAdd(n.redMul(this.a)).redAdd(r), o2 = i.redSqrt();
    return o2.redSqr().cmp(i) === 0;
  };
  function Ve2(t, e, r) {
    Vn.BasePoint.call(this, t, "projective"), e === null && r === null ? (this.x = this.curve.one, this.z = this.curve.zero) : (this.x = new Wi(e, 16), this.z = new Wi(r, 16), this.x.red || (this.x = this.x.toRed(this.curve.red)), this.z.red || (this.z = this.z.toRed(this.curve.red)));
  }
  Md(Ve2, Vn.BasePoint);
  Vi.prototype.decodePoint = function(e, r) {
    return this.point(m6.toArray(e, r), 1);
  };
  Vi.prototype.point = function(e, r) {
    return new Ve2(this, e, r);
  };
  Vi.prototype.pointFromJSON = function(e) {
    return Ve2.fromJSON(this, e);
  };
  Ve2.prototype.precompute = function() {
  };
  Ve2.prototype._encode = function() {
    return this.getX().toArray("be", this.curve.p.byteLength());
  };
  Ve2.fromJSON = function(e, r) {
    return new Ve2(e, r[0], r[1] || e.one);
  };
  Ve2.prototype.inspect = function() {
    return this.isInfinity() ? "<EC Point Infinity>" : "<EC Point x: " + this.x.fromRed().toString(16, 2) + " z: " + this.z.fromRed().toString(16, 2) + ">";
  };
  Ve2.prototype.isInfinity = function() {
    return this.z.cmpn(0) === 0;
  };
  Ve2.prototype.dbl = function() {
    var e = this.x.redAdd(this.z), r = e.redSqr(), n = this.x.redSub(this.z), i = n.redSqr(), o2 = r.redSub(i), p3 = r.redMul(i), y4 = o2.redMul(i.redAdd(this.curve.a24.redMul(o2)));
    return this.curve.point(p3, y4);
  };
  Ve2.prototype.add = function() {
    throw new Error("Not supported on Montgomery curve");
  };
  Ve2.prototype.diffAdd = function(e, r) {
    var n = this.x.redAdd(this.z), i = this.x.redSub(this.z), o2 = e.x.redAdd(e.z), p3 = e.x.redSub(e.z), y4 = p3.redMul(n), w2 = o2.redMul(i), x = r.z.redMul(y4.redAdd(w2).redSqr()), M4 = r.x.redMul(y4.redISub(w2).redSqr());
    return this.curve.point(x, M4);
  };
  Ve2.prototype.mul = function(e) {
    for (var r = e.clone(), n = this, i = this.curve.point(null, null), o2 = this, p3 = []; r.cmpn(0) !== 0; r.iushrn(1))
      p3.push(r.andln(1));
    for (var y4 = p3.length - 1; y4 >= 0; y4--)
      p3[y4] === 0 ? (n = n.diffAdd(i, o2), i = i.dbl()) : (i = n.diffAdd(i, o2), n = n.dbl());
    return i;
  };
  Ve2.prototype.mulAdd = function() {
    throw new Error("Not supported on Montgomery curve");
  };
  Ve2.prototype.jumlAdd = function() {
    throw new Error("Not supported on Montgomery curve");
  };
  Ve2.prototype.eq = function(e) {
    return this.getX().cmp(e.getX()) === 0;
  };
  Ve2.prototype.normalize = function() {
    return this.x = this.x.redMul(this.z.redInvm()), this.z = this.curve.one, this;
  };
  Ve2.prototype.getX = function() {
    return this.normalize(), this.x.fromRed();
  };
});
var Bd = k2((ym, qd) => {
  "use strict";
  var g6 = ht2(), _r2 = Fe(), Ad = qe(), Zn = Lf(), y6 = g6.assert;
  function ir2(t) {
    this.twisted = (t.a | 0) !== 1, this.mOneA = this.twisted && (t.a | 0) === -1, this.extended = this.mOneA, Zn.call(this, "edwards", t), this.a = new _r2(t.a, 16).umod(this.red.m), this.a = this.a.toRed(this.red), this.c = new _r2(t.c, 16).toRed(this.red), this.c2 = this.c.redSqr(), this.d = new _r2(t.d, 16).toRed(this.red), this.dd = this.d.redAdd(this.d), y6(!this.twisted || this.c.fromRed().cmpn(1) === 0), this.oneC = (t.c | 0) === 1;
  }
  Ad(ir2, Zn);
  qd.exports = ir2;
  ir2.prototype._mulA = function(e) {
    return this.mOneA ? e.redNeg() : this.a.redMul(e);
  };
  ir2.prototype._mulC = function(e) {
    return this.oneC ? e : this.c.redMul(e);
  };
  ir2.prototype.jpoint = function(e, r, n, i) {
    return this.point(e, r, n, i);
  };
  ir2.prototype.pointFromX = function(e, r) {
    e = new _r2(e, 16), e.red || (e = e.toRed(this.red));
    var n = e.redSqr(), i = this.c2.redSub(this.a.redMul(n)), o2 = this.one.redSub(this.c2.redMul(this.d).redMul(n)), p3 = i.redMul(o2.redInvm()), y4 = p3.redSqrt();
    if (y4.redSqr().redSub(p3).cmp(this.zero) !== 0)
      throw new Error("invalid point");
    var w2 = y4.fromRed().isOdd();
    return (r && !w2 || !r && w2) && (y4 = y4.redNeg()), this.point(e, y4);
  };
  ir2.prototype.pointFromY = function(e, r) {
    e = new _r2(e, 16), e.red || (e = e.toRed(this.red));
    var n = e.redSqr(), i = n.redSub(this.c2), o2 = n.redMul(this.d).redMul(this.c2).redSub(this.a), p3 = i.redMul(o2.redInvm());
    if (p3.cmp(this.zero) === 0) {
      if (r)
        throw new Error("invalid point");
      return this.point(this.zero, e);
    }
    var y4 = p3.redSqrt();
    if (y4.redSqr().redSub(p3).cmp(this.zero) !== 0)
      throw new Error("invalid point");
    return y4.fromRed().isOdd() !== r && (y4 = y4.redNeg()), this.point(y4, e);
  };
  ir2.prototype.validate = function(e) {
    if (e.isInfinity())
      return true;
    e.normalize();
    var r = e.x.redSqr(), n = e.y.redSqr(), i = r.redMul(this.a).redAdd(n), o2 = this.c2.redMul(this.one.redAdd(this.d.redMul(r).redMul(n)));
    return i.cmp(o2) === 0;
  };
  function Te(t, e, r, n, i) {
    Zn.BasePoint.call(this, t, "projective"), e === null && r === null && n === null ? (this.x = this.curve.zero, this.y = this.curve.one, this.z = this.curve.one, this.t = this.curve.zero, this.zOne = true) : (this.x = new _r2(e, 16), this.y = new _r2(r, 16), this.z = n ? new _r2(n, 16) : this.curve.one, this.t = i && new _r2(i, 16), this.x.red || (this.x = this.x.toRed(this.curve.red)), this.y.red || (this.y = this.y.toRed(this.curve.red)), this.z.red || (this.z = this.z.toRed(this.curve.red)), this.t && !this.t.red && (this.t = this.t.toRed(this.curve.red)), this.zOne = this.z === this.curve.one, this.curve.extended && !this.t && (this.t = this.x.redMul(this.y), this.zOne || (this.t = this.t.redMul(this.z.redInvm()))));
  }
  Ad(Te, Zn.BasePoint);
  ir2.prototype.pointFromJSON = function(e) {
    return Te.fromJSON(this, e);
  };
  ir2.prototype.point = function(e, r, n, i) {
    return new Te(this, e, r, n, i);
  };
  Te.fromJSON = function(e, r) {
    return new Te(e, r[0], r[1], r[2]);
  };
  Te.prototype.inspect = function() {
    return this.isInfinity() ? "<EC Point Infinity>" : "<EC Point x: " + this.x.fromRed().toString(16, 2) + " y: " + this.y.fromRed().toString(16, 2) + " z: " + this.z.fromRed().toString(16, 2) + ">";
  };
  Te.prototype.isInfinity = function() {
    return this.x.cmpn(0) === 0 && (this.y.cmp(this.z) === 0 || this.zOne && this.y.cmp(this.curve.c) === 0);
  };
  Te.prototype._extDbl = function() {
    var e = this.x.redSqr(), r = this.y.redSqr(), n = this.z.redSqr();
    n = n.redIAdd(n);
    var i = this.curve._mulA(e), o2 = this.x.redAdd(this.y).redSqr().redISub(e).redISub(r), p3 = i.redAdd(r), y4 = p3.redSub(n), w2 = i.redSub(r), x = o2.redMul(y4), M4 = p3.redMul(w2), E2 = o2.redMul(w2), A4 = y4.redMul(p3);
    return this.curve.point(x, M4, A4, E2);
  };
  Te.prototype._projDbl = function() {
    var e = this.x.redAdd(this.y).redSqr(), r = this.x.redSqr(), n = this.y.redSqr(), i, o2, p3, y4, w2, x;
    if (this.curve.twisted) {
      y4 = this.curve._mulA(r);
      var M4 = y4.redAdd(n);
      this.zOne ? (i = e.redSub(r).redSub(n).redMul(M4.redSub(this.curve.two)), o2 = M4.redMul(y4.redSub(n)), p3 = M4.redSqr().redSub(M4).redSub(M4)) : (w2 = this.z.redSqr(), x = M4.redSub(w2).redISub(w2), i = e.redSub(r).redISub(n).redMul(x), o2 = M4.redMul(y4.redSub(n)), p3 = M4.redMul(x));
    } else
      y4 = r.redAdd(n), w2 = this.curve._mulC(this.z).redSqr(), x = y4.redSub(w2).redSub(w2), i = this.curve._mulC(e.redISub(y4)).redMul(x), o2 = this.curve._mulC(y4).redMul(r.redISub(n)), p3 = y4.redMul(x);
    return this.curve.point(i, o2, p3);
  };
  Te.prototype.dbl = function() {
    return this.isInfinity() ? this : this.curve.extended ? this._extDbl() : this._projDbl();
  };
  Te.prototype._extAdd = function(e) {
    var r = this.y.redSub(this.x).redMul(e.y.redSub(e.x)), n = this.y.redAdd(this.x).redMul(e.y.redAdd(e.x)), i = this.t.redMul(this.curve.dd).redMul(e.t), o2 = this.z.redMul(e.z.redAdd(e.z)), p3 = n.redSub(r), y4 = o2.redSub(i), w2 = o2.redAdd(i), x = n.redAdd(r), M4 = p3.redMul(y4), E2 = w2.redMul(x), A4 = p3.redMul(x), I3 = y4.redMul(w2);
    return this.curve.point(M4, E2, I3, A4);
  };
  Te.prototype._projAdd = function(e) {
    var r = this.z.redMul(e.z), n = r.redSqr(), i = this.x.redMul(e.x), o2 = this.y.redMul(e.y), p3 = this.curve.d.redMul(i).redMul(o2), y4 = n.redSub(p3), w2 = n.redAdd(p3), x = this.x.redAdd(this.y).redMul(e.x.redAdd(e.y)).redISub(i).redISub(o2), M4 = r.redMul(y4).redMul(x), E2, A4;
    return this.curve.twisted ? (E2 = r.redMul(w2).redMul(o2.redSub(this.curve._mulA(i))), A4 = y4.redMul(w2)) : (E2 = r.redMul(w2).redMul(o2.redSub(i)), A4 = this.curve._mulC(y4).redMul(w2)), this.curve.point(M4, E2, A4);
  };
  Te.prototype.add = function(e) {
    return this.isInfinity() ? e : e.isInfinity() ? this : this.curve.extended ? this._extAdd(e) : this._projAdd(e);
  };
  Te.prototype.mul = function(e) {
    return this._hasDoubles(e) ? this.curve._fixedNafMul(this, e) : this.curve._wnafMul(this, e);
  };
  Te.prototype.mulAdd = function(e, r, n) {
    return this.curve._wnafMulAdd(1, [this, r], [e, n], 2, false);
  };
  Te.prototype.jmulAdd = function(e, r, n) {
    return this.curve._wnafMulAdd(1, [this, r], [e, n], 2, true);
  };
  Te.prototype.normalize = function() {
    if (this.zOne)
      return this;
    var e = this.z.redInvm();
    return this.x = this.x.redMul(e), this.y = this.y.redMul(e), this.t && (this.t = this.t.redMul(e)), this.z = this.curve.one, this.zOne = true, this;
  };
  Te.prototype.neg = function() {
    return this.curve.point(this.x.redNeg(), this.y, this.z, this.t && this.t.redNeg());
  };
  Te.prototype.getX = function() {
    return this.normalize(), this.x.fromRed();
  };
  Te.prototype.getY = function() {
    return this.normalize(), this.y.fromRed();
  };
  Te.prototype.eq = function(e) {
    return this === e || this.getX().cmp(e.getX()) === 0 && this.getY().cmp(e.getY()) === 0;
  };
  Te.prototype.eqXToP = function(e) {
    var r = e.toRed(this.curve.red).redMul(this.z);
    if (this.x.cmp(r) === 0)
      return true;
    for (var n = e.clone(), i = this.curve.redN.redMul(this.z); ; ) {
      if (n.iadd(this.curve.n), n.cmp(this.curve.p) >= 0)
        return false;
      if (r.redIAdd(i), this.x.cmp(r) === 0)
        return true;
    }
  };
  Te.prototype.toP = Te.prototype.normalize;
  Te.prototype.mixedAdd = Te.prototype.add;
});
var W0 = k2((Rd) => {
  "use strict";
  var Gn = Rd;
  Gn.base = Lf();
  Gn.short = xd();
  Gn.mont = Ed();
  Gn.edwards = Bd();
});
var Vt = k2((Pe) => {
  "use strict";
  var _6 = ot(), w6 = qe();
  Pe.inherits = w6;
  function x6(t, e) {
    return (t.charCodeAt(e) & 64512) !== 55296 || e < 0 || e + 1 >= t.length ? false : (t.charCodeAt(e + 1) & 64512) === 56320;
  }
  function M6(t, e) {
    if (Array.isArray(t))
      return t.slice();
    if (!t)
      return [];
    var r = [];
    if (typeof t == "string")
      if (e) {
        if (e === "hex")
          for (t = t.replace(/[^a-z0-9]+/ig, ""), t.length % 2 !== 0 && (t = "0" + t), i = 0; i < t.length; i += 2)
            r.push(parseInt(t[i] + t[i + 1], 16));
      } else
        for (var n = 0, i = 0; i < t.length; i++) {
          var o2 = t.charCodeAt(i);
          o2 < 128 ? r[n++] = o2 : o2 < 2048 ? (r[n++] = o2 >> 6 | 192, r[n++] = o2 & 63 | 128) : x6(t, i) ? (o2 = 65536 + ((o2 & 1023) << 10) + (t.charCodeAt(++i) & 1023), r[n++] = o2 >> 18 | 240, r[n++] = o2 >> 12 & 63 | 128, r[n++] = o2 >> 6 & 63 | 128, r[n++] = o2 & 63 | 128) : (r[n++] = o2 >> 12 | 224, r[n++] = o2 >> 6 & 63 | 128, r[n++] = o2 & 63 | 128);
        }
    else
      for (i = 0; i < t.length; i++)
        r[i] = t[i] | 0;
    return r;
  }
  Pe.toArray = M6;
  function S6(t) {
    for (var e = "", r = 0; r < t.length; r++)
      e += kd(t[r].toString(16));
    return e;
  }
  Pe.toHex = S6;
  function Id(t) {
    var e = t >>> 24 | t >>> 8 & 65280 | t << 8 & 16711680 | (t & 255) << 24;
    return e >>> 0;
  }
  Pe.htonl = Id;
  function E6(t, e) {
    for (var r = "", n = 0; n < t.length; n++) {
      var i = t[n];
      e === "little" && (i = Id(i)), r += Dd(i.toString(16));
    }
    return r;
  }
  Pe.toHex32 = E6;
  function kd(t) {
    return t.length === 1 ? "0" + t : t;
  }
  Pe.zero2 = kd;
  function Dd(t) {
    return t.length === 7 ? "0" + t : t.length === 6 ? "00" + t : t.length === 5 ? "000" + t : t.length === 4 ? "0000" + t : t.length === 3 ? "00000" + t : t.length === 2 ? "000000" + t : t.length === 1 ? "0000000" + t : t;
  }
  Pe.zero8 = Dd;
  function A6(t, e, r, n) {
    var i = r - e;
    _6(i % 4 === 0);
    for (var o2 = new Array(i / 4), p3 = 0, y4 = e; p3 < o2.length; p3++, y4 += 4) {
      var w2;
      n === "big" ? w2 = t[y4] << 24 | t[y4 + 1] << 16 | t[y4 + 2] << 8 | t[y4 + 3] : w2 = t[y4 + 3] << 24 | t[y4 + 2] << 16 | t[y4 + 1] << 8 | t[y4], o2[p3] = w2 >>> 0;
    }
    return o2;
  }
  Pe.join32 = A6;
  function q6(t, e) {
    for (var r = new Array(t.length * 4), n = 0, i = 0; n < t.length; n++, i += 4) {
      var o2 = t[n];
      e === "big" ? (r[i] = o2 >>> 24, r[i + 1] = o2 >>> 16 & 255, r[i + 2] = o2 >>> 8 & 255, r[i + 3] = o2 & 255) : (r[i + 3] = o2 >>> 24, r[i + 2] = o2 >>> 16 & 255, r[i + 1] = o2 >>> 8 & 255, r[i] = o2 & 255);
    }
    return r;
  }
  Pe.split32 = q6;
  function B6(t, e) {
    return t >>> e | t << 32 - e;
  }
  Pe.rotr32 = B6;
  function R6(t, e) {
    return t << e | t >>> 32 - e;
  }
  Pe.rotl32 = R6;
  function I6(t, e) {
    return t + e >>> 0;
  }
  Pe.sum32 = I6;
  function k6(t, e, r) {
    return t + e + r >>> 0;
  }
  Pe.sum32_3 = k6;
  function D6(t, e, r, n) {
    return t + e + r + n >>> 0;
  }
  Pe.sum32_4 = D6;
  function P6(t, e, r, n, i) {
    return t + e + r + n + i >>> 0;
  }
  Pe.sum32_5 = P6;
  function T6(t, e, r, n) {
    var i = t[e], o2 = t[e + 1], p3 = n + o2 >>> 0, y4 = (p3 < n ? 1 : 0) + r + i;
    t[e] = y4 >>> 0, t[e + 1] = p3;
  }
  Pe.sum64 = T6;
  function C6(t, e, r, n) {
    var i = e + n >>> 0, o2 = (i < e ? 1 : 0) + t + r;
    return o2 >>> 0;
  }
  Pe.sum64_hi = C6;
  function N6(t, e, r, n) {
    var i = e + n;
    return i >>> 0;
  }
  Pe.sum64_lo = N6;
  function L6(t, e, r, n, i, o2, p3, y4) {
    var w2 = 0, x = e;
    x = x + n >>> 0, w2 += x < e ? 1 : 0, x = x + o2 >>> 0, w2 += x < o2 ? 1 : 0, x = x + y4 >>> 0, w2 += x < y4 ? 1 : 0;
    var M4 = t + r + i + p3 + w2;
    return M4 >>> 0;
  }
  Pe.sum64_4_hi = L6;
  function O6(t, e, r, n, i, o2, p3, y4) {
    var w2 = e + n + o2 + y4;
    return w2 >>> 0;
  }
  Pe.sum64_4_lo = O6;
  function z6(t, e, r, n, i, o2, p3, y4, w2, x) {
    var M4 = 0, E2 = e;
    E2 = E2 + n >>> 0, M4 += E2 < e ? 1 : 0, E2 = E2 + o2 >>> 0, M4 += E2 < o2 ? 1 : 0, E2 = E2 + y4 >>> 0, M4 += E2 < y4 ? 1 : 0, E2 = E2 + x >>> 0, M4 += E2 < x ? 1 : 0;
    var A4 = t + r + i + p3 + w2 + M4;
    return A4 >>> 0;
  }
  Pe.sum64_5_hi = z6;
  function U6(t, e, r, n, i, o2, p3, y4, w2, x) {
    var M4 = e + n + o2 + y4 + x;
    return M4 >>> 0;
  }
  Pe.sum64_5_lo = U6;
  function H6(t, e, r) {
    var n = e << 32 - r | t >>> r;
    return n >>> 0;
  }
  Pe.rotr64_hi = H6;
  function F6(t, e, r) {
    var n = t << 32 - r | e >>> r;
    return n >>> 0;
  }
  Pe.rotr64_lo = F6;
  function K6(t, e, r) {
    return t >>> r;
  }
  Pe.shr64_hi = K6;
  function j6(t, e, r) {
    var n = t << 32 - r | e >>> r;
    return n >>> 0;
  }
  Pe.shr64_lo = j6;
});
var Zi = k2((Td) => {
  "use strict";
  var Pd = Vt(), W6 = ot();
  function Xn() {
    this.pending = null, this.pendingTotal = 0, this.blockSize = this.constructor.blockSize, this.outSize = this.constructor.outSize, this.hmacStrength = this.constructor.hmacStrength, this.padLength = this.constructor.padLength / 8, this.endian = "big", this._delta8 = this.blockSize / 8, this._delta32 = this.blockSize / 32;
  }
  Td.BlockHash = Xn;
  Xn.prototype.update = function(e, r) {
    if (e = Pd.toArray(e, r), this.pending ? this.pending = this.pending.concat(e) : this.pending = e, this.pendingTotal += e.length, this.pending.length >= this._delta8) {
      e = this.pending;
      var n = e.length % this._delta8;
      this.pending = e.slice(e.length - n, e.length), this.pending.length === 0 && (this.pending = null), e = Pd.join32(e, 0, e.length - n, this.endian);
      for (var i = 0; i < e.length; i += this._delta32)
        this._update(e, i, i + this._delta32);
    }
    return this;
  };
  Xn.prototype.digest = function(e) {
    return this.update(this._pad()), W6(this.pending === null), this._digest(e);
  };
  Xn.prototype._pad = function() {
    var e = this.pendingTotal, r = this._delta8, n = r - (e + this.padLength) % r, i = new Array(n + this.padLength);
    i[0] = 128;
    for (var o2 = 1; o2 < n; o2++)
      i[o2] = 0;
    if (e <<= 3, this.endian === "big") {
      for (var p3 = 8; p3 < this.padLength; p3++)
        i[o2++] = 0;
      i[o2++] = 0, i[o2++] = 0, i[o2++] = 0, i[o2++] = 0, i[o2++] = e >>> 24 & 255, i[o2++] = e >>> 16 & 255, i[o2++] = e >>> 8 & 255, i[o2++] = e & 255;
    } else
      for (i[o2++] = e & 255, i[o2++] = e >>> 8 & 255, i[o2++] = e >>> 16 & 255, i[o2++] = e >>> 24 & 255, i[o2++] = 0, i[o2++] = 0, i[o2++] = 0, i[o2++] = 0, p3 = 8; p3 < this.padLength; p3++)
        i[o2++] = 0;
    return i;
  };
});
var V0 = k2((wr2) => {
  "use strict";
  var V6 = Vt(), fr = V6.rotr32;
  function Z6(t, e, r, n) {
    if (t === 0)
      return Cd(e, r, n);
    if (t === 1 || t === 3)
      return Ld(e, r, n);
    if (t === 2)
      return Nd(e, r, n);
  }
  wr2.ft_1 = Z6;
  function Cd(t, e, r) {
    return t & e ^ ~t & r;
  }
  wr2.ch32 = Cd;
  function Nd(t, e, r) {
    return t & e ^ t & r ^ e & r;
  }
  wr2.maj32 = Nd;
  function Ld(t, e, r) {
    return t ^ e ^ r;
  }
  wr2.p32 = Ld;
  function G6(t) {
    return fr(t, 2) ^ fr(t, 13) ^ fr(t, 22);
  }
  wr2.s0_256 = G6;
  function X6(t) {
    return fr(t, 6) ^ fr(t, 11) ^ fr(t, 25);
  }
  wr2.s1_256 = X6;
  function Y6(t) {
    return fr(t, 7) ^ fr(t, 18) ^ t >>> 3;
  }
  wr2.g0_256 = Y6;
  function J6(t) {
    return fr(t, 17) ^ fr(t, 19) ^ t >>> 10;
  }
  wr2.g1_256 = J6;
});
var Ud = k2((Sm, zd) => {
  "use strict";
  var Gi = Vt(), $6 = Zi(), Q6 = V0(), Z0 = Gi.rotl32, Of = Gi.sum32, e3 = Gi.sum32_5, t3 = Q6.ft_1, Od = $6.BlockHash, r3 = [1518500249, 1859775393, 2400959708, 3395469782];
  function nr() {
    if (!(this instanceof nr))
      return new nr();
    Od.call(this), this.h = [1732584193, 4023233417, 2562383102, 271733878, 3285377520], this.W = new Array(80);
  }
  Gi.inherits(nr, Od);
  zd.exports = nr;
  nr.blockSize = 512;
  nr.outSize = 160;
  nr.hmacStrength = 80;
  nr.padLength = 64;
  nr.prototype._update = function(e, r) {
    for (var n = this.W, i = 0; i < 16; i++)
      n[i] = e[r + i];
    for (; i < n.length; i++)
      n[i] = Z0(n[i - 3] ^ n[i - 8] ^ n[i - 14] ^ n[i - 16], 1);
    var o2 = this.h[0], p3 = this.h[1], y4 = this.h[2], w2 = this.h[3], x = this.h[4];
    for (i = 0; i < n.length; i++) {
      var M4 = ~~(i / 20), E2 = e3(Z0(o2, 5), t3(M4, p3, y4, w2), x, n[i], r3[M4]);
      x = w2, w2 = y4, y4 = Z0(p3, 30), p3 = o2, o2 = E2;
    }
    this.h[0] = Of(this.h[0], o2), this.h[1] = Of(this.h[1], p3), this.h[2] = Of(this.h[2], y4), this.h[3] = Of(this.h[3], w2), this.h[4] = Of(this.h[4], x);
  };
  nr.prototype._digest = function(e) {
    return e === "hex" ? Gi.toHex32(this.h, "big") : Gi.split32(this.h, "big");
  };
});
var G0 = k2((Em, Fd) => {
  "use strict";
  var Xi = Vt(), i3 = Zi(), Yi = V0(), f3 = ot(), Zt2 = Xi.sum32, n3 = Xi.sum32_4, a3 = Xi.sum32_5, s3 = Yi.ch32, o3 = Yi.maj32, h3 = Yi.s0_256, u3 = Yi.s1_256, d32 = Yi.g0_256, c32 = Yi.g1_256, Hd = i3.BlockHash, l3 = [1116352408, 1899447441, 3049323471, 3921009573, 961987163, 1508970993, 2453635748, 2870763221, 3624381080, 310598401, 607225278, 1426881987, 1925078388, 2162078206, 2614888103, 3248222580, 3835390401, 4022224774, 264347078, 604807628, 770255983, 1249150122, 1555081692, 1996064986, 2554220882, 2821834349, 2952996808, 3210313671, 3336571891, 3584528711, 113926993, 338241895, 666307205, 773529912, 1294757372, 1396182291, 1695183700, 1986661051, 2177026350, 2456956037, 2730485921, 2820302411, 3259730800, 3345764771, 3516065817, 3600352804, 4094571909, 275423344, 430227734, 506948616, 659060556, 883997877, 958139571, 1322822218, 1537002063, 1747873779, 1955562222, 2024104815, 2227730452, 2361852424, 2428436474, 2756734187, 3204031479, 3329325298];
  function ar() {
    if (!(this instanceof ar))
      return new ar();
    Hd.call(this), this.h = [1779033703, 3144134277, 1013904242, 2773480762, 1359893119, 2600822924, 528734635, 1541459225], this.k = l3, this.W = new Array(64);
  }
  Xi.inherits(ar, Hd);
  Fd.exports = ar;
  ar.blockSize = 512;
  ar.outSize = 256;
  ar.hmacStrength = 192;
  ar.padLength = 64;
  ar.prototype._update = function(e, r) {
    for (var n = this.W, i = 0; i < 16; i++)
      n[i] = e[r + i];
    for (; i < n.length; i++)
      n[i] = n3(c32(n[i - 2]), n[i - 7], d32(n[i - 15]), n[i - 16]);
    var o2 = this.h[0], p3 = this.h[1], y4 = this.h[2], w2 = this.h[3], x = this.h[4], M4 = this.h[5], E2 = this.h[6], A4 = this.h[7];
    for (f3(this.k.length === n.length), i = 0; i < n.length; i++) {
      var I3 = a3(A4, u3(x), s3(x, M4, E2), this.k[i], n[i]), D6 = Zt2(h3(o2), o3(o2, p3, y4));
      A4 = E2, E2 = M4, M4 = x, x = Zt2(w2, I3), w2 = y4, y4 = p3, p3 = o2, o2 = Zt2(I3, D6);
    }
    this.h[0] = Zt2(this.h[0], o2), this.h[1] = Zt2(this.h[1], p3), this.h[2] = Zt2(this.h[2], y4), this.h[3] = Zt2(this.h[3], w2), this.h[4] = Zt2(this.h[4], x), this.h[5] = Zt2(this.h[5], M4), this.h[6] = Zt2(this.h[6], E2), this.h[7] = Zt2(this.h[7], A4);
  };
  ar.prototype._digest = function(e) {
    return e === "hex" ? Xi.toHex32(this.h, "big") : Xi.split32(this.h, "big");
  };
});
var Wd = k2((Am, jd) => {
  "use strict";
  var X0 = Vt(), Kd = G0();
  function xr2() {
    if (!(this instanceof xr2))
      return new xr2();
    Kd.call(this), this.h = [3238371032, 914150663, 812702999, 4144912697, 4290775857, 1750603025, 1694076839, 3204075428];
  }
  X0.inherits(xr2, Kd);
  jd.exports = xr2;
  xr2.blockSize = 512;
  xr2.outSize = 224;
  xr2.hmacStrength = 192;
  xr2.padLength = 64;
  xr2.prototype._digest = function(e) {
    return e === "hex" ? X0.toHex32(this.h.slice(0, 7), "big") : X0.split32(this.h.slice(0, 7), "big");
  };
});
var $0 = k2((qm, Xd) => {
  "use strict";
  var nt = Vt(), v3 = Zi(), p3 = ot(), sr = nt.rotr64_hi, or2 = nt.rotr64_lo, Vd = nt.shr64_hi, Zd = nt.shr64_lo, Yr2 = nt.sum64, Y0 = nt.sum64_hi, J0 = nt.sum64_lo, b3 = nt.sum64_4_hi, m3 = nt.sum64_4_lo, g3 = nt.sum64_5_hi, y32 = nt.sum64_5_lo, Gd = v3.BlockHash, _3 = [1116352408, 3609767458, 1899447441, 602891725, 3049323471, 3964484399, 3921009573, 2173295548, 961987163, 4081628472, 1508970993, 3053834265, 2453635748, 2937671579, 2870763221, 3664609560, 3624381080, 2734883394, 310598401, 1164996542, 607225278, 1323610764, 1426881987, 3590304994, 1925078388, 4068182383, 2162078206, 991336113, 2614888103, 633803317, 3248222580, 3479774868, 3835390401, 2666613458, 4022224774, 944711139, 264347078, 2341262773, 604807628, 2007800933, 770255983, 1495990901, 1249150122, 1856431235, 1555081692, 3175218132, 1996064986, 2198950837, 2554220882, 3999719339, 2821834349, 766784016, 2952996808, 2566594879, 3210313671, 3203337956, 3336571891, 1034457026, 3584528711, 2466948901, 113926993, 3758326383, 338241895, 168717936, 666307205, 1188179964, 773529912, 1546045734, 1294757372, 1522805485, 1396182291, 2643833823, 1695183700, 2343527390, 1986661051, 1014477480, 2177026350, 1206759142, 2456956037, 344077627, 2730485921, 1290863460, 2820302411, 3158454273, 3259730800, 3505952657, 3345764771, 106217008, 3516065817, 3606008344, 3600352804, 1432725776, 4094571909, 1467031594, 275423344, 851169720, 430227734, 3100823752, 506948616, 1363258195, 659060556, 3750685593, 883997877, 3785050280, 958139571, 3318307427, 1322822218, 3812723403, 1537002063, 2003034995, 1747873779, 3602036899, 1955562222, 1575990012, 2024104815, 1125592928, 2227730452, 2716904306, 2361852424, 442776044, 2428436474, 593698344, 2756734187, 3733110249, 3204031479, 2999351573, 3329325298, 3815920427, 3391569614, 3928383900, 3515267271, 566280711, 3940187606, 3454069534, 4118630271, 4000239992, 116418474, 1914138554, 174292421, 2731055270, 289380356, 3203993006, 460393269, 320620315, 685471733, 587496836, 852142971, 1086792851, 1017036298, 365543100, 1126000580, 2618297676, 1288033470, 3409855158, 1501505948, 4234509866, 1607167915, 987167468, 1816402316, 1246189591];
  function Gt() {
    if (!(this instanceof Gt))
      return new Gt();
    Gd.call(this), this.h = [1779033703, 4089235720, 3144134277, 2227873595, 1013904242, 4271175723, 2773480762, 1595750129, 1359893119, 2917565137, 2600822924, 725511199, 528734635, 4215389547, 1541459225, 327033209], this.k = _3, this.W = new Array(160);
  }
  nt.inherits(Gt, Gd);
  Xd.exports = Gt;
  Gt.blockSize = 1024;
  Gt.outSize = 512;
  Gt.hmacStrength = 192;
  Gt.padLength = 128;
  Gt.prototype._prepareBlock = function(e, r) {
    for (var n = this.W, i = 0; i < 32; i++)
      n[i] = e[r + i];
    for (; i < n.length; i += 2) {
      var o2 = k32(n[i - 4], n[i - 3]), p4 = D32(n[i - 4], n[i - 3]), y4 = n[i - 14], w2 = n[i - 13], x = R3(n[i - 30], n[i - 29]), M4 = I3(n[i - 30], n[i - 29]), E2 = n[i - 32], A4 = n[i - 31];
      n[i] = b3(o2, p4, y4, w2, x, M4, E2, A4), n[i + 1] = m3(o2, p4, y4, w2, x, M4, E2, A4);
    }
  };
  Gt.prototype._update = function(e, r) {
    this._prepareBlock(e, r);
    var n = this.W, i = this.h[0], o2 = this.h[1], p4 = this.h[2], y4 = this.h[3], w2 = this.h[4], x = this.h[5], M4 = this.h[6], E2 = this.h[7], A4 = this.h[8], I4 = this.h[9], D6 = this.h[10], C = this.h[11], ge2 = this.h[12], L4 = this.h[13], ye = this.h[14], Re = this.h[15];
    p3(this.k.length === n.length);
    for (var xe3 = 0; xe3 < n.length; xe3 += 2) {
      var ke = ye, Me = Re, Ce3 = q3(A4, I4), Ee2 = B3(A4, I4), Ne3 = w3(A4, I4, D6, C, ge2, L4), S4 = x3(A4, I4, D6, C, ge2, L4), v2 = this.k[xe3], _2 = this.k[xe3 + 1], c5 = n[xe3], f = n[xe3 + 1], a = g3(ke, Me, Ce3, Ee2, Ne3, S4, v2, _2, c5, f), u = y32(ke, Me, Ce3, Ee2, Ne3, S4, v2, _2, c5, f);
      ke = E3(i, o2), Me = A32(i, o2), Ce3 = M32(i, o2, p4, y4, w2, x), Ee2 = S3(i, o2, p4, y4, w2, x);
      var l = Y0(ke, Me, Ce3, Ee2), d4 = J0(ke, Me, Ce3, Ee2);
      ye = ge2, Re = L4, ge2 = D6, L4 = C, D6 = A4, C = I4, A4 = Y0(M4, E2, a, u), I4 = J0(E2, E2, a, u), M4 = w2, E2 = x, w2 = p4, x = y4, p4 = i, y4 = o2, i = Y0(a, u, l, d4), o2 = J0(a, u, l, d4);
    }
    Yr2(this.h, 0, i, o2), Yr2(this.h, 2, p4, y4), Yr2(this.h, 4, w2, x), Yr2(this.h, 6, M4, E2), Yr2(this.h, 8, A4, I4), Yr2(this.h, 10, D6, C), Yr2(this.h, 12, ge2, L4), Yr2(this.h, 14, ye, Re);
  };
  Gt.prototype._digest = function(e) {
    return e === "hex" ? nt.toHex32(this.h, "big") : nt.split32(this.h, "big");
  };
  function w3(t, e, r, n, i) {
    var o2 = t & r ^ ~t & i;
    return o2 < 0 && (o2 += 4294967296), o2;
  }
  function x3(t, e, r, n, i, o2) {
    var p4 = e & n ^ ~e & o2;
    return p4 < 0 && (p4 += 4294967296), p4;
  }
  function M32(t, e, r, n, i) {
    var o2 = t & r ^ t & i ^ r & i;
    return o2 < 0 && (o2 += 4294967296), o2;
  }
  function S3(t, e, r, n, i, o2) {
    var p4 = e & n ^ e & o2 ^ n & o2;
    return p4 < 0 && (p4 += 4294967296), p4;
  }
  function E3(t, e) {
    var r = sr(t, e, 28), n = sr(e, t, 2), i = sr(e, t, 7), o2 = r ^ n ^ i;
    return o2 < 0 && (o2 += 4294967296), o2;
  }
  function A32(t, e) {
    var r = or2(t, e, 28), n = or2(e, t, 2), i = or2(e, t, 7), o2 = r ^ n ^ i;
    return o2 < 0 && (o2 += 4294967296), o2;
  }
  function q3(t, e) {
    var r = sr(t, e, 14), n = sr(t, e, 18), i = sr(e, t, 9), o2 = r ^ n ^ i;
    return o2 < 0 && (o2 += 4294967296), o2;
  }
  function B3(t, e) {
    var r = or2(t, e, 14), n = or2(t, e, 18), i = or2(e, t, 9), o2 = r ^ n ^ i;
    return o2 < 0 && (o2 += 4294967296), o2;
  }
  function R3(t, e) {
    var r = sr(t, e, 1), n = sr(t, e, 8), i = Vd(t, e, 7), o2 = r ^ n ^ i;
    return o2 < 0 && (o2 += 4294967296), o2;
  }
  function I3(t, e) {
    var r = or2(t, e, 1), n = or2(t, e, 8), i = Zd(t, e, 7), o2 = r ^ n ^ i;
    return o2 < 0 && (o2 += 4294967296), o2;
  }
  function k32(t, e) {
    var r = sr(t, e, 19), n = sr(e, t, 29), i = Vd(t, e, 6), o2 = r ^ n ^ i;
    return o2 < 0 && (o2 += 4294967296), o2;
  }
  function D32(t, e) {
    var r = or2(t, e, 19), n = or2(e, t, 29), i = Zd(t, e, 6), o2 = r ^ n ^ i;
    return o2 < 0 && (o2 += 4294967296), o2;
  }
});
var $d = k2((Bm, Jd) => {
  "use strict";
  var Q0 = Vt(), Yd = $0();
  function Mr() {
    if (!(this instanceof Mr))
      return new Mr();
    Yd.call(this), this.h = [3418070365, 3238371032, 1654270250, 914150663, 2438529370, 812702999, 355462360, 4144912697, 1731405415, 4290775857, 2394180231, 1750603025, 3675008525, 1694076839, 1203062813, 3204075428];
  }
  Q0.inherits(Mr, Yd);
  Jd.exports = Mr;
  Mr.blockSize = 1024;
  Mr.outSize = 384;
  Mr.hmacStrength = 192;
  Mr.padLength = 128;
  Mr.prototype._digest = function(e) {
    return e === "hex" ? Q0.toHex32(this.h.slice(0, 12), "big") : Q0.split32(this.h.slice(0, 12), "big");
  };
});
var Qd = k2((Ji) => {
  "use strict";
  Ji.sha1 = Ud();
  Ji.sha224 = Wd();
  Ji.sha256 = G0();
  Ji.sha384 = $d();
  Ji.sha512 = $0();
});
var nc = k2((fc) => {
  "use strict";
  var xi = Vt(), P3 = Zi(), Yn = xi.rotl32, ec = xi.sum32, zf = xi.sum32_3, tc = xi.sum32_4, ic = P3.BlockHash;
  function hr() {
    if (!(this instanceof hr))
      return new hr();
    ic.call(this), this.h = [1732584193, 4023233417, 2562383102, 271733878, 3285377520], this.endian = "little";
  }
  xi.inherits(hr, ic);
  fc.ripemd160 = hr;
  hr.blockSize = 512;
  hr.outSize = 160;
  hr.hmacStrength = 192;
  hr.padLength = 64;
  hr.prototype._update = function(e, r) {
    for (var n = this.h[0], i = this.h[1], o2 = this.h[2], p3 = this.h[3], y4 = this.h[4], w2 = n, x = i, M4 = o2, E2 = p3, A4 = y4, I3 = 0; I3 < 80; I3++) {
      var D6 = ec(Yn(tc(n, rc(I3, i, o2, p3), e[N32[I3] + r], T32(I3)), O3[I3]), y4);
      n = y4, y4 = p3, p3 = Yn(o2, 10), o2 = i, i = D6, D6 = ec(Yn(tc(w2, rc(79 - I3, x, M4, E2), e[L32[I3] + r], C3(I3)), z3[I3]), A4), w2 = A4, A4 = E2, E2 = Yn(M4, 10), M4 = x, x = D6;
    }
    D6 = zf(this.h[1], o2, E2), this.h[1] = zf(this.h[2], p3, A4), this.h[2] = zf(this.h[3], y4, w2), this.h[3] = zf(this.h[4], n, x), this.h[4] = zf(this.h[0], i, M4), this.h[0] = D6;
  };
  hr.prototype._digest = function(e) {
    return e === "hex" ? xi.toHex32(this.h, "little") : xi.split32(this.h, "little");
  };
  function rc(t, e, r, n) {
    return t <= 15 ? e ^ r ^ n : t <= 31 ? e & r | ~e & n : t <= 47 ? (e | ~r) ^ n : t <= 63 ? e & n | r & ~n : e ^ (r | ~n);
  }
  function T32(t) {
    return t <= 15 ? 0 : t <= 31 ? 1518500249 : t <= 47 ? 1859775393 : t <= 63 ? 2400959708 : 2840853838;
  }
  function C3(t) {
    return t <= 15 ? 1352829926 : t <= 31 ? 1548603684 : t <= 47 ? 1836072691 : t <= 63 ? 2053994217 : 0;
  }
  var N32 = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8, 3, 10, 14, 4, 9, 15, 8, 1, 2, 7, 0, 6, 13, 11, 5, 12, 1, 9, 11, 10, 0, 8, 12, 4, 13, 3, 7, 15, 14, 5, 6, 2, 4, 0, 5, 9, 7, 12, 2, 10, 14, 1, 3, 8, 11, 6, 15, 13], L32 = [5, 14, 7, 0, 9, 2, 11, 4, 13, 6, 15, 8, 1, 10, 3, 12, 6, 11, 3, 7, 0, 13, 5, 10, 14, 15, 8, 12, 4, 9, 1, 2, 15, 5, 1, 3, 7, 14, 6, 9, 11, 8, 12, 2, 10, 0, 4, 13, 8, 6, 4, 1, 3, 11, 15, 0, 5, 12, 2, 13, 9, 7, 10, 14, 12, 15, 10, 4, 1, 5, 8, 7, 6, 2, 13, 14, 0, 3, 9, 11], O3 = [11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8, 7, 6, 8, 13, 11, 9, 7, 15, 7, 12, 15, 9, 11, 7, 13, 12, 11, 13, 6, 7, 14, 9, 13, 15, 14, 8, 13, 6, 5, 12, 7, 5, 11, 12, 14, 15, 14, 15, 9, 8, 9, 14, 5, 6, 8, 6, 5, 12, 9, 15, 5, 11, 6, 8, 13, 12, 5, 12, 13, 14, 11, 8, 5, 6], z3 = [8, 9, 9, 11, 13, 15, 15, 5, 7, 7, 8, 11, 14, 14, 12, 6, 9, 13, 15, 7, 12, 8, 9, 11, 7, 7, 12, 7, 6, 15, 13, 11, 9, 7, 15, 11, 8, 6, 6, 14, 12, 13, 5, 14, 13, 13, 7, 5, 15, 5, 8, 11, 14, 14, 6, 14, 6, 9, 12, 9, 12, 5, 15, 8, 8, 5, 12, 9, 12, 5, 14, 6, 8, 13, 6, 5, 15, 13, 11, 11];
});
var sc = k2((km, ac) => {
  "use strict";
  var U3 = Vt(), H3 = ot();
  function $i(t, e, r) {
    if (!(this instanceof $i))
      return new $i(t, e, r);
    this.Hash = t, this.blockSize = t.blockSize / 8, this.outSize = t.outSize / 8, this.inner = null, this.outer = null, this._init(U3.toArray(e, r));
  }
  ac.exports = $i;
  $i.prototype._init = function(e) {
    e.length > this.blockSize && (e = new this.Hash().update(e).digest()), H3(e.length <= this.blockSize);
    for (var r = e.length; r < this.blockSize; r++)
      e.push(0);
    for (r = 0; r < e.length; r++)
      e[r] ^= 54;
    for (this.inner = new this.Hash().update(e), r = 0; r < e.length; r++)
      e[r] ^= 106;
    this.outer = new this.Hash().update(e);
  };
  $i.prototype.update = function(e, r) {
    return this.inner.update(e, r), this;
  };
  $i.prototype.digest = function(e) {
    return this.outer.update(this.inner.digest()), this.outer.digest(e);
  };
});
var Jn = k2((oc) => {
  var Ye2 = oc;
  Ye2.utils = Vt();
  Ye2.common = Zi();
  Ye2.sha = Qd();
  Ye2.ripemd = nc();
  Ye2.hmac = sc();
  Ye2.sha1 = Ye2.sha.sha1;
  Ye2.sha256 = Ye2.sha.sha256;
  Ye2.sha224 = Ye2.sha.sha224;
  Ye2.sha384 = Ye2.sha.sha384;
  Ye2.sha512 = Ye2.sha.sha512;
  Ye2.ripemd160 = Ye2.ripemd.ripemd160;
});
var uc = k2((Pm, hc) => {
  hc.exports = { doubles: { step: 4, points: [["e60fce93b59e9ec53011aabc21c23e97b2a31369b87a5ae9c44ee89e2a6dec0a", "f7e3507399e595929db99f34f57937101296891e44d23f0be1f32cce69616821"], ["8282263212c609d9ea2a6e3e172de238d8c39cabd5ac1ca10646e23fd5f51508", "11f8a8098557dfe45e8256e830b60ace62d613ac2f7b17bed31b6eaff6e26caf"], ["175e159f728b865a72f99cc6c6fc846de0b93833fd2222ed73fce5b551e5b739", "d3506e0d9e3c79eba4ef97a51ff71f5eacb5955add24345c6efa6ffee9fed695"], ["363d90d447b00c9c99ceac05b6262ee053441c7e55552ffe526bad8f83ff4640", "4e273adfc732221953b445397f3363145b9a89008199ecb62003c7f3bee9de9"], ["8b4b5f165df3c2be8c6244b5b745638843e4a781a15bcd1b69f79a55dffdf80c", "4aad0a6f68d308b4b3fbd7813ab0da04f9e336546162ee56b3eff0c65fd4fd36"], ["723cbaa6e5db996d6bf771c00bd548c7b700dbffa6c0e77bcb6115925232fcda", "96e867b5595cc498a921137488824d6e2660a0653779494801dc069d9eb39f5f"], ["eebfa4d493bebf98ba5feec812c2d3b50947961237a919839a533eca0e7dd7fa", "5d9a8ca3970ef0f269ee7edaf178089d9ae4cdc3a711f712ddfd4fdae1de8999"], ["100f44da696e71672791d0a09b7bde459f1215a29b3c03bfefd7835b39a48db0", "cdd9e13192a00b772ec8f3300c090666b7ff4a18ff5195ac0fbd5cd62bc65a09"], ["e1031be262c7ed1b1dc9227a4a04c017a77f8d4464f3b3852c8acde6e534fd2d", "9d7061928940405e6bb6a4176597535af292dd419e1ced79a44f18f29456a00d"], ["feea6cae46d55b530ac2839f143bd7ec5cf8b266a41d6af52d5e688d9094696d", "e57c6b6c97dce1bab06e4e12bf3ecd5c981c8957cc41442d3155debf18090088"], ["da67a91d91049cdcb367be4be6ffca3cfeed657d808583de33fa978bc1ec6cb1", "9bacaa35481642bc41f463f7ec9780e5dec7adc508f740a17e9ea8e27a68be1d"], ["53904faa0b334cdda6e000935ef22151ec08d0f7bb11069f57545ccc1a37b7c0", "5bc087d0bc80106d88c9eccac20d3c1c13999981e14434699dcb096b022771c8"], ["8e7bcd0bd35983a7719cca7764ca906779b53a043a9b8bcaeff959f43ad86047", "10b7770b2a3da4b3940310420ca9514579e88e2e47fd68b3ea10047e8460372a"], ["385eed34c1cdff21e6d0818689b81bde71a7f4f18397e6690a841e1599c43862", "283bebc3e8ea23f56701de19e9ebf4576b304eec2086dc8cc0458fe5542e5453"], ["6f9d9b803ecf191637c73a4413dfa180fddf84a5947fbc9c606ed86c3fac3a7", "7c80c68e603059ba69b8e2a30e45c4d47ea4dd2f5c281002d86890603a842160"], ["3322d401243c4e2582a2147c104d6ecbf774d163db0f5e5313b7e0e742d0e6bd", "56e70797e9664ef5bfb019bc4ddaf9b72805f63ea2873af624f3a2e96c28b2a0"], ["85672c7d2de0b7da2bd1770d89665868741b3f9af7643397721d74d28134ab83", "7c481b9b5b43b2eb6374049bfa62c2e5e77f17fcc5298f44c8e3094f790313a6"], ["948bf809b1988a46b06c9f1919413b10f9226c60f668832ffd959af60c82a0a", "53a562856dcb6646dc6b74c5d1c3418c6d4dff08c97cd2bed4cb7f88d8c8e589"], ["6260ce7f461801c34f067ce0f02873a8f1b0e44dfc69752accecd819f38fd8e8", "bc2da82b6fa5b571a7f09049776a1ef7ecd292238051c198c1a84e95b2b4ae17"], ["e5037de0afc1d8d43d8348414bbf4103043ec8f575bfdc432953cc8d2037fa2d", "4571534baa94d3b5f9f98d09fb990bddbd5f5b03ec481f10e0e5dc841d755bda"], ["e06372b0f4a207adf5ea905e8f1771b4e7e8dbd1c6a6c5b725866a0ae4fce725", "7a908974bce18cfe12a27bb2ad5a488cd7484a7787104870b27034f94eee31dd"], ["213c7a715cd5d45358d0bbf9dc0ce02204b10bdde2a3f58540ad6908d0559754", "4b6dad0b5ae462507013ad06245ba190bb4850f5f36a7eeddff2c27534b458f2"], ["4e7c272a7af4b34e8dbb9352a5419a87e2838c70adc62cddf0cc3a3b08fbd53c", "17749c766c9d0b18e16fd09f6def681b530b9614bff7dd33e0b3941817dcaae6"], ["fea74e3dbe778b1b10f238ad61686aa5c76e3db2be43057632427e2840fb27b6", "6e0568db9b0b13297cf674deccb6af93126b596b973f7b77701d3db7f23cb96f"], ["76e64113f677cf0e10a2570d599968d31544e179b760432952c02a4417bdde39", "c90ddf8dee4e95cf577066d70681f0d35e2a33d2b56d2032b4b1752d1901ac01"], ["c738c56b03b2abe1e8281baa743f8f9a8f7cc643df26cbee3ab150242bcbb891", "893fb578951ad2537f718f2eacbfbbbb82314eef7880cfe917e735d9699a84c3"], ["d895626548b65b81e264c7637c972877d1d72e5f3a925014372e9f6588f6c14b", "febfaa38f2bc7eae728ec60818c340eb03428d632bb067e179363ed75d7d991f"], ["b8da94032a957518eb0f6433571e8761ceffc73693e84edd49150a564f676e03", "2804dfa44805a1e4d7c99cc9762808b092cc584d95ff3b511488e4e74efdf6e7"], ["e80fea14441fb33a7d8adab9475d7fab2019effb5156a792f1a11778e3c0df5d", "eed1de7f638e00771e89768ca3ca94472d155e80af322ea9fcb4291b6ac9ec78"], ["a301697bdfcd704313ba48e51d567543f2a182031efd6915ddc07bbcc4e16070", "7370f91cfb67e4f5081809fa25d40f9b1735dbf7c0a11a130c0d1a041e177ea1"], ["90ad85b389d6b936463f9d0512678de208cc330b11307fffab7ac63e3fb04ed4", "e507a3620a38261affdcbd9427222b839aefabe1582894d991d4d48cb6ef150"], ["8f68b9d2f63b5f339239c1ad981f162ee88c5678723ea3351b7b444c9ec4c0da", "662a9f2dba063986de1d90c2b6be215dbbea2cfe95510bfdf23cbf79501fff82"], ["e4f3fb0176af85d65ff99ff9198c36091f48e86503681e3e6686fd5053231e11", "1e63633ad0ef4f1c1661a6d0ea02b7286cc7e74ec951d1c9822c38576feb73bc"], ["8c00fa9b18ebf331eb961537a45a4266c7034f2f0d4e1d0716fb6eae20eae29e", "efa47267fea521a1a9dc343a3736c974c2fadafa81e36c54e7d2a4c66702414b"], ["e7a26ce69dd4829f3e10cec0a9e98ed3143d084f308b92c0997fddfc60cb3e41", "2a758e300fa7984b471b006a1aafbb18d0a6b2c0420e83e20e8a9421cf2cfd51"], ["b6459e0ee3662ec8d23540c223bcbdc571cbcb967d79424f3cf29eb3de6b80ef", "67c876d06f3e06de1dadf16e5661db3c4b3ae6d48e35b2ff30bf0b61a71ba45"], ["d68a80c8280bb840793234aa118f06231d6f1fc67e73c5a5deda0f5b496943e8", "db8ba9fff4b586d00c4b1f9177b0e28b5b0e7b8f7845295a294c84266b133120"], ["324aed7df65c804252dc0270907a30b09612aeb973449cea4095980fc28d3d5d", "648a365774b61f2ff130c0c35aec1f4f19213b0c7e332843967224af96ab7c84"], ["4df9c14919cde61f6d51dfdbe5fee5dceec4143ba8d1ca888e8bd373fd054c96", "35ec51092d8728050974c23a1d85d4b5d506cdc288490192ebac06cad10d5d"], ["9c3919a84a474870faed8a9c1cc66021523489054d7f0308cbfc99c8ac1f98cd", "ddb84f0f4a4ddd57584f044bf260e641905326f76c64c8e6be7e5e03d4fc599d"], ["6057170b1dd12fdf8de05f281d8e06bb91e1493a8b91d4cc5a21382120a959e5", "9a1af0b26a6a4807add9a2daf71df262465152bc3ee24c65e899be932385a2a8"], ["a576df8e23a08411421439a4518da31880cef0fba7d4df12b1a6973eecb94266", "40a6bf20e76640b2c92b97afe58cd82c432e10a7f514d9f3ee8be11ae1b28ec8"], ["7778a78c28dec3e30a05fe9629de8c38bb30d1f5cf9a3a208f763889be58ad71", "34626d9ab5a5b22ff7098e12f2ff580087b38411ff24ac563b513fc1fd9f43ac"], ["928955ee637a84463729fd30e7afd2ed5f96274e5ad7e5cb09eda9c06d903ac", "c25621003d3f42a827b78a13093a95eeac3d26efa8a8d83fc5180e935bcd091f"], ["85d0fef3ec6db109399064f3a0e3b2855645b4a907ad354527aae75163d82751", "1f03648413a38c0be29d496e582cf5663e8751e96877331582c237a24eb1f962"], ["ff2b0dce97eece97c1c9b6041798b85dfdfb6d8882da20308f5404824526087e", "493d13fef524ba188af4c4dc54d07936c7b7ed6fb90e2ceb2c951e01f0c29907"], ["827fbbe4b1e880ea9ed2b2e6301b212b57f1ee148cd6dd28780e5e2cf856e241", "c60f9c923c727b0b71bef2c67d1d12687ff7a63186903166d605b68baec293ec"], ["eaa649f21f51bdbae7be4ae34ce6e5217a58fdce7f47f9aa7f3b58fa2120e2b3", "be3279ed5bbbb03ac69a80f89879aa5a01a6b965f13f7e59d47a5305ba5ad93d"], ["e4a42d43c5cf169d9391df6decf42ee541b6d8f0c9a137401e23632dda34d24f", "4d9f92e716d1c73526fc99ccfb8ad34ce886eedfa8d8e4f13a7f7131deba9414"], ["1ec80fef360cbdd954160fadab352b6b92b53576a88fea4947173b9d4300bf19", "aeefe93756b5340d2f3a4958a7abbf5e0146e77f6295a07b671cdc1cc107cefd"], ["146a778c04670c2f91b00af4680dfa8bce3490717d58ba889ddb5928366642be", "b318e0ec3354028add669827f9d4b2870aaa971d2f7e5ed1d0b297483d83efd0"], ["fa50c0f61d22e5f07e3acebb1aa07b128d0012209a28b9776d76a8793180eef9", "6b84c6922397eba9b72cd2872281a68a5e683293a57a213b38cd8d7d3f4f2811"], ["da1d61d0ca721a11b1a5bf6b7d88e8421a288ab5d5bba5220e53d32b5f067ec2", "8157f55a7c99306c79c0766161c91e2966a73899d279b48a655fba0f1ad836f1"], ["a8e282ff0c9706907215ff98e8fd416615311de0446f1e062a73b0610d064e13", "7f97355b8db81c09abfb7f3c5b2515888b679a3e50dd6bd6cef7c73111f4cc0c"], ["174a53b9c9a285872d39e56e6913cab15d59b1fa512508c022f382de8319497c", "ccc9dc37abfc9c1657b4155f2c47f9e6646b3a1d8cb9854383da13ac079afa73"], ["959396981943785c3d3e57edf5018cdbe039e730e4918b3d884fdff09475b7ba", "2e7e552888c331dd8ba0386a4b9cd6849c653f64c8709385e9b8abf87524f2fd"], ["d2a63a50ae401e56d645a1153b109a8fcca0a43d561fba2dbb51340c9d82b151", "e82d86fb6443fcb7565aee58b2948220a70f750af484ca52d4142174dcf89405"], ["64587e2335471eb890ee7896d7cfdc866bacbdbd3839317b3436f9b45617e073", "d99fcdd5bf6902e2ae96dd6447c299a185b90a39133aeab358299e5e9faf6589"], ["8481bde0e4e4d885b3a546d3e549de042f0aa6cea250e7fd358d6c86dd45e458", "38ee7b8cba5404dd84a25bf39cecb2ca900a79c42b262e556d64b1b59779057e"], ["13464a57a78102aa62b6979ae817f4637ffcfed3c4b1ce30bcd6303f6caf666b", "69be159004614580ef7e433453ccb0ca48f300a81d0942e13f495a907f6ecc27"], ["bc4a9df5b713fe2e9aef430bcc1dc97a0cd9ccede2f28588cada3a0d2d83f366", "d3a81ca6e785c06383937adf4b798caa6e8a9fbfa547b16d758d666581f33c1"], ["8c28a97bf8298bc0d23d8c749452a32e694b65e30a9472a3954ab30fe5324caa", "40a30463a3305193378fedf31f7cc0eb7ae784f0451cb9459e71dc73cbef9482"], ["8ea9666139527a8c1dd94ce4f071fd23c8b350c5a4bb33748c4ba111faccae0", "620efabbc8ee2782e24e7c0cfb95c5d735b783be9cf0f8e955af34a30e62b945"], ["dd3625faef5ba06074669716bbd3788d89bdde815959968092f76cc4eb9a9787", "7a188fa3520e30d461da2501045731ca941461982883395937f68d00c644a573"], ["f710d79d9eb962297e4f6232b40e8f7feb2bc63814614d692c12de752408221e", "ea98e67232d3b3295d3b535532115ccac8612c721851617526ae47a9c77bfc82"]] }, naf: { wnd: 7, points: [["f9308a019258c31049344f85f89d5229b531c845836f99b08601f113bce036f9", "388f7b0f632de8140fe337e62a37f3566500a99934c2231b6cb9fd7584b8e672"], ["2f8bde4d1a07209355b4a7250a5c5128e88b84bddc619ab7cba8d569b240efe4", "d8ac222636e5e3d6d4dba9dda6c9c426f788271bab0d6840dca87d3aa6ac62d6"], ["5cbdf0646e5db4eaa398f365f2ea7a0e3d419b7e0330e39ce92bddedcac4f9bc", "6aebca40ba255960a3178d6d861a54dba813d0b813fde7b5a5082628087264da"], ["acd484e2f0c7f65309ad178a9f559abde09796974c57e714c35f110dfc27ccbe", "cc338921b0a7d9fd64380971763b61e9add888a4375f8e0f05cc262ac64f9c37"], ["774ae7f858a9411e5ef4246b70c65aac5649980be5c17891bbec17895da008cb", "d984a032eb6b5e190243dd56d7b7b365372db1e2dff9d6a8301d74c9c953c61b"], ["f28773c2d975288bc7d1d205c3748651b075fbc6610e58cddeeddf8f19405aa8", "ab0902e8d880a89758212eb65cdaf473a1a06da521fa91f29b5cb52db03ed81"], ["d7924d4f7d43ea965a465ae3095ff41131e5946f3c85f79e44adbcf8e27e080e", "581e2872a86c72a683842ec228cc6defea40af2bd896d3a5c504dc9ff6a26b58"], ["defdea4cdb677750a420fee807eacf21eb9898ae79b9768766e4faa04a2d4a34", "4211ab0694635168e997b0ead2a93daeced1f4a04a95c0f6cfb199f69e56eb77"], ["2b4ea0a797a443d293ef5cff444f4979f06acfebd7e86d277475656138385b6c", "85e89bc037945d93b343083b5a1c86131a01f60c50269763b570c854e5c09b7a"], ["352bbf4a4cdd12564f93fa332ce333301d9ad40271f8107181340aef25be59d5", "321eb4075348f534d59c18259dda3e1f4a1b3b2e71b1039c67bd3d8bcf81998c"], ["2fa2104d6b38d11b0230010559879124e42ab8dfeff5ff29dc9cdadd4ecacc3f", "2de1068295dd865b64569335bd5dd80181d70ecfc882648423ba76b532b7d67"], ["9248279b09b4d68dab21a9b066edda83263c3d84e09572e269ca0cd7f5453714", "73016f7bf234aade5d1aa71bdea2b1ff3fc0de2a887912ffe54a32ce97cb3402"], ["daed4f2be3a8bf278e70132fb0beb7522f570e144bf615c07e996d443dee8729", "a69dce4a7d6c98e8d4a1aca87ef8d7003f83c230f3afa726ab40e52290be1c55"], ["c44d12c7065d812e8acf28d7cbb19f9011ecd9e9fdf281b0e6a3b5e87d22e7db", "2119a460ce326cdc76c45926c982fdac0e106e861edf61c5a039063f0e0e6482"], ["6a245bf6dc698504c89a20cfded60853152b695336c28063b61c65cbd269e6b4", "e022cf42c2bd4a708b3f5126f16a24ad8b33ba48d0423b6efd5e6348100d8a82"], ["1697ffa6fd9de627c077e3d2fe541084ce13300b0bec1146f95ae57f0d0bd6a5", "b9c398f186806f5d27561506e4557433a2cf15009e498ae7adee9d63d01b2396"], ["605bdb019981718b986d0f07e834cb0d9deb8360ffb7f61df982345ef27a7479", "2972d2de4f8d20681a78d93ec96fe23c26bfae84fb14db43b01e1e9056b8c49"], ["62d14dab4150bf497402fdc45a215e10dcb01c354959b10cfe31c7e9d87ff33d", "80fc06bd8cc5b01098088a1950eed0db01aa132967ab472235f5642483b25eaf"], ["80c60ad0040f27dade5b4b06c408e56b2c50e9f56b9b8b425e555c2f86308b6f", "1c38303f1cc5c30f26e66bad7fe72f70a65eed4cbe7024eb1aa01f56430bd57a"], ["7a9375ad6167ad54aa74c6348cc54d344cc5dc9487d847049d5eabb0fa03c8fb", "d0e3fa9eca8726909559e0d79269046bdc59ea10c70ce2b02d499ec224dc7f7"], ["d528ecd9b696b54c907a9ed045447a79bb408ec39b68df504bb51f459bc3ffc9", "eecf41253136e5f99966f21881fd656ebc4345405c520dbc063465b521409933"], ["49370a4b5f43412ea25f514e8ecdad05266115e4a7ecb1387231808f8b45963", "758f3f41afd6ed428b3081b0512fd62a54c3f3afbb5b6764b653052a12949c9a"], ["77f230936ee88cbbd73df930d64702ef881d811e0e1498e2f1c13eb1fc345d74", "958ef42a7886b6400a08266e9ba1b37896c95330d97077cbbe8eb3c7671c60d6"], ["f2dac991cc4ce4b9ea44887e5c7c0bce58c80074ab9d4dbaeb28531b7739f530", "e0dedc9b3b2f8dad4da1f32dec2531df9eb5fbeb0598e4fd1a117dba703a3c37"], ["463b3d9f662621fb1b4be8fbbe2520125a216cdfc9dae3debcba4850c690d45b", "5ed430d78c296c3543114306dd8622d7c622e27c970a1de31cb377b01af7307e"], ["f16f804244e46e2a09232d4aff3b59976b98fac14328a2d1a32496b49998f247", "cedabd9b82203f7e13d206fcdf4e33d92a6c53c26e5cce26d6579962c4e31df6"], ["caf754272dc84563b0352b7a14311af55d245315ace27c65369e15f7151d41d1", "cb474660ef35f5f2a41b643fa5e460575f4fa9b7962232a5c32f908318a04476"], ["2600ca4b282cb986f85d0f1709979d8b44a09c07cb86d7c124497bc86f082120", "4119b88753c15bd6a693b03fcddbb45d5ac6be74ab5f0ef44b0be9475a7e4b40"], ["7635ca72d7e8432c338ec53cd12220bc01c48685e24f7dc8c602a7746998e435", "91b649609489d613d1d5e590f78e6d74ecfc061d57048bad9e76f302c5b9c61"], ["754e3239f325570cdbbf4a87deee8a66b7f2b33479d468fbc1a50743bf56cc18", "673fb86e5bda30fb3cd0ed304ea49a023ee33d0197a695d0c5d98093c536683"], ["e3e6bd1071a1e96aff57859c82d570f0330800661d1c952f9fe2694691d9b9e8", "59c9e0bba394e76f40c0aa58379a3cb6a5a2283993e90c4167002af4920e37f5"], ["186b483d056a033826ae73d88f732985c4ccb1f32ba35f4b4cc47fdcf04aa6eb", "3b952d32c67cf77e2e17446e204180ab21fb8090895138b4a4a797f86e80888b"], ["df9d70a6b9876ce544c98561f4be4f725442e6d2b737d9c91a8321724ce0963f", "55eb2dafd84d6ccd5f862b785dc39d4ab157222720ef9da217b8c45cf2ba2417"], ["5edd5cc23c51e87a497ca815d5dce0f8ab52554f849ed8995de64c5f34ce7143", "efae9c8dbc14130661e8cec030c89ad0c13c66c0d17a2905cdc706ab7399a868"], ["290798c2b6476830da12fe02287e9e777aa3fba1c355b17a722d362f84614fba", "e38da76dcd440621988d00bcf79af25d5b29c094db2a23146d003afd41943e7a"], ["af3c423a95d9f5b3054754efa150ac39cd29552fe360257362dfdecef4053b45", "f98a3fd831eb2b749a93b0e6f35cfb40c8cd5aa667a15581bc2feded498fd9c6"], ["766dbb24d134e745cccaa28c99bf274906bb66b26dcf98df8d2fed50d884249a", "744b1152eacbe5e38dcc887980da38b897584a65fa06cedd2c924f97cbac5996"], ["59dbf46f8c94759ba21277c33784f41645f7b44f6c596a58ce92e666191abe3e", "c534ad44175fbc300f4ea6ce648309a042ce739a7919798cd85e216c4a307f6e"], ["f13ada95103c4537305e691e74e9a4a8dd647e711a95e73cb62dc6018cfd87b8", "e13817b44ee14de663bf4bc808341f326949e21a6a75c2570778419bdaf5733d"], ["7754b4fa0e8aced06d4167a2c59cca4cda1869c06ebadfb6488550015a88522c", "30e93e864e669d82224b967c3020b8fa8d1e4e350b6cbcc537a48b57841163a2"], ["948dcadf5990e048aa3874d46abef9d701858f95de8041d2a6828c99e2262519", "e491a42537f6e597d5d28a3224b1bc25df9154efbd2ef1d2cbba2cae5347d57e"], ["7962414450c76c1689c7b48f8202ec37fb224cf5ac0bfa1570328a8a3d7c77ab", "100b610ec4ffb4760d5c1fc133ef6f6b12507a051f04ac5760afa5b29db83437"], ["3514087834964b54b15b160644d915485a16977225b8847bb0dd085137ec47ca", "ef0afbb2056205448e1652c48e8127fc6039e77c15c2378b7e7d15a0de293311"], ["d3cc30ad6b483e4bc79ce2c9dd8bc54993e947eb8df787b442943d3f7b527eaf", "8b378a22d827278d89c5e9be8f9508ae3c2ad46290358630afb34db04eede0a4"], ["1624d84780732860ce1c78fcbfefe08b2b29823db913f6493975ba0ff4847610", "68651cf9b6da903e0914448c6cd9d4ca896878f5282be4c8cc06e2a404078575"], ["733ce80da955a8a26902c95633e62a985192474b5af207da6df7b4fd5fc61cd4", "f5435a2bd2badf7d485a4d8b8db9fcce3e1ef8e0201e4578c54673bc1dc5ea1d"], ["15d9441254945064cf1a1c33bbd3b49f8966c5092171e699ef258dfab81c045c", "d56eb30b69463e7234f5137b73b84177434800bacebfc685fc37bbe9efe4070d"], ["a1d0fcf2ec9de675b612136e5ce70d271c21417c9d2b8aaaac138599d0717940", "edd77f50bcb5a3cab2e90737309667f2641462a54070f3d519212d39c197a629"], ["e22fbe15c0af8ccc5780c0735f84dbe9a790badee8245c06c7ca37331cb36980", "a855babad5cd60c88b430a69f53a1a7a38289154964799be43d06d77d31da06"], ["311091dd9860e8e20ee13473c1155f5f69635e394704eaa74009452246cfa9b3", "66db656f87d1f04fffd1f04788c06830871ec5a64feee685bd80f0b1286d8374"], ["34c1fd04d301be89b31c0442d3e6ac24883928b45a9340781867d4232ec2dbdf", "9414685e97b1b5954bd46f730174136d57f1ceeb487443dc5321857ba73abee"], ["f219ea5d6b54701c1c14de5b557eb42a8d13f3abbcd08affcc2a5e6b049b8d63", "4cb95957e83d40b0f73af4544cccf6b1f4b08d3c07b27fb8d8c2962a400766d1"], ["d7b8740f74a8fbaab1f683db8f45de26543a5490bca627087236912469a0b448", "fa77968128d9c92ee1010f337ad4717eff15db5ed3c049b3411e0315eaa4593b"], ["32d31c222f8f6f0ef86f7c98d3a3335ead5bcd32abdd94289fe4d3091aa824bf", "5f3032f5892156e39ccd3d7915b9e1da2e6dac9e6f26e961118d14b8462e1661"], ["7461f371914ab32671045a155d9831ea8793d77cd59592c4340f86cbc18347b5", "8ec0ba238b96bec0cbdddcae0aa442542eee1ff50c986ea6b39847b3cc092ff6"], ["ee079adb1df1860074356a25aa38206a6d716b2c3e67453d287698bad7b2b2d6", "8dc2412aafe3be5c4c5f37e0ecc5f9f6a446989af04c4e25ebaac479ec1c8c1e"], ["16ec93e447ec83f0467b18302ee620f7e65de331874c9dc72bfd8616ba9da6b5", "5e4631150e62fb40d0e8c2a7ca5804a39d58186a50e497139626778e25b0674d"], ["eaa5f980c245f6f038978290afa70b6bd8855897f98b6aa485b96065d537bd99", "f65f5d3e292c2e0819a528391c994624d784869d7e6ea67fb18041024edc07dc"], ["78c9407544ac132692ee1910a02439958ae04877151342ea96c4b6b35a49f51", "f3e0319169eb9b85d5404795539a5e68fa1fbd583c064d2462b675f194a3ddb4"], ["494f4be219a1a77016dcd838431aea0001cdc8ae7a6fc688726578d9702857a5", "42242a969283a5f339ba7f075e36ba2af925ce30d767ed6e55f4b031880d562c"], ["a598a8030da6d86c6bc7f2f5144ea549d28211ea58faa70ebf4c1e665c1fe9b5", "204b5d6f84822c307e4b4a7140737aec23fc63b65b35f86a10026dbd2d864e6b"], ["c41916365abb2b5d09192f5f2dbeafec208f020f12570a184dbadc3e58595997", "4f14351d0087efa49d245b328984989d5caf9450f34bfc0ed16e96b58fa9913"], ["841d6063a586fa475a724604da03bc5b92a2e0d2e0a36acfe4c73a5514742881", "73867f59c0659e81904f9a1c7543698e62562d6744c169ce7a36de01a8d6154"], ["5e95bb399a6971d376026947f89bde2f282b33810928be4ded112ac4d70e20d5", "39f23f366809085beebfc71181313775a99c9aed7d8ba38b161384c746012865"], ["36e4641a53948fd476c39f8a99fd974e5ec07564b5315d8bf99471bca0ef2f66", "d2424b1b1abe4eb8164227b085c9aa9456ea13493fd563e06fd51cf5694c78fc"], ["336581ea7bfbbb290c191a2f507a41cf5643842170e914faeab27c2c579f726", "ead12168595fe1be99252129b6e56b3391f7ab1410cd1e0ef3dcdcabd2fda224"], ["8ab89816dadfd6b6a1f2634fcf00ec8403781025ed6890c4849742706bd43ede", "6fdcef09f2f6d0a044e654aef624136f503d459c3e89845858a47a9129cdd24e"], ["1e33f1a746c9c5778133344d9299fcaa20b0938e8acff2544bb40284b8c5fb94", "60660257dd11b3aa9c8ed618d24edff2306d320f1d03010e33a7d2057f3b3b6"], ["85b7c1dcb3cec1b7ee7f30ded79dd20a0ed1f4cc18cbcfcfa410361fd8f08f31", "3d98a9cdd026dd43f39048f25a8847f4fcafad1895d7a633c6fed3c35e999511"], ["29df9fbd8d9e46509275f4b125d6d45d7fbe9a3b878a7af872a2800661ac5f51", "b4c4fe99c775a606e2d8862179139ffda61dc861c019e55cd2876eb2a27d84b"], ["a0b1cae06b0a847a3fea6e671aaf8adfdfe58ca2f768105c8082b2e449fce252", "ae434102edde0958ec4b19d917a6a28e6b72da1834aff0e650f049503a296cf2"], ["4e8ceafb9b3e9a136dc7ff67e840295b499dfb3b2133e4ba113f2e4c0e121e5", "cf2174118c8b6d7a4b48f6d534ce5c79422c086a63460502b827ce62a326683c"], ["d24a44e047e19b6f5afb81c7ca2f69080a5076689a010919f42725c2b789a33b", "6fb8d5591b466f8fc63db50f1c0f1c69013f996887b8244d2cdec417afea8fa3"], ["ea01606a7a6c9cdd249fdfcfacb99584001edd28abbab77b5104e98e8e3b35d4", "322af4908c7312b0cfbfe369f7a7b3cdb7d4494bc2823700cfd652188a3ea98d"], ["af8addbf2b661c8a6c6328655eb96651252007d8c5ea31be4ad196de8ce2131f", "6749e67c029b85f52a034eafd096836b2520818680e26ac8f3dfbcdb71749700"], ["e3ae1974566ca06cc516d47e0fb165a674a3dabcfca15e722f0e3450f45889", "2aeabe7e4531510116217f07bf4d07300de97e4874f81f533420a72eeb0bd6a4"], ["591ee355313d99721cf6993ffed1e3e301993ff3ed258802075ea8ced397e246", "b0ea558a113c30bea60fc4775460c7901ff0b053d25ca2bdeee98f1a4be5d196"], ["11396d55fda54c49f19aa97318d8da61fa8584e47b084945077cf03255b52984", "998c74a8cd45ac01289d5833a7beb4744ff536b01b257be4c5767bea93ea57a4"], ["3c5d2a1ba39c5a1790000738c9e0c40b8dcdfd5468754b6405540157e017aa7a", "b2284279995a34e2f9d4de7396fc18b80f9b8b9fdd270f6661f79ca4c81bd257"], ["cc8704b8a60a0defa3a99a7299f2e9c3fbc395afb04ac078425ef8a1793cc030", "bdd46039feed17881d1e0862db347f8cf395b74fc4bcdc4e940b74e3ac1f1b13"], ["c533e4f7ea8555aacd9777ac5cad29b97dd4defccc53ee7ea204119b2889b197", "6f0a256bc5efdf429a2fb6242f1a43a2d9b925bb4a4b3a26bb8e0f45eb596096"], ["c14f8f2ccb27d6f109f6d08d03cc96a69ba8c34eec07bbcf566d48e33da6593", "c359d6923bb398f7fd4473e16fe1c28475b740dd098075e6c0e8649113dc3a38"], ["a6cbc3046bc6a450bac24789fa17115a4c9739ed75f8f21ce441f72e0b90e6ef", "21ae7f4680e889bb130619e2c0f95a360ceb573c70603139862afd617fa9b9f"], ["347d6d9a02c48927ebfb86c1359b1caf130a3c0267d11ce6344b39f99d43cc38", "60ea7f61a353524d1c987f6ecec92f086d565ab687870cb12689ff1e31c74448"], ["da6545d2181db8d983f7dcb375ef5866d47c67b1bf31c8cf855ef7437b72656a", "49b96715ab6878a79e78f07ce5680c5d6673051b4935bd897fea824b77dc208a"], ["c40747cc9d012cb1a13b8148309c6de7ec25d6945d657146b9d5994b8feb1111", "5ca560753be2a12fc6de6caf2cb489565db936156b9514e1bb5e83037e0fa2d4"], ["4e42c8ec82c99798ccf3a610be870e78338c7f713348bd34c8203ef4037f3502", "7571d74ee5e0fb92a7a8b33a07783341a5492144cc54bcc40a94473693606437"], ["3775ab7089bc6af823aba2e1af70b236d251cadb0c86743287522a1b3b0dedea", "be52d107bcfa09d8bcb9736a828cfa7fac8db17bf7a76a2c42ad961409018cf7"], ["cee31cbf7e34ec379d94fb814d3d775ad954595d1314ba8846959e3e82f74e26", "8fd64a14c06b589c26b947ae2bcf6bfa0149ef0be14ed4d80f448a01c43b1c6d"], ["b4f9eaea09b6917619f6ea6a4eb5464efddb58fd45b1ebefcdc1a01d08b47986", "39e5c9925b5a54b07433a4f18c61726f8bb131c012ca542eb24a8ac07200682a"], ["d4263dfc3d2df923a0179a48966d30ce84e2515afc3dccc1b77907792ebcc60e", "62dfaf07a0f78feb30e30d6295853ce189e127760ad6cf7fae164e122a208d54"], ["48457524820fa65a4f8d35eb6930857c0032acc0a4a2de422233eeda897612c4", "25a748ab367979d98733c38a1fa1c2e7dc6cc07db2d60a9ae7a76aaa49bd0f77"], ["dfeeef1881101f2cb11644f3a2afdfc2045e19919152923f367a1767c11cceda", "ecfb7056cf1de042f9420bab396793c0c390bde74b4bbdff16a83ae09a9a7517"], ["6d7ef6b17543f8373c573f44e1f389835d89bcbc6062ced36c82df83b8fae859", "cd450ec335438986dfefa10c57fea9bcc521a0959b2d80bbf74b190dca712d10"], ["e75605d59102a5a2684500d3b991f2e3f3c88b93225547035af25af66e04541f", "f5c54754a8f71ee540b9b48728473e314f729ac5308b06938360990e2bfad125"], ["eb98660f4c4dfaa06a2be453d5020bc99a0c2e60abe388457dd43fefb1ed620c", "6cb9a8876d9cb8520609af3add26cd20a0a7cd8a9411131ce85f44100099223e"], ["13e87b027d8514d35939f2e6892b19922154596941888336dc3563e3b8dba942", "fef5a3c68059a6dec5d624114bf1e91aac2b9da568d6abeb2570d55646b8adf1"], ["ee163026e9fd6fe017c38f06a5be6fc125424b371ce2708e7bf4491691e5764a", "1acb250f255dd61c43d94ccc670d0f58f49ae3fa15b96623e5430da0ad6c62b2"], ["b268f5ef9ad51e4d78de3a750c2dc89b1e626d43505867999932e5db33af3d80", "5f310d4b3c99b9ebb19f77d41c1dee018cf0d34fd4191614003e945a1216e423"], ["ff07f3118a9df035e9fad85eb6c7bfe42b02f01ca99ceea3bf7ffdba93c4750d", "438136d603e858a3a5c440c38eccbaddc1d2942114e2eddd4740d098ced1f0d8"], ["8d8b9855c7c052a34146fd20ffb658bea4b9f69e0d825ebec16e8c3ce2b526a1", "cdb559eedc2d79f926baf44fb84ea4d44bcf50fee51d7ceb30e2e7f463036758"], ["52db0b5384dfbf05bfa9d472d7ae26dfe4b851ceca91b1eba54263180da32b63", "c3b997d050ee5d423ebaf66a6db9f57b3180c902875679de924b69d84a7b375"], ["e62f9490d3d51da6395efd24e80919cc7d0f29c3f3fa48c6fff543becbd43352", "6d89ad7ba4876b0b22c2ca280c682862f342c8591f1daf5170e07bfd9ccafa7d"], ["7f30ea2476b399b4957509c88f77d0191afa2ff5cb7b14fd6d8e7d65aaab1193", "ca5ef7d4b231c94c3b15389a5f6311e9daff7bb67b103e9880ef4bff637acaec"], ["5098ff1e1d9f14fb46a210fada6c903fef0fb7b4a1dd1d9ac60a0361800b7a00", "9731141d81fc8f8084d37c6e7542006b3ee1b40d60dfe5362a5b132fd17ddc0"], ["32b78c7de9ee512a72895be6b9cbefa6e2f3c4ccce445c96b9f2c81e2778ad58", "ee1849f513df71e32efc3896ee28260c73bb80547ae2275ba497237794c8753c"], ["e2cb74fddc8e9fbcd076eef2a7c72b0ce37d50f08269dfc074b581550547a4f7", "d3aa2ed71c9dd2247a62df062736eb0baddea9e36122d2be8641abcb005cc4a4"], ["8438447566d4d7bedadc299496ab357426009a35f235cb141be0d99cd10ae3a8", "c4e1020916980a4da5d01ac5e6ad330734ef0d7906631c4f2390426b2edd791f"], ["4162d488b89402039b584c6fc6c308870587d9c46f660b878ab65c82c711d67e", "67163e903236289f776f22c25fb8a3afc1732f2b84b4e95dbda47ae5a0852649"], ["3fad3fa84caf0f34f0f89bfd2dcf54fc175d767aec3e50684f3ba4a4bf5f683d", "cd1bc7cb6cc407bb2f0ca647c718a730cf71872e7d0d2a53fa20efcdfe61826"], ["674f2600a3007a00568c1a7ce05d0816c1fb84bf1370798f1c69532faeb1a86b", "299d21f9413f33b3edf43b257004580b70db57da0b182259e09eecc69e0d38a5"], ["d32f4da54ade74abb81b815ad1fb3b263d82d6c692714bcff87d29bd5ee9f08f", "f9429e738b8e53b968e99016c059707782e14f4535359d582fc416910b3eea87"], ["30e4e670435385556e593657135845d36fbb6931f72b08cb1ed954f1e3ce3ff6", "462f9bce619898638499350113bbc9b10a878d35da70740dc695a559eb88db7b"], ["be2062003c51cc3004682904330e4dee7f3dcd10b01e580bf1971b04d4cad297", "62188bc49d61e5428573d48a74e1c655b1c61090905682a0d5558ed72dccb9bc"], ["93144423ace3451ed29e0fb9ac2af211cb6e84a601df5993c419859fff5df04a", "7c10dfb164c3425f5c71a3f9d7992038f1065224f72bb9d1d902a6d13037b47c"], ["b015f8044f5fcbdcf21ca26d6c34fb8197829205c7b7d2a7cb66418c157b112c", "ab8c1e086d04e813744a655b2df8d5f83b3cdc6faa3088c1d3aea1454e3a1d5f"], ["d5e9e1da649d97d89e4868117a465a3a4f8a18de57a140d36b3f2af341a21b52", "4cb04437f391ed73111a13cc1d4dd0db1693465c2240480d8955e8592f27447a"], ["d3ae41047dd7ca065dbf8ed77b992439983005cd72e16d6f996a5316d36966bb", "bd1aeb21ad22ebb22a10f0303417c6d964f8cdd7df0aca614b10dc14d125ac46"], ["463e2763d885f958fc66cdd22800f0a487197d0a82e377b49f80af87c897b065", "bfefacdb0e5d0fd7df3a311a94de062b26b80c61fbc97508b79992671ef7ca7f"], ["7985fdfd127c0567c6f53ec1bb63ec3158e597c40bfe747c83cddfc910641917", "603c12daf3d9862ef2b25fe1de289aed24ed291e0ec6708703a5bd567f32ed03"], ["74a1ad6b5f76e39db2dd249410eac7f99e74c59cb83d2d0ed5ff1543da7703e9", "cc6157ef18c9c63cd6193d83631bbea0093e0968942e8c33d5737fd790e0db08"], ["30682a50703375f602d416664ba19b7fc9bab42c72747463a71d0896b22f6da3", "553e04f6b018b4fa6c8f39e7f311d3176290d0e0f19ca73f17714d9977a22ff8"], ["9e2158f0d7c0d5f26c3791efefa79597654e7a2b2464f52b1ee6c1347769ef57", "712fcdd1b9053f09003a3481fa7762e9ffd7c8ef35a38509e2fbf2629008373"], ["176e26989a43c9cfeba4029c202538c28172e566e3c4fce7322857f3be327d66", "ed8cc9d04b29eb877d270b4878dc43c19aefd31f4eee09ee7b47834c1fa4b1c3"], ["75d46efea3771e6e68abb89a13ad747ecf1892393dfc4f1b7004788c50374da8", "9852390a99507679fd0b86fd2b39a868d7efc22151346e1a3ca4726586a6bed8"], ["809a20c67d64900ffb698c4c825f6d5f2310fb0451c869345b7319f645605721", "9e994980d9917e22b76b061927fa04143d096ccc54963e6a5ebfa5f3f8e286c1"], ["1b38903a43f7f114ed4500b4eac7083fdefece1cf29c63528d563446f972c180", "4036edc931a60ae889353f77fd53de4a2708b26b6f5da72ad3394119daf408f9"]] } };
});
var $n = k2((lc) => {
  "use strict";
  var ts = lc, Jr = Jn(), es = W0(), F32 = ht2(), dc = F32.assert;
  function cc(t) {
    t.type === "short" ? this.curve = new es.short(t) : t.type === "edwards" ? this.curve = new es.edwards(t) : this.curve = new es.mont(t), this.g = this.curve.g, this.n = this.curve.n, this.hash = t.hash, dc(this.g.validate(), "Invalid curve"), dc(this.g.mul(this.n).isInfinity(), "Invalid curve, G*N != O");
  }
  ts.PresetCurve = cc;
  function $r3(t, e) {
    Object.defineProperty(ts, t, { configurable: true, enumerable: true, get: function() {
      var r = new cc(e);
      return Object.defineProperty(ts, t, { configurable: true, enumerable: true, value: r }), r;
    } });
  }
  $r3("p192", { type: "short", prime: "p192", p: "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff", a: "ffffffff ffffffff ffffffff fffffffe ffffffff fffffffc", b: "64210519 e59c80e7 0fa7e9ab 72243049 feb8deec c146b9b1", n: "ffffffff ffffffff ffffffff 99def836 146bc9b1 b4d22831", hash: Jr.sha256, gRed: false, g: ["188da80e b03090f6 7cbf20eb 43a18800 f4ff0afd 82ff1012", "07192b95 ffc8da78 631011ed 6b24cdd5 73f977a1 1e794811"] });
  $r3("p224", { type: "short", prime: "p224", p: "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001", a: "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff fffffffe", b: "b4050a85 0c04b3ab f5413256 5044b0b7 d7bfd8ba 270b3943 2355ffb4", n: "ffffffff ffffffff ffffffff ffff16a2 e0b8f03e 13dd2945 5c5c2a3d", hash: Jr.sha256, gRed: false, g: ["b70e0cbd 6bb4bf7f 321390b9 4a03c1d3 56c21122 343280d6 115c1d21", "bd376388 b5f723fb 4c22dfe6 cd4375a0 5a074764 44d58199 85007e34"] });
  $r3("p256", { type: "short", prime: null, p: "ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff ffffffff", a: "ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff fffffffc", b: "5ac635d8 aa3a93e7 b3ebbd55 769886bc 651d06b0 cc53b0f6 3bce3c3e 27d2604b", n: "ffffffff 00000000 ffffffff ffffffff bce6faad a7179e84 f3b9cac2 fc632551", hash: Jr.sha256, gRed: false, g: ["6b17d1f2 e12c4247 f8bce6e5 63a440f2 77037d81 2deb33a0 f4a13945 d898c296", "4fe342e2 fe1a7f9b 8ee7eb4a 7c0f9e16 2bce3357 6b315ece cbb64068 37bf51f5"] });
  $r3("p384", { type: "short", prime: null, p: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 ffffffff", a: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 fffffffc", b: "b3312fa7 e23ee7e4 988e056b e3f82d19 181d9c6e fe814112 0314088f 5013875a c656398d 8a2ed19d 2a85c8ed d3ec2aef", n: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff c7634d81 f4372ddf 581a0db2 48b0a77a ecec196a ccc52973", hash: Jr.sha384, gRed: false, g: ["aa87ca22 be8b0537 8eb1c71e f320ad74 6e1d3b62 8ba79b98 59f741e0 82542a38 5502f25d bf55296c 3a545e38 72760ab7", "3617de4a 96262c6f 5d9e98bf 9292dc29 f8f41dbd 289a147c e9da3113 b5f0b8c0 0a60b1ce 1d7e819d 7a431d7c 90ea0e5f"] });
  $r3("p521", { type: "short", prime: null, p: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff", a: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffc", b: "00000051 953eb961 8e1c9a1f 929a21a0 b68540ee a2da725b 99b315f3 b8b48991 8ef109e1 56193951 ec7e937b 1652c0bd 3bb1bf07 3573df88 3d2c34f1 ef451fd4 6b503f00", n: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffa 51868783 bf2f966b 7fcc0148 f709a5d0 3bb5c9b8 899c47ae bb6fb71e 91386409", hash: Jr.sha512, gRed: false, g: ["000000c6 858e06b7 0404e9cd 9e3ecb66 2395b442 9c648139 053fb521 f828af60 6b4d3dba a14b5e77 efe75928 fe1dc127 a2ffa8de 3348b3c1 856a429b f97e7e31 c2e5bd66", "00000118 39296a78 9a3bc004 5c8a5fb4 2c7d1bd9 98f54449 579b4468 17afbd17 273e662c 97ee7299 5ef42640 c550b901 3fad0761 353c7086 a272c240 88be9476 9fd16650"] });
  $r3("curve25519", { type: "mont", prime: "p25519", p: "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed", a: "76d06", b: "1", n: "1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed", hash: Jr.sha256, gRed: false, g: ["9"] });
  $r3("ed25519", { type: "edwards", prime: "p25519", p: "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed", a: "-1", c: "1", d: "52036cee2b6ffe73 8cc740797779e898 00700a4d4141d8ab 75eb4dca135978a3", n: "1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed", hash: Jr.sha256, gRed: false, g: ["216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a", "6666666666666666666666666666666666666666666666666666666666666658"] });
  var rs;
  try {
    rs = uc();
  } catch {
    rs = void 0;
  }
  $r3("secp256k1", { type: "short", prime: "k256", p: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f", a: "0", b: "7", n: "ffffffff ffffffff ffffffff fffffffe baaedce6 af48a03b bfd25e8c d0364141", h: "1", hash: Jr.sha256, beta: "7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee", lambda: "5363ad4cc05c30e0a5261c028812645a122e22ea20816678df02967c1b23bd72", basis: [{ a: "3086d221a7d46bcde86c90e49284eb15", b: "-e4437ed6010e88286f547fa90abfe4c3" }, { a: "114ca50f7a8e2f3f657c1108d9d44cfd8", b: "3086d221a7d46bcde86c90e49284eb15" }], gRed: false, g: ["79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798", "483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8", rs] });
});
var bc = k2((Cm, pc) => {
  "use strict";
  var K32 = Jn(), Mi = K0(), vc = ot();
  function Qr2(t) {
    if (!(this instanceof Qr2))
      return new Qr2(t);
    this.hash = t.hash, this.predResist = !!t.predResist, this.outLen = this.hash.outSize, this.minEntropy = t.minEntropy || this.hash.hmacStrength, this._reseed = null, this.reseedInterval = null, this.K = null, this.V = null;
    var e = Mi.toArray(t.entropy, t.entropyEnc || "hex"), r = Mi.toArray(t.nonce, t.nonceEnc || "hex"), n = Mi.toArray(t.pers, t.persEnc || "hex");
    vc(e.length >= this.minEntropy / 8, "Not enough entropy. Minimum is: " + this.minEntropy + " bits"), this._init(e, r, n);
  }
  pc.exports = Qr2;
  Qr2.prototype._init = function(e, r, n) {
    var i = e.concat(r).concat(n);
    this.K = new Array(this.outLen / 8), this.V = new Array(this.outLen / 8);
    for (var o2 = 0; o2 < this.V.length; o2++)
      this.K[o2] = 0, this.V[o2] = 1;
    this._update(i), this._reseed = 1, this.reseedInterval = 281474976710656;
  };
  Qr2.prototype._hmac = function() {
    return new K32.hmac(this.hash, this.K);
  };
  Qr2.prototype._update = function(e) {
    var r = this._hmac().update(this.V).update([0]);
    e && (r = r.update(e)), this.K = r.digest(), this.V = this._hmac().update(this.V).digest(), e && (this.K = this._hmac().update(this.V).update([1]).update(e).digest(), this.V = this._hmac().update(this.V).digest());
  };
  Qr2.prototype.reseed = function(e, r, n, i) {
    typeof r != "string" && (i = n, n = r, r = null), e = Mi.toArray(e, r), n = Mi.toArray(n, i), vc(e.length >= this.minEntropy / 8, "Not enough entropy. Minimum is: " + this.minEntropy + " bits"), this._update(e.concat(n || [])), this._reseed = 1;
  };
  Qr2.prototype.generate = function(e, r, n, i) {
    if (this._reseed > this.reseedInterval)
      throw new Error("Reseed is required");
    typeof r != "string" && (i = n, n = r, r = null), n && (n = Mi.toArray(n, i || "hex"), this._update(n));
    for (var o2 = []; o2.length < e; )
      this.V = this._hmac().update(this.V).digest(), o2 = o2.concat(this.V);
    var p3 = o2.slice(0, e);
    return this._update(n), this._reseed++, Mi.encode(p3, r);
  };
});
var gc = k2((Nm, mc) => {
  "use strict";
  var j3 = Fe(), W32 = ht2(), is = W32.assert;
  function tt(t, e) {
    this.ec = t, this.priv = null, this.pub = null, e.priv && this._importPrivate(e.priv, e.privEnc), e.pub && this._importPublic(e.pub, e.pubEnc);
  }
  mc.exports = tt;
  tt.fromPublic = function(e, r, n) {
    return r instanceof tt ? r : new tt(e, { pub: r, pubEnc: n });
  };
  tt.fromPrivate = function(e, r, n) {
    return r instanceof tt ? r : new tt(e, { priv: r, privEnc: n });
  };
  tt.prototype.validate = function() {
    var e = this.getPublic();
    return e.isInfinity() ? { result: false, reason: "Invalid public key" } : e.validate() ? e.mul(this.ec.curve.n).isInfinity() ? { result: true, reason: null } : { result: false, reason: "Public key * N != O" } : { result: false, reason: "Public key is not a point" };
  };
  tt.prototype.getPublic = function(e, r) {
    return typeof e == "string" && (r = e, e = null), this.pub || (this.pub = this.ec.g.mul(this.priv)), r ? this.pub.encode(r, e) : this.pub;
  };
  tt.prototype.getPrivate = function(e) {
    return e === "hex" ? this.priv.toString(16, 2) : this.priv;
  };
  tt.prototype._importPrivate = function(e, r) {
    this.priv = new j3(e, r || 16), this.priv = this.priv.umod(this.ec.curve.n);
  };
  tt.prototype._importPublic = function(e, r) {
    if (e.x || e.y) {
      this.ec.curve.type === "mont" ? is(e.x, "Need x coordinate") : (this.ec.curve.type === "short" || this.ec.curve.type === "edwards") && is(e.x && e.y, "Need both x and y coordinate"), this.pub = this.ec.curve.point(e.x, e.y);
      return;
    }
    this.pub = this.ec.curve.decodePoint(e, r);
  };
  tt.prototype.derive = function(e) {
    return e.validate() || is(e.validate(), "public point not validated"), e.mul(this.priv).getX();
  };
  tt.prototype.sign = function(e, r, n) {
    return this.ec.sign(e, this, r, n);
  };
  tt.prototype.verify = function(e, r) {
    return this.ec.verify(e, r, this);
  };
  tt.prototype.inspect = function() {
    return "<Key priv: " + (this.priv && this.priv.toString(16, 2)) + " pub: " + (this.pub && this.pub.inspect()) + " >";
  };
});
var wc = k2((Lm, _c) => {
  "use strict";
  var Qn = Fe(), as = ht2(), V3 = as.assert;
  function ea(t, e) {
    if (t instanceof ea)
      return t;
    this._importDER(t, e) || (V3(t.r && t.s, "Signature without r or s"), this.r = new Qn(t.r, 16), this.s = new Qn(t.s, 16), t.recoveryParam === void 0 ? this.recoveryParam = null : this.recoveryParam = t.recoveryParam);
  }
  _c.exports = ea;
  function Z32() {
    this.place = 0;
  }
  function fs2(t, e) {
    var r = t[e.place++];
    if (!(r & 128))
      return r;
    var n = r & 15;
    if (n === 0 || n > 4)
      return false;
    for (var i = 0, o2 = 0, p3 = e.place; o2 < n; o2++, p3++)
      i <<= 8, i |= t[p3], i >>>= 0;
    return i <= 127 ? false : (e.place = p3, i);
  }
  function yc(t) {
    for (var e = 0, r = t.length - 1; !t[e] && !(t[e + 1] & 128) && e < r; )
      e++;
    return e === 0 ? t : t.slice(e);
  }
  ea.prototype._importDER = function(e, r) {
    e = as.toArray(e, r);
    var n = new Z32();
    if (e[n.place++] !== 48)
      return false;
    var i = fs2(e, n);
    if (i === false || i + n.place !== e.length || e[n.place++] !== 2)
      return false;
    var o2 = fs2(e, n);
    if (o2 === false)
      return false;
    var p3 = e.slice(n.place, o2 + n.place);
    if (n.place += o2, e[n.place++] !== 2)
      return false;
    var y4 = fs2(e, n);
    if (y4 === false || e.length !== y4 + n.place)
      return false;
    var w2 = e.slice(n.place, y4 + n.place);
    if (p3[0] === 0)
      if (p3[1] & 128)
        p3 = p3.slice(1);
      else
        return false;
    if (w2[0] === 0)
      if (w2[1] & 128)
        w2 = w2.slice(1);
      else
        return false;
    return this.r = new Qn(p3), this.s = new Qn(w2), this.recoveryParam = null, true;
  };
  function ns(t, e) {
    if (e < 128) {
      t.push(e);
      return;
    }
    var r = 1 + (Math.log(e) / Math.LN2 >>> 3);
    for (t.push(r | 128); --r; )
      t.push(e >>> (r << 3) & 255);
    t.push(e);
  }
  ea.prototype.toDER = function(e) {
    var r = this.r.toArray(), n = this.s.toArray();
    for (r[0] & 128 && (r = [0].concat(r)), n[0] & 128 && (n = [0].concat(n)), r = yc(r), n = yc(n); !n[0] && !(n[1] & 128); )
      n = n.slice(1);
    var i = [2];
    ns(i, r.length), i = i.concat(r), i.push(2), ns(i, n.length);
    var o2 = i.concat(n), p3 = [48];
    return ns(p3, o2.length), p3 = p3.concat(o2), as.encode(p3, e);
  };
});
var Ec = k2((Om, Sc) => {
  "use strict";
  var Si = Fe(), xc = bc(), G32 = ht2(), ss = $n(), X32 = On(), Mc = G32.assert, os3 = gc(), ta = wc();
  function _t(t) {
    if (!(this instanceof _t))
      return new _t(t);
    typeof t == "string" && (Mc(Object.prototype.hasOwnProperty.call(ss, t), "Unknown curve " + t), t = ss[t]), t instanceof ss.PresetCurve && (t = { curve: t }), this.curve = t.curve.curve, this.n = this.curve.n, this.nh = this.n.ushrn(1), this.g = this.curve.g, this.g = t.curve.g, this.g.precompute(t.curve.n.bitLength() + 1), this.hash = t.hash || t.curve.hash;
  }
  Sc.exports = _t;
  _t.prototype.keyPair = function(e) {
    return new os3(this, e);
  };
  _t.prototype.keyFromPrivate = function(e, r) {
    return os3.fromPrivate(this, e, r);
  };
  _t.prototype.keyFromPublic = function(e, r) {
    return os3.fromPublic(this, e, r);
  };
  _t.prototype.genKeyPair = function(e) {
    e || (e = {});
    for (var r = new xc({ hash: this.hash, pers: e.pers, persEnc: e.persEnc || "utf8", entropy: e.entropy || X32(this.hash.hmacStrength), entropyEnc: e.entropy && e.entropyEnc || "utf8", nonce: this.n.toArray() }), n = this.n.byteLength(), i = this.n.sub(new Si(2)); ; ) {
      var o2 = new Si(r.generate(n));
      if (!(o2.cmp(i) > 0))
        return o2.iaddn(1), this.keyFromPrivate(o2);
    }
  };
  _t.prototype._truncateToN = function(e, r) {
    var n = e.byteLength() * 8 - this.n.bitLength();
    return n > 0 && (e = e.ushrn(n)), !r && e.cmp(this.n) >= 0 ? e.sub(this.n) : e;
  };
  _t.prototype.sign = function(e, r, n, i) {
    typeof n == "object" && (i = n, n = null), i || (i = {}), r = this.keyFromPrivate(r, n), e = this._truncateToN(new Si(e, 16));
    for (var o2 = this.n.byteLength(), p3 = r.getPrivate().toArray("be", o2), y4 = e.toArray("be", o2), w2 = new xc({ hash: this.hash, entropy: p3, nonce: y4, pers: i.pers, persEnc: i.persEnc || "utf8" }), x = this.n.sub(new Si(1)), M4 = 0; ; M4++) {
      var E2 = i.k ? i.k(M4) : new Si(w2.generate(this.n.byteLength()));
      if (E2 = this._truncateToN(E2, true), !(E2.cmpn(1) <= 0 || E2.cmp(x) >= 0)) {
        var A4 = this.g.mul(E2);
        if (!A4.isInfinity()) {
          var I3 = A4.getX(), D6 = I3.umod(this.n);
          if (D6.cmpn(0) !== 0) {
            var C = E2.invm(this.n).mul(D6.mul(r.getPrivate()).iadd(e));
            if (C = C.umod(this.n), C.cmpn(0) !== 0) {
              var ge2 = (A4.getY().isOdd() ? 1 : 0) | (I3.cmp(D6) !== 0 ? 2 : 0);
              return i.canonical && C.cmp(this.nh) > 0 && (C = this.n.sub(C), ge2 ^= 1), new ta({ r: D6, s: C, recoveryParam: ge2 });
            }
          }
        }
      }
    }
  };
  _t.prototype.verify = function(e, r, n, i) {
    e = this._truncateToN(new Si(e, 16)), n = this.keyFromPublic(n, i), r = new ta(r, "hex");
    var o2 = r.r, p3 = r.s;
    if (o2.cmpn(1) < 0 || o2.cmp(this.n) >= 0 || p3.cmpn(1) < 0 || p3.cmp(this.n) >= 0)
      return false;
    var y4 = p3.invm(this.n), w2 = y4.mul(e).umod(this.n), x = y4.mul(o2).umod(this.n), M4;
    return this.curve._maxwellTrick ? (M4 = this.g.jmulAdd(w2, n.getPublic(), x), M4.isInfinity() ? false : M4.eqXToP(o2)) : (M4 = this.g.mulAdd(w2, n.getPublic(), x), M4.isInfinity() ? false : M4.getX().umod(this.n).cmp(o2) === 0);
  };
  _t.prototype.recoverPubKey = function(t, e, r, n) {
    Mc((3 & r) === r, "The recovery param is more than two bits"), e = new ta(e, n);
    var i = this.n, o2 = new Si(t), p3 = e.r, y4 = e.s, w2 = r & 1, x = r >> 1;
    if (p3.cmp(this.curve.p.umod(this.curve.n)) >= 0 && x)
      throw new Error("Unable to find sencond key candinate");
    x ? p3 = this.curve.pointFromX(p3.add(this.curve.n), w2) : p3 = this.curve.pointFromX(p3, w2);
    var M4 = e.r.invm(i), E2 = i.sub(o2).mul(M4).umod(i), A4 = y4.mul(M4).umod(i);
    return this.g.mulAdd(E2, p3, A4);
  };
  _t.prototype.getKeyRecoveryParam = function(t, e, r, n) {
    if (e = new ta(e, n), e.recoveryParam !== null)
      return e.recoveryParam;
    for (var i = 0; i < 4; i++) {
      var o2;
      try {
        o2 = this.recoverPubKey(t, e, i);
      } catch {
        continue;
      }
      if (o2.eq(r))
        return i;
    }
    throw new Error("Unable to find valid recovery factor");
  };
});
var Rc = k2((zm, Bc) => {
  "use strict";
  var Uf = ht2(), qc = Uf.assert, Ac = Uf.parseBytes, Qi = Uf.cachedProperty;
  function Ze2(t, e) {
    this.eddsa = t, this._secret = Ac(e.secret), t.isPoint(e.pub) ? this._pub = e.pub : this._pubBytes = Ac(e.pub);
  }
  Ze2.fromPublic = function(e, r) {
    return r instanceof Ze2 ? r : new Ze2(e, { pub: r });
  };
  Ze2.fromSecret = function(e, r) {
    return r instanceof Ze2 ? r : new Ze2(e, { secret: r });
  };
  Ze2.prototype.secret = function() {
    return this._secret;
  };
  Qi(Ze2, "pubBytes", function() {
    return this.eddsa.encodePoint(this.pub());
  });
  Qi(Ze2, "pub", function() {
    return this._pubBytes ? this.eddsa.decodePoint(this._pubBytes) : this.eddsa.g.mul(this.priv());
  });
  Qi(Ze2, "privBytes", function() {
    var e = this.eddsa, r = this.hash(), n = e.encodingLength - 1, i = r.slice(0, e.encodingLength);
    return i[0] &= 248, i[n] &= 127, i[n] |= 64, i;
  });
  Qi(Ze2, "priv", function() {
    return this.eddsa.decodeInt(this.privBytes());
  });
  Qi(Ze2, "hash", function() {
    return this.eddsa.hash().update(this.secret()).digest();
  });
  Qi(Ze2, "messagePrefix", function() {
    return this.hash().slice(this.eddsa.encodingLength);
  });
  Ze2.prototype.sign = function(e) {
    return qc(this._secret, "KeyPair can only verify"), this.eddsa.sign(e, this);
  };
  Ze2.prototype.verify = function(e, r) {
    return this.eddsa.verify(e, r, this);
  };
  Ze2.prototype.getSecret = function(e) {
    return qc(this._secret, "KeyPair is public only"), Uf.encode(this.secret(), e);
  };
  Ze2.prototype.getPublic = function(e) {
    return Uf.encode(this.pubBytes(), e);
  };
  Bc.exports = Ze2;
});
var kc = k2((Um, Ic) => {
  "use strict";
  var Y32 = Fe(), ra = ht2(), J3 = ra.assert, ia = ra.cachedProperty, $32 = ra.parseBytes;
  function Ei(t, e) {
    this.eddsa = t, typeof e != "object" && (e = $32(e)), Array.isArray(e) && (e = { R: e.slice(0, t.encodingLength), S: e.slice(t.encodingLength) }), J3(e.R && e.S, "Signature without R or S"), t.isPoint(e.R) && (this._R = e.R), e.S instanceof Y32 && (this._S = e.S), this._Rencoded = Array.isArray(e.R) ? e.R : e.Rencoded, this._Sencoded = Array.isArray(e.S) ? e.S : e.Sencoded;
  }
  ia(Ei, "S", function() {
    return this.eddsa.decodeInt(this.Sencoded());
  });
  ia(Ei, "R", function() {
    return this.eddsa.decodePoint(this.Rencoded());
  });
  ia(Ei, "Rencoded", function() {
    return this.eddsa.encodePoint(this.R());
  });
  ia(Ei, "Sencoded", function() {
    return this.eddsa.encodeInt(this.S());
  });
  Ei.prototype.toBytes = function() {
    return this.Rencoded().concat(this.Sencoded());
  };
  Ei.prototype.toHex = function() {
    return ra.encode(this.toBytes(), "hex").toUpperCase();
  };
  Ic.exports = Ei;
});
var Nc = k2((Hm, Cc) => {
  "use strict";
  var Q3 = Jn(), e4 = $n(), ef = ht2(), t4 = ef.assert, Pc = ef.parseBytes, Tc = Rc(), Dc = kc();
  function at2(t) {
    if (t4(t === "ed25519", "only tested with ed25519 so far"), !(this instanceof at2))
      return new at2(t);
    t = e4[t].curve, this.curve = t, this.g = t.g, this.g.precompute(t.n.bitLength() + 1), this.pointClass = t.point().constructor, this.encodingLength = Math.ceil(t.n.bitLength() / 8), this.hash = Q3.sha512;
  }
  Cc.exports = at2;
  at2.prototype.sign = function(e, r) {
    e = Pc(e);
    var n = this.keyFromSecret(r), i = this.hashInt(n.messagePrefix(), e), o2 = this.g.mul(i), p3 = this.encodePoint(o2), y4 = this.hashInt(p3, n.pubBytes(), e).mul(n.priv()), w2 = i.add(y4).umod(this.curve.n);
    return this.makeSignature({ R: o2, S: w2, Rencoded: p3 });
  };
  at2.prototype.verify = function(e, r, n) {
    e = Pc(e), r = this.makeSignature(r);
    var i = this.keyFromPublic(n), o2 = this.hashInt(r.Rencoded(), i.pubBytes(), e), p3 = this.g.mul(r.S()), y4 = r.R().add(i.pub().mul(o2));
    return y4.eq(p3);
  };
  at2.prototype.hashInt = function() {
    for (var e = this.hash(), r = 0; r < arguments.length; r++)
      e.update(arguments[r]);
    return ef.intFromLE(e.digest()).umod(this.curve.n);
  };
  at2.prototype.keyFromPublic = function(e) {
    return Tc.fromPublic(this, e);
  };
  at2.prototype.keyFromSecret = function(e) {
    return Tc.fromSecret(this, e);
  };
  at2.prototype.makeSignature = function(e) {
    return e instanceof Dc ? e : new Dc(this, e);
  };
  at2.prototype.encodePoint = function(e) {
    var r = e.getY().toArray("le", this.encodingLength);
    return r[this.encodingLength - 1] |= e.getX().isOdd() ? 128 : 0, r;
  };
  at2.prototype.decodePoint = function(e) {
    e = ef.parseBytes(e);
    var r = e.length - 1, n = e.slice(0, r).concat(e[r] & -129), i = (e[r] & 128) !== 0, o2 = ef.intFromLE(n);
    return this.curve.pointFromY(o2, i);
  };
  at2.prototype.encodeInt = function(e) {
    return e.toArray("le", this.encodingLength);
  };
  at2.prototype.decodeInt = function(e) {
    return ef.intFromLE(e);
  };
  at2.prototype.isPoint = function(e) {
    return e instanceof this.pointClass;
  };
});
var fa = k2((Lc) => {
  "use strict";
  var Ai = Lc;
  Ai.version = pd().version;
  Ai.utils = ht2();
  Ai.rand = On();
  Ai.curve = W0();
  Ai.curves = $n();
  Ai.ec = Ec();
  Ai.eddsa = Nc();
});
var us = k2((Oc, hs) => {
  (function(t, e) {
    "use strict";
    function r(c5, f) {
      if (!c5)
        throw new Error(f || "Assertion failed");
    }
    function n(c5, f) {
      c5.super_ = f;
      var a = function() {
      };
      a.prototype = f.prototype, c5.prototype = new a(), c5.prototype.constructor = c5;
    }
    function i(c5, f, a) {
      if (i.isBN(c5))
        return c5;
      this.negative = 0, this.words = null, this.length = 0, this.red = null, c5 !== null && ((f === "le" || f === "be") && (a = f, f = 10), this._init(c5 || 0, f || 10, a || "be"));
    }
    typeof t == "object" ? t.exports = i : e.BN = i, i.BN = i, i.wordSize = 26;
    var o2;
    try {
      typeof document < "u" && typeof window.Buffer < "u" ? o2 = window.Buffer : o2 = export_default.Buffer;
    } catch {
    }
    i.isBN = function(f) {
      return f instanceof i ? true : f !== null && typeof f == "object" && f.constructor.wordSize === i.wordSize && Array.isArray(f.words);
    }, i.max = function(f, a) {
      return f.cmp(a) > 0 ? f : a;
    }, i.min = function(f, a) {
      return f.cmp(a) < 0 ? f : a;
    }, i.prototype._init = function(f, a, u) {
      if (typeof f == "number")
        return this._initNumber(f, a, u);
      if (typeof f == "object")
        return this._initArray(f, a, u);
      a === "hex" && (a = 16), r(a === (a | 0) && a >= 2 && a <= 36), f = f.toString().replace(/\s+/g, "");
      var l = 0;
      f[0] === "-" && (l++, this.negative = 1), l < f.length && (a === 16 ? this._parseHex(f, l, u) : (this._parseBase(f, a, l), u === "le" && this._initArray(this.toArray(), a, u)));
    }, i.prototype._initNumber = function(f, a, u) {
      f < 0 && (this.negative = 1, f = -f), f < 67108864 ? (this.words = [f & 67108863], this.length = 1) : f < 4503599627370496 ? (this.words = [f & 67108863, f / 67108864 & 67108863], this.length = 2) : (r(f < 9007199254740992), this.words = [f & 67108863, f / 67108864 & 67108863, 1], this.length = 3), u === "le" && this._initArray(this.toArray(), a, u);
    }, i.prototype._initArray = function(f, a, u) {
      if (r(typeof f.length == "number"), f.length <= 0)
        return this.words = [0], this.length = 1, this;
      this.length = Math.ceil(f.length / 3), this.words = new Array(this.length);
      for (var l = 0; l < this.length; l++)
        this.words[l] = 0;
      var d4, h, b2 = 0;
      if (u === "be")
        for (l = f.length - 1, d4 = 0; l >= 0; l -= 3)
          h = f[l] | f[l - 1] << 8 | f[l - 2] << 16, this.words[d4] |= h << b2 & 67108863, this.words[d4 + 1] = h >>> 26 - b2 & 67108863, b2 += 24, b2 >= 26 && (b2 -= 26, d4++);
      else if (u === "le")
        for (l = 0, d4 = 0; l < f.length; l += 3)
          h = f[l] | f[l + 1] << 8 | f[l + 2] << 16, this.words[d4] |= h << b2 & 67108863, this.words[d4 + 1] = h >>> 26 - b2 & 67108863, b2 += 24, b2 >= 26 && (b2 -= 26, d4++);
      return this._strip();
    };
    function p3(c5, f) {
      var a = c5.charCodeAt(f);
      if (a >= 48 && a <= 57)
        return a - 48;
      if (a >= 65 && a <= 70)
        return a - 55;
      if (a >= 97 && a <= 102)
        return a - 87;
      r(false, "Invalid character in " + c5);
    }
    function y4(c5, f, a) {
      var u = p3(c5, a);
      return a - 1 >= f && (u |= p3(c5, a - 1) << 4), u;
    }
    i.prototype._parseHex = function(f, a, u) {
      this.length = Math.ceil((f.length - a) / 6), this.words = new Array(this.length);
      for (var l = 0; l < this.length; l++)
        this.words[l] = 0;
      var d4 = 0, h = 0, b2;
      if (u === "be")
        for (l = f.length - 1; l >= a; l -= 2)
          b2 = y4(f, a, l) << d4, this.words[h] |= b2 & 67108863, d4 >= 18 ? (d4 -= 18, h += 1, this.words[h] |= b2 >>> 26) : d4 += 8;
      else {
        var m3 = f.length - a;
        for (l = m3 % 2 === 0 ? a + 1 : a; l < f.length; l += 2)
          b2 = y4(f, a, l) << d4, this.words[h] |= b2 & 67108863, d4 >= 18 ? (d4 -= 18, h += 1, this.words[h] |= b2 >>> 26) : d4 += 8;
      }
      this._strip();
    };
    function w2(c5, f, a, u) {
      for (var l = 0, d4 = 0, h = Math.min(c5.length, a), b2 = f; b2 < h; b2++) {
        var m3 = c5.charCodeAt(b2) - 48;
        l *= u, m3 >= 49 ? d4 = m3 - 49 + 10 : m3 >= 17 ? d4 = m3 - 17 + 10 : d4 = m3, r(m3 >= 0 && d4 < u, "Invalid character"), l += d4;
      }
      return l;
    }
    i.prototype._parseBase = function(f, a, u) {
      this.words = [0], this.length = 1;
      for (var l = 0, d4 = 1; d4 <= 67108863; d4 *= a)
        l++;
      l--, d4 = d4 / a | 0;
      for (var h = f.length - u, b2 = h % l, m3 = Math.min(h, h - b2) + u, s = 0, g2 = u; g2 < m3; g2 += l)
        s = w2(f, g2, g2 + l, a), this.imuln(d4), this.words[0] + s < 67108864 ? this.words[0] += s : this._iaddn(s);
      if (b2 !== 0) {
        var q = 1;
        for (s = w2(f, g2, f.length, a), g2 = 0; g2 < b2; g2++)
          q *= a;
        this.imuln(q), this.words[0] + s < 67108864 ? this.words[0] += s : this._iaddn(s);
      }
      this._strip();
    }, i.prototype.copy = function(f) {
      f.words = new Array(this.length);
      for (var a = 0; a < this.length; a++)
        f.words[a] = this.words[a];
      f.length = this.length, f.negative = this.negative, f.red = this.red;
    };
    function x(c5, f) {
      c5.words = f.words, c5.length = f.length, c5.negative = f.negative, c5.red = f.red;
    }
    if (i.prototype._move = function(f) {
      x(f, this);
    }, i.prototype.clone = function() {
      var f = new i(null);
      return this.copy(f), f;
    }, i.prototype._expand = function(f) {
      for (; this.length < f; )
        this.words[this.length++] = 0;
      return this;
    }, i.prototype._strip = function() {
      for (; this.length > 1 && this.words[this.length - 1] === 0; )
        this.length--;
      return this._normSign();
    }, i.prototype._normSign = function() {
      return this.length === 1 && this.words[0] === 0 && (this.negative = 0), this;
    }, typeof Symbol < "u" && typeof Symbol.for == "function")
      try {
        i.prototype[Symbol.for("nodejs.util.inspect.custom")] = M4;
      } catch {
        i.prototype.inspect = M4;
      }
    else
      i.prototype.inspect = M4;
    function M4() {
      return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
    }
    var E2 = ["", "0", "00", "000", "0000", "00000", "000000", "0000000", "00000000", "000000000", "0000000000", "00000000000", "000000000000", "0000000000000", "00000000000000", "000000000000000", "0000000000000000", "00000000000000000", "000000000000000000", "0000000000000000000", "00000000000000000000", "000000000000000000000", "0000000000000000000000", "00000000000000000000000", "000000000000000000000000", "0000000000000000000000000"], A4 = [0, 0, 25, 16, 12, 11, 10, 9, 8, 8, 7, 7, 7, 7, 6, 6, 6, 6, 6, 6, 6, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5], I3 = [0, 0, 33554432, 43046721, 16777216, 48828125, 60466176, 40353607, 16777216, 43046721, 1e7, 19487171, 35831808, 62748517, 7529536, 11390625, 16777216, 24137569, 34012224, 47045881, 64e6, 4084101, 5153632, 6436343, 7962624, 9765625, 11881376, 14348907, 17210368, 20511149, 243e5, 28629151, 33554432, 39135393, 45435424, 52521875, 60466176];
    i.prototype.toString = function(f, a) {
      f = f || 10, a = a | 0 || 1;
      var u;
      if (f === 16 || f === "hex") {
        u = "";
        for (var l = 0, d4 = 0, h = 0; h < this.length; h++) {
          var b2 = this.words[h], m3 = ((b2 << l | d4) & 16777215).toString(16);
          d4 = b2 >>> 24 - l & 16777215, l += 2, l >= 26 && (l -= 26, h--), d4 !== 0 || h !== this.length - 1 ? u = E2[6 - m3.length] + m3 + u : u = m3 + u;
        }
        for (d4 !== 0 && (u = d4.toString(16) + u); u.length % a !== 0; )
          u = "0" + u;
        return this.negative !== 0 && (u = "-" + u), u;
      }
      if (f === (f | 0) && f >= 2 && f <= 36) {
        var s = A4[f], g2 = I3[f];
        u = "";
        var q = this.clone();
        for (q.negative = 0; !q.isZero(); ) {
          var R3 = q.modrn(g2).toString(f);
          q = q.idivn(g2), q.isZero() ? u = R3 + u : u = E2[s - R3.length] + R3 + u;
        }
        for (this.isZero() && (u = "0" + u); u.length % a !== 0; )
          u = "0" + u;
        return this.negative !== 0 && (u = "-" + u), u;
      }
      r(false, "Base should be between 2 and 36");
    }, i.prototype.toNumber = function() {
      var f = this.words[0];
      return this.length === 2 ? f += this.words[1] * 67108864 : this.length === 3 && this.words[2] === 1 ? f += 4503599627370496 + this.words[1] * 67108864 : this.length > 2 && r(false, "Number can only safely store up to 53 bits"), this.negative !== 0 ? -f : f;
    }, i.prototype.toJSON = function() {
      return this.toString(16, 2);
    }, o2 && (i.prototype.toBuffer = function(f, a) {
      return this.toArrayLike(o2, f, a);
    }), i.prototype.toArray = function(f, a) {
      return this.toArrayLike(Array, f, a);
    };
    var D6 = function(f, a) {
      return f.allocUnsafe ? f.allocUnsafe(a) : new f(a);
    };
    i.prototype.toArrayLike = function(f, a, u) {
      this._strip();
      var l = this.byteLength(), d4 = u || Math.max(1, l);
      r(l <= d4, "byte array longer than desired length"), r(d4 > 0, "Requested array length <= 0");
      var h = D6(f, d4), b2 = a === "le" ? "LE" : "BE";
      return this["_toArrayLike" + b2](h, l), h;
    }, i.prototype._toArrayLikeLE = function(f, a) {
      for (var u = 0, l = 0, d4 = 0, h = 0; d4 < this.length; d4++) {
        var b2 = this.words[d4] << h | l;
        f[u++] = b2 & 255, u < f.length && (f[u++] = b2 >> 8 & 255), u < f.length && (f[u++] = b2 >> 16 & 255), h === 6 ? (u < f.length && (f[u++] = b2 >> 24 & 255), l = 0, h = 0) : (l = b2 >>> 24, h += 2);
      }
      if (u < f.length)
        for (f[u++] = l; u < f.length; )
          f[u++] = 0;
    }, i.prototype._toArrayLikeBE = function(f, a) {
      for (var u = f.length - 1, l = 0, d4 = 0, h = 0; d4 < this.length; d4++) {
        var b2 = this.words[d4] << h | l;
        f[u--] = b2 & 255, u >= 0 && (f[u--] = b2 >> 8 & 255), u >= 0 && (f[u--] = b2 >> 16 & 255), h === 6 ? (u >= 0 && (f[u--] = b2 >> 24 & 255), l = 0, h = 0) : (l = b2 >>> 24, h += 2);
      }
      if (u >= 0)
        for (f[u--] = l; u >= 0; )
          f[u--] = 0;
    }, Math.clz32 ? i.prototype._countBits = function(f) {
      return 32 - Math.clz32(f);
    } : i.prototype._countBits = function(f) {
      var a = f, u = 0;
      return a >= 4096 && (u += 13, a >>>= 13), a >= 64 && (u += 7, a >>>= 7), a >= 8 && (u += 4, a >>>= 4), a >= 2 && (u += 2, a >>>= 2), u + a;
    }, i.prototype._zeroBits = function(f) {
      if (f === 0)
        return 26;
      var a = f, u = 0;
      return (a & 8191) === 0 && (u += 13, a >>>= 13), (a & 127) === 0 && (u += 7, a >>>= 7), (a & 15) === 0 && (u += 4, a >>>= 4), (a & 3) === 0 && (u += 2, a >>>= 2), (a & 1) === 0 && u++, u;
    }, i.prototype.bitLength = function() {
      var f = this.words[this.length - 1], a = this._countBits(f);
      return (this.length - 1) * 26 + a;
    };
    function C(c5) {
      for (var f = new Array(c5.bitLength()), a = 0; a < f.length; a++) {
        var u = a / 26 | 0, l = a % 26;
        f[a] = c5.words[u] >>> l & 1;
      }
      return f;
    }
    i.prototype.zeroBits = function() {
      if (this.isZero())
        return 0;
      for (var f = 0, a = 0; a < this.length; a++) {
        var u = this._zeroBits(this.words[a]);
        if (f += u, u !== 26)
          break;
      }
      return f;
    }, i.prototype.byteLength = function() {
      return Math.ceil(this.bitLength() / 8);
    }, i.prototype.toTwos = function(f) {
      return this.negative !== 0 ? this.abs().inotn(f).iaddn(1) : this.clone();
    }, i.prototype.fromTwos = function(f) {
      return this.testn(f - 1) ? this.notn(f).iaddn(1).ineg() : this.clone();
    }, i.prototype.isNeg = function() {
      return this.negative !== 0;
    }, i.prototype.neg = function() {
      return this.clone().ineg();
    }, i.prototype.ineg = function() {
      return this.isZero() || (this.negative ^= 1), this;
    }, i.prototype.iuor = function(f) {
      for (; this.length < f.length; )
        this.words[this.length++] = 0;
      for (var a = 0; a < f.length; a++)
        this.words[a] = this.words[a] | f.words[a];
      return this._strip();
    }, i.prototype.ior = function(f) {
      return r((this.negative | f.negative) === 0), this.iuor(f);
    }, i.prototype.or = function(f) {
      return this.length > f.length ? this.clone().ior(f) : f.clone().ior(this);
    }, i.prototype.uor = function(f) {
      return this.length > f.length ? this.clone().iuor(f) : f.clone().iuor(this);
    }, i.prototype.iuand = function(f) {
      var a;
      this.length > f.length ? a = f : a = this;
      for (var u = 0; u < a.length; u++)
        this.words[u] = this.words[u] & f.words[u];
      return this.length = a.length, this._strip();
    }, i.prototype.iand = function(f) {
      return r((this.negative | f.negative) === 0), this.iuand(f);
    }, i.prototype.and = function(f) {
      return this.length > f.length ? this.clone().iand(f) : f.clone().iand(this);
    }, i.prototype.uand = function(f) {
      return this.length > f.length ? this.clone().iuand(f) : f.clone().iuand(this);
    }, i.prototype.iuxor = function(f) {
      var a, u;
      this.length > f.length ? (a = this, u = f) : (a = f, u = this);
      for (var l = 0; l < u.length; l++)
        this.words[l] = a.words[l] ^ u.words[l];
      if (this !== a)
        for (; l < a.length; l++)
          this.words[l] = a.words[l];
      return this.length = a.length, this._strip();
    }, i.prototype.ixor = function(f) {
      return r((this.negative | f.negative) === 0), this.iuxor(f);
    }, i.prototype.xor = function(f) {
      return this.length > f.length ? this.clone().ixor(f) : f.clone().ixor(this);
    }, i.prototype.uxor = function(f) {
      return this.length > f.length ? this.clone().iuxor(f) : f.clone().iuxor(this);
    }, i.prototype.inotn = function(f) {
      r(typeof f == "number" && f >= 0);
      var a = Math.ceil(f / 26) | 0, u = f % 26;
      this._expand(a), u > 0 && a--;
      for (var l = 0; l < a; l++)
        this.words[l] = ~this.words[l] & 67108863;
      return u > 0 && (this.words[l] = ~this.words[l] & 67108863 >> 26 - u), this._strip();
    }, i.prototype.notn = function(f) {
      return this.clone().inotn(f);
    }, i.prototype.setn = function(f, a) {
      r(typeof f == "number" && f >= 0);
      var u = f / 26 | 0, l = f % 26;
      return this._expand(u + 1), a ? this.words[u] = this.words[u] | 1 << l : this.words[u] = this.words[u] & ~(1 << l), this._strip();
    }, i.prototype.iadd = function(f) {
      var a;
      if (this.negative !== 0 && f.negative === 0)
        return this.negative = 0, a = this.isub(f), this.negative ^= 1, this._normSign();
      if (this.negative === 0 && f.negative !== 0)
        return f.negative = 0, a = this.isub(f), f.negative = 1, a._normSign();
      var u, l;
      this.length > f.length ? (u = this, l = f) : (u = f, l = this);
      for (var d4 = 0, h = 0; h < l.length; h++)
        a = (u.words[h] | 0) + (l.words[h] | 0) + d4, this.words[h] = a & 67108863, d4 = a >>> 26;
      for (; d4 !== 0 && h < u.length; h++)
        a = (u.words[h] | 0) + d4, this.words[h] = a & 67108863, d4 = a >>> 26;
      if (this.length = u.length, d4 !== 0)
        this.words[this.length] = d4, this.length++;
      else if (u !== this)
        for (; h < u.length; h++)
          this.words[h] = u.words[h];
      return this;
    }, i.prototype.add = function(f) {
      var a;
      return f.negative !== 0 && this.negative === 0 ? (f.negative = 0, a = this.sub(f), f.negative ^= 1, a) : f.negative === 0 && this.negative !== 0 ? (this.negative = 0, a = f.sub(this), this.negative = 1, a) : this.length > f.length ? this.clone().iadd(f) : f.clone().iadd(this);
    }, i.prototype.isub = function(f) {
      if (f.negative !== 0) {
        f.negative = 0;
        var a = this.iadd(f);
        return f.negative = 1, a._normSign();
      } else if (this.negative !== 0)
        return this.negative = 0, this.iadd(f), this.negative = 1, this._normSign();
      var u = this.cmp(f);
      if (u === 0)
        return this.negative = 0, this.length = 1, this.words[0] = 0, this;
      var l, d4;
      u > 0 ? (l = this, d4 = f) : (l = f, d4 = this);
      for (var h = 0, b2 = 0; b2 < d4.length; b2++)
        a = (l.words[b2] | 0) - (d4.words[b2] | 0) + h, h = a >> 26, this.words[b2] = a & 67108863;
      for (; h !== 0 && b2 < l.length; b2++)
        a = (l.words[b2] | 0) + h, h = a >> 26, this.words[b2] = a & 67108863;
      if (h === 0 && b2 < l.length && l !== this)
        for (; b2 < l.length; b2++)
          this.words[b2] = l.words[b2];
      return this.length = Math.max(this.length, b2), l !== this && (this.negative = 1), this._strip();
    }, i.prototype.sub = function(f) {
      return this.clone().isub(f);
    };
    function ge2(c5, f, a) {
      a.negative = f.negative ^ c5.negative;
      var u = c5.length + f.length | 0;
      a.length = u, u = u - 1 | 0;
      var l = c5.words[0] | 0, d4 = f.words[0] | 0, h = l * d4, b2 = h & 67108863, m3 = h / 67108864 | 0;
      a.words[0] = b2;
      for (var s = 1; s < u; s++) {
        for (var g2 = m3 >>> 26, q = m3 & 67108863, R3 = Math.min(s, f.length - 1), B3 = Math.max(0, s - c5.length + 1); B3 <= R3; B3++) {
          var P2 = s - B3 | 0;
          l = c5.words[P2] | 0, d4 = f.words[B3] | 0, h = l * d4 + q, g2 += h / 67108864 | 0, q = h & 67108863;
        }
        a.words[s] = q | 0, m3 = g2 | 0;
      }
      return m3 !== 0 ? a.words[s] = m3 | 0 : a.length--, a._strip();
    }
    var L4 = function(f, a, u) {
      var l = f.words, d4 = a.words, h = u.words, b2 = 0, m3, s, g2, q = l[0] | 0, R3 = q & 8191, B3 = q >>> 13, P2 = l[1] | 0, T4 = P2 & 8191, N4 = P2 >>> 13, ze = l[2] | 0, O = ze & 8191, z = ze >>> 13, Er3 = l[3] | 0, U2 = Er3 & 8191, H3 = Er3 >>> 13, Ar = l[4] | 0, F4 = Ar & 8191, K4 = Ar >>> 13, qr2 = l[5] | 0, j2 = qr2 & 8191, W4 = qr2 >>> 13, Br2 = l[6] | 0, V3 = Br2 & 8191, Z5 = Br2 >>> 13, Rr2 = l[7] | 0, G4 = Rr2 & 8191, X5 = Rr2 >>> 13, Ir2 = l[8] | 0, Y4 = Ir2 & 8191, J3 = Ir2 >>> 13, kr2 = l[9] | 0, $4 = kr2 & 8191, Q3 = kr2 >>> 13, Dr = d4[0] | 0, ee2 = Dr & 8191, te = Dr >>> 13, Pr2 = d4[1] | 0, re2 = Pr2 & 8191, ie = Pr2 >>> 13, Tr2 = d4[2] | 0, fe = Tr2 & 8191, ne = Tr2 >>> 13, Cr2 = d4[3] | 0, ae2 = Cr2 & 8191, se = Cr2 >>> 13, Nr2 = d4[4] | 0, oe = Nr2 & 8191, he2 = Nr2 >>> 13, Lr4 = d4[5] | 0, ue2 = Lr4 & 8191, de4 = Lr4 >>> 13, Or2 = d4[6] | 0, ce2 = Or2 & 8191, le2 = Or2 >>> 13, zr = d4[7] | 0, ve2 = zr & 8191, pe = zr >>> 13, Ur3 = d4[8] | 0, be = Ur3 & 8191, me = Ur3 >>> 13, dr2 = d4[9] | 0, _e2 = dr2 & 8191, we2 = dr2 >>> 13;
      u.negative = f.negative ^ a.negative, u.length = 19, m3 = Math.imul(R3, ee2), s = Math.imul(R3, te), s = s + Math.imul(B3, ee2) | 0, g2 = Math.imul(B3, te);
      var At2 = (b2 + m3 | 0) + ((s & 8191) << 13) | 0;
      b2 = (g2 + (s >>> 13) | 0) + (At2 >>> 26) | 0, At2 &= 67108863, m3 = Math.imul(T4, ee2), s = Math.imul(T4, te), s = s + Math.imul(N4, ee2) | 0, g2 = Math.imul(N4, te), m3 = m3 + Math.imul(R3, re2) | 0, s = s + Math.imul(R3, ie) | 0, s = s + Math.imul(B3, re2) | 0, g2 = g2 + Math.imul(B3, ie) | 0;
      var qt2 = (b2 + m3 | 0) + ((s & 8191) << 13) | 0;
      b2 = (g2 + (s >>> 13) | 0) + (qt2 >>> 26) | 0, qt2 &= 67108863, m3 = Math.imul(O, ee2), s = Math.imul(O, te), s = s + Math.imul(z, ee2) | 0, g2 = Math.imul(z, te), m3 = m3 + Math.imul(T4, re2) | 0, s = s + Math.imul(T4, ie) | 0, s = s + Math.imul(N4, re2) | 0, g2 = g2 + Math.imul(N4, ie) | 0, m3 = m3 + Math.imul(R3, fe) | 0, s = s + Math.imul(R3, ne) | 0, s = s + Math.imul(B3, fe) | 0, g2 = g2 + Math.imul(B3, ne) | 0;
      var Bt = (b2 + m3 | 0) + ((s & 8191) << 13) | 0;
      b2 = (g2 + (s >>> 13) | 0) + (Bt >>> 26) | 0, Bt &= 67108863, m3 = Math.imul(U2, ee2), s = Math.imul(U2, te), s = s + Math.imul(H3, ee2) | 0, g2 = Math.imul(H3, te), m3 = m3 + Math.imul(O, re2) | 0, s = s + Math.imul(O, ie) | 0, s = s + Math.imul(z, re2) | 0, g2 = g2 + Math.imul(z, ie) | 0, m3 = m3 + Math.imul(T4, fe) | 0, s = s + Math.imul(T4, ne) | 0, s = s + Math.imul(N4, fe) | 0, g2 = g2 + Math.imul(N4, ne) | 0, m3 = m3 + Math.imul(R3, ae2) | 0, s = s + Math.imul(R3, se) | 0, s = s + Math.imul(B3, ae2) | 0, g2 = g2 + Math.imul(B3, se) | 0;
      var Rt2 = (b2 + m3 | 0) + ((s & 8191) << 13) | 0;
      b2 = (g2 + (s >>> 13) | 0) + (Rt2 >>> 26) | 0, Rt2 &= 67108863, m3 = Math.imul(F4, ee2), s = Math.imul(F4, te), s = s + Math.imul(K4, ee2) | 0, g2 = Math.imul(K4, te), m3 = m3 + Math.imul(U2, re2) | 0, s = s + Math.imul(U2, ie) | 0, s = s + Math.imul(H3, re2) | 0, g2 = g2 + Math.imul(H3, ie) | 0, m3 = m3 + Math.imul(O, fe) | 0, s = s + Math.imul(O, ne) | 0, s = s + Math.imul(z, fe) | 0, g2 = g2 + Math.imul(z, ne) | 0, m3 = m3 + Math.imul(T4, ae2) | 0, s = s + Math.imul(T4, se) | 0, s = s + Math.imul(N4, ae2) | 0, g2 = g2 + Math.imul(N4, se) | 0, m3 = m3 + Math.imul(R3, oe) | 0, s = s + Math.imul(R3, he2) | 0, s = s + Math.imul(B3, oe) | 0, g2 = g2 + Math.imul(B3, he2) | 0;
      var It2 = (b2 + m3 | 0) + ((s & 8191) << 13) | 0;
      b2 = (g2 + (s >>> 13) | 0) + (It2 >>> 26) | 0, It2 &= 67108863, m3 = Math.imul(j2, ee2), s = Math.imul(j2, te), s = s + Math.imul(W4, ee2) | 0, g2 = Math.imul(W4, te), m3 = m3 + Math.imul(F4, re2) | 0, s = s + Math.imul(F4, ie) | 0, s = s + Math.imul(K4, re2) | 0, g2 = g2 + Math.imul(K4, ie) | 0, m3 = m3 + Math.imul(U2, fe) | 0, s = s + Math.imul(U2, ne) | 0, s = s + Math.imul(H3, fe) | 0, g2 = g2 + Math.imul(H3, ne) | 0, m3 = m3 + Math.imul(O, ae2) | 0, s = s + Math.imul(O, se) | 0, s = s + Math.imul(z, ae2) | 0, g2 = g2 + Math.imul(z, se) | 0, m3 = m3 + Math.imul(T4, oe) | 0, s = s + Math.imul(T4, he2) | 0, s = s + Math.imul(N4, oe) | 0, g2 = g2 + Math.imul(N4, he2) | 0, m3 = m3 + Math.imul(R3, ue2) | 0, s = s + Math.imul(R3, de4) | 0, s = s + Math.imul(B3, ue2) | 0, g2 = g2 + Math.imul(B3, de4) | 0;
      var kt2 = (b2 + m3 | 0) + ((s & 8191) << 13) | 0;
      b2 = (g2 + (s >>> 13) | 0) + (kt2 >>> 26) | 0, kt2 &= 67108863, m3 = Math.imul(V3, ee2), s = Math.imul(V3, te), s = s + Math.imul(Z5, ee2) | 0, g2 = Math.imul(Z5, te), m3 = m3 + Math.imul(j2, re2) | 0, s = s + Math.imul(j2, ie) | 0, s = s + Math.imul(W4, re2) | 0, g2 = g2 + Math.imul(W4, ie) | 0, m3 = m3 + Math.imul(F4, fe) | 0, s = s + Math.imul(F4, ne) | 0, s = s + Math.imul(K4, fe) | 0, g2 = g2 + Math.imul(K4, ne) | 0, m3 = m3 + Math.imul(U2, ae2) | 0, s = s + Math.imul(U2, se) | 0, s = s + Math.imul(H3, ae2) | 0, g2 = g2 + Math.imul(H3, se) | 0, m3 = m3 + Math.imul(O, oe) | 0, s = s + Math.imul(O, he2) | 0, s = s + Math.imul(z, oe) | 0, g2 = g2 + Math.imul(z, he2) | 0, m3 = m3 + Math.imul(T4, ue2) | 0, s = s + Math.imul(T4, de4) | 0, s = s + Math.imul(N4, ue2) | 0, g2 = g2 + Math.imul(N4, de4) | 0, m3 = m3 + Math.imul(R3, ce2) | 0, s = s + Math.imul(R3, le2) | 0, s = s + Math.imul(B3, ce2) | 0, g2 = g2 + Math.imul(B3, le2) | 0;
      var Dt = (b2 + m3 | 0) + ((s & 8191) << 13) | 0;
      b2 = (g2 + (s >>> 13) | 0) + (Dt >>> 26) | 0, Dt &= 67108863, m3 = Math.imul(G4, ee2), s = Math.imul(G4, te), s = s + Math.imul(X5, ee2) | 0, g2 = Math.imul(X5, te), m3 = m3 + Math.imul(V3, re2) | 0, s = s + Math.imul(V3, ie) | 0, s = s + Math.imul(Z5, re2) | 0, g2 = g2 + Math.imul(Z5, ie) | 0, m3 = m3 + Math.imul(j2, fe) | 0, s = s + Math.imul(j2, ne) | 0, s = s + Math.imul(W4, fe) | 0, g2 = g2 + Math.imul(W4, ne) | 0, m3 = m3 + Math.imul(F4, ae2) | 0, s = s + Math.imul(F4, se) | 0, s = s + Math.imul(K4, ae2) | 0, g2 = g2 + Math.imul(K4, se) | 0, m3 = m3 + Math.imul(U2, oe) | 0, s = s + Math.imul(U2, he2) | 0, s = s + Math.imul(H3, oe) | 0, g2 = g2 + Math.imul(H3, he2) | 0, m3 = m3 + Math.imul(O, ue2) | 0, s = s + Math.imul(O, de4) | 0, s = s + Math.imul(z, ue2) | 0, g2 = g2 + Math.imul(z, de4) | 0, m3 = m3 + Math.imul(T4, ce2) | 0, s = s + Math.imul(T4, le2) | 0, s = s + Math.imul(N4, ce2) | 0, g2 = g2 + Math.imul(N4, le2) | 0, m3 = m3 + Math.imul(R3, ve2) | 0, s = s + Math.imul(R3, pe) | 0, s = s + Math.imul(B3, ve2) | 0, g2 = g2 + Math.imul(B3, pe) | 0;
      var Pt2 = (b2 + m3 | 0) + ((s & 8191) << 13) | 0;
      b2 = (g2 + (s >>> 13) | 0) + (Pt2 >>> 26) | 0, Pt2 &= 67108863, m3 = Math.imul(Y4, ee2), s = Math.imul(Y4, te), s = s + Math.imul(J3, ee2) | 0, g2 = Math.imul(J3, te), m3 = m3 + Math.imul(G4, re2) | 0, s = s + Math.imul(G4, ie) | 0, s = s + Math.imul(X5, re2) | 0, g2 = g2 + Math.imul(X5, ie) | 0, m3 = m3 + Math.imul(V3, fe) | 0, s = s + Math.imul(V3, ne) | 0, s = s + Math.imul(Z5, fe) | 0, g2 = g2 + Math.imul(Z5, ne) | 0, m3 = m3 + Math.imul(j2, ae2) | 0, s = s + Math.imul(j2, se) | 0, s = s + Math.imul(W4, ae2) | 0, g2 = g2 + Math.imul(W4, se) | 0, m3 = m3 + Math.imul(F4, oe) | 0, s = s + Math.imul(F4, he2) | 0, s = s + Math.imul(K4, oe) | 0, g2 = g2 + Math.imul(K4, he2) | 0, m3 = m3 + Math.imul(U2, ue2) | 0, s = s + Math.imul(U2, de4) | 0, s = s + Math.imul(H3, ue2) | 0, g2 = g2 + Math.imul(H3, de4) | 0, m3 = m3 + Math.imul(O, ce2) | 0, s = s + Math.imul(O, le2) | 0, s = s + Math.imul(z, ce2) | 0, g2 = g2 + Math.imul(z, le2) | 0, m3 = m3 + Math.imul(T4, ve2) | 0, s = s + Math.imul(T4, pe) | 0, s = s + Math.imul(N4, ve2) | 0, g2 = g2 + Math.imul(N4, pe) | 0, m3 = m3 + Math.imul(R3, be) | 0, s = s + Math.imul(R3, me) | 0, s = s + Math.imul(B3, be) | 0, g2 = g2 + Math.imul(B3, me) | 0;
      var Tt2 = (b2 + m3 | 0) + ((s & 8191) << 13) | 0;
      b2 = (g2 + (s >>> 13) | 0) + (Tt2 >>> 26) | 0, Tt2 &= 67108863, m3 = Math.imul($4, ee2), s = Math.imul($4, te), s = s + Math.imul(Q3, ee2) | 0, g2 = Math.imul(Q3, te), m3 = m3 + Math.imul(Y4, re2) | 0, s = s + Math.imul(Y4, ie) | 0, s = s + Math.imul(J3, re2) | 0, g2 = g2 + Math.imul(J3, ie) | 0, m3 = m3 + Math.imul(G4, fe) | 0, s = s + Math.imul(G4, ne) | 0, s = s + Math.imul(X5, fe) | 0, g2 = g2 + Math.imul(X5, ne) | 0, m3 = m3 + Math.imul(V3, ae2) | 0, s = s + Math.imul(V3, se) | 0, s = s + Math.imul(Z5, ae2) | 0, g2 = g2 + Math.imul(Z5, se) | 0, m3 = m3 + Math.imul(j2, oe) | 0, s = s + Math.imul(j2, he2) | 0, s = s + Math.imul(W4, oe) | 0, g2 = g2 + Math.imul(W4, he2) | 0, m3 = m3 + Math.imul(F4, ue2) | 0, s = s + Math.imul(F4, de4) | 0, s = s + Math.imul(K4, ue2) | 0, g2 = g2 + Math.imul(K4, de4) | 0, m3 = m3 + Math.imul(U2, ce2) | 0, s = s + Math.imul(U2, le2) | 0, s = s + Math.imul(H3, ce2) | 0, g2 = g2 + Math.imul(H3, le2) | 0, m3 = m3 + Math.imul(O, ve2) | 0, s = s + Math.imul(O, pe) | 0, s = s + Math.imul(z, ve2) | 0, g2 = g2 + Math.imul(z, pe) | 0, m3 = m3 + Math.imul(T4, be) | 0, s = s + Math.imul(T4, me) | 0, s = s + Math.imul(N4, be) | 0, g2 = g2 + Math.imul(N4, me) | 0, m3 = m3 + Math.imul(R3, _e2) | 0, s = s + Math.imul(R3, we2) | 0, s = s + Math.imul(B3, _e2) | 0, g2 = g2 + Math.imul(B3, we2) | 0;
      var Ct2 = (b2 + m3 | 0) + ((s & 8191) << 13) | 0;
      b2 = (g2 + (s >>> 13) | 0) + (Ct2 >>> 26) | 0, Ct2 &= 67108863, m3 = Math.imul($4, re2), s = Math.imul($4, ie), s = s + Math.imul(Q3, re2) | 0, g2 = Math.imul(Q3, ie), m3 = m3 + Math.imul(Y4, fe) | 0, s = s + Math.imul(Y4, ne) | 0, s = s + Math.imul(J3, fe) | 0, g2 = g2 + Math.imul(J3, ne) | 0, m3 = m3 + Math.imul(G4, ae2) | 0, s = s + Math.imul(G4, se) | 0, s = s + Math.imul(X5, ae2) | 0, g2 = g2 + Math.imul(X5, se) | 0, m3 = m3 + Math.imul(V3, oe) | 0, s = s + Math.imul(V3, he2) | 0, s = s + Math.imul(Z5, oe) | 0, g2 = g2 + Math.imul(Z5, he2) | 0, m3 = m3 + Math.imul(j2, ue2) | 0, s = s + Math.imul(j2, de4) | 0, s = s + Math.imul(W4, ue2) | 0, g2 = g2 + Math.imul(W4, de4) | 0, m3 = m3 + Math.imul(F4, ce2) | 0, s = s + Math.imul(F4, le2) | 0, s = s + Math.imul(K4, ce2) | 0, g2 = g2 + Math.imul(K4, le2) | 0, m3 = m3 + Math.imul(U2, ve2) | 0, s = s + Math.imul(U2, pe) | 0, s = s + Math.imul(H3, ve2) | 0, g2 = g2 + Math.imul(H3, pe) | 0, m3 = m3 + Math.imul(O, be) | 0, s = s + Math.imul(O, me) | 0, s = s + Math.imul(z, be) | 0, g2 = g2 + Math.imul(z, me) | 0, m3 = m3 + Math.imul(T4, _e2) | 0, s = s + Math.imul(T4, we2) | 0, s = s + Math.imul(N4, _e2) | 0, g2 = g2 + Math.imul(N4, we2) | 0;
      var Nt2 = (b2 + m3 | 0) + ((s & 8191) << 13) | 0;
      b2 = (g2 + (s >>> 13) | 0) + (Nt2 >>> 26) | 0, Nt2 &= 67108863, m3 = Math.imul($4, fe), s = Math.imul($4, ne), s = s + Math.imul(Q3, fe) | 0, g2 = Math.imul(Q3, ne), m3 = m3 + Math.imul(Y4, ae2) | 0, s = s + Math.imul(Y4, se) | 0, s = s + Math.imul(J3, ae2) | 0, g2 = g2 + Math.imul(J3, se) | 0, m3 = m3 + Math.imul(G4, oe) | 0, s = s + Math.imul(G4, he2) | 0, s = s + Math.imul(X5, oe) | 0, g2 = g2 + Math.imul(X5, he2) | 0, m3 = m3 + Math.imul(V3, ue2) | 0, s = s + Math.imul(V3, de4) | 0, s = s + Math.imul(Z5, ue2) | 0, g2 = g2 + Math.imul(Z5, de4) | 0, m3 = m3 + Math.imul(j2, ce2) | 0, s = s + Math.imul(j2, le2) | 0, s = s + Math.imul(W4, ce2) | 0, g2 = g2 + Math.imul(W4, le2) | 0, m3 = m3 + Math.imul(F4, ve2) | 0, s = s + Math.imul(F4, pe) | 0, s = s + Math.imul(K4, ve2) | 0, g2 = g2 + Math.imul(K4, pe) | 0, m3 = m3 + Math.imul(U2, be) | 0, s = s + Math.imul(U2, me) | 0, s = s + Math.imul(H3, be) | 0, g2 = g2 + Math.imul(H3, me) | 0, m3 = m3 + Math.imul(O, _e2) | 0, s = s + Math.imul(O, we2) | 0, s = s + Math.imul(z, _e2) | 0, g2 = g2 + Math.imul(z, we2) | 0;
      var Lt2 = (b2 + m3 | 0) + ((s & 8191) << 13) | 0;
      b2 = (g2 + (s >>> 13) | 0) + (Lt2 >>> 26) | 0, Lt2 &= 67108863, m3 = Math.imul($4, ae2), s = Math.imul($4, se), s = s + Math.imul(Q3, ae2) | 0, g2 = Math.imul(Q3, se), m3 = m3 + Math.imul(Y4, oe) | 0, s = s + Math.imul(Y4, he2) | 0, s = s + Math.imul(J3, oe) | 0, g2 = g2 + Math.imul(J3, he2) | 0, m3 = m3 + Math.imul(G4, ue2) | 0, s = s + Math.imul(G4, de4) | 0, s = s + Math.imul(X5, ue2) | 0, g2 = g2 + Math.imul(X5, de4) | 0, m3 = m3 + Math.imul(V3, ce2) | 0, s = s + Math.imul(V3, le2) | 0, s = s + Math.imul(Z5, ce2) | 0, g2 = g2 + Math.imul(Z5, le2) | 0, m3 = m3 + Math.imul(j2, ve2) | 0, s = s + Math.imul(j2, pe) | 0, s = s + Math.imul(W4, ve2) | 0, g2 = g2 + Math.imul(W4, pe) | 0, m3 = m3 + Math.imul(F4, be) | 0, s = s + Math.imul(F4, me) | 0, s = s + Math.imul(K4, be) | 0, g2 = g2 + Math.imul(K4, me) | 0, m3 = m3 + Math.imul(U2, _e2) | 0, s = s + Math.imul(U2, we2) | 0, s = s + Math.imul(H3, _e2) | 0, g2 = g2 + Math.imul(H3, we2) | 0;
      var Ot = (b2 + m3 | 0) + ((s & 8191) << 13) | 0;
      b2 = (g2 + (s >>> 13) | 0) + (Ot >>> 26) | 0, Ot &= 67108863, m3 = Math.imul($4, oe), s = Math.imul($4, he2), s = s + Math.imul(Q3, oe) | 0, g2 = Math.imul(Q3, he2), m3 = m3 + Math.imul(Y4, ue2) | 0, s = s + Math.imul(Y4, de4) | 0, s = s + Math.imul(J3, ue2) | 0, g2 = g2 + Math.imul(J3, de4) | 0, m3 = m3 + Math.imul(G4, ce2) | 0, s = s + Math.imul(G4, le2) | 0, s = s + Math.imul(X5, ce2) | 0, g2 = g2 + Math.imul(X5, le2) | 0, m3 = m3 + Math.imul(V3, ve2) | 0, s = s + Math.imul(V3, pe) | 0, s = s + Math.imul(Z5, ve2) | 0, g2 = g2 + Math.imul(Z5, pe) | 0, m3 = m3 + Math.imul(j2, be) | 0, s = s + Math.imul(j2, me) | 0, s = s + Math.imul(W4, be) | 0, g2 = g2 + Math.imul(W4, me) | 0, m3 = m3 + Math.imul(F4, _e2) | 0, s = s + Math.imul(F4, we2) | 0, s = s + Math.imul(K4, _e2) | 0, g2 = g2 + Math.imul(K4, we2) | 0;
      var zt2 = (b2 + m3 | 0) + ((s & 8191) << 13) | 0;
      b2 = (g2 + (s >>> 13) | 0) + (zt2 >>> 26) | 0, zt2 &= 67108863, m3 = Math.imul($4, ue2), s = Math.imul($4, de4), s = s + Math.imul(Q3, ue2) | 0, g2 = Math.imul(Q3, de4), m3 = m3 + Math.imul(Y4, ce2) | 0, s = s + Math.imul(Y4, le2) | 0, s = s + Math.imul(J3, ce2) | 0, g2 = g2 + Math.imul(J3, le2) | 0, m3 = m3 + Math.imul(G4, ve2) | 0, s = s + Math.imul(G4, pe) | 0, s = s + Math.imul(X5, ve2) | 0, g2 = g2 + Math.imul(X5, pe) | 0, m3 = m3 + Math.imul(V3, be) | 0, s = s + Math.imul(V3, me) | 0, s = s + Math.imul(Z5, be) | 0, g2 = g2 + Math.imul(Z5, me) | 0, m3 = m3 + Math.imul(j2, _e2) | 0, s = s + Math.imul(j2, we2) | 0, s = s + Math.imul(W4, _e2) | 0, g2 = g2 + Math.imul(W4, we2) | 0;
      var Ut = (b2 + m3 | 0) + ((s & 8191) << 13) | 0;
      b2 = (g2 + (s >>> 13) | 0) + (Ut >>> 26) | 0, Ut &= 67108863, m3 = Math.imul($4, ce2), s = Math.imul($4, le2), s = s + Math.imul(Q3, ce2) | 0, g2 = Math.imul(Q3, le2), m3 = m3 + Math.imul(Y4, ve2) | 0, s = s + Math.imul(Y4, pe) | 0, s = s + Math.imul(J3, ve2) | 0, g2 = g2 + Math.imul(J3, pe) | 0, m3 = m3 + Math.imul(G4, be) | 0, s = s + Math.imul(G4, me) | 0, s = s + Math.imul(X5, be) | 0, g2 = g2 + Math.imul(X5, me) | 0, m3 = m3 + Math.imul(V3, _e2) | 0, s = s + Math.imul(V3, we2) | 0, s = s + Math.imul(Z5, _e2) | 0, g2 = g2 + Math.imul(Z5, we2) | 0;
      var Ht = (b2 + m3 | 0) + ((s & 8191) << 13) | 0;
      b2 = (g2 + (s >>> 13) | 0) + (Ht >>> 26) | 0, Ht &= 67108863, m3 = Math.imul($4, ve2), s = Math.imul($4, pe), s = s + Math.imul(Q3, ve2) | 0, g2 = Math.imul(Q3, pe), m3 = m3 + Math.imul(Y4, be) | 0, s = s + Math.imul(Y4, me) | 0, s = s + Math.imul(J3, be) | 0, g2 = g2 + Math.imul(J3, me) | 0, m3 = m3 + Math.imul(G4, _e2) | 0, s = s + Math.imul(G4, we2) | 0, s = s + Math.imul(X5, _e2) | 0, g2 = g2 + Math.imul(X5, we2) | 0;
      var ei = (b2 + m3 | 0) + ((s & 8191) << 13) | 0;
      b2 = (g2 + (s >>> 13) | 0) + (ei >>> 26) | 0, ei &= 67108863, m3 = Math.imul($4, be), s = Math.imul($4, me), s = s + Math.imul(Q3, be) | 0, g2 = Math.imul(Q3, me), m3 = m3 + Math.imul(Y4, _e2) | 0, s = s + Math.imul(Y4, we2) | 0, s = s + Math.imul(J3, _e2) | 0, g2 = g2 + Math.imul(J3, we2) | 0;
      var ti = (b2 + m3 | 0) + ((s & 8191) << 13) | 0;
      b2 = (g2 + (s >>> 13) | 0) + (ti >>> 26) | 0, ti &= 67108863, m3 = Math.imul($4, _e2), s = Math.imul($4, we2), s = s + Math.imul(Q3, _e2) | 0, g2 = Math.imul(Q3, we2);
      var ri = (b2 + m3 | 0) + ((s & 8191) << 13) | 0;
      return b2 = (g2 + (s >>> 13) | 0) + (ri >>> 26) | 0, ri &= 67108863, h[0] = At2, h[1] = qt2, h[2] = Bt, h[3] = Rt2, h[4] = It2, h[5] = kt2, h[6] = Dt, h[7] = Pt2, h[8] = Tt2, h[9] = Ct2, h[10] = Nt2, h[11] = Lt2, h[12] = Ot, h[13] = zt2, h[14] = Ut, h[15] = Ht, h[16] = ei, h[17] = ti, h[18] = ri, b2 !== 0 && (h[19] = b2, u.length++), u;
    };
    Math.imul || (L4 = ge2);
    function ye(c5, f, a) {
      a.negative = f.negative ^ c5.negative, a.length = c5.length + f.length;
      for (var u = 0, l = 0, d4 = 0; d4 < a.length - 1; d4++) {
        var h = l;
        l = 0;
        for (var b2 = u & 67108863, m3 = Math.min(d4, f.length - 1), s = Math.max(0, d4 - c5.length + 1); s <= m3; s++) {
          var g2 = d4 - s, q = c5.words[g2] | 0, R3 = f.words[s] | 0, B3 = q * R3, P2 = B3 & 67108863;
          h = h + (B3 / 67108864 | 0) | 0, P2 = P2 + b2 | 0, b2 = P2 & 67108863, h = h + (P2 >>> 26) | 0, l += h >>> 26, h &= 67108863;
        }
        a.words[d4] = b2, u = h, h = l;
      }
      return u !== 0 ? a.words[d4] = u : a.length--, a._strip();
    }
    function Re(c5, f, a) {
      return ye(c5, f, a);
    }
    i.prototype.mulTo = function(f, a) {
      var u, l = this.length + f.length;
      return this.length === 10 && f.length === 10 ? u = L4(this, f, a) : l < 63 ? u = ge2(this, f, a) : l < 1024 ? u = ye(this, f, a) : u = Re(this, f, a), u;
    };
    function xe3(c5, f) {
      this.x = c5, this.y = f;
    }
    xe3.prototype.makeRBT = function(f) {
      for (var a = new Array(f), u = i.prototype._countBits(f) - 1, l = 0; l < f; l++)
        a[l] = this.revBin(l, u, f);
      return a;
    }, xe3.prototype.revBin = function(f, a, u) {
      if (f === 0 || f === u - 1)
        return f;
      for (var l = 0, d4 = 0; d4 < a; d4++)
        l |= (f & 1) << a - d4 - 1, f >>= 1;
      return l;
    }, xe3.prototype.permute = function(f, a, u, l, d4, h) {
      for (var b2 = 0; b2 < h; b2++)
        l[b2] = a[f[b2]], d4[b2] = u[f[b2]];
    }, xe3.prototype.transform = function(f, a, u, l, d4, h) {
      this.permute(h, f, a, u, l, d4);
      for (var b2 = 1; b2 < d4; b2 <<= 1)
        for (var m3 = b2 << 1, s = Math.cos(2 * Math.PI / m3), g2 = Math.sin(2 * Math.PI / m3), q = 0; q < d4; q += m3)
          for (var R3 = s, B3 = g2, P2 = 0; P2 < b2; P2++) {
            var T4 = u[q + P2], N4 = l[q + P2], ze = u[q + P2 + b2], O = l[q + P2 + b2], z = R3 * ze - B3 * O;
            O = R3 * O + B3 * ze, ze = z, u[q + P2] = T4 + ze, l[q + P2] = N4 + O, u[q + P2 + b2] = T4 - ze, l[q + P2 + b2] = N4 - O, P2 !== m3 && (z = s * R3 - g2 * B3, B3 = s * B3 + g2 * R3, R3 = z);
          }
    }, xe3.prototype.guessLen13b = function(f, a) {
      var u = Math.max(a, f) | 1, l = u & 1, d4 = 0;
      for (u = u / 2 | 0; u; u = u >>> 1)
        d4++;
      return 1 << d4 + 1 + l;
    }, xe3.prototype.conjugate = function(f, a, u) {
      if (!(u <= 1))
        for (var l = 0; l < u / 2; l++) {
          var d4 = f[l];
          f[l] = f[u - l - 1], f[u - l - 1] = d4, d4 = a[l], a[l] = -a[u - l - 1], a[u - l - 1] = -d4;
        }
    }, xe3.prototype.normalize13b = function(f, a) {
      for (var u = 0, l = 0; l < a / 2; l++) {
        var d4 = Math.round(f[2 * l + 1] / a) * 8192 + Math.round(f[2 * l] / a) + u;
        f[l] = d4 & 67108863, d4 < 67108864 ? u = 0 : u = d4 / 67108864 | 0;
      }
      return f;
    }, xe3.prototype.convert13b = function(f, a, u, l) {
      for (var d4 = 0, h = 0; h < a; h++)
        d4 = d4 + (f[h] | 0), u[2 * h] = d4 & 8191, d4 = d4 >>> 13, u[2 * h + 1] = d4 & 8191, d4 = d4 >>> 13;
      for (h = 2 * a; h < l; ++h)
        u[h] = 0;
      r(d4 === 0), r((d4 & -8192) === 0);
    }, xe3.prototype.stub = function(f) {
      for (var a = new Array(f), u = 0; u < f; u++)
        a[u] = 0;
      return a;
    }, xe3.prototype.mulp = function(f, a, u) {
      var l = 2 * this.guessLen13b(f.length, a.length), d4 = this.makeRBT(l), h = this.stub(l), b2 = new Array(l), m3 = new Array(l), s = new Array(l), g2 = new Array(l), q = new Array(l), R3 = new Array(l), B3 = u.words;
      B3.length = l, this.convert13b(f.words, f.length, b2, l), this.convert13b(a.words, a.length, g2, l), this.transform(b2, h, m3, s, l, d4), this.transform(g2, h, q, R3, l, d4);
      for (var P2 = 0; P2 < l; P2++) {
        var T4 = m3[P2] * q[P2] - s[P2] * R3[P2];
        s[P2] = m3[P2] * R3[P2] + s[P2] * q[P2], m3[P2] = T4;
      }
      return this.conjugate(m3, s, l), this.transform(m3, s, B3, h, l, d4), this.conjugate(B3, h, l), this.normalize13b(B3, l), u.negative = f.negative ^ a.negative, u.length = f.length + a.length, u._strip();
    }, i.prototype.mul = function(f) {
      var a = new i(null);
      return a.words = new Array(this.length + f.length), this.mulTo(f, a);
    }, i.prototype.mulf = function(f) {
      var a = new i(null);
      return a.words = new Array(this.length + f.length), Re(this, f, a);
    }, i.prototype.imul = function(f) {
      return this.clone().mulTo(f, this);
    }, i.prototype.imuln = function(f) {
      var a = f < 0;
      a && (f = -f), r(typeof f == "number"), r(f < 67108864);
      for (var u = 0, l = 0; l < this.length; l++) {
        var d4 = (this.words[l] | 0) * f, h = (d4 & 67108863) + (u & 67108863);
        u >>= 26, u += d4 / 67108864 | 0, u += h >>> 26, this.words[l] = h & 67108863;
      }
      return u !== 0 && (this.words[l] = u, this.length++), a ? this.ineg() : this;
    }, i.prototype.muln = function(f) {
      return this.clone().imuln(f);
    }, i.prototype.sqr = function() {
      return this.mul(this);
    }, i.prototype.isqr = function() {
      return this.imul(this.clone());
    }, i.prototype.pow = function(f) {
      var a = C(f);
      if (a.length === 0)
        return new i(1);
      for (var u = this, l = 0; l < a.length && a[l] === 0; l++, u = u.sqr())
        ;
      if (++l < a.length)
        for (var d4 = u.sqr(); l < a.length; l++, d4 = d4.sqr())
          a[l] !== 0 && (u = u.mul(d4));
      return u;
    }, i.prototype.iushln = function(f) {
      r(typeof f == "number" && f >= 0);
      var a = f % 26, u = (f - a) / 26, l = 67108863 >>> 26 - a << 26 - a, d4;
      if (a !== 0) {
        var h = 0;
        for (d4 = 0; d4 < this.length; d4++) {
          var b2 = this.words[d4] & l, m3 = (this.words[d4] | 0) - b2 << a;
          this.words[d4] = m3 | h, h = b2 >>> 26 - a;
        }
        h && (this.words[d4] = h, this.length++);
      }
      if (u !== 0) {
        for (d4 = this.length - 1; d4 >= 0; d4--)
          this.words[d4 + u] = this.words[d4];
        for (d4 = 0; d4 < u; d4++)
          this.words[d4] = 0;
        this.length += u;
      }
      return this._strip();
    }, i.prototype.ishln = function(f) {
      return r(this.negative === 0), this.iushln(f);
    }, i.prototype.iushrn = function(f, a, u) {
      r(typeof f == "number" && f >= 0);
      var l;
      a ? l = (a - a % 26) / 26 : l = 0;
      var d4 = f % 26, h = Math.min((f - d4) / 26, this.length), b2 = 67108863 ^ 67108863 >>> d4 << d4, m3 = u;
      if (l -= h, l = Math.max(0, l), m3) {
        for (var s = 0; s < h; s++)
          m3.words[s] = this.words[s];
        m3.length = h;
      }
      if (h !== 0)
        if (this.length > h)
          for (this.length -= h, s = 0; s < this.length; s++)
            this.words[s] = this.words[s + h];
        else
          this.words[0] = 0, this.length = 1;
      var g2 = 0;
      for (s = this.length - 1; s >= 0 && (g2 !== 0 || s >= l); s--) {
        var q = this.words[s] | 0;
        this.words[s] = g2 << 26 - d4 | q >>> d4, g2 = q & b2;
      }
      return m3 && g2 !== 0 && (m3.words[m3.length++] = g2), this.length === 0 && (this.words[0] = 0, this.length = 1), this._strip();
    }, i.prototype.ishrn = function(f, a, u) {
      return r(this.negative === 0), this.iushrn(f, a, u);
    }, i.prototype.shln = function(f) {
      return this.clone().ishln(f);
    }, i.prototype.ushln = function(f) {
      return this.clone().iushln(f);
    }, i.prototype.shrn = function(f) {
      return this.clone().ishrn(f);
    }, i.prototype.ushrn = function(f) {
      return this.clone().iushrn(f);
    }, i.prototype.testn = function(f) {
      r(typeof f == "number" && f >= 0);
      var a = f % 26, u = (f - a) / 26, l = 1 << a;
      if (this.length <= u)
        return false;
      var d4 = this.words[u];
      return !!(d4 & l);
    }, i.prototype.imaskn = function(f) {
      r(typeof f == "number" && f >= 0);
      var a = f % 26, u = (f - a) / 26;
      if (r(this.negative === 0, "imaskn works only with positive numbers"), this.length <= u)
        return this;
      if (a !== 0 && u++, this.length = Math.min(u, this.length), a !== 0) {
        var l = 67108863 ^ 67108863 >>> a << a;
        this.words[this.length - 1] &= l;
      }
      return this._strip();
    }, i.prototype.maskn = function(f) {
      return this.clone().imaskn(f);
    }, i.prototype.iaddn = function(f) {
      return r(typeof f == "number"), r(f < 67108864), f < 0 ? this.isubn(-f) : this.negative !== 0 ? this.length === 1 && (this.words[0] | 0) <= f ? (this.words[0] = f - (this.words[0] | 0), this.negative = 0, this) : (this.negative = 0, this.isubn(f), this.negative = 1, this) : this._iaddn(f);
    }, i.prototype._iaddn = function(f) {
      this.words[0] += f;
      for (var a = 0; a < this.length && this.words[a] >= 67108864; a++)
        this.words[a] -= 67108864, a === this.length - 1 ? this.words[a + 1] = 1 : this.words[a + 1]++;
      return this.length = Math.max(this.length, a + 1), this;
    }, i.prototype.isubn = function(f) {
      if (r(typeof f == "number"), r(f < 67108864), f < 0)
        return this.iaddn(-f);
      if (this.negative !== 0)
        return this.negative = 0, this.iaddn(f), this.negative = 1, this;
      if (this.words[0] -= f, this.length === 1 && this.words[0] < 0)
        this.words[0] = -this.words[0], this.negative = 1;
      else
        for (var a = 0; a < this.length && this.words[a] < 0; a++)
          this.words[a] += 67108864, this.words[a + 1] -= 1;
      return this._strip();
    }, i.prototype.addn = function(f) {
      return this.clone().iaddn(f);
    }, i.prototype.subn = function(f) {
      return this.clone().isubn(f);
    }, i.prototype.iabs = function() {
      return this.negative = 0, this;
    }, i.prototype.abs = function() {
      return this.clone().iabs();
    }, i.prototype._ishlnsubmul = function(f, a, u) {
      var l = f.length + u, d4;
      this._expand(l);
      var h, b2 = 0;
      for (d4 = 0; d4 < f.length; d4++) {
        h = (this.words[d4 + u] | 0) + b2;
        var m3 = (f.words[d4] | 0) * a;
        h -= m3 & 67108863, b2 = (h >> 26) - (m3 / 67108864 | 0), this.words[d4 + u] = h & 67108863;
      }
      for (; d4 < this.length - u; d4++)
        h = (this.words[d4 + u] | 0) + b2, b2 = h >> 26, this.words[d4 + u] = h & 67108863;
      if (b2 === 0)
        return this._strip();
      for (r(b2 === -1), b2 = 0, d4 = 0; d4 < this.length; d4++)
        h = -(this.words[d4] | 0) + b2, b2 = h >> 26, this.words[d4] = h & 67108863;
      return this.negative = 1, this._strip();
    }, i.prototype._wordDiv = function(f, a) {
      var u = this.length - f.length, l = this.clone(), d4 = f, h = d4.words[d4.length - 1] | 0, b2 = this._countBits(h);
      u = 26 - b2, u !== 0 && (d4 = d4.ushln(u), l.iushln(u), h = d4.words[d4.length - 1] | 0);
      var m3 = l.length - d4.length, s;
      if (a !== "mod") {
        s = new i(null), s.length = m3 + 1, s.words = new Array(s.length);
        for (var g2 = 0; g2 < s.length; g2++)
          s.words[g2] = 0;
      }
      var q = l.clone()._ishlnsubmul(d4, 1, m3);
      q.negative === 0 && (l = q, s && (s.words[m3] = 1));
      for (var R3 = m3 - 1; R3 >= 0; R3--) {
        var B3 = (l.words[d4.length + R3] | 0) * 67108864 + (l.words[d4.length + R3 - 1] | 0);
        for (B3 = Math.min(B3 / h | 0, 67108863), l._ishlnsubmul(d4, B3, R3); l.negative !== 0; )
          B3--, l.negative = 0, l._ishlnsubmul(d4, 1, R3), l.isZero() || (l.negative ^= 1);
        s && (s.words[R3] = B3);
      }
      return s && s._strip(), l._strip(), a !== "div" && u !== 0 && l.iushrn(u), { div: s || null, mod: l };
    }, i.prototype.divmod = function(f, a, u) {
      if (r(!f.isZero()), this.isZero())
        return { div: new i(0), mod: new i(0) };
      var l, d4, h;
      return this.negative !== 0 && f.negative === 0 ? (h = this.neg().divmod(f, a), a !== "mod" && (l = h.div.neg()), a !== "div" && (d4 = h.mod.neg(), u && d4.negative !== 0 && d4.iadd(f)), { div: l, mod: d4 }) : this.negative === 0 && f.negative !== 0 ? (h = this.divmod(f.neg(), a), a !== "mod" && (l = h.div.neg()), { div: l, mod: h.mod }) : (this.negative & f.negative) !== 0 ? (h = this.neg().divmod(f.neg(), a), a !== "div" && (d4 = h.mod.neg(), u && d4.negative !== 0 && d4.isub(f)), { div: h.div, mod: d4 }) : f.length > this.length || this.cmp(f) < 0 ? { div: new i(0), mod: this } : f.length === 1 ? a === "div" ? { div: this.divn(f.words[0]), mod: null } : a === "mod" ? { div: null, mod: new i(this.modrn(f.words[0])) } : { div: this.divn(f.words[0]), mod: new i(this.modrn(f.words[0])) } : this._wordDiv(f, a);
    }, i.prototype.div = function(f) {
      return this.divmod(f, "div", false).div;
    }, i.prototype.mod = function(f) {
      return this.divmod(f, "mod", false).mod;
    }, i.prototype.umod = function(f) {
      return this.divmod(f, "mod", true).mod;
    }, i.prototype.divRound = function(f) {
      var a = this.divmod(f);
      if (a.mod.isZero())
        return a.div;
      var u = a.div.negative !== 0 ? a.mod.isub(f) : a.mod, l = f.ushrn(1), d4 = f.andln(1), h = u.cmp(l);
      return h < 0 || d4 === 1 && h === 0 ? a.div : a.div.negative !== 0 ? a.div.isubn(1) : a.div.iaddn(1);
    }, i.prototype.modrn = function(f) {
      var a = f < 0;
      a && (f = -f), r(f <= 67108863);
      for (var u = (1 << 26) % f, l = 0, d4 = this.length - 1; d4 >= 0; d4--)
        l = (u * l + (this.words[d4] | 0)) % f;
      return a ? -l : l;
    }, i.prototype.modn = function(f) {
      return this.modrn(f);
    }, i.prototype.idivn = function(f) {
      var a = f < 0;
      a && (f = -f), r(f <= 67108863);
      for (var u = 0, l = this.length - 1; l >= 0; l--) {
        var d4 = (this.words[l] | 0) + u * 67108864;
        this.words[l] = d4 / f | 0, u = d4 % f;
      }
      return this._strip(), a ? this.ineg() : this;
    }, i.prototype.divn = function(f) {
      return this.clone().idivn(f);
    }, i.prototype.egcd = function(f) {
      r(f.negative === 0), r(!f.isZero());
      var a = this, u = f.clone();
      a.negative !== 0 ? a = a.umod(f) : a = a.clone();
      for (var l = new i(1), d4 = new i(0), h = new i(0), b2 = new i(1), m3 = 0; a.isEven() && u.isEven(); )
        a.iushrn(1), u.iushrn(1), ++m3;
      for (var s = u.clone(), g2 = a.clone(); !a.isZero(); ) {
        for (var q = 0, R3 = 1; (a.words[0] & R3) === 0 && q < 26; ++q, R3 <<= 1)
          ;
        if (q > 0)
          for (a.iushrn(q); q-- > 0; )
            (l.isOdd() || d4.isOdd()) && (l.iadd(s), d4.isub(g2)), l.iushrn(1), d4.iushrn(1);
        for (var B3 = 0, P2 = 1; (u.words[0] & P2) === 0 && B3 < 26; ++B3, P2 <<= 1)
          ;
        if (B3 > 0)
          for (u.iushrn(B3); B3-- > 0; )
            (h.isOdd() || b2.isOdd()) && (h.iadd(s), b2.isub(g2)), h.iushrn(1), b2.iushrn(1);
        a.cmp(u) >= 0 ? (a.isub(u), l.isub(h), d4.isub(b2)) : (u.isub(a), h.isub(l), b2.isub(d4));
      }
      return { a: h, b: b2, gcd: u.iushln(m3) };
    }, i.prototype._invmp = function(f) {
      r(f.negative === 0), r(!f.isZero());
      var a = this, u = f.clone();
      a.negative !== 0 ? a = a.umod(f) : a = a.clone();
      for (var l = new i(1), d4 = new i(0), h = u.clone(); a.cmpn(1) > 0 && u.cmpn(1) > 0; ) {
        for (var b2 = 0, m3 = 1; (a.words[0] & m3) === 0 && b2 < 26; ++b2, m3 <<= 1)
          ;
        if (b2 > 0)
          for (a.iushrn(b2); b2-- > 0; )
            l.isOdd() && l.iadd(h), l.iushrn(1);
        for (var s = 0, g2 = 1; (u.words[0] & g2) === 0 && s < 26; ++s, g2 <<= 1)
          ;
        if (s > 0)
          for (u.iushrn(s); s-- > 0; )
            d4.isOdd() && d4.iadd(h), d4.iushrn(1);
        a.cmp(u) >= 0 ? (a.isub(u), l.isub(d4)) : (u.isub(a), d4.isub(l));
      }
      var q;
      return a.cmpn(1) === 0 ? q = l : q = d4, q.cmpn(0) < 0 && q.iadd(f), q;
    }, i.prototype.gcd = function(f) {
      if (this.isZero())
        return f.abs();
      if (f.isZero())
        return this.abs();
      var a = this.clone(), u = f.clone();
      a.negative = 0, u.negative = 0;
      for (var l = 0; a.isEven() && u.isEven(); l++)
        a.iushrn(1), u.iushrn(1);
      do {
        for (; a.isEven(); )
          a.iushrn(1);
        for (; u.isEven(); )
          u.iushrn(1);
        var d4 = a.cmp(u);
        if (d4 < 0) {
          var h = a;
          a = u, u = h;
        } else if (d4 === 0 || u.cmpn(1) === 0)
          break;
        a.isub(u);
      } while (true);
      return u.iushln(l);
    }, i.prototype.invm = function(f) {
      return this.egcd(f).a.umod(f);
    }, i.prototype.isEven = function() {
      return (this.words[0] & 1) === 0;
    }, i.prototype.isOdd = function() {
      return (this.words[0] & 1) === 1;
    }, i.prototype.andln = function(f) {
      return this.words[0] & f;
    }, i.prototype.bincn = function(f) {
      r(typeof f == "number");
      var a = f % 26, u = (f - a) / 26, l = 1 << a;
      if (this.length <= u)
        return this._expand(u + 1), this.words[u] |= l, this;
      for (var d4 = l, h = u; d4 !== 0 && h < this.length; h++) {
        var b2 = this.words[h] | 0;
        b2 += d4, d4 = b2 >>> 26, b2 &= 67108863, this.words[h] = b2;
      }
      return d4 !== 0 && (this.words[h] = d4, this.length++), this;
    }, i.prototype.isZero = function() {
      return this.length === 1 && this.words[0] === 0;
    }, i.prototype.cmpn = function(f) {
      var a = f < 0;
      if (this.negative !== 0 && !a)
        return -1;
      if (this.negative === 0 && a)
        return 1;
      this._strip();
      var u;
      if (this.length > 1)
        u = 1;
      else {
        a && (f = -f), r(f <= 67108863, "Number is too big");
        var l = this.words[0] | 0;
        u = l === f ? 0 : l < f ? -1 : 1;
      }
      return this.negative !== 0 ? -u | 0 : u;
    }, i.prototype.cmp = function(f) {
      if (this.negative !== 0 && f.negative === 0)
        return -1;
      if (this.negative === 0 && f.negative !== 0)
        return 1;
      var a = this.ucmp(f);
      return this.negative !== 0 ? -a | 0 : a;
    }, i.prototype.ucmp = function(f) {
      if (this.length > f.length)
        return 1;
      if (this.length < f.length)
        return -1;
      for (var a = 0, u = this.length - 1; u >= 0; u--) {
        var l = this.words[u] | 0, d4 = f.words[u] | 0;
        if (l !== d4) {
          l < d4 ? a = -1 : l > d4 && (a = 1);
          break;
        }
      }
      return a;
    }, i.prototype.gtn = function(f) {
      return this.cmpn(f) === 1;
    }, i.prototype.gt = function(f) {
      return this.cmp(f) === 1;
    }, i.prototype.gten = function(f) {
      return this.cmpn(f) >= 0;
    }, i.prototype.gte = function(f) {
      return this.cmp(f) >= 0;
    }, i.prototype.ltn = function(f) {
      return this.cmpn(f) === -1;
    }, i.prototype.lt = function(f) {
      return this.cmp(f) === -1;
    }, i.prototype.lten = function(f) {
      return this.cmpn(f) <= 0;
    }, i.prototype.lte = function(f) {
      return this.cmp(f) <= 0;
    }, i.prototype.eqn = function(f) {
      return this.cmpn(f) === 0;
    }, i.prototype.eq = function(f) {
      return this.cmp(f) === 0;
    }, i.red = function(f) {
      return new v2(f);
    }, i.prototype.toRed = function(f) {
      return r(!this.red, "Already a number in reduction context"), r(this.negative === 0, "red works only with positives"), f.convertTo(this)._forceRed(f);
    }, i.prototype.fromRed = function() {
      return r(this.red, "fromRed works only with numbers in reduction context"), this.red.convertFrom(this);
    }, i.prototype._forceRed = function(f) {
      return this.red = f, this;
    }, i.prototype.forceRed = function(f) {
      return r(!this.red, "Already a number in reduction context"), this._forceRed(f);
    }, i.prototype.redAdd = function(f) {
      return r(this.red, "redAdd works only with red numbers"), this.red.add(this, f);
    }, i.prototype.redIAdd = function(f) {
      return r(this.red, "redIAdd works only with red numbers"), this.red.iadd(this, f);
    }, i.prototype.redSub = function(f) {
      return r(this.red, "redSub works only with red numbers"), this.red.sub(this, f);
    }, i.prototype.redISub = function(f) {
      return r(this.red, "redISub works only with red numbers"), this.red.isub(this, f);
    }, i.prototype.redShl = function(f) {
      return r(this.red, "redShl works only with red numbers"), this.red.shl(this, f);
    }, i.prototype.redMul = function(f) {
      return r(this.red, "redMul works only with red numbers"), this.red._verify2(this, f), this.red.mul(this, f);
    }, i.prototype.redIMul = function(f) {
      return r(this.red, "redMul works only with red numbers"), this.red._verify2(this, f), this.red.imul(this, f);
    }, i.prototype.redSqr = function() {
      return r(this.red, "redSqr works only with red numbers"), this.red._verify1(this), this.red.sqr(this);
    }, i.prototype.redISqr = function() {
      return r(this.red, "redISqr works only with red numbers"), this.red._verify1(this), this.red.isqr(this);
    }, i.prototype.redSqrt = function() {
      return r(this.red, "redSqrt works only with red numbers"), this.red._verify1(this), this.red.sqrt(this);
    }, i.prototype.redInvm = function() {
      return r(this.red, "redInvm works only with red numbers"), this.red._verify1(this), this.red.invm(this);
    }, i.prototype.redNeg = function() {
      return r(this.red, "redNeg works only with red numbers"), this.red._verify1(this), this.red.neg(this);
    }, i.prototype.redPow = function(f) {
      return r(this.red && !f.red, "redPow(normalNum)"), this.red._verify1(this), this.red.pow(this, f);
    };
    var ke = { k256: null, p224: null, p192: null, p25519: null };
    function Me(c5, f) {
      this.name = c5, this.p = new i(f, 16), this.n = this.p.bitLength(), this.k = new i(1).iushln(this.n).isub(this.p), this.tmp = this._tmp();
    }
    Me.prototype._tmp = function() {
      var f = new i(null);
      return f.words = new Array(Math.ceil(this.n / 13)), f;
    }, Me.prototype.ireduce = function(f) {
      var a = f, u;
      do
        this.split(a, this.tmp), a = this.imulK(a), a = a.iadd(this.tmp), u = a.bitLength();
      while (u > this.n);
      var l = u < this.n ? -1 : a.ucmp(this.p);
      return l === 0 ? (a.words[0] = 0, a.length = 1) : l > 0 ? a.isub(this.p) : a.strip !== void 0 ? a.strip() : a._strip(), a;
    }, Me.prototype.split = function(f, a) {
      f.iushrn(this.n, 0, a);
    }, Me.prototype.imulK = function(f) {
      return f.imul(this.k);
    };
    function Ce3() {
      Me.call(this, "k256", "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f");
    }
    n(Ce3, Me), Ce3.prototype.split = function(f, a) {
      for (var u = 4194303, l = Math.min(f.length, 9), d4 = 0; d4 < l; d4++)
        a.words[d4] = f.words[d4];
      if (a.length = l, f.length <= 9) {
        f.words[0] = 0, f.length = 1;
        return;
      }
      var h = f.words[9];
      for (a.words[a.length++] = h & u, d4 = 10; d4 < f.length; d4++) {
        var b2 = f.words[d4] | 0;
        f.words[d4 - 10] = (b2 & u) << 4 | h >>> 22, h = b2;
      }
      h >>>= 22, f.words[d4 - 10] = h, h === 0 && f.length > 10 ? f.length -= 10 : f.length -= 9;
    }, Ce3.prototype.imulK = function(f) {
      f.words[f.length] = 0, f.words[f.length + 1] = 0, f.length += 2;
      for (var a = 0, u = 0; u < f.length; u++) {
        var l = f.words[u] | 0;
        a += l * 977, f.words[u] = a & 67108863, a = l * 64 + (a / 67108864 | 0);
      }
      return f.words[f.length - 1] === 0 && (f.length--, f.words[f.length - 1] === 0 && f.length--), f;
    };
    function Ee2() {
      Me.call(this, "p224", "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001");
    }
    n(Ee2, Me);
    function Ne3() {
      Me.call(this, "p192", "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff");
    }
    n(Ne3, Me);
    function S3() {
      Me.call(this, "25519", "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed");
    }
    n(S3, Me), S3.prototype.imulK = function(f) {
      for (var a = 0, u = 0; u < f.length; u++) {
        var l = (f.words[u] | 0) * 19 + a, d4 = l & 67108863;
        l >>>= 26, f.words[u] = d4, a = l;
      }
      return a !== 0 && (f.words[f.length++] = a), f;
    }, i._prime = function(f) {
      if (ke[f])
        return ke[f];
      var a;
      if (f === "k256")
        a = new Ce3();
      else if (f === "p224")
        a = new Ee2();
      else if (f === "p192")
        a = new Ne3();
      else if (f === "p25519")
        a = new S3();
      else
        throw new Error("Unknown prime " + f);
      return ke[f] = a, a;
    };
    function v2(c5) {
      if (typeof c5 == "string") {
        var f = i._prime(c5);
        this.m = f.p, this.prime = f;
      } else
        r(c5.gtn(1), "modulus must be greater than 1"), this.m = c5, this.prime = null;
    }
    v2.prototype._verify1 = function(f) {
      r(f.negative === 0, "red works only with positives"), r(f.red, "red works only with red numbers");
    }, v2.prototype._verify2 = function(f, a) {
      r((f.negative | a.negative) === 0, "red works only with positives"), r(f.red && f.red === a.red, "red works only with red numbers");
    }, v2.prototype.imod = function(f) {
      return this.prime ? this.prime.ireduce(f)._forceRed(this) : (x(f, f.umod(this.m)._forceRed(this)), f);
    }, v2.prototype.neg = function(f) {
      return f.isZero() ? f.clone() : this.m.sub(f)._forceRed(this);
    }, v2.prototype.add = function(f, a) {
      this._verify2(f, a);
      var u = f.add(a);
      return u.cmp(this.m) >= 0 && u.isub(this.m), u._forceRed(this);
    }, v2.prototype.iadd = function(f, a) {
      this._verify2(f, a);
      var u = f.iadd(a);
      return u.cmp(this.m) >= 0 && u.isub(this.m), u;
    }, v2.prototype.sub = function(f, a) {
      this._verify2(f, a);
      var u = f.sub(a);
      return u.cmpn(0) < 0 && u.iadd(this.m), u._forceRed(this);
    }, v2.prototype.isub = function(f, a) {
      this._verify2(f, a);
      var u = f.isub(a);
      return u.cmpn(0) < 0 && u.iadd(this.m), u;
    }, v2.prototype.shl = function(f, a) {
      return this._verify1(f), this.imod(f.ushln(a));
    }, v2.prototype.imul = function(f, a) {
      return this._verify2(f, a), this.imod(f.imul(a));
    }, v2.prototype.mul = function(f, a) {
      return this._verify2(f, a), this.imod(f.mul(a));
    }, v2.prototype.isqr = function(f) {
      return this.imul(f, f.clone());
    }, v2.prototype.sqr = function(f) {
      return this.mul(f, f);
    }, v2.prototype.sqrt = function(f) {
      if (f.isZero())
        return f.clone();
      var a = this.m.andln(3);
      if (r(a % 2 === 1), a === 3) {
        var u = this.m.add(new i(1)).iushrn(2);
        return this.pow(f, u);
      }
      for (var l = this.m.subn(1), d4 = 0; !l.isZero() && l.andln(1) === 0; )
        d4++, l.iushrn(1);
      r(!l.isZero());
      var h = new i(1).toRed(this), b2 = h.redNeg(), m3 = this.m.subn(1).iushrn(1), s = this.m.bitLength();
      for (s = new i(2 * s * s).toRed(this); this.pow(s, m3).cmp(b2) !== 0; )
        s.redIAdd(b2);
      for (var g2 = this.pow(s, l), q = this.pow(f, l.addn(1).iushrn(1)), R3 = this.pow(f, l), B3 = d4; R3.cmp(h) !== 0; ) {
        for (var P2 = R3, T4 = 0; P2.cmp(h) !== 0; T4++)
          P2 = P2.redSqr();
        r(T4 < B3);
        var N4 = this.pow(g2, new i(1).iushln(B3 - T4 - 1));
        q = q.redMul(N4), g2 = N4.redSqr(), R3 = R3.redMul(g2), B3 = T4;
      }
      return q;
    }, v2.prototype.invm = function(f) {
      var a = f._invmp(this.m);
      return a.negative !== 0 ? (a.negative = 0, this.imod(a).redNeg()) : this.imod(a);
    }, v2.prototype.pow = function(f, a) {
      if (a.isZero())
        return new i(1).toRed(this);
      if (a.cmpn(1) === 0)
        return f.clone();
      var u = 4, l = new Array(1 << u);
      l[0] = new i(1).toRed(this), l[1] = f;
      for (var d4 = 2; d4 < l.length; d4++)
        l[d4] = this.mul(l[d4 - 1], f);
      var h = l[0], b2 = 0, m3 = 0, s = a.bitLength() % 26;
      for (s === 0 && (s = 26), d4 = a.length - 1; d4 >= 0; d4--) {
        for (var g2 = a.words[d4], q = s - 1; q >= 0; q--) {
          var R3 = g2 >> q & 1;
          if (h !== l[0] && (h = this.sqr(h)), R3 === 0 && b2 === 0) {
            m3 = 0;
            continue;
          }
          b2 <<= 1, b2 |= R3, m3++, !(m3 !== u && (d4 !== 0 || q !== 0)) && (h = this.mul(h, l[b2]), m3 = 0, b2 = 0);
        }
        s = 26;
      }
      return h;
    }, v2.prototype.convertTo = function(f) {
      var a = f.umod(this.m);
      return a === f ? a.clone() : a;
    }, v2.prototype.convertFrom = function(f) {
      var a = f.clone();
      return a.red = null, a;
    }, i.mont = function(f) {
      return new _2(f);
    };
    function _2(c5) {
      v2.call(this, c5), this.shift = this.m.bitLength(), this.shift % 26 !== 0 && (this.shift += 26 - this.shift % 26), this.r = new i(1).iushln(this.shift), this.r2 = this.imod(this.r.sqr()), this.rinv = this.r._invmp(this.m), this.minv = this.rinv.mul(this.r).isubn(1).div(this.m), this.minv = this.minv.umod(this.r), this.minv = this.r.sub(this.minv);
    }
    n(_2, v2), _2.prototype.convertTo = function(f) {
      return this.imod(f.ushln(this.shift));
    }, _2.prototype.convertFrom = function(f) {
      var a = this.imod(f.mul(this.rinv));
      return a.red = null, a;
    }, _2.prototype.imul = function(f, a) {
      if (f.isZero() || a.isZero())
        return f.words[0] = 0, f.length = 1, f;
      var u = f.imul(a), l = u.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), d4 = u.isub(l).iushrn(this.shift), h = d4;
      return d4.cmp(this.m) >= 0 ? h = d4.isub(this.m) : d4.cmpn(0) < 0 && (h = d4.iadd(this.m)), h._forceRed(this);
    }, _2.prototype.mul = function(f, a) {
      if (f.isZero() || a.isZero())
        return new i(0)._forceRed(this);
      var u = f.mul(a), l = u.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), d4 = u.isub(l).iushrn(this.shift), h = d4;
      return d4.cmp(this.m) >= 0 ? h = d4.isub(this.m) : d4.cmpn(0) < 0 && (h = d4.iadd(this.m)), h._forceRed(this);
    }, _2.prototype.invm = function(f) {
      var a = this.imod(f._invmp(this.m).mul(this.r2));
      return a._forceRed(this);
    };
  })(typeof hs > "u" || hs, Oc);
});
var aa = k2((Km, zc) => {
  "use strict";
  var na = export_default, tf = na.Buffer, wt = {}, xt2;
  for (xt2 in na)
    !na.hasOwnProperty(xt2) || xt2 === "SlowBuffer" || xt2 === "Buffer" || (wt[xt2] = na[xt2]);
  var rf = wt.Buffer = {};
  for (xt2 in tf)
    !tf.hasOwnProperty(xt2) || xt2 === "allocUnsafe" || xt2 === "allocUnsafeSlow" || (rf[xt2] = tf[xt2]);
  wt.Buffer.prototype = tf.prototype;
  (!rf.from || rf.from === Uint8Array.from) && (rf.from = function(t, e, r) {
    if (typeof t == "number")
      throw new TypeError('The "value" argument must not be of type number. Received type ' + typeof t);
    if (t && typeof t.length > "u")
      throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof t);
    return tf(t, e, r);
  });
  rf.alloc || (rf.alloc = function(t, e, r) {
    if (typeof t != "number")
      throw new TypeError('The "size" argument must be of type number. Received type ' + typeof t);
    if (t < 0 || t >= 2 * (1 << 30))
      throw new RangeError('The value "' + t + '" is invalid for option "size"');
    var n = tf(t);
    return !e || e.length === 0 ? n.fill(0) : typeof r == "string" ? n.fill(e, r) : n.fill(e), n;
  });
  if (!wt.kStringMaxLength)
    try {
      wt.kStringMaxLength = process_default.binding("buffer").kStringMaxLength;
    } catch {
    }
  wt.constants || (wt.constants = { MAX_LENGTH: wt.kMaxLength }, wt.kStringMaxLength && (wt.constants.MAX_STRING_LENGTH = wt.kStringMaxLength));
  zc.exports = wt;
});
var sa = k2((Uc) => {
  "use strict";
  var r4 = qe();
  function Mt(t) {
    this._reporterState = { obj: null, path: [], options: t || {}, errors: [] };
  }
  Uc.Reporter = Mt;
  Mt.prototype.isError = function(e) {
    return e instanceof ff;
  };
  Mt.prototype.save = function() {
    let e = this._reporterState;
    return { obj: e.obj, pathLen: e.path.length };
  };
  Mt.prototype.restore = function(e) {
    let r = this._reporterState;
    r.obj = e.obj, r.path = r.path.slice(0, e.pathLen);
  };
  Mt.prototype.enterKey = function(e) {
    return this._reporterState.path.push(e);
  };
  Mt.prototype.exitKey = function(e) {
    let r = this._reporterState;
    r.path = r.path.slice(0, e - 1);
  };
  Mt.prototype.leaveKey = function(e, r, n) {
    let i = this._reporterState;
    this.exitKey(e), i.obj !== null && (i.obj[r] = n);
  };
  Mt.prototype.path = function() {
    return this._reporterState.path.join("/");
  };
  Mt.prototype.enterObject = function() {
    let e = this._reporterState, r = e.obj;
    return e.obj = {}, r;
  };
  Mt.prototype.leaveObject = function(e) {
    let r = this._reporterState, n = r.obj;
    return r.obj = e, n;
  };
  Mt.prototype.error = function(e) {
    let r, n = this._reporterState, i = e instanceof ff;
    if (i ? r = e : r = new ff(n.path.map(function(o2) {
      return "[" + JSON.stringify(o2) + "]";
    }).join(""), e.message || e, e.stack), !n.options.partial)
      throw r;
    return i || n.errors.push(r), r;
  };
  Mt.prototype.wrapResult = function(e) {
    let r = this._reporterState;
    return r.options.partial ? { result: this.isError(e) ? null : e, errors: r.errors } : e;
  };
  function ff(t, e) {
    this.path = t, this.rethrow(e);
  }
  r4(ff, Error);
  ff.prototype.rethrow = function(e) {
    if (this.message = e + " at: " + (this.path || "(shallow)"), Error.captureStackTrace && Error.captureStackTrace(this, ff), !this.stack)
      try {
        throw new Error(this.message);
      } catch (r) {
        this.stack = r.stack;
      }
    return this;
  };
});
var sf = k2((ds) => {
  "use strict";
  var i4 = qe(), oa = sa().Reporter, nf = aa().Buffer;
  function St(t, e) {
    if (oa.call(this, e), !nf.isBuffer(t)) {
      this.error("Input not Buffer");
      return;
    }
    this.base = t, this.offset = 0, this.length = t.length;
  }
  i4(St, oa);
  ds.DecoderBuffer = St;
  St.isDecoderBuffer = function(e) {
    return e instanceof St ? true : typeof e == "object" && nf.isBuffer(e.base) && e.constructor.name === "DecoderBuffer" && typeof e.offset == "number" && typeof e.length == "number" && typeof e.save == "function" && typeof e.restore == "function" && typeof e.isEmpty == "function" && typeof e.readUInt8 == "function" && typeof e.skip == "function" && typeof e.raw == "function";
  };
  St.prototype.save = function() {
    return { offset: this.offset, reporter: oa.prototype.save.call(this) };
  };
  St.prototype.restore = function(e) {
    let r = new St(this.base);
    return r.offset = e.offset, r.length = this.offset, this.offset = e.offset, oa.prototype.restore.call(this, e.reporter), r;
  };
  St.prototype.isEmpty = function() {
    return this.offset === this.length;
  };
  St.prototype.readUInt8 = function(e) {
    return this.offset + 1 <= this.length ? this.base.readUInt8(this.offset++, true) : this.error(e || "DecoderBuffer overrun");
  };
  St.prototype.skip = function(e, r) {
    if (!(this.offset + e <= this.length))
      return this.error(r || "DecoderBuffer overrun");
    let n = new St(this.base);
    return n._reporterState = this._reporterState, n.offset = this.offset, n.length = this.offset + e, this.offset += e, n;
  };
  St.prototype.raw = function(e) {
    return this.base.slice(e ? e.offset : this.offset, this.length);
  };
  function af(t, e) {
    if (Array.isArray(t))
      this.length = 0, this.value = t.map(function(r) {
        return af.isEncoderBuffer(r) || (r = new af(r, e)), this.length += r.length, r;
      }, this);
    else if (typeof t == "number") {
      if (!(0 <= t && t <= 255))
        return e.error("non-byte EncoderBuffer value");
      this.value = t, this.length = 1;
    } else if (typeof t == "string")
      this.value = t, this.length = nf.byteLength(t);
    else if (nf.isBuffer(t))
      this.value = t, this.length = t.length;
    else
      return e.error("Unsupported type: " + typeof t);
  }
  ds.EncoderBuffer = af;
  af.isEncoderBuffer = function(e) {
    return e instanceof af ? true : typeof e == "object" && e.constructor.name === "EncoderBuffer" && typeof e.length == "number" && typeof e.join == "function";
  };
  af.prototype.join = function(e, r) {
    return e || (e = nf.alloc(this.length)), r || (r = 0), this.length === 0 || (Array.isArray(this.value) ? this.value.forEach(function(n) {
      n.join(e, r), r += n.length;
    }) : (typeof this.value == "number" ? e[r] = this.value : typeof this.value == "string" ? e.write(this.value, r) : nf.isBuffer(this.value) && this.value.copy(e, r), r += this.length)), e;
  };
});
var ha = k2((Vm, Fc) => {
  "use strict";
  var f4 = sa().Reporter, n4 = sf().EncoderBuffer, a4 = sf().DecoderBuffer, it2 = ot(), Hc = ["seq", "seqof", "set", "setof", "objid", "bool", "gentime", "utctime", "null_", "enum", "int", "objDesc", "bitstr", "bmpstr", "charstr", "genstr", "graphstr", "ia5str", "iso646str", "numstr", "octstr", "printstr", "t61str", "unistr", "utf8str", "videostr"], s4 = ["key", "obj", "use", "optional", "explicit", "implicit", "def", "choice", "any", "contains"].concat(Hc), o4 = ["_peekTag", "_decodeTag", "_use", "_decodeStr", "_decodeObjid", "_decodeTime", "_decodeNull", "_decodeInt", "_decodeBool", "_decodeList", "_encodeComposite", "_encodeStr", "_encodeObjid", "_encodeTime", "_encodeNull", "_encodeInt", "_encodeBool"];
  function De4(t, e, r) {
    let n = {};
    this._baseState = n, n.name = r, n.enc = t, n.parent = e || null, n.children = null, n.tag = null, n.args = null, n.reverseArgs = null, n.choice = null, n.optional = false, n.any = false, n.obj = false, n.use = null, n.useDecoder = null, n.key = null, n.default = null, n.explicit = null, n.implicit = null, n.contains = null, n.parent || (n.children = [], this._wrap());
  }
  Fc.exports = De4;
  var h4 = ["enc", "parent", "children", "tag", "args", "reverseArgs", "choice", "optional", "any", "obj", "use", "alteredUse", "key", "default", "explicit", "implicit", "contains"];
  De4.prototype.clone = function() {
    let e = this._baseState, r = {};
    h4.forEach(function(i) {
      r[i] = e[i];
    });
    let n = new this.constructor(r.parent);
    return n._baseState = r, n;
  };
  De4.prototype._wrap = function() {
    let e = this._baseState;
    s4.forEach(function(r) {
      this[r] = function() {
        let i = new this.constructor(this);
        return e.children.push(i), i[r].apply(i, arguments);
      };
    }, this);
  };
  De4.prototype._init = function(e) {
    let r = this._baseState;
    it2(r.parent === null), e.call(this), r.children = r.children.filter(function(n) {
      return n._baseState.parent === this;
    }, this), it2.equal(r.children.length, 1, "Root node can have only one child");
  };
  De4.prototype._useArgs = function(e) {
    let r = this._baseState, n = e.filter(function(i) {
      return i instanceof this.constructor;
    }, this);
    e = e.filter(function(i) {
      return !(i instanceof this.constructor);
    }, this), n.length !== 0 && (it2(r.children === null), r.children = n, n.forEach(function(i) {
      i._baseState.parent = this;
    }, this)), e.length !== 0 && (it2(r.args === null), r.args = e, r.reverseArgs = e.map(function(i) {
      if (typeof i != "object" || i.constructor !== Object)
        return i;
      let o2 = {};
      return Object.keys(i).forEach(function(p3) {
        p3 == (p3 | 0) && (p3 |= 0);
        let y4 = i[p3];
        o2[y4] = p3;
      }), o2;
    }));
  };
  o4.forEach(function(t) {
    De4.prototype[t] = function() {
      let r = this._baseState;
      throw new Error(t + " not implemented for encoding: " + r.enc);
    };
  });
  Hc.forEach(function(t) {
    De4.prototype[t] = function() {
      let r = this._baseState, n = Array.prototype.slice.call(arguments);
      return it2(r.tag === null), r.tag = t, this._useArgs(n), this;
    };
  });
  De4.prototype.use = function(e) {
    it2(e);
    let r = this._baseState;
    return it2(r.use === null), r.use = e, this;
  };
  De4.prototype.optional = function() {
    let e = this._baseState;
    return e.optional = true, this;
  };
  De4.prototype.def = function(e) {
    let r = this._baseState;
    return it2(r.default === null), r.default = e, r.optional = true, this;
  };
  De4.prototype.explicit = function(e) {
    let r = this._baseState;
    return it2(r.explicit === null && r.implicit === null), r.explicit = e, this;
  };
  De4.prototype.implicit = function(e) {
    let r = this._baseState;
    return it2(r.explicit === null && r.implicit === null), r.implicit = e, this;
  };
  De4.prototype.obj = function() {
    let e = this._baseState, r = Array.prototype.slice.call(arguments);
    return e.obj = true, r.length !== 0 && this._useArgs(r), this;
  };
  De4.prototype.key = function(e) {
    let r = this._baseState;
    return it2(r.key === null), r.key = e, this;
  };
  De4.prototype.any = function() {
    let e = this._baseState;
    return e.any = true, this;
  };
  De4.prototype.choice = function(e) {
    let r = this._baseState;
    return it2(r.choice === null), r.choice = e, this._useArgs(Object.keys(e).map(function(n) {
      return e[n];
    })), this;
  };
  De4.prototype.contains = function(e) {
    let r = this._baseState;
    return it2(r.use === null), r.contains = e, this;
  };
  De4.prototype._decode = function(e, r) {
    let n = this._baseState;
    if (n.parent === null)
      return e.wrapResult(n.children[0]._decode(e, r));
    let i = n.default, o2 = true, p3 = null;
    if (n.key !== null && (p3 = e.enterKey(n.key)), n.optional) {
      let w2 = null;
      if (n.explicit !== null ? w2 = n.explicit : n.implicit !== null ? w2 = n.implicit : n.tag !== null && (w2 = n.tag), w2 === null && !n.any) {
        let x = e.save();
        try {
          n.choice === null ? this._decodeGeneric(n.tag, e, r) : this._decodeChoice(e, r), o2 = true;
        } catch {
          o2 = false;
        }
        e.restore(x);
      } else if (o2 = this._peekTag(e, w2, n.any), e.isError(o2))
        return o2;
    }
    let y4;
    if (n.obj && o2 && (y4 = e.enterObject()), o2) {
      if (n.explicit !== null) {
        let x = this._decodeTag(e, n.explicit);
        if (e.isError(x))
          return x;
        e = x;
      }
      let w2 = e.offset;
      if (n.use === null && n.choice === null) {
        let x;
        n.any && (x = e.save());
        let M4 = this._decodeTag(e, n.implicit !== null ? n.implicit : n.tag, n.any);
        if (e.isError(M4))
          return M4;
        n.any ? i = e.raw(x) : e = M4;
      }
      if (r && r.track && n.tag !== null && r.track(e.path(), w2, e.length, "tagged"), r && r.track && n.tag !== null && r.track(e.path(), e.offset, e.length, "content"), n.any || (n.choice === null ? i = this._decodeGeneric(n.tag, e, r) : i = this._decodeChoice(e, r)), e.isError(i))
        return i;
      if (!n.any && n.choice === null && n.children !== null && n.children.forEach(function(M4) {
        M4._decode(e, r);
      }), n.contains && (n.tag === "octstr" || n.tag === "bitstr")) {
        let x = new a4(i);
        i = this._getUse(n.contains, e._reporterState.obj)._decode(x, r);
      }
    }
    return n.obj && o2 && (i = e.leaveObject(y4)), n.key !== null && (i !== null || o2 === true) ? e.leaveKey(p3, n.key, i) : p3 !== null && e.exitKey(p3), i;
  };
  De4.prototype._decodeGeneric = function(e, r, n) {
    let i = this._baseState;
    return e === "seq" || e === "set" ? null : e === "seqof" || e === "setof" ? this._decodeList(r, e, i.args[0], n) : /str$/.test(e) ? this._decodeStr(r, e, n) : e === "objid" && i.args ? this._decodeObjid(r, i.args[0], i.args[1], n) : e === "objid" ? this._decodeObjid(r, null, null, n) : e === "gentime" || e === "utctime" ? this._decodeTime(r, e, n) : e === "null_" ? this._decodeNull(r, n) : e === "bool" ? this._decodeBool(r, n) : e === "objDesc" ? this._decodeStr(r, e, n) : e === "int" || e === "enum" ? this._decodeInt(r, i.args && i.args[0], n) : i.use !== null ? this._getUse(i.use, r._reporterState.obj)._decode(r, n) : r.error("unknown tag: " + e);
  };
  De4.prototype._getUse = function(e, r) {
    let n = this._baseState;
    return n.useDecoder = this._use(e, r), it2(n.useDecoder._baseState.parent === null), n.useDecoder = n.useDecoder._baseState.children[0], n.implicit !== n.useDecoder._baseState.implicit && (n.useDecoder = n.useDecoder.clone(), n.useDecoder._baseState.implicit = n.implicit), n.useDecoder;
  };
  De4.prototype._decodeChoice = function(e, r) {
    let n = this._baseState, i = null, o2 = false;
    return Object.keys(n.choice).some(function(p3) {
      let y4 = e.save(), w2 = n.choice[p3];
      try {
        let x = w2._decode(e, r);
        if (e.isError(x))
          return false;
        i = { type: p3, value: x }, o2 = true;
      } catch {
        return e.restore(y4), false;
      }
      return true;
    }, this), o2 ? i : e.error("Choice not matched");
  };
  De4.prototype._createEncoderBuffer = function(e) {
    return new n4(e, this.reporter);
  };
  De4.prototype._encode = function(e, r, n) {
    let i = this._baseState;
    if (i.default !== null && i.default === e)
      return;
    let o2 = this._encodeValue(e, r, n);
    if (o2 !== void 0 && !this._skipDefault(o2, r, n))
      return o2;
  };
  De4.prototype._encodeValue = function(e, r, n) {
    let i = this._baseState;
    if (i.parent === null)
      return i.children[0]._encode(e, r || new f4());
    let o2 = null;
    if (this.reporter = r, i.optional && e === void 0)
      if (i.default !== null)
        e = i.default;
      else
        return;
    let p3 = null, y4 = false;
    if (i.any)
      o2 = this._createEncoderBuffer(e);
    else if (i.choice)
      o2 = this._encodeChoice(e, r);
    else if (i.contains)
      p3 = this._getUse(i.contains, n)._encode(e, r), y4 = true;
    else if (i.children)
      p3 = i.children.map(function(w2) {
        if (w2._baseState.tag === "null_")
          return w2._encode(null, r, e);
        if (w2._baseState.key === null)
          return r.error("Child should have a key");
        let x = r.enterKey(w2._baseState.key);
        if (typeof e != "object")
          return r.error("Child expected, but input is not object");
        let M4 = w2._encode(e[w2._baseState.key], r, e);
        return r.leaveKey(x), M4;
      }, this).filter(function(w2) {
        return w2;
      }), p3 = this._createEncoderBuffer(p3);
    else if (i.tag === "seqof" || i.tag === "setof") {
      if (!(i.args && i.args.length === 1))
        return r.error("Too many args for : " + i.tag);
      if (!Array.isArray(e))
        return r.error("seqof/setof, but data is not Array");
      let w2 = this.clone();
      w2._baseState.implicit = null, p3 = this._createEncoderBuffer(e.map(function(x) {
        let M4 = this._baseState;
        return this._getUse(M4.args[0], e)._encode(x, r);
      }, w2));
    } else
      i.use !== null ? o2 = this._getUse(i.use, n)._encode(e, r) : (p3 = this._encodePrimitive(i.tag, e), y4 = true);
    if (!i.any && i.choice === null) {
      let w2 = i.implicit !== null ? i.implicit : i.tag, x = i.implicit === null ? "universal" : "context";
      w2 === null ? i.use === null && r.error("Tag could be omitted only for .use()") : i.use === null && (o2 = this._encodeComposite(w2, y4, x, p3));
    }
    return i.explicit !== null && (o2 = this._encodeComposite(i.explicit, false, "context", o2)), o2;
  };
  De4.prototype._encodeChoice = function(e, r) {
    let n = this._baseState, i = n.choice[e.type];
    return i || it2(false, e.type + " not found in " + JSON.stringify(Object.keys(n.choice))), i._encode(e.value, r);
  };
  De4.prototype._encodePrimitive = function(e, r) {
    let n = this._baseState;
    if (/str$/.test(e))
      return this._encodeStr(r, e);
    if (e === "objid" && n.args)
      return this._encodeObjid(r, n.reverseArgs[0], n.args[1]);
    if (e === "objid")
      return this._encodeObjid(r, null, null);
    if (e === "gentime" || e === "utctime")
      return this._encodeTime(r, e);
    if (e === "null_")
      return this._encodeNull();
    if (e === "int" || e === "enum")
      return this._encodeInt(r, n.args && n.reverseArgs[0]);
    if (e === "bool")
      return this._encodeBool(r);
    if (e === "objDesc")
      return this._encodeStr(r, e);
    throw new Error("Unsupported tag: " + e);
  };
  De4.prototype._isNumstr = function(e) {
    return /^[0-9 ]*$/.test(e);
  };
  De4.prototype._isPrintstr = function(e) {
    return /^[A-Za-z0-9 '()+,-./:=?]*$/.test(e);
  };
});
var ua = k2((qi) => {
  "use strict";
  function Kc(t) {
    let e = {};
    return Object.keys(t).forEach(function(r) {
      (r | 0) == r && (r = r | 0);
      let n = t[r];
      e[n] = r;
    }), e;
  }
  qi.tagClass = { 0: "universal", 1: "application", 2: "context", 3: "private" };
  qi.tagClassByName = Kc(qi.tagClass);
  qi.tag = { 0: "end", 1: "bool", 2: "int", 3: "bitstr", 4: "octstr", 5: "null_", 6: "objid", 7: "objDesc", 8: "external", 9: "real", 10: "enum", 11: "embed", 12: "utf8str", 13: "relativeOid", 16: "seq", 17: "set", 18: "numstr", 19: "printstr", 20: "t61str", 21: "videostr", 22: "ia5str", 23: "utctime", 24: "gentime", 25: "graphstr", 26: "iso646str", 27: "genstr", 28: "unistr", 29: "charstr", 30: "bmpstr" };
  qi.tagByName = Kc(qi.tag);
});
var ls = k2((Gm, Vc) => {
  "use strict";
  var u4 = qe(), Sr = aa().Buffer, jc = ha(), cs = ua();
  function Wc(t) {
    this.enc = "der", this.name = t.name, this.entity = t, this.tree = new Xt(), this.tree._init(t.body);
  }
  Vc.exports = Wc;
  Wc.prototype.encode = function(e, r) {
    return this.tree._encode(e, r).join();
  };
  function Xt(t) {
    jc.call(this, "der", t);
  }
  u4(Xt, jc);
  Xt.prototype._encodeComposite = function(e, r, n, i) {
    let o2 = d4(e, r, n, this.reporter);
    if (i.length < 128) {
      let w2 = Sr.alloc(2);
      return w2[0] = o2, w2[1] = i.length, this._createEncoderBuffer([w2, i]);
    }
    let p3 = 1;
    for (let w2 = i.length; w2 >= 256; w2 >>= 8)
      p3++;
    let y4 = Sr.alloc(1 + 1 + p3);
    y4[0] = o2, y4[1] = 128 | p3;
    for (let w2 = 1 + p3, x = i.length; x > 0; w2--, x >>= 8)
      y4[w2] = x & 255;
    return this._createEncoderBuffer([y4, i]);
  };
  Xt.prototype._encodeStr = function(e, r) {
    if (r === "bitstr")
      return this._createEncoderBuffer([e.unused | 0, e.data]);
    if (r === "bmpstr") {
      let n = Sr.alloc(e.length * 2);
      for (let i = 0; i < e.length; i++)
        n.writeUInt16BE(e.charCodeAt(i), i * 2);
      return this._createEncoderBuffer(n);
    } else
      return r === "numstr" ? this._isNumstr(e) ? this._createEncoderBuffer(e) : this.reporter.error("Encoding of string type: numstr supports only digits and space") : r === "printstr" ? this._isPrintstr(e) ? this._createEncoderBuffer(e) : this.reporter.error("Encoding of string type: printstr supports only latin upper and lower case letters, digits, space, apostrophe, left and rigth parenthesis, plus sign, comma, hyphen, dot, slash, colon, equal sign, question mark") : /str$/.test(r) ? this._createEncoderBuffer(e) : r === "objDesc" ? this._createEncoderBuffer(e) : this.reporter.error("Encoding of string type: " + r + " unsupported");
  };
  Xt.prototype._encodeObjid = function(e, r, n) {
    if (typeof e == "string") {
      if (!r)
        return this.reporter.error("string objid given, but no values map found");
      if (!r.hasOwnProperty(e))
        return this.reporter.error("objid not found in values map");
      e = r[e].split(/[\s.]+/g);
      for (let y4 = 0; y4 < e.length; y4++)
        e[y4] |= 0;
    } else if (Array.isArray(e)) {
      e = e.slice();
      for (let y4 = 0; y4 < e.length; y4++)
        e[y4] |= 0;
    }
    if (!Array.isArray(e))
      return this.reporter.error("objid() should be either array or string, got: " + JSON.stringify(e));
    if (!n) {
      if (e[1] >= 40)
        return this.reporter.error("Second objid identifier OOB");
      e.splice(0, 2, e[0] * 40 + e[1]);
    }
    let i = 0;
    for (let y4 = 0; y4 < e.length; y4++) {
      let w2 = e[y4];
      for (i++; w2 >= 128; w2 >>= 7)
        i++;
    }
    let o2 = Sr.alloc(i), p3 = o2.length - 1;
    for (let y4 = e.length - 1; y4 >= 0; y4--) {
      let w2 = e[y4];
      for (o2[p3--] = w2 & 127; (w2 >>= 7) > 0; )
        o2[p3--] = 128 | w2 & 127;
    }
    return this._createEncoderBuffer(o2);
  };
  function Et2(t) {
    return t < 10 ? "0" + t : t;
  }
  Xt.prototype._encodeTime = function(e, r) {
    let n, i = new Date(e);
    return r === "gentime" ? n = [Et2(i.getUTCFullYear()), Et2(i.getUTCMonth() + 1), Et2(i.getUTCDate()), Et2(i.getUTCHours()), Et2(i.getUTCMinutes()), Et2(i.getUTCSeconds()), "Z"].join("") : r === "utctime" ? n = [Et2(i.getUTCFullYear() % 100), Et2(i.getUTCMonth() + 1), Et2(i.getUTCDate()), Et2(i.getUTCHours()), Et2(i.getUTCMinutes()), Et2(i.getUTCSeconds()), "Z"].join("") : this.reporter.error("Encoding " + r + " time is not supported yet"), this._encodeStr(n, "octstr");
  };
  Xt.prototype._encodeNull = function() {
    return this._createEncoderBuffer("");
  };
  Xt.prototype._encodeInt = function(e, r) {
    if (typeof e == "string") {
      if (!r)
        return this.reporter.error("String int or enum given, but no values map");
      if (!r.hasOwnProperty(e))
        return this.reporter.error("Values map doesn't contain: " + JSON.stringify(e));
      e = r[e];
    }
    if (typeof e != "number" && !Sr.isBuffer(e)) {
      let o2 = e.toArray();
      !e.sign && o2[0] & 128 && o2.unshift(0), e = Sr.from(o2);
    }
    if (Sr.isBuffer(e)) {
      let o2 = e.length;
      e.length === 0 && o2++;
      let p3 = Sr.alloc(o2);
      return e.copy(p3), e.length === 0 && (p3[0] = 0), this._createEncoderBuffer(p3);
    }
    if (e < 128)
      return this._createEncoderBuffer(e);
    if (e < 256)
      return this._createEncoderBuffer([0, e]);
    let n = 1;
    for (let o2 = e; o2 >= 256; o2 >>= 8)
      n++;
    let i = new Array(n);
    for (let o2 = i.length - 1; o2 >= 0; o2--)
      i[o2] = e & 255, e >>= 8;
    return i[0] & 128 && i.unshift(0), this._createEncoderBuffer(Sr.from(i));
  };
  Xt.prototype._encodeBool = function(e) {
    return this._createEncoderBuffer(e ? 255 : 0);
  };
  Xt.prototype._use = function(e, r) {
    return typeof e == "function" && (e = e(r)), e._getEncoder("der").tree;
  };
  Xt.prototype._skipDefault = function(e, r, n) {
    let i = this._baseState, o2;
    if (i.default === null)
      return false;
    let p3 = e.join();
    if (i.defaultBuffer === void 0 && (i.defaultBuffer = this._encodeValue(i.default, r, n).join()), p3.length !== i.defaultBuffer.length)
      return false;
    for (o2 = 0; o2 < p3.length; o2++)
      if (p3[o2] !== i.defaultBuffer[o2])
        return false;
    return true;
  };
  function d4(t, e, r, n) {
    let i;
    if (t === "seqof" ? t = "seq" : t === "setof" && (t = "set"), cs.tagByName.hasOwnProperty(t))
      i = cs.tagByName[t];
    else if (typeof t == "number" && (t | 0) === t)
      i = t;
    else
      return n.error("Unknown tag: " + t);
    return i >= 31 ? n.error("Multi-octet tag encoding unsupported") : (e || (i |= 32), i |= cs.tagClassByName[r || "universal"] << 6, i);
  }
});
var Gc = k2((Xm, Zc) => {
  "use strict";
  var c42 = qe(), vs = ls();
  function ps(t) {
    vs.call(this, t), this.enc = "pem";
  }
  c42(ps, vs);
  Zc.exports = ps;
  ps.prototype.encode = function(e, r) {
    let i = vs.prototype.encode.call(this, e).toString("base64"), o2 = ["-----BEGIN " + r.label + "-----"];
    for (let p3 = 0; p3 < i.length; p3 += 64)
      o2.push(i.slice(p3, p3 + 64));
    return o2.push("-----END " + r.label + "-----"), o2.join(`
`);
  };
});
var bs = k2((Yc) => {
  "use strict";
  var Xc = Yc;
  Xc.der = ls();
  Xc.pem = Gc();
});
var gs = k2((Jm, rl) => {
  "use strict";
  var l4 = qe(), v4 = Fe(), Jc = sf().DecoderBuffer, Qc = ha(), $c = ua();
  function el(t) {
    this.enc = "der", this.name = t.name, this.entity = t, this.tree = new ut4(), this.tree._init(t.body);
  }
  rl.exports = el;
  el.prototype.decode = function(e, r) {
    return Jc.isDecoderBuffer(e) || (e = new Jc(e, r)), this.tree._decode(e, r);
  };
  function ut4(t) {
    Qc.call(this, "der", t);
  }
  l4(ut4, Qc);
  ut4.prototype._peekTag = function(e, r, n) {
    if (e.isEmpty())
      return false;
    let i = e.save(), o2 = ms(e, 'Failed to peek tag: "' + r + '"');
    return e.isError(o2) ? o2 : (e.restore(i), o2.tag === r || o2.tagStr === r || o2.tagStr + "of" === r || n);
  };
  ut4.prototype._decodeTag = function(e, r, n) {
    let i = ms(e, 'Failed to decode tag of "' + r + '"');
    if (e.isError(i))
      return i;
    let o2 = tl(e, i.primitive, 'Failed to get length of "' + r + '"');
    if (e.isError(o2))
      return o2;
    if (!n && i.tag !== r && i.tagStr !== r && i.tagStr + "of" !== r)
      return e.error('Failed to match tag: "' + r + '"');
    if (i.primitive || o2 !== null)
      return e.skip(o2, 'Failed to match body of: "' + r + '"');
    let p3 = e.save(), y4 = this._skipUntilEnd(e, 'Failed to skip indefinite length body: "' + this.tag + '"');
    return e.isError(y4) ? y4 : (o2 = e.offset - p3.offset, e.restore(p3), e.skip(o2, 'Failed to match body of: "' + r + '"'));
  };
  ut4.prototype._skipUntilEnd = function(e, r) {
    for (; ; ) {
      let n = ms(e, r);
      if (e.isError(n))
        return n;
      let i = tl(e, n.primitive, r);
      if (e.isError(i))
        return i;
      let o2;
      if (n.primitive || i !== null ? o2 = e.skip(i) : o2 = this._skipUntilEnd(e, r), e.isError(o2))
        return o2;
      if (n.tagStr === "end")
        break;
    }
  };
  ut4.prototype._decodeList = function(e, r, n, i) {
    let o2 = [];
    for (; !e.isEmpty(); ) {
      let p3 = this._peekTag(e, "end");
      if (e.isError(p3))
        return p3;
      let y4 = n.decode(e, "der", i);
      if (e.isError(y4) && p3)
        break;
      o2.push(y4);
    }
    return o2;
  };
  ut4.prototype._decodeStr = function(e, r) {
    if (r === "bitstr") {
      let n = e.readUInt8();
      return e.isError(n) ? n : { unused: n, data: e.raw() };
    } else if (r === "bmpstr") {
      let n = e.raw();
      if (n.length % 2 === 1)
        return e.error("Decoding of string type: bmpstr length mismatch");
      let i = "";
      for (let o2 = 0; o2 < n.length / 2; o2++)
        i += String.fromCharCode(n.readUInt16BE(o2 * 2));
      return i;
    } else if (r === "numstr") {
      let n = e.raw().toString("ascii");
      return this._isNumstr(n) ? n : e.error("Decoding of string type: numstr unsupported characters");
    } else {
      if (r === "octstr")
        return e.raw();
      if (r === "objDesc")
        return e.raw();
      if (r === "printstr") {
        let n = e.raw().toString("ascii");
        return this._isPrintstr(n) ? n : e.error("Decoding of string type: printstr unsupported characters");
      } else
        return /str$/.test(r) ? e.raw().toString() : e.error("Decoding of string type: " + r + " unsupported");
    }
  };
  ut4.prototype._decodeObjid = function(e, r, n) {
    let i, o2 = [], p3 = 0, y4 = 0;
    for (; !e.isEmpty(); )
      y4 = e.readUInt8(), p3 <<= 7, p3 |= y4 & 127, (y4 & 128) === 0 && (o2.push(p3), p3 = 0);
    y4 & 128 && o2.push(p3);
    let w2 = o2[0] / 40 | 0, x = o2[0] % 40;
    if (n ? i = o2 : i = [w2, x].concat(o2.slice(1)), r) {
      let M4 = r[i.join(" ")];
      M4 === void 0 && (M4 = r[i.join(".")]), M4 !== void 0 && (i = M4);
    }
    return i;
  };
  ut4.prototype._decodeTime = function(e, r) {
    let n = e.raw().toString(), i, o2, p3, y4, w2, x;
    if (r === "gentime")
      i = n.slice(0, 4) | 0, o2 = n.slice(4, 6) | 0, p3 = n.slice(6, 8) | 0, y4 = n.slice(8, 10) | 0, w2 = n.slice(10, 12) | 0, x = n.slice(12, 14) | 0;
    else if (r === "utctime")
      i = n.slice(0, 2) | 0, o2 = n.slice(2, 4) | 0, p3 = n.slice(4, 6) | 0, y4 = n.slice(6, 8) | 0, w2 = n.slice(8, 10) | 0, x = n.slice(10, 12) | 0, i < 70 ? i = 2e3 + i : i = 1900 + i;
    else
      return e.error("Decoding " + r + " time is not supported yet");
    return Date.UTC(i, o2 - 1, p3, y4, w2, x, 0);
  };
  ut4.prototype._decodeNull = function() {
    return null;
  };
  ut4.prototype._decodeBool = function(e) {
    let r = e.readUInt8();
    return e.isError(r) ? r : r !== 0;
  };
  ut4.prototype._decodeInt = function(e, r) {
    let n = e.raw(), i = new v4(n);
    return r && (i = r[i.toString(10)] || i), i;
  };
  ut4.prototype._use = function(e, r) {
    return typeof e == "function" && (e = e(r)), e._getDecoder("der").tree;
  };
  function ms(t, e) {
    let r = t.readUInt8(e);
    if (t.isError(r))
      return r;
    let n = $c.tagClass[r >> 6], i = (r & 32) === 0;
    if ((r & 31) === 31) {
      let p3 = r;
      for (r = 0; (p3 & 128) === 128; ) {
        if (p3 = t.readUInt8(e), t.isError(p3))
          return p3;
        r <<= 7, r |= p3 & 127;
      }
    } else
      r &= 31;
    let o2 = $c.tag[r];
    return { cls: n, primitive: i, tag: r, tagStr: o2 };
  }
  function tl(t, e, r) {
    let n = t.readUInt8(r);
    if (t.isError(n))
      return n;
    if (!e && n === 128)
      return null;
    if ((n & 128) === 0)
      return n;
    let i = n & 127;
    if (i > 4)
      return t.error("length octect is too long");
    n = 0;
    for (let o2 = 0; o2 < i; o2++) {
      n <<= 8;
      let p3 = t.readUInt8(r);
      if (t.isError(p3))
        return p3;
      n |= p3;
    }
    return n;
  }
});
var fl = k2(($m, il) => {
  "use strict";
  var p4 = qe(), b4 = aa().Buffer, ys = gs();
  function _s(t) {
    ys.call(this, t), this.enc = "pem";
  }
  p4(_s, ys);
  il.exports = _s;
  _s.prototype.decode = function(e, r) {
    let n = e.toString().split(/[\r\n]+/g), i = r.label.toUpperCase(), o2 = /^-----(BEGIN|END) ([^-]+)-----$/, p3 = -1, y4 = -1;
    for (let M4 = 0; M4 < n.length; M4++) {
      let E2 = n[M4].match(o2);
      if (E2 !== null && E2[2] === i)
        if (p3 === -1) {
          if (E2[1] !== "BEGIN")
            break;
          p3 = M4;
        } else {
          if (E2[1] !== "END")
            break;
          y4 = M4;
          break;
        }
    }
    if (p3 === -1 || y4 === -1)
      throw new Error("PEM section not found for: " + i);
    let w2 = n.slice(p3 + 1, y4).join("");
    w2.replace(/[^a-z0-9+/=]+/gi, "");
    let x = b4.from(w2, "base64");
    return ys.prototype.decode.call(this, x, r);
  };
});
var ws = k2((al) => {
  "use strict";
  var nl = al;
  nl.der = gs();
  nl.pem = fl();
});
var ol = k2((sl) => {
  "use strict";
  var m4 = bs(), g4 = ws(), y4 = qe(), _4 = sl;
  _4.define = function(e, r) {
    return new of(e, r);
  };
  function of(t, e) {
    this.name = t, this.body = e, this.decoders = {}, this.encoders = {};
  }
  of.prototype._createNamed = function(e) {
    let r = this.name;
    function n(i) {
      this._initNamed(i, r);
    }
    return y4(n, e), n.prototype._initNamed = function(o2, p3) {
      e.call(this, o2, p3);
    }, new n(this);
  };
  of.prototype._getDecoder = function(e) {
    return e = e || "der", this.decoders.hasOwnProperty(e) || (this.decoders[e] = this._createNamed(g4[e])), this.decoders[e];
  };
  of.prototype.decode = function(e, r, n) {
    return this._getDecoder(r).decode(e, n);
  };
  of.prototype._getEncoder = function(e) {
    return e = e || "der", this.encoders.hasOwnProperty(e) || (this.encoders[e] = this._createNamed(m4[e])), this.encoders[e];
  };
  of.prototype.encode = function(e, r, n) {
    return this._getEncoder(r).encode(e, n);
  };
});
var ul = k2((hl) => {
  "use strict";
  var da = hl;
  da.Reporter = sa().Reporter;
  da.DecoderBuffer = sf().DecoderBuffer;
  da.EncoderBuffer = sf().EncoderBuffer;
  da.Node = ha();
});
var ll = k2((cl) => {
  "use strict";
  var dl = cl;
  dl._reverse = function(e) {
    let r = {};
    return Object.keys(e).forEach(function(n) {
      (n | 0) == n && (n = n | 0);
      let i = e[n];
      r[i] = n;
    }), r;
  };
  dl.der = ua();
});
var xs = k2((vl) => {
  "use strict";
  var hf = vl;
  hf.bignum = Fe();
  hf.define = ol().define;
  hf.base = ul();
  hf.constants = ll();
  hf.decoders = ws();
  hf.encoders = bs();
});
var gl = k2((f7, ml) => {
  "use strict";
  var Yt = xs(), pl = Yt.define("Time", function() {
    this.choice({ utcTime: this.utctime(), generalTime: this.gentime() });
  }), w4 = Yt.define("AttributeTypeValue", function() {
    this.seq().obj(this.key("type").objid(), this.key("value").any());
  }), Ms = Yt.define("AlgorithmIdentifier", function() {
    this.seq().obj(this.key("algorithm").objid(), this.key("parameters").optional(), this.key("curve").objid().optional());
  }), x4 = Yt.define("SubjectPublicKeyInfo", function() {
    this.seq().obj(this.key("algorithm").use(Ms), this.key("subjectPublicKey").bitstr());
  }), M4 = Yt.define("RelativeDistinguishedName", function() {
    this.setof(w4);
  }), S4 = Yt.define("RDNSequence", function() {
    this.seqof(M4);
  }), bl = Yt.define("Name", function() {
    this.choice({ rdnSequence: this.use(S4) });
  }), E4 = Yt.define("Validity", function() {
    this.seq().obj(this.key("notBefore").use(pl), this.key("notAfter").use(pl));
  }), A4 = Yt.define("Extension", function() {
    this.seq().obj(this.key("extnID").objid(), this.key("critical").bool().def(false), this.key("extnValue").octstr());
  }), q4 = Yt.define("TBSCertificate", function() {
    this.seq().obj(this.key("version").explicit(0).int().optional(), this.key("serialNumber").int(), this.key("signature").use(Ms), this.key("issuer").use(bl), this.key("validity").use(E4), this.key("subject").use(bl), this.key("subjectPublicKeyInfo").use(x4), this.key("issuerUniqueID").implicit(1).bitstr().optional(), this.key("subjectUniqueID").implicit(2).bitstr().optional(), this.key("extensions").explicit(3).seqof(A4).optional());
  }), B4 = Yt.define("X509Certificate", function() {
    this.seq().obj(this.key("tbsCertificate").use(q4), this.key("signatureAlgorithm").use(Ms), this.key("signatureValue").bitstr());
  });
  ml.exports = B4;
});
var _l = k2(($t) => {
  "use strict";
  var Jt = xs();
  $t.certificate = gl();
  var R4 = Jt.define("RSAPrivateKey", function() {
    this.seq().obj(this.key("version").int(), this.key("modulus").int(), this.key("publicExponent").int(), this.key("privateExponent").int(), this.key("prime1").int(), this.key("prime2").int(), this.key("exponent1").int(), this.key("exponent2").int(), this.key("coefficient").int());
  });
  $t.RSAPrivateKey = R4;
  var I4 = Jt.define("RSAPublicKey", function() {
    this.seq().obj(this.key("modulus").int(), this.key("publicExponent").int());
  });
  $t.RSAPublicKey = I4;
  var k42 = Jt.define("SubjectPublicKeyInfo", function() {
    this.seq().obj(this.key("algorithm").use(yl), this.key("subjectPublicKey").bitstr());
  });
  $t.PublicKey = k42;
  var yl = Jt.define("AlgorithmIdentifier", function() {
    this.seq().obj(this.key("algorithm").objid(), this.key("none").null_().optional(), this.key("curve").objid().optional(), this.key("params").seq().obj(this.key("p").int(), this.key("q").int(), this.key("g").int()).optional());
  }), D42 = Jt.define("PrivateKeyInfo", function() {
    this.seq().obj(this.key("version").int(), this.key("algorithm").use(yl), this.key("subjectPrivateKey").octstr());
  });
  $t.PrivateKey = D42;
  var P4 = Jt.define("EncryptedPrivateKeyInfo", function() {
    this.seq().obj(this.key("algorithm").seq().obj(this.key("id").objid(), this.key("decrypt").seq().obj(this.key("kde").seq().obj(this.key("id").objid(), this.key("kdeparams").seq().obj(this.key("salt").octstr(), this.key("iters").int())), this.key("cipher").seq().obj(this.key("algo").objid(), this.key("iv").octstr()))), this.key("subjectPrivateKey").octstr());
  });
  $t.EncryptedPrivateKey = P4;
  var T4 = Jt.define("DSAPrivateKey", function() {
    this.seq().obj(this.key("version").int(), this.key("p").int(), this.key("q").int(), this.key("g").int(), this.key("pub_key").int(), this.key("priv_key").int());
  });
  $t.DSAPrivateKey = T4;
  $t.DSAparam = Jt.define("DSAparam", function() {
    this.int();
  });
  var C4 = Jt.define("ECPrivateKey", function() {
    this.seq().obj(this.key("version").int(), this.key("privateKey").octstr(), this.key("parameters").optional().explicit(0).use(N4), this.key("publicKey").optional().explicit(1).bitstr());
  });
  $t.ECPrivateKey = C4;
  var N4 = Jt.define("ECParameters", function() {
    this.choice({ namedCurve: this.objid() });
  });
  $t.signature = Jt.define("signature", function() {
    this.seq().obj(this.key("r").int(), this.key("s").int());
  });
});
var wl = k2((a7, L4) => {
  L4.exports = { "2.16.840.1.101.3.4.1.1": "aes-128-ecb", "2.16.840.1.101.3.4.1.2": "aes-128-cbc", "2.16.840.1.101.3.4.1.3": "aes-128-ofb", "2.16.840.1.101.3.4.1.4": "aes-128-cfb", "2.16.840.1.101.3.4.1.21": "aes-192-ecb", "2.16.840.1.101.3.4.1.22": "aes-192-cbc", "2.16.840.1.101.3.4.1.23": "aes-192-ofb", "2.16.840.1.101.3.4.1.24": "aes-192-cfb", "2.16.840.1.101.3.4.1.41": "aes-256-ecb", "2.16.840.1.101.3.4.1.42": "aes-256-cbc", "2.16.840.1.101.3.4.1.43": "aes-256-ofb", "2.16.840.1.101.3.4.1.44": "aes-256-cfb" };
});
var Ml = k2((s7, xl) => {
  var O4 = /Proc-Type: 4,ENCRYPTED[\n\r]+DEK-Info: AES-((?:128)|(?:192)|(?:256))-CBC,([0-9A-H]+)[\n\r]+([0-9A-z\n\r+/=]+)[\n\r]+/m, z4 = /^-----BEGIN ((?:.*? KEY)|CERTIFICATE)-----/m, U4 = /^-----BEGIN ((?:.*? KEY)|CERTIFICATE)-----([0-9A-z\n\r+/=]+)-----END \1-----$/m, H4 = Pf(), F4 = Ln(), ca = Ae().Buffer;
  xl.exports = function(t, e) {
    var r = t.toString(), n = r.match(O4), i;
    if (n) {
      var p3 = "aes" + n[1], y4 = ca.from(n[2], "hex"), w2 = ca.from(n[3].replace(/[\r\n]/g, ""), "base64"), x = H4(e, y4.slice(0, 8), parseInt(n[1], 10)).key, M4 = [], E2 = F4.createDecipheriv(p3, x, y4);
      M4.push(E2.update(w2)), M4.push(E2.final()), i = ca.concat(M4);
    } else {
      var o2 = r.match(U4);
      i = ca.from(o2[2].replace(/[\r\n]/g, ""), "base64");
    }
    var A4 = r.match(z4)[1];
    return { tag: A4, data: i };
  };
});
var Hf = k2((o7, El) => {
  var st2 = _l(), K4 = wl(), j4 = Ml(), W4 = Ln(), V4 = d0(), Ss = Ae().Buffer;
  El.exports = Sl;
  function Sl(t) {
    var e;
    typeof t == "object" && !Ss.isBuffer(t) && (e = t.passphrase, t = t.key), typeof t == "string" && (t = Ss.from(t));
    var r = j4(t, e), n = r.tag, i = r.data, o2, p3;
    switch (n) {
      case "CERTIFICATE":
        p3 = st2.certificate.decode(i, "der").tbsCertificate.subjectPublicKeyInfo;
      case "PUBLIC KEY":
        switch (p3 || (p3 = st2.PublicKey.decode(i, "der")), o2 = p3.algorithm.algorithm.join("."), o2) {
          case "1.2.840.113549.1.1.1":
            return st2.RSAPublicKey.decode(p3.subjectPublicKey.data, "der");
          case "1.2.840.10045.2.1":
            return p3.subjectPrivateKey = p3.subjectPublicKey, { type: "ec", data: p3 };
          case "1.2.840.10040.4.1":
            return p3.algorithm.params.pub_key = st2.DSAparam.decode(p3.subjectPublicKey.data, "der"), { type: "dsa", data: p3.algorithm.params };
          default:
            throw new Error("unknown key id " + o2);
        }
      case "ENCRYPTED PRIVATE KEY":
        i = st2.EncryptedPrivateKey.decode(i, "der"), i = Z42(i, e);
      case "PRIVATE KEY":
        switch (p3 = st2.PrivateKey.decode(i, "der"), o2 = p3.algorithm.algorithm.join("."), o2) {
          case "1.2.840.113549.1.1.1":
            return st2.RSAPrivateKey.decode(p3.subjectPrivateKey, "der");
          case "1.2.840.10045.2.1":
            return { curve: p3.algorithm.curve, privateKey: st2.ECPrivateKey.decode(p3.subjectPrivateKey, "der").privateKey };
          case "1.2.840.10040.4.1":
            return p3.algorithm.params.priv_key = st2.DSAparam.decode(p3.subjectPrivateKey, "der"), { type: "dsa", params: p3.algorithm.params };
          default:
            throw new Error("unknown key id " + o2);
        }
      case "RSA PUBLIC KEY":
        return st2.RSAPublicKey.decode(i, "der");
      case "RSA PRIVATE KEY":
        return st2.RSAPrivateKey.decode(i, "der");
      case "DSA PRIVATE KEY":
        return { type: "dsa", params: st2.DSAPrivateKey.decode(i, "der") };
      case "EC PRIVATE KEY":
        return i = st2.ECPrivateKey.decode(i, "der"), { curve: i.parameters.value, privateKey: i.privateKey };
      default:
        throw new Error("unknown key type " + n);
    }
  }
  Sl.signature = st2.signature;
  function Z42(t, e) {
    var r = t.algorithm.decrypt.kde.kdeparams.salt, n = parseInt(t.algorithm.decrypt.kde.kdeparams.iters.toString(), 10), i = K4[t.algorithm.decrypt.cipher.algo.join(".")], o2 = t.algorithm.decrypt.cipher.iv, p3 = t.subjectPrivateKey, y4 = parseInt(i.split("-")[1], 10) / 8, w2 = V4.pbkdf2Sync(e, r, n, y4, "sha1"), x = W4.createDecipheriv(i, w2, o2), M4 = [];
    return M4.push(x.update(p3)), M4.push(x.final()), Ss.concat(M4);
  }
});
var Es = k2((h7, G4) => {
  G4.exports = { "1.3.132.0.10": "secp256k1", "1.3.132.0.33": "p224", "1.2.840.10045.3.1.1": "p192", "1.2.840.10045.3.1.7": "p256", "1.3.132.0.34": "p384", "1.3.132.0.35": "p521" };
});
var Bl = k2((u7, va) => {
  var rt2 = Ae().Buffer, Bi = t0(), X42 = Hn(), Y4 = fa().ec, la = us(), J4 = Hf(), $4 = Es();
  function Q4(t, e, r, n, i) {
    var o2 = J4(e);
    if (o2.curve) {
      if (n !== "ecdsa" && n !== "ecdsa/rsa")
        throw new Error("wrong private key type");
      return e8(t, o2);
    } else if (o2.type === "dsa") {
      if (n !== "dsa")
        throw new Error("wrong private key type");
      return t8(t, o2, r);
    } else if (n !== "rsa" && n !== "ecdsa/rsa")
      throw new Error("wrong private key type");
    t = rt2.concat([i, t]);
    for (var p3 = o2.modulus.byteLength(), y4 = [0, 1]; t.length + y4.length + 1 < p3; )
      y4.push(255);
    y4.push(0);
    for (var w2 = -1; ++w2 < t.length; )
      y4.push(t[w2]);
    var x = X42(y4, o2);
    return x;
  }
  function e8(t, e) {
    var r = $4[e.curve.join(".")];
    if (!r)
      throw new Error("unknown curve " + e.curve.join("."));
    var n = new Y4(r), i = n.keyFromPrivate(e.privateKey), o2 = i.sign(t);
    return rt2.from(o2.toDER());
  }
  function t8(t, e, r) {
    for (var n = e.params.priv_key, i = e.params.p, o2 = e.params.q, p3 = e.params.g, y4 = new la(0), w2, x = As(t, o2).mod(o2), M4 = false, E2 = Al(n, o2, t, r); M4 === false; )
      w2 = ql(o2, E2, r), y4 = f8(p3, w2, i, o2), M4 = w2.invm(o2).imul(x.add(n.mul(y4))).mod(o2), M4.cmpn(0) === 0 && (M4 = false, y4 = new la(0));
    return r8(y4, M4);
  }
  function r8(t, e) {
    t = t.toArray(), e = e.toArray(), t[0] & 128 && (t = [0].concat(t)), e[0] & 128 && (e = [0].concat(e));
    var r = t.length + e.length + 4, n = [48, r, 2, t.length];
    return n = n.concat(t, [2, e.length], e), rt2.from(n);
  }
  function Al(t, e, r, n) {
    if (t = rt2.from(t.toArray()), t.length < e.byteLength()) {
      var i = rt2.alloc(e.byteLength() - t.length);
      t = rt2.concat([i, t]);
    }
    var o2 = r.length, p3 = i8(r, e), y4 = rt2.alloc(o2);
    y4.fill(1);
    var w2 = rt2.alloc(o2);
    return w2 = Bi(n, w2).update(y4).update(rt2.from([0])).update(t).update(p3).digest(), y4 = Bi(n, w2).update(y4).digest(), w2 = Bi(n, w2).update(y4).update(rt2.from([1])).update(t).update(p3).digest(), y4 = Bi(n, w2).update(y4).digest(), { k: w2, v: y4 };
  }
  function As(t, e) {
    var r = new la(t), n = (t.length << 3) - e.bitLength();
    return n > 0 && r.ishrn(n), r;
  }
  function i8(t, e) {
    t = As(t, e), t = t.mod(e);
    var r = rt2.from(t.toArray());
    if (r.length < e.byteLength()) {
      var n = rt2.alloc(e.byteLength() - r.length);
      r = rt2.concat([n, r]);
    }
    return r;
  }
  function ql(t, e, r) {
    var n, i;
    do {
      for (n = rt2.alloc(0); n.length * 8 < t.bitLength(); )
        e.v = Bi(r, e.k).update(e.v).digest(), n = rt2.concat([n, e.v]);
      i = As(n, t), e.k = Bi(r, e.k).update(e.v).update(rt2.from([0])).digest(), e.v = Bi(r, e.k).update(e.v).digest();
    } while (i.cmp(t) !== -1);
    return i;
  }
  function f8(t, e, r, n) {
    return t.toRed(la.mont(r)).redPow(e).fromRed().mod(n);
  }
  va.exports = Q4;
  va.exports.getKey = Al;
  va.exports.makeKey = ql;
});
var Dl = k2((d7, kl) => {
  var qs = Ae().Buffer, Ff = us(), n8 = fa().ec, Il = Hf(), a8 = Es();
  function s8(t, e, r, n, i) {
    var o2 = Il(r);
    if (o2.type === "ec") {
      if (n !== "ecdsa" && n !== "ecdsa/rsa")
        throw new Error("wrong public key type");
      return o8(t, e, o2);
    } else if (o2.type === "dsa") {
      if (n !== "dsa")
        throw new Error("wrong public key type");
      return h8(t, e, o2);
    } else if (n !== "rsa" && n !== "ecdsa/rsa")
      throw new Error("wrong public key type");
    e = qs.concat([i, e]);
    for (var p3 = o2.modulus.byteLength(), y4 = [1], w2 = 0; e.length + y4.length + 2 < p3; )
      y4.push(255), w2++;
    y4.push(0);
    for (var x = -1; ++x < e.length; )
      y4.push(e[x]);
    y4 = qs.from(y4);
    var M4 = Ff.mont(o2.modulus);
    t = new Ff(t).toRed(M4), t = t.redPow(new Ff(o2.publicExponent)), t = qs.from(t.fromRed().toArray());
    var E2 = w2 < 8 ? 1 : 0;
    for (p3 = Math.min(t.length, y4.length), t.length !== y4.length && (E2 = 1), x = -1; ++x < p3; )
      E2 |= t[x] ^ y4[x];
    return E2 === 0;
  }
  function o8(t, e, r) {
    var n = a8[r.data.algorithm.curve.join(".")];
    if (!n)
      throw new Error("unknown curve " + r.data.algorithm.curve.join("."));
    var i = new n8(n), o2 = r.data.subjectPrivateKey.data;
    return i.verify(e, t, o2);
  }
  function h8(t, e, r) {
    var n = r.data.p, i = r.data.q, o2 = r.data.g, p3 = r.data.pub_key, y4 = Il.signature.decode(t, "der"), w2 = y4.s, x = y4.r;
    Rl(w2, i), Rl(x, i);
    var M4 = Ff.mont(n), E2 = w2.invm(i), A4 = o2.toRed(M4).redPow(new Ff(e).mul(E2).mod(i)).fromRed().mul(p3.toRed(M4).redPow(x.mul(E2).mod(i)).fromRed()).mod(n).mod(i);
    return A4.cmp(x) === 0;
  }
  function Rl(t, e) {
    if (t.cmpn(0) <= 0)
      throw new Error("invalid sig");
    if (t.cmp(e) >= e)
      throw new Error("invalid sig");
  }
  kl.exports = s8;
});
var Ol = k2((c7, Ll) => {
  var pa = Ae().Buffer, Cl = Ni(), ba = Za(), Nl = qe(), u8 = Bl(), d8 = Dl(), Ri = r0();
  Object.keys(Ri).forEach(function(t) {
    Ri[t].id = pa.from(Ri[t].id, "hex"), Ri[t.toLowerCase()] = Ri[t];
  });
  function Kf(t) {
    ba.Writable.call(this);
    var e = Ri[t];
    if (!e)
      throw new Error("Unknown message digest");
    this._hashType = e.hash, this._hash = Cl(e.hash), this._tag = e.id, this._signType = e.sign;
  }
  Nl(Kf, ba.Writable);
  Kf.prototype._write = function(e, r, n) {
    this._hash.update(e), n();
  };
  Kf.prototype.update = function(e, r) {
    return typeof e == "string" && (e = pa.from(e, r)), this._hash.update(e), this;
  };
  Kf.prototype.sign = function(e, r) {
    this.end();
    var n = this._hash.digest(), i = u8(n, e, this._hashType, this._signType, this._tag);
    return r ? i.toString(r) : i;
  };
  function jf(t) {
    ba.Writable.call(this);
    var e = Ri[t];
    if (!e)
      throw new Error("Unknown message digest");
    this._hash = Cl(e.hash), this._tag = e.id, this._signType = e.sign;
  }
  Nl(jf, ba.Writable);
  jf.prototype._write = function(e, r, n) {
    this._hash.update(e), n();
  };
  jf.prototype.update = function(e, r) {
    return typeof e == "string" && (e = pa.from(e, r)), this._hash.update(e), this;
  };
  jf.prototype.verify = function(e, r, n) {
    typeof r == "string" && (r = pa.from(r, n)), this.end();
    var i = this._hash.digest();
    return d8(r, i, e, this._signType, this._tag);
  };
  function Pl(t) {
    return new Kf(t);
  }
  function Tl(t) {
    return new jf(t);
  }
  Ll.exports = { Sign: Pl, Verify: Tl, createSign: Pl, createVerify: Tl };
});
var Ul = k2((l7, zl) => {
  var c8 = fa(), l8 = Fe();
  zl.exports = function(e) {
    return new Ii(e);
  };
  var dt = { secp256k1: { name: "secp256k1", byteLength: 32 }, secp224r1: { name: "p224", byteLength: 28 }, prime256v1: { name: "p256", byteLength: 32 }, prime192v1: { name: "p192", byteLength: 24 }, ed25519: { name: "ed25519", byteLength: 32 }, secp384r1: { name: "p384", byteLength: 48 }, secp521r1: { name: "p521", byteLength: 66 } };
  dt.p224 = dt.secp224r1;
  dt.p256 = dt.secp256r1 = dt.prime256v1;
  dt.p192 = dt.secp192r1 = dt.prime192v1;
  dt.p384 = dt.secp384r1;
  dt.p521 = dt.secp521r1;
  function Ii(t) {
    this.curveType = dt[t], this.curveType || (this.curveType = { name: t }), this.curve = new c8.ec(this.curveType.name), this.keys = void 0;
  }
  Ii.prototype.generateKeys = function(t, e) {
    return this.keys = this.curve.genKeyPair(), this.getPublicKey(t, e);
  };
  Ii.prototype.computeSecret = function(t, e, r) {
    e = e || "utf8", Buffer3.isBuffer(t) || (t = new Buffer3(t, e));
    var n = this.curve.keyFromPublic(t).getPublic(), i = n.mul(this.keys.getPrivate()).getX();
    return Bs(i, r, this.curveType.byteLength);
  };
  Ii.prototype.getPublicKey = function(t, e) {
    var r = this.keys.getPublic(e === "compressed", true);
    return e === "hybrid" && (r[r.length - 1] % 2 ? r[0] = 7 : r[0] = 6), Bs(r, t);
  };
  Ii.prototype.getPrivateKey = function(t) {
    return Bs(this.keys.getPrivate(), t);
  };
  Ii.prototype.setPublicKey = function(t, e) {
    return e = e || "utf8", Buffer3.isBuffer(t) || (t = new Buffer3(t, e)), this.keys._importPublic(t), this;
  };
  Ii.prototype.setPrivateKey = function(t, e) {
    e = e || "utf8", Buffer3.isBuffer(t) || (t = new Buffer3(t, e));
    var r = new l8(t);
    return r = r.toString(16), this.keys = this.curve.genKeyPair(), this.keys._importPrivate(r), this;
  };
  function Bs(t, e, r) {
    Array.isArray(t) || (t = t.toArray());
    var n = new Buffer3(t);
    if (r && n.length < r) {
      var i = new Buffer3(r - n.length);
      i.fill(0), n = Buffer3.concat([i, n]);
    }
    return e ? n.toString(e) : n;
  }
});
var Is = k2((v7, Hl) => {
  var v8 = Ni(), Rs = Ae().Buffer;
  Hl.exports = function(t, e) {
    for (var r = Rs.alloc(0), n = 0, i; r.length < e; )
      i = p8(n++), r = Rs.concat([r, v8("sha1").update(t).update(i).digest()]);
    return r.slice(0, e);
  };
  function p8(t) {
    var e = Rs.allocUnsafe(4);
    return e.writeUInt32BE(t, 0), e;
  }
});
var ks = k2((p7, Fl) => {
  Fl.exports = function(e, r) {
    for (var n = e.length, i = -1; ++i < n; )
      e[i] ^= r[i];
    return e;
  };
});
var Ds = k2((b7, jl) => {
  var Kl = Fe(), b8 = Ae().Buffer;
  function m8(t, e) {
    return b8.from(t.toRed(Kl.mont(e.modulus)).redPow(new Kl(e.publicExponent)).fromRed().toArray());
  }
  jl.exports = m8;
});
var Gl = k2((m7, Zl) => {
  var g8 = Hf(), Ps = fi(), y8 = Ni(), Wl = Is(), Vl = ks(), Ts = Fe(), _8 = Ds(), w8 = Hn(), Qt = Ae().Buffer;
  Zl.exports = function(e, r, n) {
    var i;
    e.padding ? i = e.padding : n ? i = 1 : i = 4;
    var o2 = g8(e), p3;
    if (i === 4)
      p3 = x8(o2, r);
    else if (i === 1)
      p3 = M8(o2, r, n);
    else if (i === 3) {
      if (p3 = new Ts(r), p3.cmp(o2.modulus) >= 0)
        throw new Error("data too long for modulus");
    } else
      throw new Error("unknown padding");
    return n ? w8(p3, o2) : _8(p3, o2);
  };
  function x8(t, e) {
    var r = t.modulus.byteLength(), n = e.length, i = y8("sha1").update(Qt.alloc(0)).digest(), o2 = i.length, p3 = 2 * o2;
    if (n > r - p3 - 2)
      throw new Error("message too long");
    var y4 = Qt.alloc(r - n - p3 - 2), w2 = r - o2 - 1, x = Ps(o2), M4 = Vl(Qt.concat([i, y4, Qt.alloc(1, 1), e], w2), Wl(x, w2)), E2 = Vl(x, Wl(M4, o2));
    return new Ts(Qt.concat([Qt.alloc(1), E2, M4], r));
  }
  function M8(t, e, r) {
    var n = e.length, i = t.modulus.byteLength();
    if (n > i - 11)
      throw new Error("message too long");
    var o2;
    return r ? o2 = Qt.alloc(i - n - 3, 255) : o2 = S8(i - n - 3), new Ts(Qt.concat([Qt.from([0, r ? 1 : 2]), o2, Qt.alloc(1), e], i));
  }
  function S8(t) {
    for (var e = Qt.allocUnsafe(t), r = 0, n = Ps(t * 2), i = 0, o2; r < t; )
      i === n.length && (n = Ps(t * 2), i = 0), o2 = n[i++], o2 && (e[r++] = o2);
    return e;
  }
});
var Ql = k2((g7, $l) => {
  var E8 = Hf(), Xl = Is(), Yl = ks(), Jl = Fe(), A8 = Hn(), q8 = Ni(), B8 = Ds(), Wf = Ae().Buffer;
  $l.exports = function(e, r, n) {
    var i;
    e.padding ? i = e.padding : n ? i = 1 : i = 4;
    var o2 = E8(e), p3 = o2.modulus.byteLength();
    if (r.length > p3 || new Jl(r).cmp(o2.modulus) >= 0)
      throw new Error("decryption error");
    var y4;
    n ? y4 = B8(new Jl(r), o2) : y4 = A8(r, o2);
    var w2 = Wf.alloc(p3 - y4.length);
    if (y4 = Wf.concat([w2, y4], p3), i === 4)
      return R8(o2, y4);
    if (i === 1)
      return I8(o2, y4, n);
    if (i === 3)
      return y4;
    throw new Error("unknown padding");
  };
  function R8(t, e) {
    var r = t.modulus.byteLength(), n = q8("sha1").update(Wf.alloc(0)).digest(), i = n.length;
    if (e[0] !== 0)
      throw new Error("decryption error");
    var o2 = e.slice(1, i + 1), p3 = e.slice(i + 1), y4 = Yl(o2, Xl(p3, i)), w2 = Yl(p3, Xl(y4, r - i - 1));
    if (k8(n, w2.slice(0, i)))
      throw new Error("decryption error");
    for (var x = i; w2[x] === 0; )
      x++;
    if (w2[x++] !== 1)
      throw new Error("decryption error");
    return w2.slice(x);
  }
  function I8(t, e, r) {
    for (var n = e.slice(0, 2), i = 2, o2 = 0; e[i++] !== 0; )
      if (i >= e.length) {
        o2++;
        break;
      }
    var p3 = e.slice(2, i - 1);
    if ((n.toString("hex") !== "0002" && !r || n.toString("hex") !== "0001" && r) && o2++, p3.length < 8 && o2++, o2)
      throw new Error("decryption error");
    return e.slice(i);
  }
  function k8(t, e) {
    t = Wf.from(t), e = Wf.from(e);
    var r = 0, n = t.length;
    t.length !== e.length && (r++, n = Math.min(t.length, e.length));
    for (var i = -1; ++i < n; )
      r += t[i] ^ e[i];
    return r;
  }
});
var e1 = k2((ki2) => {
  ki2.publicEncrypt = Gl();
  ki2.privateDecrypt = Ql();
  ki2.privateEncrypt = function(e, r) {
    return ki2.publicEncrypt(e, r, true);
  };
  ki2.publicDecrypt = function(e, r) {
    return ki2.privateDecrypt(e, r, true);
  };
});
var u1 = k2((Vf) => {
  "use strict";
  function t1() {
    throw new Error(`secure random number generation not supported by this browser
use chrome, FireFox or Internet Explorer 11`);
  }
  var i1 = Ae(), r1 = fi(), f1 = i1.Buffer, n1 = i1.kMaxLength, Cs = __global$.crypto || __global$.msCrypto, a1 = Math.pow(2, 32) - 1;
  function s1(t, e) {
    if (typeof t != "number" || t !== t)
      throw new TypeError("offset must be a number");
    if (t > a1 || t < 0)
      throw new TypeError("offset must be a uint32");
    if (t > n1 || t > e)
      throw new RangeError("offset out of range");
  }
  function o1(t, e, r) {
    if (typeof t != "number" || t !== t)
      throw new TypeError("size must be a number");
    if (t > a1 || t < 0)
      throw new TypeError("size must be a uint32");
    if (t + e > r || t > n1)
      throw new RangeError("buffer too small");
  }
  Cs && Cs.getRandomValues || !process_default.browser ? (Vf.randomFill = D8, Vf.randomFillSync = P8) : (Vf.randomFill = t1, Vf.randomFillSync = t1);
  function D8(t, e, r, n) {
    if (!f1.isBuffer(t) && !(t instanceof __global$.Uint8Array))
      throw new TypeError('"buf" argument must be a Buffer or Uint8Array');
    if (typeof e == "function")
      n = e, e = 0, r = t.length;
    else if (typeof r == "function")
      n = r, r = t.length - e;
    else if (typeof n != "function")
      throw new TypeError('"cb" argument must be a function');
    return s1(e, t.length), o1(r, e, t.length), h1(t, e, r, n);
  }
  function h1(t, e, r, n) {
    if (process_default.browser) {
      var i = t.buffer, o2 = new Uint8Array(i, e, r);
      if (Cs.getRandomValues(o2), n) {
        process_default.nextTick(function() {
          n(null, t);
        });
        return;
      }
      return t;
    }
    if (n) {
      r1(r, function(y4, w2) {
        if (y4)
          return n(y4);
        w2.copy(t, e), n(null, t);
      });
      return;
    }
    var p3 = r1(r);
    return p3.copy(t, e), t;
  }
  function P8(t, e, r) {
    if (typeof e > "u" && (e = 0), !f1.isBuffer(t) && !(t instanceof __global$.Uint8Array))
      throw new TypeError('"buf" argument must be a Buffer or Uint8Array');
    return s1(e, t.length), r === void 0 && (r = t.length - e), o1(r, e, t.length), h1(t, e, r);
  }
});
var Ns = k2((Se2) => {
  "use strict";
  Se2.randomBytes = Se2.rng = Se2.pseudoRandomBytes = Se2.prng = fi();
  Se2.createHash = Se2.Hash = Ni();
  Se2.createHmac = Se2.Hmac = t0();
  var T8 = Bh(), C8 = Object.keys(T8), N8 = ["sha1", "sha224", "sha256", "sha384", "sha512", "md5", "rmd160"].concat(C8);
  Se2.getHashes = function() {
    return N8;
  };
  var d1 = d0();
  Se2.pbkdf2 = d1.pbkdf2;
  Se2.pbkdf2Sync = d1.pbkdf2Sync;
  var ur2 = Yu();
  Se2.Cipher = ur2.Cipher;
  Se2.createCipher = ur2.createCipher;
  Se2.Cipheriv = ur2.Cipheriv;
  Se2.createCipheriv = ur2.createCipheriv;
  Se2.Decipher = ur2.Decipher;
  Se2.createDecipher = ur2.createDecipher;
  Se2.Decipheriv = ur2.Decipheriv;
  Se2.createDecipheriv = ur2.createDecipheriv;
  Se2.getCiphers = ur2.getCiphers;
  Se2.listCiphers = ur2.listCiphers;
  var Zf = hd();
  Se2.DiffieHellmanGroup = Zf.DiffieHellmanGroup;
  Se2.createDiffieHellmanGroup = Zf.createDiffieHellmanGroup;
  Se2.getDiffieHellman = Zf.getDiffieHellman;
  Se2.createDiffieHellman = Zf.createDiffieHellman;
  Se2.DiffieHellman = Zf.DiffieHellman;
  var ma = Ol();
  Se2.createSign = ma.createSign;
  Se2.Sign = ma.Sign;
  Se2.createVerify = ma.createVerify;
  Se2.Verify = ma.Verify;
  Se2.createECDH = Ul();
  var ga = e1();
  Se2.publicEncrypt = ga.publicEncrypt;
  Se2.privateEncrypt = ga.privateEncrypt;
  Se2.publicDecrypt = ga.publicDecrypt;
  Se2.privateDecrypt = ga.privateDecrypt;
  var c1 = u1();
  Se2.randomFill = c1.randomFill;
  Se2.randomFillSync = c1.randomFillSync;
  Se2.createCredentials = function() {
    throw new Error(["sorry, createCredentials is not implemented yet", "we accept pull requests", "https://github.com/crypto-browserify/crypto-browserify"].join(`
`));
  };
  Se2.constants = { DH_CHECK_P_NOT_SAFE_PRIME: 2, DH_CHECK_P_NOT_PRIME: 1, DH_UNABLE_TO_CHECK_GENERATOR: 4, DH_NOT_SUITABLE_GENERATOR: 8, NPN_ENABLED: 1, ALPN_ENABLED: 1, RSA_PKCS1_PADDING: 1, RSA_SSLV23_PADDING: 2, RSA_NO_PADDING: 3, RSA_PKCS1_OAEP_PADDING: 4, RSA_X931_PADDING: 5, RSA_PKCS1_PSS_PADDING: 6, POINT_CONVERSION_COMPRESSED: 2, POINT_CONVERSION_UNCOMPRESSED: 4, POINT_CONVERSION_HYBRID: 6 };
});
var l1 = Os(Ns());
var v1 = Os(Ns());
var { randomBytes: x7, rng: M7, pseudoRandomBytes: S7, prng: E7, createHash: A7, Hash: q7, createHmac: B7, Hmac: R7, getHashes: I7, pbkdf2: k7, pbkdf2Sync: D7, Cipher: P7, createCipher: T7, Cipheriv: C7, createCipheriv: N7, Decipher: L7, createDecipher: O7, Decipheriv: z7, createDecipheriv: U7, getCiphers: H7, listCiphers: F7, DiffieHellmanGroup: K7, createDiffieHellmanGroup: j7, getDiffieHellman: W7, createDiffieHellman: V7, DiffieHellman: Z7, createSign: G7, Sign: X7, createVerify: Y7, Verify: J7, createECDH: $7, publicEncrypt: Q7, privateEncrypt: e9, publicDecrypt: t9, privateDecrypt: r9, randomFill: i9, randomFillSync: f9, createCredentials: n9, constants: a9 } = v1;
var { default: L8, ...O8 } = v1;
var s9 = l1.default ?? L8 ?? O8;

// deno:file:///Users/mcharlton/OtherCode/deno-web-push/src/crypto.ts
var crypto_default2 = crypto_browserify_bundle_exports;

// deno:https://deno.land/std@0.141.0/node/internal/error_codes.ts
var codes2 = {};

// deno:https://deno.land/std@0.141.0/node/internal_binding/types.ts
var types_exports3 = {};
__export(types_exports3, {
  default: () => types_default3,
  isAnyArrayBuffer: () => isAnyArrayBuffer3,
  isArgumentsObject: () => isArgumentsObject3,
  isArrayBuffer: () => isArrayBuffer3,
  isAsyncFunction: () => isAsyncFunction3,
  isBigIntObject: () => isBigIntObject3,
  isBooleanObject: () => isBooleanObject3,
  isBoxedPrimitive: () => isBoxedPrimitive3,
  isDataView: () => isDataView3,
  isDate: () => isDate4,
  isGeneratorFunction: () => isGeneratorFunction3,
  isGeneratorObject: () => isGeneratorObject3,
  isMap: () => isMap3,
  isMapIterator: () => isMapIterator3,
  isModuleNamespaceObject: () => isModuleNamespaceObject3,
  isNativeError: () => isNativeError3,
  isNumberObject: () => isNumberObject3,
  isPromise: () => isPromise3,
  isRegExp: () => isRegExp4,
  isSet: () => isSet3,
  isSetIterator: () => isSetIterator3,
  isSharedArrayBuffer: () => isSharedArrayBuffer3,
  isStringObject: () => isStringObject3,
  isSymbolObject: () => isSymbolObject3,
  isWeakMap: () => isWeakMap3,
  isWeakSet: () => isWeakSet3
});
var _toString3 = Object.prototype.toString;
var _isObjectLike3 = (value) => value !== null && typeof value === "object";
var _isFunctionLike2 = (value) => value !== null && typeof value === "function";
function isAnyArrayBuffer3(value) {
  return _isObjectLike3(value) && (_toString3.call(value) === "[object ArrayBuffer]" || _toString3.call(value) === "[object SharedArrayBuffer]");
}
function isArgumentsObject3(value) {
  return _isObjectLike3(value) && _toString3.call(value) === "[object Arguments]";
}
function isArrayBuffer3(value) {
  return _isObjectLike3(value) && _toString3.call(value) === "[object ArrayBuffer]";
}
function isAsyncFunction3(value) {
  return _isFunctionLike2(value) && _toString3.call(value) === "[object AsyncFunction]";
}
function isBooleanObject3(value) {
  return _isObjectLike3(value) && _toString3.call(value) === "[object Boolean]";
}
function isBoxedPrimitive3(value) {
  return isBooleanObject3(value) || isStringObject3(value) || isNumberObject3(value) || isSymbolObject3(value) || isBigIntObject3(value);
}
function isDataView3(value) {
  return _isObjectLike3(value) && _toString3.call(value) === "[object DataView]";
}
function isDate4(value) {
  return _isObjectLike3(value) && _toString3.call(value) === "[object Date]";
}
function isGeneratorFunction3(value) {
  return _isFunctionLike2(value) && _toString3.call(value) === "[object GeneratorFunction]";
}
function isGeneratorObject3(value) {
  return _isObjectLike3(value) && _toString3.call(value) === "[object Generator]";
}
function isMap3(value) {
  return _isObjectLike3(value) && _toString3.call(value) === "[object Map]";
}
function isMapIterator3(value) {
  return _isObjectLike3(value) && _toString3.call(value) === "[object Map Iterator]";
}
function isModuleNamespaceObject3(value) {
  return _isObjectLike3(value) && _toString3.call(value) === "[object Module]";
}
function isNativeError3(value) {
  return _isObjectLike3(value) && _toString3.call(value) === "[object Error]";
}
function isNumberObject3(value) {
  return _isObjectLike3(value) && _toString3.call(value) === "[object Number]";
}
function isBigIntObject3(value) {
  return _isObjectLike3(value) && _toString3.call(value) === "[object BigInt]";
}
function isPromise3(value) {
  return _isObjectLike3(value) && _toString3.call(value) === "[object Promise]";
}
function isRegExp4(value) {
  return _isObjectLike3(value) && _toString3.call(value) === "[object RegExp]";
}
function isSet3(value) {
  return _isObjectLike3(value) && _toString3.call(value) === "[object Set]";
}
function isSetIterator3(value) {
  return _isObjectLike3(value) && _toString3.call(value) === "[object Set Iterator]";
}
function isSharedArrayBuffer3(value) {
  return _isObjectLike3(value) && _toString3.call(value) === "[object SharedArrayBuffer]";
}
function isStringObject3(value) {
  return _isObjectLike3(value) && _toString3.call(value) === "[object String]";
}
function isSymbolObject3(value) {
  return _isObjectLike3(value) && _toString3.call(value) === "[object Symbol]";
}
function isWeakMap3(value) {
  return _isObjectLike3(value) && _toString3.call(value) === "[object WeakMap]";
}
function isWeakSet3(value) {
  return _isObjectLike3(value) && _toString3.call(value) === "[object WeakSet]";
}
var types_default3 = {
  isAsyncFunction: isAsyncFunction3,
  isGeneratorFunction: isGeneratorFunction3,
  isAnyArrayBuffer: isAnyArrayBuffer3,
  isArrayBuffer: isArrayBuffer3,
  isArgumentsObject: isArgumentsObject3,
  isBoxedPrimitive: isBoxedPrimitive3,
  isDataView: isDataView3,
  isMap: isMap3,
  isMapIterator: isMapIterator3,
  isModuleNamespaceObject: isModuleNamespaceObject3,
  isNativeError: isNativeError3,
  isPromise: isPromise3,
  isSet: isSet3,
  isSetIterator: isSetIterator3,
  isWeakMap: isWeakMap3,
  isWeakSet: isWeakSet3,
  isRegExp: isRegExp4,
  isDate: isDate4,
  isStringObject: isStringObject3,
  isNumberObject: isNumberObject3,
  isBooleanObject: isBooleanObject3,
  isBigIntObject: isBigIntObject3
};

// deno:https://deno.land/std@0.141.0/node/internal/crypto/constants.ts
var kHandle2 = Symbol("kHandle");
var kKeyObject2 = Symbol("kKeyObject");

// deno:https://deno.land/std@0.141.0/node/internal/crypto/_keys.ts
var kKeyType2 = Symbol("kKeyType");

// deno:https://deno.land/std@0.141.0/node/internal/util/types.ts
var _toString4 = Object.prototype.toString;
var _isObjectLike4 = (value) => value !== null && typeof value === "object";
function isArrayBufferView2(value) {
  return ArrayBuffer.isView(value);
}
function isUint8Array2(value) {
  return _isObjectLike4(value) && _toString4.call(value) === "[object Uint8Array]";
}
var {
  isDate: isDate5,
  isArgumentsObject: isArgumentsObject4,
  isBigIntObject: isBigIntObject4,
  isBooleanObject: isBooleanObject4,
  isNumberObject: isNumberObject4,
  isStringObject: isStringObject4,
  isSymbolObject: isSymbolObject4,
  isNativeError: isNativeError4,
  isRegExp: isRegExp5,
  isAsyncFunction: isAsyncFunction4,
  isGeneratorFunction: isGeneratorFunction4,
  isGeneratorObject: isGeneratorObject4,
  isPromise: isPromise4,
  isMap: isMap4,
  isSet: isSet4,
  isMapIterator: isMapIterator4,
  isSetIterator: isSetIterator4,
  isWeakMap: isWeakMap4,
  isWeakSet: isWeakSet4,
  isArrayBuffer: isArrayBuffer4,
  isDataView: isDataView4,
  isSharedArrayBuffer: isSharedArrayBuffer4,
  isModuleNamespaceObject: isModuleNamespaceObject4,
  isAnyArrayBuffer: isAnyArrayBuffer4,
  isBoxedPrimitive: isBoxedPrimitive4
} = types_exports3;

// deno:https://deno.land/std@0.141.0/node/internal/hide_stack_frames.ts
function hideStackFrames2(fn) {
  const hidden = "__node_internal_" + fn.name;
  Object.defineProperty(fn, "name", { value: hidden });
  return fn;
}

// deno:https://deno.land/std@0.141.0/node/internal/normalize_encoding.mjs
function normalizeEncoding4(enc) {
  if (enc == null || enc === "utf8" || enc === "utf-8")
    return "utf8";
  return slowCases3(enc);
}
function slowCases3(enc) {
  switch (enc.length) {
    case 4:
      if (enc === "UTF8")
        return "utf8";
      if (enc === "ucs2" || enc === "UCS2")
        return "utf16le";
      enc = `${enc}`.toLowerCase();
      if (enc === "utf8")
        return "utf8";
      if (enc === "ucs2")
        return "utf16le";
      break;
    case 3:
      if (enc === "hex" || enc === "HEX" || `${enc}`.toLowerCase() === "hex") {
        return "hex";
      }
      break;
    case 5:
      if (enc === "ascii")
        return "ascii";
      if (enc === "ucs-2")
        return "utf16le";
      if (enc === "UTF-8")
        return "utf8";
      if (enc === "ASCII")
        return "ascii";
      if (enc === "UCS-2")
        return "utf16le";
      enc = `${enc}`.toLowerCase();
      if (enc === "utf-8")
        return "utf8";
      if (enc === "ascii")
        return "ascii";
      if (enc === "ucs-2")
        return "utf16le";
      break;
    case 6:
      if (enc === "base64")
        return "base64";
      if (enc === "latin1" || enc === "binary")
        return "latin1";
      if (enc === "BASE64")
        return "base64";
      if (enc === "LATIN1" || enc === "BINARY")
        return "latin1";
      enc = `${enc}`.toLowerCase();
      if (enc === "base64")
        return "base64";
      if (enc === "latin1" || enc === "binary")
        return "latin1";
      break;
    case 7:
      if (enc === "utf16le" || enc === "UTF16LE" || `${enc}`.toLowerCase() === "utf16le") {
        return "utf16le";
      }
      break;
    case 8:
      if (enc === "utf-16le" || enc === "UTF-16LE" || `${enc}`.toLowerCase() === "utf-16le") {
        return "utf16le";
      }
      break;
    case 9:
      if (enc === "base64url" || enc === "BASE64URL" || `${enc}`.toLowerCase() === "base64url") {
        return "base64url";
      }
      break;
    default:
      if (enc === "")
        return "utf8";
  }
}

// deno:https://deno.land/std@0.141.0/node/internal/validators.mjs
function isInt322(value) {
  return value === (value | 0);
}
function isUint322(value) {
  return value === value >>> 0;
}
var validateBuffer2 = hideStackFrames2((buffer, name = "buffer") => {
  if (!isArrayBufferView2(buffer)) {
    throw new codes2.ERR_INVALID_ARG_TYPE(name, ["Buffer", "TypedArray", "DataView"], buffer);
  }
});
var validateInteger2 = hideStackFrames2((value, name, min4 = Number.MIN_SAFE_INTEGER, max2 = Number.MAX_SAFE_INTEGER) => {
  if (typeof value !== "number") {
    throw new codes2.ERR_INVALID_ARG_TYPE(name, "number", value);
  }
  if (!Number.isInteger(value)) {
    throw new codes2.ERR_OUT_OF_RANGE(name, "an integer", value);
  }
  if (value < min4 || value > max2) {
    throw new codes2.ERR_OUT_OF_RANGE(name, `>= ${min4} && <= ${max2}`, value);
  }
});
var validateObject2 = hideStackFrames2((value, name, options) => {
  const useDefaultOptions = options == null;
  const allowArray = useDefaultOptions ? false : options.allowArray;
  const allowFunction = useDefaultOptions ? false : options.allowFunction;
  const nullable = useDefaultOptions ? false : options.nullable;
  if (!nullable && value === null || !allowArray && Array.isArray(value) || typeof value !== "object" && (!allowFunction || typeof value !== "function")) {
    throw new codes2.ERR_INVALID_ARG_TYPE(name, "Object", value);
  }
});
var validateInt322 = hideStackFrames2((value, name, min4 = -2147483648, max2 = 2147483647) => {
  if (!isInt322(value)) {
    if (typeof value !== "number") {
      throw new codes2.ERR_INVALID_ARG_TYPE(name, "number", value);
    }
    if (!Number.isInteger(value)) {
      throw new codes2.ERR_OUT_OF_RANGE(name, "an integer", value);
    }
    throw new codes2.ERR_OUT_OF_RANGE(name, `>= ${min4} && <= ${max2}`, value);
  }
  if (value < min4 || value > max2) {
    throw new codes2.ERR_OUT_OF_RANGE(name, `>= ${min4} && <= ${max2}`, value);
  }
});
var validateUint322 = hideStackFrames2((value, name, positive) => {
  if (!isUint322(value)) {
    if (typeof value !== "number") {
      throw new codes2.ERR_INVALID_ARG_TYPE(name, "number", value);
    }
    if (!Number.isInteger(value)) {
      throw new codes2.ERR_OUT_OF_RANGE(name, "an integer", value);
    }
    const min4 = positive ? 1 : 0;
    throw new codes2.ERR_OUT_OF_RANGE(name, `>= ${min4} && < 4294967296`, value);
  }
  if (positive && value === 0) {
    throw new codes2.ERR_OUT_OF_RANGE(name, ">= 1 && < 4294967296", value);
  }
});
var validateOneOf2 = hideStackFrames2((value, name, oneOf) => {
  if (!Array.prototype.includes.call(oneOf, value)) {
    const allowed = Array.prototype.join.call(Array.prototype.map.call(oneOf, (v2) => typeof v2 === "string" ? `'${v2}'` : String(v2)), ", ");
    const reason = "must be one of: " + allowed;
    throw new codes2.ERR_INVALID_ARG_VALUE(name, value, reason);
  }
});
var validateCallback2 = hideStackFrames2((callback) => {
  if (typeof callback !== "function") {
    throw new codes2.ERR_INVALID_CALLBACK(callback);
  }
});
var validateAbortSignal3 = hideStackFrames2((signal, name) => {
  if (signal !== void 0 && (signal === null || typeof signal !== "object" || !("aborted" in signal))) {
    throw new codes2.ERR_INVALID_ARG_TYPE(name, "AbortSignal", signal);
  }
});
var validateFunction2 = hideStackFrames2((value, name) => {
  if (typeof value !== "function") {
    throw new codes2.ERR_INVALID_ARG_TYPE(name, "Function", value);
  }
});
var validateArray2 = hideStackFrames2((value, name, minLength = 0) => {
  if (!Array.isArray(value)) {
    throw new codes2.ERR_INVALID_ARG_TYPE(name, "Array", value);
  }
  if (value.length < minLength) {
    const reason = `must be longer than ${minLength}`;
    throw new codes2.ERR_INVALID_ARG_VALUE(name, value, reason);
  }
});

// deno:https://deno.land/std@0.141.0/node/internal/util.mjs
var customInspectSymbol4 = Symbol.for("nodejs.util.inspect.custom");
var kEnumerableProperty2 = /* @__PURE__ */ Object.create(null);
kEnumerableProperty2.enumerable = true;
var kCustomPromisifiedSymbol2 = Symbol.for("nodejs.util.promisify.custom");
var kCustomPromisifyArgsSymbol2 = Symbol.for("nodejs.util.promisify.customArgs");
function promisify2(original) {
  validateFunction2(original, "original");
  if (original[kCustomPromisifiedSymbol2]) {
    const fn2 = original[kCustomPromisifiedSymbol2];
    validateFunction2(fn2, "util.promisify.custom");
    return Object.defineProperty(fn2, kCustomPromisifiedSymbol2, {
      value: fn2,
      enumerable: false,
      writable: false,
      configurable: true
    });
  }
  const argumentNames = original[kCustomPromisifyArgsSymbol2];
  function fn(...args) {
    return new Promise((resolve7, reject) => {
      args.push((err, ...values) => {
        if (err) {
          return reject(err);
        }
        if (argumentNames !== void 0 && values.length > 1) {
          const obj2 = {};
          for (let i = 0; i < argumentNames.length; i++) {
            obj2[argumentNames[i]] = values[i];
          }
          resolve7(obj2);
        } else {
          resolve7(values[0]);
        }
      });
      Reflect.apply(original, this, args);
    });
  }
  Object.setPrototypeOf(fn, Object.getPrototypeOf(original));
  Object.defineProperty(fn, kCustomPromisifiedSymbol2, {
    value: fn,
    enumerable: false,
    writable: false,
    configurable: true
  });
  return Object.defineProperties(fn, Object.getOwnPropertyDescriptors(original));
}
promisify2.custom = kCustomPromisifiedSymbol2;

// deno:https://deno.land/std@0.141.0/node/internal_binding/_node.ts
var Encodings2 = /* @__PURE__ */ ((Encodings4) => {
  Encodings4[Encodings4["ASCII"] = 0] = "ASCII";
  Encodings4[Encodings4["UTF8"] = 1] = "UTF8";
  Encodings4[Encodings4["BASE64"] = 2] = "BASE64";
  Encodings4[Encodings4["UCS2"] = 3] = "UCS2";
  Encodings4[Encodings4["BINARY"] = 4] = "BINARY";
  Encodings4[Encodings4["HEX"] = 5] = "HEX";
  Encodings4[Encodings4["BUFFER"] = 6] = "BUFFER";
  Encodings4[Encodings4["BASE64URL"] = 7] = "BASE64URL";
  Encodings4[Encodings4["LATIN1"] = 4] = "LATIN1";
  return Encodings4;
})(Encodings2 || {});

// deno:https://deno.land/std@0.141.0/node/internal_binding/string_decoder.ts
var encodings2 = [];
encodings2[0 /* ASCII */] = "ascii";
encodings2[2 /* BASE64 */] = "base64";
encodings2[7 /* BASE64URL */] = "base64url";
encodings2[6 /* BUFFER */] = "buffer";
encodings2[5 /* HEX */] = "hex";
encodings2[4 /* LATIN1 */] = "latin1";
encodings2[3 /* UCS2 */] = "utf16le";
encodings2[1 /* UTF8 */] = "utf8";

// deno:https://deno.land/std@0.141.0/bytes/mod.ts
function indexOfNeedle2(source, needle, start = 0) {
  if (start >= source.length) {
    return -1;
  }
  if (start < 0) {
    start = Math.max(0, source.length + start);
  }
  const s = needle[0];
  for (let i = start; i < source.length; i++) {
    if (source[i] !== s)
      continue;
    const pin = i;
    let matched = 1;
    let j2 = i;
    while (matched < needle.length) {
      j2++;
      if (source[j2] !== needle[j2 - pin]) {
        break;
      }
      matched++;
    }
    if (matched === needle.length) {
      return pin;
    }
  }
  return -1;
}

// deno:https://deno.land/std@0.141.0/node/internal_binding/buffer.ts
function numberToBytes2(n) {
  if (n === 0)
    return new Uint8Array([0]);
  const bytes = [];
  bytes.unshift(n & 255);
  while (n >= 256) {
    n = n >>> 8;
    bytes.unshift(n & 255);
  }
  return new Uint8Array(bytes);
}
function findLastIndex2(targetBuffer, buffer, offset) {
  offset = offset > targetBuffer.length ? targetBuffer.length : offset;
  const searchableBuffer = targetBuffer.slice(0, offset + buffer.length);
  const searchableBufferLastIndex = searchableBuffer.length - 1;
  const bufferLastIndex = buffer.length - 1;
  let lastMatchIndex = -1;
  let matches = 0;
  let index = -1;
  for (let x = 0; x <= searchableBufferLastIndex; x++) {
    if (searchableBuffer[searchableBufferLastIndex - x] === buffer[bufferLastIndex - matches]) {
      if (lastMatchIndex === -1) {
        lastMatchIndex = x;
      }
      matches++;
    } else {
      matches = 0;
      if (lastMatchIndex !== -1) {
        x = lastMatchIndex + 1;
        lastMatchIndex = -1;
      }
      continue;
    }
    if (matches === buffer.length) {
      index = x;
      break;
    }
  }
  if (index === -1)
    return index;
  return searchableBufferLastIndex - index;
}
function indexOfBuffer2(targetBuffer, buffer, byteOffset, encoding, forwardDirection) {
  if (!Encodings2[encoding] === void 0) {
    throw new Error(`Unknown encoding code ${encoding}`);
  }
  if (!forwardDirection) {
    if (byteOffset < 0) {
      byteOffset = targetBuffer.length + byteOffset;
    }
    if (buffer.length === 0) {
      return byteOffset <= targetBuffer.length ? byteOffset : targetBuffer.length;
    }
    return findLastIndex2(targetBuffer, buffer, byteOffset);
  }
  if (buffer.length === 0) {
    return byteOffset <= targetBuffer.length ? byteOffset : targetBuffer.length;
  }
  return indexOfNeedle2(targetBuffer, buffer, byteOffset);
}
function indexOfNumber2(targetBuffer, number, byteOffset, forwardDirection) {
  const bytes = numberToBytes2(number);
  if (bytes.length > 1) {
    throw new Error("Multi byte number search is not supported");
  }
  return indexOfBuffer2(targetBuffer, numberToBytes2(number), byteOffset, 1 /* UTF8 */, forwardDirection);
}

// deno:https://deno.land/std@0.141.0/encoding/base64.ts
var base64abc2 = [
  "A",
  "B",
  "C",
  "D",
  "E",
  "F",
  "G",
  "H",
  "I",
  "J",
  "K",
  "L",
  "M",
  "N",
  "O",
  "P",
  "Q",
  "R",
  "S",
  "T",
  "U",
  "V",
  "W",
  "X",
  "Y",
  "Z",
  "a",
  "b",
  "c",
  "d",
  "e",
  "f",
  "g",
  "h",
  "i",
  "j",
  "k",
  "l",
  "m",
  "n",
  "o",
  "p",
  "q",
  "r",
  "s",
  "t",
  "u",
  "v",
  "w",
  "x",
  "y",
  "z",
  "0",
  "1",
  "2",
  "3",
  "4",
  "5",
  "6",
  "7",
  "8",
  "9",
  "+",
  "/"
];
function encode9(data) {
  const uint8 = typeof data === "string" ? new TextEncoder().encode(data) : data instanceof Uint8Array ? data : new Uint8Array(data);
  let result = "", i;
  const l = uint8.length;
  for (i = 2; i < l; i += 3) {
    result += base64abc2[uint8[i - 2] >> 2];
    result += base64abc2[(uint8[i - 2] & 3) << 4 | uint8[i - 1] >> 4];
    result += base64abc2[(uint8[i - 1] & 15) << 2 | uint8[i] >> 6];
    result += base64abc2[uint8[i] & 63];
  }
  if (i === l + 1) {
    result += base64abc2[uint8[i - 2] >> 2];
    result += base64abc2[(uint8[i - 2] & 3) << 4];
    result += "==";
  }
  if (i === l) {
    result += base64abc2[uint8[i - 2] >> 2];
    result += base64abc2[(uint8[i - 2] & 3) << 4 | uint8[i - 1] >> 4];
    result += base64abc2[(uint8[i - 1] & 15) << 2];
    result += "=";
  }
  return result;
}
function decode7(b64) {
  const binString = atob(b64);
  const size = binString.length;
  const bytes = new Uint8Array(size);
  for (let i = 0; i < size; i++) {
    bytes[i] = binString.charCodeAt(i);
  }
  return bytes;
}

// deno:https://deno.land/std@0.141.0/encoding/base64url.ts
function addPaddingToBase64url2(base64url) {
  if (base64url.length % 4 === 2)
    return base64url + "==";
  if (base64url.length % 4 === 3)
    return base64url + "=";
  if (base64url.length % 4 === 1) {
    throw new TypeError("Illegal base64url string!");
  }
  return base64url;
}
function convertBase64urlToBase642(b64url) {
  if (!/^[-_A-Z0-9]*?={0,2}$/i.test(b64url)) {
    throw new TypeError("Failed to decode base64url: invalid character");
  }
  return addPaddingToBase64url2(b64url).replace(/\-/g, "+").replace(/_/g, "/");
}
function convertBase64ToBase64url2(b64) {
  return b64.replace(/=/g, "").replace(/\+/g, "-").replace(/\//g, "_");
}
function encode10(data) {
  return convertBase64ToBase64url2(encode9(data));
}
function decode8(b64url) {
  return decode7(convertBase64urlToBase642(b64url));
}

// deno:https://deno.land/std@0.141.0/node/internal_binding/_utils.ts
function asciiToBytes2(str) {
  const byteArray = [];
  for (let i = 0; i < str.length; ++i) {
    byteArray.push(str.charCodeAt(i) & 255);
  }
  return new Uint8Array(byteArray);
}
function base64ToBytes2(str) {
  str = base64clean2(str);
  str = str.replaceAll("-", "+").replaceAll("_", "/");
  return decode7(str);
}
var INVALID_BASE64_RE2 = /[^+/0-9A-Za-z-_]/g;
function base64clean2(str) {
  str = str.split("=")[0];
  str = str.trim().replace(INVALID_BASE64_RE2, "");
  if (str.length < 2)
    return "";
  while (str.length % 4 !== 0) {
    str = str + "=";
  }
  return str;
}
function base64UrlToBytes2(str) {
  str = base64clean2(str);
  str = str.replaceAll("+", "-").replaceAll("/", "_");
  return decode8(str);
}
function hexToBytes2(str) {
  const byteArray = new Uint8Array(Math.floor((str || "").length / 2));
  let i;
  for (i = 0; i < byteArray.length; i++) {
    const a = Number.parseInt(str[i * 2], 16);
    const b2 = Number.parseInt(str[i * 2 + 1], 16);
    if (Number.isNaN(a) && Number.isNaN(b2)) {
      break;
    }
    byteArray[i] = a << 4 | b2;
  }
  return new Uint8Array(i === byteArray.length ? byteArray : byteArray.slice(0, i));
}
function utf16leToBytes2(str, units) {
  let c5, hi2, lo3;
  const byteArray = [];
  for (let i = 0; i < str.length; ++i) {
    if ((units -= 2) < 0) {
      break;
    }
    c5 = str.charCodeAt(i);
    hi2 = c5 >> 8;
    lo3 = c5 % 256;
    byteArray.push(lo3);
    byteArray.push(hi2);
  }
  return new Uint8Array(byteArray);
}
function bytesToAscii2(bytes) {
  let ret = "";
  for (let i = 0; i < bytes.length; ++i) {
    ret += String.fromCharCode(bytes[i] & 127);
  }
  return ret;
}
function bytesToUtf16le2(bytes) {
  let res = "";
  for (let i = 0; i < bytes.length - 1; i += 2) {
    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);
  }
  return res;
}

// deno:https://deno.land/std@0.141.0/node/internal/buffer.mjs
var utf8Encoder2 = new TextEncoder();
var float32Array2 = new Float32Array(1);
var uInt8Float32Array2 = new Uint8Array(float32Array2.buffer);
var float64Array2 = new Float64Array(1);
var uInt8Float64Array2 = new Uint8Array(float64Array2.buffer);
float32Array2[0] = -1;
var bigEndian2 = uInt8Float32Array2[3] === 0;
function readUInt48LE2(buf, offset = 0) {
  validateNumber2(offset, "offset");
  const first = buf[offset];
  const last = buf[offset + 5];
  if (first === void 0 || last === void 0) {
    boundsError2(offset, buf.length - 6);
  }
  return first + buf[++offset] * 2 ** 8 + buf[++offset] * 2 ** 16 + buf[++offset] * 2 ** 24 + (buf[++offset] + last * 2 ** 8) * 2 ** 32;
}
function readUInt40LE2(buf, offset = 0) {
  validateNumber2(offset, "offset");
  const first = buf[offset];
  const last = buf[offset + 4];
  if (first === void 0 || last === void 0) {
    boundsError2(offset, buf.length - 5);
  }
  return first + buf[++offset] * 2 ** 8 + buf[++offset] * 2 ** 16 + buf[++offset] * 2 ** 24 + last * 2 ** 32;
}
function readUInt24LE2(buf, offset = 0) {
  validateNumber2(offset, "offset");
  const first = buf[offset];
  const last = buf[offset + 2];
  if (first === void 0 || last === void 0) {
    boundsError2(offset, buf.length - 3);
  }
  return first + buf[++offset] * 2 ** 8 + last * 2 ** 16;
}
function readUInt48BE2(buf, offset = 0) {
  validateNumber2(offset, "offset");
  const first = buf[offset];
  const last = buf[offset + 5];
  if (first === void 0 || last === void 0) {
    boundsError2(offset, buf.length - 6);
  }
  return (first * 2 ** 8 + buf[++offset]) * 2 ** 32 + buf[++offset] * 2 ** 24 + buf[++offset] * 2 ** 16 + buf[++offset] * 2 ** 8 + last;
}
function readUInt40BE2(buf, offset = 0) {
  validateNumber2(offset, "offset");
  const first = buf[offset];
  const last = buf[offset + 4];
  if (first === void 0 || last === void 0) {
    boundsError2(offset, buf.length - 5);
  }
  return first * 2 ** 32 + buf[++offset] * 2 ** 24 + buf[++offset] * 2 ** 16 + buf[++offset] * 2 ** 8 + last;
}
function readUInt24BE2(buf, offset = 0) {
  validateNumber2(offset, "offset");
  const first = buf[offset];
  const last = buf[offset + 2];
  if (first === void 0 || last === void 0) {
    boundsError2(offset, buf.length - 3);
  }
  return first * 2 ** 16 + buf[++offset] * 2 ** 8 + last;
}
function readUInt16BE2(offset = 0) {
  validateNumber2(offset, "offset");
  const first = this[offset];
  const last = this[offset + 1];
  if (first === void 0 || last === void 0) {
    boundsError2(offset, this.length - 2);
  }
  return first * 2 ** 8 + last;
}
function readUInt32BE2(offset = 0) {
  validateNumber2(offset, "offset");
  const first = this[offset];
  const last = this[offset + 3];
  if (first === void 0 || last === void 0) {
    boundsError2(offset, this.length - 4);
  }
  return first * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + last;
}
function readDoubleBackwards2(buffer, offset = 0) {
  validateNumber2(offset, "offset");
  const first = buffer[offset];
  const last = buffer[offset + 7];
  if (first === void 0 || last === void 0) {
    boundsError2(offset, buffer.length - 8);
  }
  uInt8Float64Array2[7] = first;
  uInt8Float64Array2[6] = buffer[++offset];
  uInt8Float64Array2[5] = buffer[++offset];
  uInt8Float64Array2[4] = buffer[++offset];
  uInt8Float64Array2[3] = buffer[++offset];
  uInt8Float64Array2[2] = buffer[++offset];
  uInt8Float64Array2[1] = buffer[++offset];
  uInt8Float64Array2[0] = last;
  return float64Array2[0];
}
function readDoubleForwards2(buffer, offset = 0) {
  validateNumber2(offset, "offset");
  const first = buffer[offset];
  const last = buffer[offset + 7];
  if (first === void 0 || last === void 0) {
    boundsError2(offset, buffer.length - 8);
  }
  uInt8Float64Array2[0] = first;
  uInt8Float64Array2[1] = buffer[++offset];
  uInt8Float64Array2[2] = buffer[++offset];
  uInt8Float64Array2[3] = buffer[++offset];
  uInt8Float64Array2[4] = buffer[++offset];
  uInt8Float64Array2[5] = buffer[++offset];
  uInt8Float64Array2[6] = buffer[++offset];
  uInt8Float64Array2[7] = last;
  return float64Array2[0];
}
function writeDoubleForwards2(buffer, val, offset = 0) {
  val = +val;
  checkBounds3(buffer, offset, 7);
  float64Array2[0] = val;
  buffer[offset++] = uInt8Float64Array2[0];
  buffer[offset++] = uInt8Float64Array2[1];
  buffer[offset++] = uInt8Float64Array2[2];
  buffer[offset++] = uInt8Float64Array2[3];
  buffer[offset++] = uInt8Float64Array2[4];
  buffer[offset++] = uInt8Float64Array2[5];
  buffer[offset++] = uInt8Float64Array2[6];
  buffer[offset++] = uInt8Float64Array2[7];
  return offset;
}
function writeDoubleBackwards2(buffer, val, offset = 0) {
  val = +val;
  checkBounds3(buffer, offset, 7);
  float64Array2[0] = val;
  buffer[offset++] = uInt8Float64Array2[7];
  buffer[offset++] = uInt8Float64Array2[6];
  buffer[offset++] = uInt8Float64Array2[5];
  buffer[offset++] = uInt8Float64Array2[4];
  buffer[offset++] = uInt8Float64Array2[3];
  buffer[offset++] = uInt8Float64Array2[2];
  buffer[offset++] = uInt8Float64Array2[1];
  buffer[offset++] = uInt8Float64Array2[0];
  return offset;
}
function readFloatBackwards2(buffer, offset = 0) {
  validateNumber2(offset, "offset");
  const first = buffer[offset];
  const last = buffer[offset + 3];
  if (first === void 0 || last === void 0) {
    boundsError2(offset, buffer.length - 4);
  }
  uInt8Float32Array2[3] = first;
  uInt8Float32Array2[2] = buffer[++offset];
  uInt8Float32Array2[1] = buffer[++offset];
  uInt8Float32Array2[0] = last;
  return float32Array2[0];
}
function readFloatForwards2(buffer, offset = 0) {
  validateNumber2(offset, "offset");
  const first = buffer[offset];
  const last = buffer[offset + 3];
  if (first === void 0 || last === void 0) {
    boundsError2(offset, buffer.length - 4);
  }
  uInt8Float32Array2[0] = first;
  uInt8Float32Array2[1] = buffer[++offset];
  uInt8Float32Array2[2] = buffer[++offset];
  uInt8Float32Array2[3] = last;
  return float32Array2[0];
}
function writeFloatForwards2(buffer, val, offset = 0) {
  val = +val;
  checkBounds3(buffer, offset, 3);
  float32Array2[0] = val;
  buffer[offset++] = uInt8Float32Array2[0];
  buffer[offset++] = uInt8Float32Array2[1];
  buffer[offset++] = uInt8Float32Array2[2];
  buffer[offset++] = uInt8Float32Array2[3];
  return offset;
}
function writeFloatBackwards2(buffer, val, offset = 0) {
  val = +val;
  checkBounds3(buffer, offset, 3);
  float32Array2[0] = val;
  buffer[offset++] = uInt8Float32Array2[3];
  buffer[offset++] = uInt8Float32Array2[2];
  buffer[offset++] = uInt8Float32Array2[1];
  buffer[offset++] = uInt8Float32Array2[0];
  return offset;
}
function readInt24LE2(buf, offset = 0) {
  validateNumber2(offset, "offset");
  const first = buf[offset];
  const last = buf[offset + 2];
  if (first === void 0 || last === void 0) {
    boundsError2(offset, buf.length - 3);
  }
  const val = first + buf[++offset] * 2 ** 8 + last * 2 ** 16;
  return val | (val & 2 ** 23) * 510;
}
function readInt40LE2(buf, offset = 0) {
  validateNumber2(offset, "offset");
  const first = buf[offset];
  const last = buf[offset + 4];
  if (first === void 0 || last === void 0) {
    boundsError2(offset, buf.length - 5);
  }
  return (last | (last & 2 ** 7) * 33554430) * 2 ** 32 + first + buf[++offset] * 2 ** 8 + buf[++offset] * 2 ** 16 + buf[++offset] * 2 ** 24;
}
function readInt48LE2(buf, offset = 0) {
  validateNumber2(offset, "offset");
  const first = buf[offset];
  const last = buf[offset + 5];
  if (first === void 0 || last === void 0) {
    boundsError2(offset, buf.length - 6);
  }
  const val = buf[offset + 4] + last * 2 ** 8;
  return (val | (val & 2 ** 15) * 131070) * 2 ** 32 + first + buf[++offset] * 2 ** 8 + buf[++offset] * 2 ** 16 + buf[++offset] * 2 ** 24;
}
function readInt24BE2(buf, offset = 0) {
  validateNumber2(offset, "offset");
  const first = buf[offset];
  const last = buf[offset + 2];
  if (first === void 0 || last === void 0) {
    boundsError2(offset, buf.length - 3);
  }
  const val = first * 2 ** 16 + buf[++offset] * 2 ** 8 + last;
  return val | (val & 2 ** 23) * 510;
}
function readInt48BE2(buf, offset = 0) {
  validateNumber2(offset, "offset");
  const first = buf[offset];
  const last = buf[offset + 5];
  if (first === void 0 || last === void 0) {
    boundsError2(offset, buf.length - 6);
  }
  const val = buf[++offset] + first * 2 ** 8;
  return (val | (val & 2 ** 15) * 131070) * 2 ** 32 + buf[++offset] * 2 ** 24 + buf[++offset] * 2 ** 16 + buf[++offset] * 2 ** 8 + last;
}
function readInt40BE2(buf, offset = 0) {
  validateNumber2(offset, "offset");
  const first = buf[offset];
  const last = buf[offset + 4];
  if (first === void 0 || last === void 0) {
    boundsError2(offset, buf.length - 5);
  }
  return (first | (first & 2 ** 7) * 33554430) * 2 ** 32 + buf[++offset] * 2 ** 24 + buf[++offset] * 2 ** 16 + buf[++offset] * 2 ** 8 + last;
}
function byteLengthUtf82(str) {
  return utf8Encoder2.encode(str).length;
}
function base64ByteLength2(str, bytes) {
  if (str.charCodeAt(bytes - 1) === 61) {
    bytes--;
  }
  if (bytes > 1 && str.charCodeAt(bytes - 1) === 61) {
    bytes--;
  }
  return bytes * 3 >>> 2;
}
var encodingsMap2 = /* @__PURE__ */ Object.create(null);
for (let i = 0; i < encodings2.length; ++i) {
  encodingsMap2[encodings2[i]] = i;
}
var encodingOps2 = {
  ascii: {
    byteLength: (string) => string.length,
    encoding: "ascii",
    encodingVal: encodingsMap2.ascii,
    indexOf: (buf, val, byteOffset, dir) => indexOfBuffer2(buf, asciiToBytes2(val), byteOffset, encodingsMap2.ascii, dir),
    slice: (buf, start, end) => buf.asciiSlice(start, end),
    write: (buf, string, offset, len) => buf.asciiWrite(string, offset, len)
  },
  base64: {
    byteLength: (string) => base64ByteLength2(string, string.length),
    encoding: "base64",
    encodingVal: encodingsMap2.base64,
    indexOf: (buf, val, byteOffset, dir) => indexOfBuffer2(buf, base64ToBytes2(val), byteOffset, encodingsMap2.base64, dir),
    slice: (buf, start, end) => buf.base64Slice(start, end),
    write: (buf, string, offset, len) => buf.base64Write(string, offset, len)
  },
  base64url: {
    byteLength: (string) => base64ByteLength2(string, string.length),
    encoding: "base64url",
    encodingVal: encodingsMap2.base64url,
    indexOf: (buf, val, byteOffset, dir) => indexOfBuffer2(buf, base64UrlToBytes2(val), byteOffset, encodingsMap2.base64url, dir),
    slice: (buf, start, end) => buf.base64urlSlice(start, end),
    write: (buf, string, offset, len) => buf.base64urlWrite(string, offset, len)
  },
  hex: {
    byteLength: (string) => string.length >>> 1,
    encoding: "hex",
    encodingVal: encodingsMap2.hex,
    indexOf: (buf, val, byteOffset, dir) => indexOfBuffer2(buf, hexToBytes2(val), byteOffset, encodingsMap2.hex, dir),
    slice: (buf, start, end) => buf.hexSlice(start, end),
    write: (buf, string, offset, len) => buf.hexWrite(string, offset, len)
  },
  latin1: {
    byteLength: (string) => string.length,
    encoding: "latin1",
    encodingVal: encodingsMap2.latin1,
    indexOf: (buf, val, byteOffset, dir) => indexOfBuffer2(buf, asciiToBytes2(val), byteOffset, encodingsMap2.latin1, dir),
    slice: (buf, start, end) => buf.latin1Slice(start, end),
    write: (buf, string, offset, len) => buf.latin1Write(string, offset, len)
  },
  ucs2: {
    byteLength: (string) => string.length * 2,
    encoding: "ucs2",
    encodingVal: encodingsMap2.utf16le,
    indexOf: (buf, val, byteOffset, dir) => indexOfBuffer2(buf, utf16leToBytes2(val), byteOffset, encodingsMap2.utf16le, dir),
    slice: (buf, start, end) => buf.ucs2Slice(start, end),
    write: (buf, string, offset, len) => buf.ucs2Write(string, offset, len)
  },
  utf8: {
    byteLength: byteLengthUtf82,
    encoding: "utf8",
    encodingVal: encodingsMap2.utf8,
    indexOf: (buf, val, byteOffset, dir) => indexOfBuffer2(buf, utf8Encoder2.encode(val), byteOffset, encodingsMap2.utf8, dir),
    slice: (buf, start, end) => buf.utf8Slice(start, end),
    write: (buf, string, offset, len) => buf.utf8Write(string, offset, len)
  },
  utf16le: {
    byteLength: (string) => string.length * 2,
    encoding: "utf16le",
    encodingVal: encodingsMap2.utf16le,
    indexOf: (buf, val, byteOffset, dir) => indexOfBuffer2(buf, utf16leToBytes2(val), byteOffset, encodingsMap2.utf16le, dir),
    slice: (buf, start, end) => buf.ucs2Slice(start, end),
    write: (buf, string, offset, len) => buf.ucs2Write(string, offset, len)
  }
};
function getEncodingOps2(encoding) {
  encoding = String(encoding).toLowerCase();
  switch (encoding.length) {
    case 4:
      if (encoding === "utf8")
        return encodingOps2.utf8;
      if (encoding === "ucs2")
        return encodingOps2.ucs2;
      break;
    case 5:
      if (encoding === "utf-8")
        return encodingOps2.utf8;
      if (encoding === "ascii")
        return encodingOps2.ascii;
      if (encoding === "ucs-2")
        return encodingOps2.ucs2;
      break;
    case 7:
      if (encoding === "utf16le") {
        return encodingOps2.utf16le;
      }
      break;
    case 8:
      if (encoding === "utf-16le") {
        return encodingOps2.utf16le;
      }
      break;
    case 6:
      if (encoding === "latin1" || encoding === "binary") {
        return encodingOps2.latin1;
      }
      if (encoding === "base64")
        return encodingOps2.base64;
    case 3:
      if (encoding === "hex") {
        return encodingOps2.hex;
      }
      break;
    case 9:
      if (encoding === "base64url") {
        return encodingOps2.base64url;
      }
      break;
  }
}
function _copyActual2(source, target, targetStart, sourceStart, sourceEnd) {
  if (sourceEnd - sourceStart > target.length - targetStart) {
    sourceEnd = sourceStart + target.length - targetStart;
  }
  let nb = sourceEnd - sourceStart;
  const sourceLen = source.length - sourceStart;
  if (nb > sourceLen) {
    nb = sourceLen;
  }
  if (sourceStart !== 0 || sourceEnd < source.length) {
    source = new Uint8Array(source.buffer, source.byteOffset + sourceStart, nb);
  }
  target.set(source, targetStart);
  return nb;
}
function boundsError2(value, length, type) {
  if (Math.floor(value) !== value) {
    validateNumber2(value, type);
    throw new codes2.ERR_OUT_OF_RANGE(type || "offset", "an integer", value);
  }
  if (length < 0) {
    throw new codes2.ERR_BUFFER_OUT_OF_BOUNDS();
  }
  throw new codes2.ERR_OUT_OF_RANGE(type || "offset", `>= ${type ? 1 : 0} and <= ${length}`, value);
}
function validateNumber2(value, name) {
  if (typeof value !== "number") {
    throw new codes2.ERR_INVALID_ARG_TYPE(name, "number", value);
  }
}
function checkBounds3(buf, offset, byteLength6) {
  validateNumber2(offset, "offset");
  if (buf[offset] === void 0 || buf[offset + byteLength6] === void 0) {
    boundsError2(offset, buf.length - (byteLength6 + 1));
  }
}
function checkInt2(value, min4, max2, buf, offset, byteLength6) {
  if (value > max2 || value < min4) {
    const n = typeof min4 === "bigint" ? "n" : "";
    let range;
    if (byteLength6 > 3) {
      if (min4 === 0 || min4 === 0n) {
        range = `>= 0${n} and < 2${n} ** ${(byteLength6 + 1) * 8}${n}`;
      } else {
        range = `>= -(2${n} ** ${(byteLength6 + 1) * 8 - 1}${n}) and < 2${n} ** ${(byteLength6 + 1) * 8 - 1}${n}`;
      }
    } else {
      range = `>= ${min4}${n} and <= ${max2}${n}`;
    }
    throw new codes2.ERR_OUT_OF_RANGE("value", range, value);
  }
  checkBounds3(buf, offset, byteLength6);
}
function toInteger2(n, defaultVal) {
  n = +n;
  if (!Number.isNaN(n) && n >= Number.MIN_SAFE_INTEGER && n <= Number.MAX_SAFE_INTEGER) {
    return n % 1 === 0 ? n : Math.floor(n);
  }
  return defaultVal;
}
function writeU_Int82(buf, value, offset, min4, max2) {
  value = +value;
  validateNumber2(offset, "offset");
  if (value > max2 || value < min4) {
    throw new codes2.ERR_OUT_OF_RANGE("value", `>= ${min4} and <= ${max2}`, value);
  }
  if (buf[offset] === void 0) {
    boundsError2(offset, buf.length - 1);
  }
  buf[offset] = value;
  return offset + 1;
}
function writeU_Int16BE2(buf, value, offset, min4, max2) {
  value = +value;
  checkInt2(value, min4, max2, buf, offset, 1);
  buf[offset++] = value >>> 8;
  buf[offset++] = value;
  return offset;
}
function _writeUInt32LE2(buf, value, offset, min4, max2) {
  value = +value;
  checkInt2(value, min4, max2, buf, offset, 3);
  buf[offset++] = value;
  value = value >>> 8;
  buf[offset++] = value;
  value = value >>> 8;
  buf[offset++] = value;
  value = value >>> 8;
  buf[offset++] = value;
  return offset;
}
function writeU_Int16LE2(buf, value, offset, min4, max2) {
  value = +value;
  checkInt2(value, min4, max2, buf, offset, 1);
  buf[offset++] = value;
  buf[offset++] = value >>> 8;
  return offset;
}
function _writeUInt32BE2(buf, value, offset, min4, max2) {
  value = +value;
  checkInt2(value, min4, max2, buf, offset, 3);
  buf[offset + 3] = value;
  value = value >>> 8;
  buf[offset + 2] = value;
  value = value >>> 8;
  buf[offset + 1] = value;
  value = value >>> 8;
  buf[offset] = value;
  return offset + 4;
}
function writeU_Int48BE2(buf, value, offset, min4, max2) {
  value = +value;
  checkInt2(value, min4, max2, buf, offset, 5);
  const newVal = Math.floor(value * 2 ** -32);
  buf[offset++] = newVal >>> 8;
  buf[offset++] = newVal;
  buf[offset + 3] = value;
  value = value >>> 8;
  buf[offset + 2] = value;
  value = value >>> 8;
  buf[offset + 1] = value;
  value = value >>> 8;
  buf[offset] = value;
  return offset + 4;
}
function writeU_Int40BE2(buf, value, offset, min4, max2) {
  value = +value;
  checkInt2(value, min4, max2, buf, offset, 4);
  buf[offset++] = Math.floor(value * 2 ** -32);
  buf[offset + 3] = value;
  value = value >>> 8;
  buf[offset + 2] = value;
  value = value >>> 8;
  buf[offset + 1] = value;
  value = value >>> 8;
  buf[offset] = value;
  return offset + 4;
}
function writeU_Int32BE2(buf, value, offset, min4, max2) {
  value = +value;
  checkInt2(value, min4, max2, buf, offset, 3);
  buf[offset + 3] = value;
  value = value >>> 8;
  buf[offset + 2] = value;
  value = value >>> 8;
  buf[offset + 1] = value;
  value = value >>> 8;
  buf[offset] = value;
  return offset + 4;
}
function writeU_Int24BE2(buf, value, offset, min4, max2) {
  value = +value;
  checkInt2(value, min4, max2, buf, offset, 2);
  buf[offset + 2] = value;
  value = value >>> 8;
  buf[offset + 1] = value;
  value = value >>> 8;
  buf[offset] = value;
  return offset + 3;
}
function validateOffset2(value, name, min4 = 0, max2 = Number.MAX_SAFE_INTEGER) {
  if (typeof value !== "number") {
    throw new codes2.ERR_INVALID_ARG_TYPE(name, "number", value);
  }
  if (!Number.isInteger(value)) {
    throw new codes2.ERR_OUT_OF_RANGE(name, "an integer", value);
  }
  if (value < min4 || value > max2) {
    throw new codes2.ERR_OUT_OF_RANGE(name, `>= ${min4} && <= ${max2}`, value);
  }
}
function writeU_Int48LE2(buf, value, offset, min4, max2) {
  value = +value;
  checkInt2(value, min4, max2, buf, offset, 5);
  const newVal = Math.floor(value * 2 ** -32);
  buf[offset++] = value;
  value = value >>> 8;
  buf[offset++] = value;
  value = value >>> 8;
  buf[offset++] = value;
  value = value >>> 8;
  buf[offset++] = value;
  buf[offset++] = newVal;
  buf[offset++] = newVal >>> 8;
  return offset;
}
function writeU_Int40LE2(buf, value, offset, min4, max2) {
  value = +value;
  checkInt2(value, min4, max2, buf, offset, 4);
  const newVal = value;
  buf[offset++] = value;
  value = value >>> 8;
  buf[offset++] = value;
  value = value >>> 8;
  buf[offset++] = value;
  value = value >>> 8;
  buf[offset++] = value;
  buf[offset++] = Math.floor(newVal * 2 ** -32);
  return offset;
}
function writeU_Int32LE2(buf, value, offset, min4, max2) {
  value = +value;
  checkInt2(value, min4, max2, buf, offset, 3);
  buf[offset++] = value;
  value = value >>> 8;
  buf[offset++] = value;
  value = value >>> 8;
  buf[offset++] = value;
  value = value >>> 8;
  buf[offset++] = value;
  return offset;
}
function writeU_Int24LE2(buf, value, offset, min4, max2) {
  value = +value;
  checkInt2(value, min4, max2, buf, offset, 2);
  buf[offset++] = value;
  value = value >>> 8;
  buf[offset++] = value;
  value = value >>> 8;
  buf[offset++] = value;
  return offset;
}

// deno:https://deno.land/std@0.141.0/node/_buffer.mjs
var kMaxLength2 = 2147483647;
var MAX_UINT323 = 2 ** 32;
var customInspectSymbol5 = typeof Symbol === "function" && typeof Symbol["for"] === "function" ? Symbol["for"]("nodejs.util.inspect.custom") : null;
var INSPECT_MAX_BYTES2 = 50;
Object.defineProperty(Buffer4.prototype, "parent", {
  enumerable: true,
  get: function() {
    if (!Buffer4.isBuffer(this)) {
      return void 0;
    }
    return this.buffer;
  }
});
Object.defineProperty(Buffer4.prototype, "offset", {
  enumerable: true,
  get: function() {
    if (!Buffer4.isBuffer(this)) {
      return void 0;
    }
    return this.byteOffset;
  }
});
function createBuffer2(length) {
  if (length > kMaxLength2) {
    throw new RangeError('The value "' + length + '" is invalid for option "size"');
  }
  const buf = new Uint8Array(length);
  Object.setPrototypeOf(buf, Buffer4.prototype);
  return buf;
}
function Buffer4(arg, encodingOrOffset, length) {
  if (typeof arg === "number") {
    if (typeof encodingOrOffset === "string") {
      throw new codes2.ERR_INVALID_ARG_TYPE("string", "string", arg);
    }
    return _allocUnsafe2(arg);
  }
  return _from3(arg, encodingOrOffset, length);
}
Buffer4.poolSize = 8192;
function _from3(value, encodingOrOffset, length) {
  if (typeof value === "string") {
    return fromString2(value, encodingOrOffset);
  }
  if (typeof value === "object" && value !== null) {
    if (isAnyArrayBuffer4(value)) {
      return fromArrayBuffer2(value, encodingOrOffset, length);
    }
    const valueOf = value.valueOf && value.valueOf();
    if (valueOf != null && valueOf !== value && (typeof valueOf === "string" || typeof valueOf === "object")) {
      return _from3(valueOf, encodingOrOffset, length);
    }
    const b2 = fromObject2(value);
    if (b2) {
      return b2;
    }
    if (typeof value[Symbol.toPrimitive] === "function") {
      const primitive = value[Symbol.toPrimitive]("string");
      if (typeof primitive === "string") {
        return fromString2(primitive, encodingOrOffset);
      }
    }
  }
  throw new codes2.ERR_INVALID_ARG_TYPE("first argument", ["string", "Buffer", "ArrayBuffer", "Array", "Array-like Object"], value);
}
Buffer4.from = function from2(value, encodingOrOffset, length) {
  return _from3(value, encodingOrOffset, length);
};
Object.setPrototypeOf(Buffer4.prototype, Uint8Array.prototype);
Object.setPrototypeOf(Buffer4, Uint8Array);
function assertSize3(size) {
  validateNumber2(size, "size");
  if (!(size >= 0 && size <= kMaxLength2)) {
    throw new codes2.ERR_INVALID_ARG_VALUE.RangeError("size", size);
  }
}
function _alloc2(size, fill5, encoding) {
  assertSize3(size);
  const buffer = createBuffer2(size);
  if (fill5 !== void 0) {
    if (encoding !== void 0 && typeof encoding !== "string") {
      throw new codes2.ERR_INVALID_ARG_TYPE("encoding", "string", encoding);
    }
    return buffer.fill(fill5, encoding);
  }
  return buffer;
}
Buffer4.alloc = function alloc2(size, fill5, encoding) {
  return _alloc2(size, fill5, encoding);
};
function _allocUnsafe2(size) {
  assertSize3(size);
  return createBuffer2(size < 0 ? 0 : checked2(size) | 0);
}
Buffer4.allocUnsafe = function allocUnsafe2(size) {
  return _allocUnsafe2(size);
};
Buffer4.allocUnsafeSlow = function allocUnsafeSlow2(size) {
  return _allocUnsafe2(size);
};
function fromString2(string, encoding) {
  if (typeof encoding !== "string" || encoding === "") {
    encoding = "utf8";
  }
  if (!Buffer4.isEncoding(encoding)) {
    throw new codes2.ERR_UNKNOWN_ENCODING(encoding);
  }
  const length = byteLength3(string, encoding) | 0;
  let buf = createBuffer2(length);
  const actual = buf.write(string, encoding);
  if (actual !== length) {
    buf = buf.slice(0, actual);
  }
  return buf;
}
function fromArrayLike2(array) {
  const length = array.length < 0 ? 0 : checked2(array.length) | 0;
  const buf = createBuffer2(length);
  for (let i = 0; i < length; i += 1) {
    buf[i] = array[i] & 255;
  }
  return buf;
}
function fromObject2(obj2) {
  if (obj2.length !== void 0 || isAnyArrayBuffer4(obj2.buffer)) {
    if (typeof obj2.length !== "number") {
      return createBuffer2(0);
    }
    return fromArrayLike2(obj2);
  }
  if (obj2.type === "Buffer" && Array.isArray(obj2.data)) {
    return fromArrayLike2(obj2.data);
  }
}
function checked2(length) {
  if (length >= kMaxLength2) {
    throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + kMaxLength2.toString(16) + " bytes");
  }
  return length | 0;
}
function SlowBuffer2(length) {
  assertSize3(length);
  return Buffer4.alloc(+length);
}
Object.setPrototypeOf(SlowBuffer2.prototype, Uint8Array.prototype);
Object.setPrototypeOf(SlowBuffer2, Uint8Array);
Buffer4.isBuffer = function isBuffer3(b2) {
  return b2 != null && b2._isBuffer === true && b2 !== Buffer4.prototype;
};
Buffer4.compare = function compare4(a, b2) {
  if (isInstance2(a, Uint8Array)) {
    a = Buffer4.from(a, a.offset, a.byteLength);
  }
  if (isInstance2(b2, Uint8Array)) {
    b2 = Buffer4.from(b2, b2.offset, b2.byteLength);
  }
  if (!Buffer4.isBuffer(a) || !Buffer4.isBuffer(b2)) {
    throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');
  }
  if (a === b2) {
    return 0;
  }
  let x = a.length;
  let y4 = b2.length;
  for (let i = 0, len = Math.min(x, y4); i < len; ++i) {
    if (a[i] !== b2[i]) {
      x = a[i];
      y4 = b2[i];
      break;
    }
  }
  if (x < y4) {
    return -1;
  }
  if (y4 < x) {
    return 1;
  }
  return 0;
};
Buffer4.isEncoding = function isEncoding2(encoding) {
  return typeof encoding === "string" && encoding.length !== 0 && normalizeEncoding4(encoding) !== void 0;
};
Buffer4.concat = function concat3(list, length) {
  if (!Array.isArray(list)) {
    throw new codes2.ERR_INVALID_ARG_TYPE("list", "Array", list);
  }
  if (list.length === 0) {
    return Buffer4.alloc(0);
  }
  if (length === void 0) {
    length = 0;
    for (let i = 0; i < list.length; i++) {
      if (list[i].length) {
        length += list[i].length;
      }
    }
  } else {
    validateOffset2(length, "length");
  }
  const buffer = Buffer4.allocUnsafe(length);
  let pos = 0;
  for (let i = 0; i < list.length; i++) {
    const buf = list[i];
    if (!isUint8Array2(buf)) {
      throw new codes2.ERR_INVALID_ARG_TYPE(`list[${i}]`, ["Buffer", "Uint8Array"], list[i]);
    }
    pos += _copyActual2(buf, buffer, pos, 0, buf.length);
  }
  if (pos < length) {
    buffer.fill(0, pos, length);
  }
  return buffer;
};
function byteLength3(string, encoding) {
  if (typeof string !== "string") {
    if (isArrayBufferView2(string) || isAnyArrayBuffer4(string)) {
      return string.byteLength;
    }
    throw new codes2.ERR_INVALID_ARG_TYPE("string", ["string", "Buffer", "ArrayBuffer"], string);
  }
  const len = string.length;
  const mustMatch = arguments.length > 2 && arguments[2] === true;
  if (!mustMatch && len === 0) {
    return 0;
  }
  if (!encoding) {
    return mustMatch ? -1 : byteLengthUtf82(string);
  }
  const ops = getEncodingOps2(encoding);
  if (ops === void 0) {
    return mustMatch ? -1 : byteLengthUtf82(string);
  }
  return ops.byteLength(string);
}
Buffer4.byteLength = byteLength3;
Buffer4.prototype._isBuffer = true;
function swap2(b2, n, m3) {
  const i = b2[n];
  b2[n] = b2[m3];
  b2[m3] = i;
}
Buffer4.prototype.swap16 = function swap162() {
  const len = this.length;
  if (len % 2 !== 0) {
    throw new RangeError("Buffer size must be a multiple of 16-bits");
  }
  for (let i = 0; i < len; i += 2) {
    swap2(this, i, i + 1);
  }
  return this;
};
Buffer4.prototype.swap32 = function swap322() {
  const len = this.length;
  if (len % 4 !== 0) {
    throw new RangeError("Buffer size must be a multiple of 32-bits");
  }
  for (let i = 0; i < len; i += 4) {
    swap2(this, i, i + 3);
    swap2(this, i + 1, i + 2);
  }
  return this;
};
Buffer4.prototype.swap64 = function swap642() {
  const len = this.length;
  if (len % 8 !== 0) {
    throw new RangeError("Buffer size must be a multiple of 64-bits");
  }
  for (let i = 0; i < len; i += 8) {
    swap2(this, i, i + 7);
    swap2(this, i + 1, i + 6);
    swap2(this, i + 2, i + 5);
    swap2(this, i + 3, i + 4);
  }
  return this;
};
Buffer4.prototype.toString = function toString3(encoding, start, end) {
  if (arguments.length === 0) {
    return this.utf8Slice(0, this.length);
  }
  const len = this.length;
  if (start <= 0) {
    start = 0;
  } else if (start >= len) {
    return "";
  } else {
    start |= 0;
  }
  if (end === void 0 || end > len) {
    end = len;
  } else {
    end |= 0;
  }
  if (end <= start) {
    return "";
  }
  if (encoding === void 0) {
    return this.utf8Slice(start, end);
  }
  const ops = getEncodingOps2(encoding);
  if (ops === void 0) {
    throw new codes2.ERR_UNKNOWN_ENCODING(encoding);
  }
  return ops.slice(this, start, end);
};
Buffer4.prototype.toLocaleString = Buffer4.prototype.toString;
Buffer4.prototype.equals = function equals4(b2) {
  if (!isUint8Array2(b2)) {
    throw new codes2.ERR_INVALID_ARG_TYPE("otherBuffer", ["Buffer", "Uint8Array"], b2);
  }
  if (this === b2) {
    return true;
  }
  return Buffer4.compare(this, b2) === 0;
};
Buffer4.prototype.inspect = function inspect4() {
  let str = "";
  const max2 = INSPECT_MAX_BYTES2;
  str = this.toString("hex", 0, max2).replace(/(.{2})/g, "$1 ").trim();
  if (this.length > max2) {
    str += " ... ";
  }
  return "<Buffer " + str + ">";
};
if (customInspectSymbol5) {
  Buffer4.prototype[customInspectSymbol5] = Buffer4.prototype.inspect;
}
Buffer4.prototype.compare = function compare5(target, start, end, thisStart, thisEnd) {
  if (isInstance2(target, Uint8Array)) {
    target = Buffer4.from(target, target.offset, target.byteLength);
  }
  if (!Buffer4.isBuffer(target)) {
    throw new codes2.ERR_INVALID_ARG_TYPE("target", ["Buffer", "Uint8Array"], target);
  }
  if (start === void 0) {
    start = 0;
  } else {
    validateOffset2(start, "targetStart", 0, kMaxLength2);
  }
  if (end === void 0) {
    end = target.length;
  } else {
    validateOffset2(end, "targetEnd", 0, target.length);
  }
  if (thisStart === void 0) {
    thisStart = 0;
  } else {
    validateOffset2(start, "sourceStart", 0, kMaxLength2);
  }
  if (thisEnd === void 0) {
    thisEnd = this.length;
  } else {
    validateOffset2(end, "sourceEnd", 0, this.length);
  }
  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
    throw new codes2.ERR_OUT_OF_RANGE("out of range index", "range");
  }
  if (thisStart >= thisEnd && start >= end) {
    return 0;
  }
  if (thisStart >= thisEnd) {
    return -1;
  }
  if (start >= end) {
    return 1;
  }
  start >>>= 0;
  end >>>= 0;
  thisStart >>>= 0;
  thisEnd >>>= 0;
  if (this === target) {
    return 0;
  }
  let x = thisEnd - thisStart;
  let y4 = end - start;
  const len = Math.min(x, y4);
  const thisCopy = this.slice(thisStart, thisEnd);
  const targetCopy = target.slice(start, end);
  for (let i = 0; i < len; ++i) {
    if (thisCopy[i] !== targetCopy[i]) {
      x = thisCopy[i];
      y4 = targetCopy[i];
      break;
    }
  }
  if (x < y4) {
    return -1;
  }
  if (y4 < x) {
    return 1;
  }
  return 0;
};
function bidirectionalIndexOf2(buffer, val, byteOffset, encoding, dir) {
  validateBuffer2(buffer);
  if (typeof byteOffset === "string") {
    encoding = byteOffset;
    byteOffset = void 0;
  } else if (byteOffset > 2147483647) {
    byteOffset = 2147483647;
  } else if (byteOffset < -2147483648) {
    byteOffset = -2147483648;
  }
  byteOffset = +byteOffset;
  if (Number.isNaN(byteOffset)) {
    byteOffset = dir ? 0 : buffer.length || buffer.byteLength;
  }
  dir = !!dir;
  if (typeof val === "number") {
    return indexOfNumber2(buffer, val >>> 0, byteOffset, dir);
  }
  let ops;
  if (encoding === void 0) {
    ops = encodingOps2.utf8;
  } else {
    ops = getEncodingOps2(encoding);
  }
  if (typeof val === "string") {
    if (ops === void 0) {
      throw new codes2.ERR_UNKNOWN_ENCODING(encoding);
    }
    return ops.indexOf(buffer, val, byteOffset, dir);
  }
  if (isUint8Array2(val)) {
    const encodingVal = ops === void 0 ? encodingsMap2.utf8 : ops.encodingVal;
    return indexOfBuffer2(buffer, val, byteOffset, encodingVal, dir);
  }
  throw new codes2.ERR_INVALID_ARG_TYPE("value", ["number", "string", "Buffer", "Uint8Array"], val);
}
Buffer4.prototype.includes = function includes2(val, byteOffset, encoding) {
  return this.indexOf(val, byteOffset, encoding) !== -1;
};
Buffer4.prototype.indexOf = function indexOf2(val, byteOffset, encoding) {
  return bidirectionalIndexOf2(this, val, byteOffset, encoding, true);
};
Buffer4.prototype.lastIndexOf = function lastIndexOf2(val, byteOffset, encoding) {
  return bidirectionalIndexOf2(this, val, byteOffset, encoding, false);
};
Buffer4.prototype.asciiSlice = function asciiSlice2(offset, length) {
  if (offset === 0 && length === this.length) {
    return bytesToAscii2(this);
  } else {
    return bytesToAscii2(this.slice(offset, length));
  }
};
Buffer4.prototype.asciiWrite = function asciiWrite2(string, offset, length) {
  return blitBuffer2(asciiToBytes2(string), this, offset, length);
};
Buffer4.prototype.base64Slice = function base64Slice2(offset, length) {
  if (offset === 0 && length === this.length) {
    return encode9(this);
  } else {
    return encode9(this.slice(offset, length));
  }
};
Buffer4.prototype.base64Write = function base64Write2(string, offset, length) {
  return blitBuffer2(base64ToBytes2(string), this, offset, length);
};
Buffer4.prototype.base64urlSlice = function base64urlSlice2(offset, length) {
  if (offset === 0 && length === this.length) {
    return encode10(this);
  } else {
    return encode10(this.slice(offset, length));
  }
};
Buffer4.prototype.base64urlWrite = function base64urlWrite2(string, offset, length) {
  return blitBuffer2(base64UrlToBytes2(string), this, offset, length);
};
Buffer4.prototype.hexWrite = function hexWrite2(string, offset, length) {
  return blitBuffer2(hexToBytes2(string, this.length - offset), this, offset, length);
};
Buffer4.prototype.hexSlice = function hexSlice3(string, offset, length) {
  return _hexSlice2(this, string, offset, length);
};
Buffer4.prototype.latin1Slice = function latin1Slice2(string, offset, length) {
  return _latin1Slice2(this, string, offset, length);
};
Buffer4.prototype.latin1Write = function latin1Write2(string, offset, length) {
  return blitBuffer2(asciiToBytes2(string), this, offset, length);
};
Buffer4.prototype.ucs2Slice = function ucs2Slice2(offset, length) {
  if (offset === 0 && length === this.length) {
    return bytesToUtf16le2(this);
  } else {
    return bytesToUtf16le2(this.slice(offset, length));
  }
};
Buffer4.prototype.ucs2Write = function ucs2Write2(string, offset, length) {
  return blitBuffer2(utf16leToBytes2(string, this.length - offset), this, offset, length);
};
Buffer4.prototype.utf8Slice = function utf8Slice2(string, offset, length) {
  return _utf8Slice2(this, string, offset, length);
};
Buffer4.prototype.utf8Write = function utf8Write3(string, offset, length) {
  return blitBuffer2(utf8ToBytes2(string, this.length - offset), this, offset, length);
};
Buffer4.prototype.write = function write2(string, offset, length, encoding) {
  if (offset === void 0) {
    return this.utf8Write(string, 0, this.length);
  }
  if (length === void 0 && typeof offset === "string") {
    encoding = offset;
    length = this.length;
    offset = 0;
  } else {
    validateOffset2(offset, "offset", 0, this.length);
    const remaining = this.length - offset;
    if (length === void 0) {
      length = remaining;
    } else if (typeof length === "string") {
      encoding = length;
      length = remaining;
    } else {
      validateOffset2(length, "length", 0, this.length);
      if (length > remaining) {
        length = remaining;
      }
    }
  }
  if (!encoding) {
    return this.utf8Write(string, offset, length);
  }
  const ops = getEncodingOps2(encoding);
  if (ops === void 0) {
    throw new codes2.ERR_UNKNOWN_ENCODING(encoding);
  }
  return ops.write(this, string, offset, length);
};
Buffer4.prototype.toJSON = function toJSON3() {
  return {
    type: "Buffer",
    data: Array.prototype.slice.call(this._arr || this, 0)
  };
};
function fromArrayBuffer2(obj2, byteOffset, length) {
  if (byteOffset === void 0) {
    byteOffset = 0;
  } else {
    byteOffset = +byteOffset;
    if (Number.isNaN(byteOffset)) {
      byteOffset = 0;
    }
  }
  const maxLength = obj2.byteLength - byteOffset;
  if (maxLength < 0) {
    throw new codes2.ERR_BUFFER_OUT_OF_BOUNDS("offset");
  }
  if (length === void 0) {
    length = maxLength;
  } else {
    length = +length;
    if (length > 0) {
      if (length > maxLength) {
        throw new codes2.ERR_BUFFER_OUT_OF_BOUNDS("length");
      }
    } else {
      length = 0;
    }
  }
  const buffer = new Uint8Array(obj2, byteOffset, length);
  Object.setPrototypeOf(buffer, Buffer4.prototype);
  return buffer;
}
function _utf8Slice2(buf, start, end) {
  end = Math.min(buf.length, end);
  const res = [];
  let i = start;
  while (i < end) {
    const firstByte = buf[i];
    let codePoint = null;
    let bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;
    if (i + bytesPerSequence <= end) {
      let secondByte, thirdByte, fourthByte, tempCodePoint;
      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 128) {
            codePoint = firstByte;
          }
          break;
        case 2:
          secondByte = buf[i + 1];
          if ((secondByte & 192) === 128) {
            tempCodePoint = (firstByte & 31) << 6 | secondByte & 63;
            if (tempCodePoint > 127) {
              codePoint = tempCodePoint;
            }
          }
          break;
        case 3:
          secondByte = buf[i + 1];
          thirdByte = buf[i + 2];
          if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {
            tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63;
            if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) {
              codePoint = tempCodePoint;
            }
          }
          break;
        case 4:
          secondByte = buf[i + 1];
          thirdByte = buf[i + 2];
          fourthByte = buf[i + 3];
          if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {
            tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63;
            if (tempCodePoint > 65535 && tempCodePoint < 1114112) {
              codePoint = tempCodePoint;
            }
          }
      }
    }
    if (codePoint === null) {
      codePoint = 65533;
      bytesPerSequence = 1;
    } else if (codePoint > 65535) {
      codePoint -= 65536;
      res.push(codePoint >>> 10 & 1023 | 55296);
      codePoint = 56320 | codePoint & 1023;
    }
    res.push(codePoint);
    i += bytesPerSequence;
  }
  return decodeCodePointsArray2(res);
}
var MAX_ARGUMENTS_LENGTH2 = 4096;
function decodeCodePointsArray2(codePoints) {
  const len = codePoints.length;
  if (len <= MAX_ARGUMENTS_LENGTH2) {
    return String.fromCharCode.apply(String, codePoints);
  }
  let res = "";
  let i = 0;
  while (i < len) {
    res += String.fromCharCode.apply(String, codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH2));
  }
  return res;
}
function _latin1Slice2(buf, start, end) {
  let ret = "";
  end = Math.min(buf.length, end);
  for (let i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i]);
  }
  return ret;
}
function _hexSlice2(buf, start, end) {
  const len = buf.length;
  if (!start || start < 0) {
    start = 0;
  }
  if (!end || end < 0 || end > len) {
    end = len;
  }
  let out = "";
  for (let i = start; i < end; ++i) {
    out += hexSliceLookupTable2[buf[i]];
  }
  return out;
}
Buffer4.prototype.slice = function slice2(start, end) {
  const len = this.length;
  start = ~~start;
  end = end === void 0 ? len : ~~end;
  if (start < 0) {
    start += len;
    if (start < 0) {
      start = 0;
    }
  } else if (start > len) {
    start = len;
  }
  if (end < 0) {
    end += len;
    if (end < 0) {
      end = 0;
    }
  } else if (end > len) {
    end = len;
  }
  if (end < start) {
    end = start;
  }
  const newBuf = this.subarray(start, end);
  Object.setPrototypeOf(newBuf, Buffer4.prototype);
  return newBuf;
};
Buffer4.prototype.readUintLE = Buffer4.prototype.readUIntLE = function readUIntLE2(offset, byteLength6) {
  if (offset === void 0) {
    throw new codes2.ERR_INVALID_ARG_TYPE("offset", "number", offset);
  }
  if (byteLength6 === 6) {
    return readUInt48LE2(this, offset);
  }
  if (byteLength6 === 5) {
    return readUInt40LE2(this, offset);
  }
  if (byteLength6 === 3) {
    return readUInt24LE2(this, offset);
  }
  if (byteLength6 === 4) {
    return this.readUInt32LE(offset);
  }
  if (byteLength6 === 2) {
    return this.readUInt16LE(offset);
  }
  if (byteLength6 === 1) {
    return this.readUInt8(offset);
  }
  boundsError2(byteLength6, 6, "byteLength");
};
Buffer4.prototype.readUintBE = Buffer4.prototype.readUIntBE = function readUIntBE2(offset, byteLength6) {
  if (offset === void 0) {
    throw new codes2.ERR_INVALID_ARG_TYPE("offset", "number", offset);
  }
  if (byteLength6 === 6) {
    return readUInt48BE2(this, offset);
  }
  if (byteLength6 === 5) {
    return readUInt40BE2(this, offset);
  }
  if (byteLength6 === 3) {
    return readUInt24BE2(this, offset);
  }
  if (byteLength6 === 4) {
    return this.readUInt32BE(offset);
  }
  if (byteLength6 === 2) {
    return this.readUInt16BE(offset);
  }
  if (byteLength6 === 1) {
    return this.readUInt8(offset);
  }
  boundsError2(byteLength6, 6, "byteLength");
};
Buffer4.prototype.readUint8 = Buffer4.prototype.readUInt8 = function readUInt83(offset = 0) {
  validateNumber2(offset, "offset");
  const val = this[offset];
  if (val === void 0) {
    boundsError2(offset, this.length - 1);
  }
  return val;
};
Buffer4.prototype.readUint16BE = Buffer4.prototype.readUInt16BE = readUInt16BE2;
Buffer4.prototype.readUint16LE = Buffer4.prototype.readUInt16LE = function readUInt16LE2(offset = 0) {
  validateNumber2(offset, "offset");
  const first = this[offset];
  const last = this[offset + 1];
  if (first === void 0 || last === void 0) {
    boundsError2(offset, this.length - 2);
  }
  return first + last * 2 ** 8;
};
Buffer4.prototype.readUint32LE = Buffer4.prototype.readUInt32LE = function readUInt32LE2(offset = 0) {
  validateNumber2(offset, "offset");
  const first = this[offset];
  const last = this[offset + 3];
  if (first === void 0 || last === void 0) {
    boundsError2(offset, this.length - 4);
  }
  return first + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + last * 2 ** 24;
};
Buffer4.prototype.readUint32BE = Buffer4.prototype.readUInt32BE = readUInt32BE2;
Buffer4.prototype.readBigUint64LE = Buffer4.prototype.readBigUInt64LE = defineBigIntMethod2(function readBigUInt64LE2(offset) {
  offset = offset >>> 0;
  validateNumber2(offset, "offset");
  const first = this[offset];
  const last = this[offset + 7];
  if (first === void 0 || last === void 0) {
    boundsError2(offset, this.length - 8);
  }
  const lo3 = first + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 24;
  const hi2 = this[++offset] + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + last * 2 ** 24;
  return BigInt(lo3) + (BigInt(hi2) << BigInt(32));
});
Buffer4.prototype.readBigUint64BE = Buffer4.prototype.readBigUInt64BE = defineBigIntMethod2(function readBigUInt64BE2(offset) {
  offset = offset >>> 0;
  validateNumber2(offset, "offset");
  const first = this[offset];
  const last = this[offset + 7];
  if (first === void 0 || last === void 0) {
    boundsError2(offset, this.length - 8);
  }
  const hi2 = first * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + this[++offset];
  const lo3 = this[++offset] * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + last;
  return (BigInt(hi2) << BigInt(32)) + BigInt(lo3);
});
Buffer4.prototype.readIntLE = function readIntLE2(offset, byteLength6) {
  if (offset === void 0) {
    throw new codes2.ERR_INVALID_ARG_TYPE("offset", "number", offset);
  }
  if (byteLength6 === 6) {
    return readInt48LE2(this, offset);
  }
  if (byteLength6 === 5) {
    return readInt40LE2(this, offset);
  }
  if (byteLength6 === 3) {
    return readInt24LE2(this, offset);
  }
  if (byteLength6 === 4) {
    return this.readInt32LE(offset);
  }
  if (byteLength6 === 2) {
    return this.readInt16LE(offset);
  }
  if (byteLength6 === 1) {
    return this.readInt8(offset);
  }
  boundsError2(byteLength6, 6, "byteLength");
};
Buffer4.prototype.readIntBE = function readIntBE2(offset, byteLength6) {
  if (offset === void 0) {
    throw new codes2.ERR_INVALID_ARG_TYPE("offset", "number", offset);
  }
  if (byteLength6 === 6) {
    return readInt48BE2(this, offset);
  }
  if (byteLength6 === 5) {
    return readInt40BE2(this, offset);
  }
  if (byteLength6 === 3) {
    return readInt24BE2(this, offset);
  }
  if (byteLength6 === 4) {
    return this.readInt32BE(offset);
  }
  if (byteLength6 === 2) {
    return this.readInt16BE(offset);
  }
  if (byteLength6 === 1) {
    return this.readInt8(offset);
  }
  boundsError2(byteLength6, 6, "byteLength");
};
Buffer4.prototype.readInt8 = function readInt82(offset = 0) {
  validateNumber2(offset, "offset");
  const val = this[offset];
  if (val === void 0) {
    boundsError2(offset, this.length - 1);
  }
  return val | (val & 2 ** 7) * 33554430;
};
Buffer4.prototype.readInt16LE = function readInt16LE2(offset = 0) {
  validateNumber2(offset, "offset");
  const first = this[offset];
  const last = this[offset + 1];
  if (first === void 0 || last === void 0) {
    boundsError2(offset, this.length - 2);
  }
  const val = first + last * 2 ** 8;
  return val | (val & 2 ** 15) * 131070;
};
Buffer4.prototype.readInt16BE = function readInt16BE2(offset = 0) {
  validateNumber2(offset, "offset");
  const first = this[offset];
  const last = this[offset + 1];
  if (first === void 0 || last === void 0) {
    boundsError2(offset, this.length - 2);
  }
  const val = first * 2 ** 8 + last;
  return val | (val & 2 ** 15) * 131070;
};
Buffer4.prototype.readInt32LE = function readInt32LE2(offset = 0) {
  validateNumber2(offset, "offset");
  const first = this[offset];
  const last = this[offset + 3];
  if (first === void 0 || last === void 0) {
    boundsError2(offset, this.length - 4);
  }
  return first + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + (last << 24);
};
Buffer4.prototype.readInt32BE = function readInt32BE2(offset = 0) {
  validateNumber2(offset, "offset");
  const first = this[offset];
  const last = this[offset + 3];
  if (first === void 0 || last === void 0) {
    boundsError2(offset, this.length - 4);
  }
  return (first << 24) + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + last;
};
Buffer4.prototype.readBigInt64LE = defineBigIntMethod2(function readBigInt64LE2(offset) {
  offset = offset >>> 0;
  validateNumber2(offset, "offset");
  const first = this[offset];
  const last = this[offset + 7];
  if (first === void 0 || last === void 0) {
    boundsError2(offset, this.length - 8);
  }
  const val = this[offset + 4] + this[offset + 5] * 2 ** 8 + this[offset + 6] * 2 ** 16 + (last << 24);
  return (BigInt(val) << BigInt(32)) + BigInt(first + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 24);
});
Buffer4.prototype.readBigInt64BE = defineBigIntMethod2(function readBigInt64BE2(offset) {
  offset = offset >>> 0;
  validateNumber2(offset, "offset");
  const first = this[offset];
  const last = this[offset + 7];
  if (first === void 0 || last === void 0) {
    boundsError2(offset, this.length - 8);
  }
  const val = (first << 24) + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + this[++offset];
  return (BigInt(val) << BigInt(32)) + BigInt(this[++offset] * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + last);
});
Buffer4.prototype.readFloatLE = function readFloatLE2(offset) {
  return bigEndian2 ? readFloatBackwards2(this, offset) : readFloatForwards2(this, offset);
};
Buffer4.prototype.readFloatBE = function readFloatBE2(offset) {
  return bigEndian2 ? readFloatForwards2(this, offset) : readFloatBackwards2(this, offset);
};
Buffer4.prototype.readDoubleLE = function readDoubleLE2(offset) {
  return bigEndian2 ? readDoubleBackwards2(this, offset) : readDoubleForwards2(this, offset);
};
Buffer4.prototype.readDoubleBE = function readDoubleBE2(offset) {
  return bigEndian2 ? readDoubleForwards2(this, offset) : readDoubleBackwards2(this, offset);
};
Buffer4.prototype.writeUintLE = Buffer4.prototype.writeUIntLE = function writeUIntLE2(value, offset, byteLength6) {
  if (byteLength6 === 6) {
    return writeU_Int48LE2(this, value, offset, 0, 281474976710655);
  }
  if (byteLength6 === 5) {
    return writeU_Int40LE2(this, value, offset, 0, 1099511627775);
  }
  if (byteLength6 === 3) {
    return writeU_Int24LE2(this, value, offset, 0, 16777215);
  }
  if (byteLength6 === 4) {
    return writeU_Int32LE2(this, value, offset, 0, 4294967295);
  }
  if (byteLength6 === 2) {
    return writeU_Int16LE2(this, value, offset, 0, 65535);
  }
  if (byteLength6 === 1) {
    return writeU_Int82(this, value, offset, 0, 255);
  }
  boundsError2(byteLength6, 6, "byteLength");
};
Buffer4.prototype.writeUintBE = Buffer4.prototype.writeUIntBE = function writeUIntBE2(value, offset, byteLength6) {
  if (byteLength6 === 6) {
    return writeU_Int48BE2(this, value, offset, 0, 281474976710655);
  }
  if (byteLength6 === 5) {
    return writeU_Int40BE2(this, value, offset, 0, 1099511627775);
  }
  if (byteLength6 === 3) {
    return writeU_Int24BE2(this, value, offset, 0, 16777215);
  }
  if (byteLength6 === 4) {
    return writeU_Int32BE2(this, value, offset, 0, 4294967295);
  }
  if (byteLength6 === 2) {
    return writeU_Int16BE2(this, value, offset, 0, 65535);
  }
  if (byteLength6 === 1) {
    return writeU_Int82(this, value, offset, 0, 255);
  }
  boundsError2(byteLength6, 6, "byteLength");
};
Buffer4.prototype.writeUint8 = Buffer4.prototype.writeUInt8 = function writeUInt82(value, offset = 0) {
  return writeU_Int82(this, value, offset, 0, 255);
};
Buffer4.prototype.writeUint16LE = Buffer4.prototype.writeUInt16LE = function writeUInt16LE2(value, offset = 0) {
  return writeU_Int16LE2(this, value, offset, 0, 65535);
};
Buffer4.prototype.writeUint16BE = Buffer4.prototype.writeUInt16BE = function writeUInt16BE2(value, offset = 0) {
  return writeU_Int16BE2(this, value, offset, 0, 65535);
};
Buffer4.prototype.writeUint32LE = Buffer4.prototype.writeUInt32LE = function writeUInt32LE2(value, offset = 0) {
  return _writeUInt32LE2(this, value, offset, 0, 4294967295);
};
Buffer4.prototype.writeUint32BE = Buffer4.prototype.writeUInt32BE = function writeUInt32BE2(value, offset = 0) {
  return _writeUInt32BE2(this, value, offset, 0, 4294967295);
};
function wrtBigUInt64LE2(buf, value, offset, min4, max2) {
  checkIntBI2(value, min4, max2, buf, offset, 7);
  let lo3 = Number(value & BigInt(4294967295));
  buf[offset++] = lo3;
  lo3 = lo3 >> 8;
  buf[offset++] = lo3;
  lo3 = lo3 >> 8;
  buf[offset++] = lo3;
  lo3 = lo3 >> 8;
  buf[offset++] = lo3;
  let hi2 = Number(value >> BigInt(32) & BigInt(4294967295));
  buf[offset++] = hi2;
  hi2 = hi2 >> 8;
  buf[offset++] = hi2;
  hi2 = hi2 >> 8;
  buf[offset++] = hi2;
  hi2 = hi2 >> 8;
  buf[offset++] = hi2;
  return offset;
}
function wrtBigUInt64BE2(buf, value, offset, min4, max2) {
  checkIntBI2(value, min4, max2, buf, offset, 7);
  let lo3 = Number(value & BigInt(4294967295));
  buf[offset + 7] = lo3;
  lo3 = lo3 >> 8;
  buf[offset + 6] = lo3;
  lo3 = lo3 >> 8;
  buf[offset + 5] = lo3;
  lo3 = lo3 >> 8;
  buf[offset + 4] = lo3;
  let hi2 = Number(value >> BigInt(32) & BigInt(4294967295));
  buf[offset + 3] = hi2;
  hi2 = hi2 >> 8;
  buf[offset + 2] = hi2;
  hi2 = hi2 >> 8;
  buf[offset + 1] = hi2;
  hi2 = hi2 >> 8;
  buf[offset] = hi2;
  return offset + 8;
}
Buffer4.prototype.writeBigUint64LE = Buffer4.prototype.writeBigUInt64LE = defineBigIntMethod2(function writeBigUInt64LE2(value, offset = 0) {
  return wrtBigUInt64LE2(this, value, offset, BigInt(0), BigInt("0xffffffffffffffff"));
});
Buffer4.prototype.writeBigUint64BE = Buffer4.prototype.writeBigUInt64BE = defineBigIntMethod2(function writeBigUInt64BE2(value, offset = 0) {
  return wrtBigUInt64BE2(this, value, offset, BigInt(0), BigInt("0xffffffffffffffff"));
});
Buffer4.prototype.writeIntLE = function writeIntLE2(value, offset, byteLength6) {
  if (byteLength6 === 6) {
    return writeU_Int48LE2(this, value, offset, -140737488355328, 140737488355327);
  }
  if (byteLength6 === 5) {
    return writeU_Int40LE2(this, value, offset, -549755813888, 549755813887);
  }
  if (byteLength6 === 3) {
    return writeU_Int24LE2(this, value, offset, -8388608, 8388607);
  }
  if (byteLength6 === 4) {
    return writeU_Int32LE2(this, value, offset, -2147483648, 2147483647);
  }
  if (byteLength6 === 2) {
    return writeU_Int16LE2(this, value, offset, -32768, 32767);
  }
  if (byteLength6 === 1) {
    return writeU_Int82(this, value, offset, -128, 127);
  }
  boundsError2(byteLength6, 6, "byteLength");
};
Buffer4.prototype.writeIntBE = function writeIntBE2(value, offset, byteLength6) {
  if (byteLength6 === 6) {
    return writeU_Int48BE2(this, value, offset, -140737488355328, 140737488355327);
  }
  if (byteLength6 === 5) {
    return writeU_Int40BE2(this, value, offset, -549755813888, 549755813887);
  }
  if (byteLength6 === 3) {
    return writeU_Int24BE2(this, value, offset, -8388608, 8388607);
  }
  if (byteLength6 === 4) {
    return writeU_Int32BE2(this, value, offset, -2147483648, 2147483647);
  }
  if (byteLength6 === 2) {
    return writeU_Int16BE2(this, value, offset, -32768, 32767);
  }
  if (byteLength6 === 1) {
    return writeU_Int82(this, value, offset, -128, 127);
  }
  boundsError2(byteLength6, 6, "byteLength");
};
Buffer4.prototype.writeInt8 = function writeInt82(value, offset = 0) {
  return writeU_Int82(this, value, offset, -128, 127);
};
Buffer4.prototype.writeInt16LE = function writeInt16LE2(value, offset = 0) {
  return writeU_Int16LE2(this, value, offset, -32768, 32767);
};
Buffer4.prototype.writeInt16BE = function writeInt16BE2(value, offset = 0) {
  return writeU_Int16BE2(this, value, offset, -32768, 32767);
};
Buffer4.prototype.writeInt32LE = function writeInt32LE2(value, offset = 0) {
  return writeU_Int32LE2(this, value, offset, -2147483648, 2147483647);
};
Buffer4.prototype.writeInt32BE = function writeInt32BE2(value, offset = 0) {
  return writeU_Int32BE2(this, value, offset, -2147483648, 2147483647);
};
Buffer4.prototype.writeBigInt64LE = defineBigIntMethod2(function writeBigInt64LE2(value, offset = 0) {
  return wrtBigUInt64LE2(this, value, offset, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
});
Buffer4.prototype.writeBigInt64BE = defineBigIntMethod2(function writeBigInt64BE2(value, offset = 0) {
  return wrtBigUInt64BE2(this, value, offset, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
});
Buffer4.prototype.writeFloatLE = function writeFloatLE2(value, offset) {
  return bigEndian2 ? writeFloatBackwards2(this, value, offset) : writeFloatForwards2(this, value, offset);
};
Buffer4.prototype.writeFloatBE = function writeFloatBE2(value, offset) {
  return bigEndian2 ? writeFloatForwards2(this, value, offset) : writeFloatBackwards2(this, value, offset);
};
Buffer4.prototype.writeDoubleLE = function writeDoubleLE2(value, offset) {
  return bigEndian2 ? writeDoubleBackwards2(this, value, offset) : writeDoubleForwards2(this, value, offset);
};
Buffer4.prototype.writeDoubleBE = function writeDoubleBE2(value, offset) {
  return bigEndian2 ? writeDoubleForwards2(this, value, offset) : writeDoubleBackwards2(this, value, offset);
};
Buffer4.prototype.copy = function copy4(target, targetStart, sourceStart, sourceEnd) {
  if (!isUint8Array2(this)) {
    throw new codes2.ERR_INVALID_ARG_TYPE("source", ["Buffer", "Uint8Array"], this);
  }
  if (!isUint8Array2(target)) {
    throw new codes2.ERR_INVALID_ARG_TYPE("target", ["Buffer", "Uint8Array"], target);
  }
  if (targetStart === void 0) {
    targetStart = 0;
  } else {
    targetStart = toInteger2(targetStart, 0);
    if (targetStart < 0) {
      throw new codes2.ERR_OUT_OF_RANGE("targetStart", ">= 0", targetStart);
    }
  }
  if (sourceStart === void 0) {
    sourceStart = 0;
  } else {
    sourceStart = toInteger2(sourceStart, 0);
    if (sourceStart < 0) {
      throw new codes2.ERR_OUT_OF_RANGE("sourceStart", ">= 0", sourceStart);
    }
    if (sourceStart >= MAX_UINT323) {
      throw new codes2.ERR_OUT_OF_RANGE("sourceStart", `< ${MAX_UINT323}`, sourceStart);
    }
  }
  if (sourceEnd === void 0) {
    sourceEnd = this.length;
  } else {
    sourceEnd = toInteger2(sourceEnd, 0);
    if (sourceEnd < 0) {
      throw new codes2.ERR_OUT_OF_RANGE("sourceEnd", ">= 0", sourceEnd);
    }
    if (sourceEnd >= MAX_UINT323) {
      throw new codes2.ERR_OUT_OF_RANGE("sourceEnd", `< ${MAX_UINT323}`, sourceEnd);
    }
  }
  if (targetStart >= target.length) {
    return 0;
  }
  if (sourceEnd > 0 && sourceEnd < sourceStart) {
    sourceEnd = sourceStart;
  }
  if (sourceEnd === sourceStart) {
    return 0;
  }
  if (target.length === 0 || this.length === 0) {
    return 0;
  }
  if (sourceEnd > this.length) {
    sourceEnd = this.length;
  }
  if (target.length - targetStart < sourceEnd - sourceStart) {
    sourceEnd = target.length - targetStart + sourceStart;
  }
  const len = sourceEnd - sourceStart;
  if (this === target && typeof Uint8Array.prototype.copyWithin === "function") {
    this.copyWithin(targetStart, sourceStart, sourceEnd);
  } else {
    Uint8Array.prototype.set.call(target, this.subarray(sourceStart, sourceEnd), targetStart);
  }
  return len;
};
Buffer4.prototype.fill = function fill2(val, start, end, encoding) {
  if (typeof val === "string") {
    if (typeof start === "string") {
      encoding = start;
      start = 0;
      end = this.length;
    } else if (typeof end === "string") {
      encoding = end;
      end = this.length;
    }
    if (encoding !== void 0 && typeof encoding !== "string") {
      throw new TypeError("encoding must be a string");
    }
    if (typeof encoding === "string" && !Buffer4.isEncoding(encoding)) {
      throw new TypeError("Unknown encoding: " + encoding);
    }
    if (val.length === 1) {
      const code2 = val.charCodeAt(0);
      if (encoding === "utf8" && code2 < 128 || encoding === "latin1") {
        val = code2;
      }
    }
  } else if (typeof val === "number") {
    val = val & 255;
  } else if (typeof val === "boolean") {
    val = Number(val);
  }
  if (start < 0 || this.length < start || this.length < end) {
    throw new RangeError("Out of range index");
  }
  if (end <= start) {
    return this;
  }
  start = start >>> 0;
  end = end === void 0 ? this.length : end >>> 0;
  if (!val) {
    val = 0;
  }
  let i;
  if (typeof val === "number") {
    for (i = start; i < end; ++i) {
      this[i] = val;
    }
  } else {
    const bytes = Buffer4.isBuffer(val) ? val : Buffer4.from(val, encoding);
    const len = bytes.length;
    if (len === 0) {
      throw new codes2.ERR_INVALID_ARG_VALUE("value", val);
    }
    for (i = 0; i < end - start; ++i) {
      this[i + start] = bytes[i % len];
    }
  }
  return this;
};
function checkBounds4(buf, offset, byteLength22) {
  validateNumber2(offset, "offset");
  if (buf[offset] === void 0 || buf[offset + byteLength22] === void 0) {
    boundsError2(offset, buf.length - (byteLength22 + 1));
  }
}
function checkIntBI2(value, min4, max2, buf, offset, byteLength22) {
  if (value > max2 || value < min4) {
    const n = typeof min4 === "bigint" ? "n" : "";
    let range;
    if (byteLength22 > 3) {
      if (min4 === 0 || min4 === BigInt(0)) {
        range = `>= 0${n} and < 2${n} ** ${(byteLength22 + 1) * 8}${n}`;
      } else {
        range = `>= -(2${n} ** ${(byteLength22 + 1) * 8 - 1}${n}) and < 2 ** ${(byteLength22 + 1) * 8 - 1}${n}`;
      }
    } else {
      range = `>= ${min4}${n} and <= ${max2}${n}`;
    }
    throw new codes2.ERR_OUT_OF_RANGE("value", range, value);
  }
  checkBounds4(buf, offset, byteLength22);
}
function utf8ToBytes2(string, units) {
  units = units || Infinity;
  let codePoint;
  const length = string.length;
  let leadSurrogate = null;
  const bytes = [];
  for (let i = 0; i < length; ++i) {
    codePoint = string.charCodeAt(i);
    if (codePoint > 55295 && codePoint < 57344) {
      if (!leadSurrogate) {
        if (codePoint > 56319) {
          if ((units -= 3) > -1) {
            bytes.push(239, 191, 189);
          }
          continue;
        } else if (i + 1 === length) {
          if ((units -= 3) > -1) {
            bytes.push(239, 191, 189);
          }
          continue;
        }
        leadSurrogate = codePoint;
        continue;
      }
      if (codePoint < 56320) {
        if ((units -= 3) > -1) {
          bytes.push(239, 191, 189);
        }
        leadSurrogate = codePoint;
        continue;
      }
      codePoint = (leadSurrogate - 55296 << 10 | codePoint - 56320) + 65536;
    } else if (leadSurrogate) {
      if ((units -= 3) > -1) {
        bytes.push(239, 191, 189);
      }
    }
    leadSurrogate = null;
    if (codePoint < 128) {
      if ((units -= 1) < 0) {
        break;
      }
      bytes.push(codePoint);
    } else if (codePoint < 2048) {
      if ((units -= 2) < 0) {
        break;
      }
      bytes.push(codePoint >> 6 | 192, codePoint & 63 | 128);
    } else if (codePoint < 65536) {
      if ((units -= 3) < 0) {
        break;
      }
      bytes.push(codePoint >> 12 | 224, codePoint >> 6 & 63 | 128, codePoint & 63 | 128);
    } else if (codePoint < 1114112) {
      if ((units -= 4) < 0) {
        break;
      }
      bytes.push(codePoint >> 18 | 240, codePoint >> 12 & 63 | 128, codePoint >> 6 & 63 | 128, codePoint & 63 | 128);
    } else {
      throw new Error("Invalid code point");
    }
  }
  return bytes;
}
function blitBuffer2(src, dst, offset, byteLength6) {
  let i;
  const length = byteLength6 === void 0 ? src.length : byteLength6;
  for (i = 0; i < length; ++i) {
    if (i + offset >= dst.length || i >= src.length) {
      break;
    }
    dst[i + offset] = src[i];
  }
  return i;
}
function isInstance2(obj2, type) {
  return obj2 instanceof type || obj2 != null && obj2.constructor != null && obj2.constructor.name != null && obj2.constructor.name === type.name;
}
var hexSliceLookupTable2 = function() {
  const alphabet = "0123456789abcdef";
  const table = new Array(256);
  for (let i = 0; i < 16; ++i) {
    const i16 = i * 16;
    for (let j2 = 0; j2 < 16; ++j2) {
      table[i16 + j2] = alphabet[i] + alphabet[j2];
    }
  }
  return table;
}();
function defineBigIntMethod2(fn) {
  return typeof BigInt === "undefined" ? BufferBigIntNotDefined2 : fn;
}
function BufferBigIntNotDefined2() {
  throw new Error("BigInt not supported");
}
var atob3 = globalThis.atob;
var Blob3 = globalThis.Blob;
var btoa2 = globalThis.btoa;

// deno:https://deno.land/std@0.146.0/node/internal/error_codes.ts
var codes3 = {};

// deno:https://deno.land/std@0.146.0/node/internal/hide_stack_frames.ts
function hideStackFrames3(fn) {
  const hidden = "__node_internal_" + fn.name;
  Object.defineProperty(fn, "name", { value: hidden });
  return fn;
}

// deno:https://deno.land/std@0.146.0/node/internal/util/types.ts
var types_exports5 = {};
__export(types_exports5, {
  isAnyArrayBuffer: () => isAnyArrayBuffer6,
  isArgumentsObject: () => isArgumentsObject6,
  isArrayBuffer: () => isArrayBuffer6,
  isArrayBufferView: () => isArrayBufferView3,
  isAsyncFunction: () => isAsyncFunction6,
  isBigInt64Array: () => isBigInt64Array2,
  isBigIntObject: () => isBigIntObject6,
  isBigUint64Array: () => isBigUint64Array2,
  isBooleanObject: () => isBooleanObject6,
  isBoxedPrimitive: () => isBoxedPrimitive6,
  isCryptoKey: () => isCryptoKey3,
  isDataView: () => isDataView6,
  isDate: () => isDate7,
  isFloat32Array: () => isFloat32Array2,
  isFloat64Array: () => isFloat64Array2,
  isGeneratorFunction: () => isGeneratorFunction6,
  isGeneratorObject: () => isGeneratorObject6,
  isInt16Array: () => isInt16Array2,
  isInt32Array: () => isInt32Array2,
  isInt8Array: () => isInt8Array2,
  isKeyObject: () => isKeyObject3,
  isMap: () => isMap6,
  isMapIterator: () => isMapIterator6,
  isModuleNamespaceObject: () => isModuleNamespaceObject6,
  isNativeError: () => isNativeError6,
  isNumberObject: () => isNumberObject6,
  isPromise: () => isPromise6,
  isRegExp: () => isRegExp7,
  isSet: () => isSet6,
  isSetIterator: () => isSetIterator6,
  isSharedArrayBuffer: () => isSharedArrayBuffer6,
  isStringObject: () => isStringObject6,
  isSymbolObject: () => isSymbolObject6,
  isTypedArray: () => isTypedArray2,
  isUint16Array: () => isUint16Array2,
  isUint32Array: () => isUint32Array2,
  isUint8Array: () => isUint8Array3,
  isUint8ClampedArray: () => isUint8ClampedArray2,
  isWeakMap: () => isWeakMap6,
  isWeakSet: () => isWeakSet6
});

// deno:https://deno.land/std@0.146.0/node/internal_binding/types.ts
var types_exports4 = {};
__export(types_exports4, {
  default: () => types_default4,
  isAnyArrayBuffer: () => isAnyArrayBuffer5,
  isArgumentsObject: () => isArgumentsObject5,
  isArrayBuffer: () => isArrayBuffer5,
  isAsyncFunction: () => isAsyncFunction5,
  isBigIntObject: () => isBigIntObject5,
  isBooleanObject: () => isBooleanObject5,
  isBoxedPrimitive: () => isBoxedPrimitive5,
  isDataView: () => isDataView5,
  isDate: () => isDate6,
  isGeneratorFunction: () => isGeneratorFunction5,
  isGeneratorObject: () => isGeneratorObject5,
  isMap: () => isMap5,
  isMapIterator: () => isMapIterator5,
  isModuleNamespaceObject: () => isModuleNamespaceObject5,
  isNativeError: () => isNativeError5,
  isNumberObject: () => isNumberObject5,
  isPromise: () => isPromise5,
  isRegExp: () => isRegExp6,
  isSet: () => isSet5,
  isSetIterator: () => isSetIterator5,
  isSharedArrayBuffer: () => isSharedArrayBuffer5,
  isStringObject: () => isStringObject5,
  isSymbolObject: () => isSymbolObject5,
  isWeakMap: () => isWeakMap5,
  isWeakSet: () => isWeakSet5
});
var _toString5 = Object.prototype.toString;
var _isObjectLike5 = (value) => value !== null && typeof value === "object";
var _isFunctionLike3 = (value) => value !== null && typeof value === "function";
function isAnyArrayBuffer5(value) {
  return _isObjectLike5(value) && (_toString5.call(value) === "[object ArrayBuffer]" || _toString5.call(value) === "[object SharedArrayBuffer]");
}
function isArgumentsObject5(value) {
  return _isObjectLike5(value) && _toString5.call(value) === "[object Arguments]";
}
function isArrayBuffer5(value) {
  return _isObjectLike5(value) && _toString5.call(value) === "[object ArrayBuffer]";
}
function isAsyncFunction5(value) {
  return _isFunctionLike3(value) && _toString5.call(value) === "[object AsyncFunction]";
}
function isBooleanObject5(value) {
  return _isObjectLike5(value) && _toString5.call(value) === "[object Boolean]";
}
function isBoxedPrimitive5(value) {
  return isBooleanObject5(value) || isStringObject5(value) || isNumberObject5(value) || isSymbolObject5(value) || isBigIntObject5(value);
}
function isDataView5(value) {
  return _isObjectLike5(value) && _toString5.call(value) === "[object DataView]";
}
function isDate6(value) {
  return _isObjectLike5(value) && _toString5.call(value) === "[object Date]";
}
function isGeneratorFunction5(value) {
  return _isFunctionLike3(value) && _toString5.call(value) === "[object GeneratorFunction]";
}
function isGeneratorObject5(value) {
  return _isObjectLike5(value) && _toString5.call(value) === "[object Generator]";
}
function isMap5(value) {
  return _isObjectLike5(value) && _toString5.call(value) === "[object Map]";
}
function isMapIterator5(value) {
  return _isObjectLike5(value) && _toString5.call(value) === "[object Map Iterator]";
}
function isModuleNamespaceObject5(value) {
  return _isObjectLike5(value) && _toString5.call(value) === "[object Module]";
}
function isNativeError5(value) {
  return _isObjectLike5(value) && _toString5.call(value) === "[object Error]";
}
function isNumberObject5(value) {
  return _isObjectLike5(value) && _toString5.call(value) === "[object Number]";
}
function isBigIntObject5(value) {
  return _isObjectLike5(value) && _toString5.call(value) === "[object BigInt]";
}
function isPromise5(value) {
  return _isObjectLike5(value) && _toString5.call(value) === "[object Promise]";
}
function isRegExp6(value) {
  return _isObjectLike5(value) && _toString5.call(value) === "[object RegExp]";
}
function isSet5(value) {
  return _isObjectLike5(value) && _toString5.call(value) === "[object Set]";
}
function isSetIterator5(value) {
  return _isObjectLike5(value) && _toString5.call(value) === "[object Set Iterator]";
}
function isSharedArrayBuffer5(value) {
  return _isObjectLike5(value) && _toString5.call(value) === "[object SharedArrayBuffer]";
}
function isStringObject5(value) {
  return _isObjectLike5(value) && _toString5.call(value) === "[object String]";
}
function isSymbolObject5(value) {
  return _isObjectLike5(value) && _toString5.call(value) === "[object Symbol]";
}
function isWeakMap5(value) {
  return _isObjectLike5(value) && _toString5.call(value) === "[object WeakMap]";
}
function isWeakSet5(value) {
  return _isObjectLike5(value) && _toString5.call(value) === "[object WeakSet]";
}
var types_default4 = {
  isAsyncFunction: isAsyncFunction5,
  isGeneratorFunction: isGeneratorFunction5,
  isAnyArrayBuffer: isAnyArrayBuffer5,
  isArrayBuffer: isArrayBuffer5,
  isArgumentsObject: isArgumentsObject5,
  isBoxedPrimitive: isBoxedPrimitive5,
  isDataView: isDataView5,
  isMap: isMap5,
  isMapIterator: isMapIterator5,
  isModuleNamespaceObject: isModuleNamespaceObject5,
  isNativeError: isNativeError5,
  isPromise: isPromise5,
  isSet: isSet5,
  isSetIterator: isSetIterator5,
  isWeakMap: isWeakMap5,
  isWeakSet: isWeakSet5,
  isRegExp: isRegExp6,
  isDate: isDate6,
  isStringObject: isStringObject5,
  isNumberObject: isNumberObject5,
  isBooleanObject: isBooleanObject5,
  isBigIntObject: isBigIntObject5
};

// deno:https://deno.land/std@0.146.0/node/internal/crypto/constants.ts
var kHandle3 = Symbol("kHandle");
var kKeyObject3 = Symbol("kKeyObject");

// deno:https://deno.land/std@0.146.0/node/internal/crypto/_keys.ts
var kKeyType3 = Symbol("kKeyType");
function isKeyObject3(obj2) {
  return obj2 != null && obj2[kKeyType3] !== void 0;
}
function isCryptoKey3(obj2) {
  return obj2 != null && obj2[kKeyObject3] !== void 0;
}

// deno:https://deno.land/std@0.146.0/node/internal/util/types.ts
var _toString6 = Object.prototype.toString;
var _isObjectLike6 = (value) => value !== null && typeof value === "object";
function isArrayBufferView3(value) {
  return ArrayBuffer.isView(value);
}
function isBigInt64Array2(value) {
  return _isObjectLike6(value) && _toString6.call(value) === "[object BigInt64Array]";
}
function isBigUint64Array2(value) {
  return _isObjectLike6(value) && _toString6.call(value) === "[object BigUint64Array]";
}
function isFloat32Array2(value) {
  return _isObjectLike6(value) && _toString6.call(value) === "[object Float32Array]";
}
function isFloat64Array2(value) {
  return _isObjectLike6(value) && _toString6.call(value) === "[object Float64Array]";
}
function isInt8Array2(value) {
  return _isObjectLike6(value) && _toString6.call(value) === "[object Int8Array]";
}
function isInt16Array2(value) {
  return _isObjectLike6(value) && _toString6.call(value) === "[object Int16Array]";
}
function isInt32Array2(value) {
  return _isObjectLike6(value) && _toString6.call(value) === "[object Int32Array]";
}
function isTypedArray2(value) {
  const reTypedTag = /^\[object (?:Float(?:32|64)|(?:Int|Uint)(?:8|16|32)|Uint8Clamped)Array\]$/;
  return _isObjectLike6(value) && reTypedTag.test(_toString6.call(value));
}
function isUint8Array3(value) {
  return _isObjectLike6(value) && _toString6.call(value) === "[object Uint8Array]";
}
function isUint8ClampedArray2(value) {
  return _isObjectLike6(value) && _toString6.call(value) === "[object Uint8ClampedArray]";
}
function isUint16Array2(value) {
  return _isObjectLike6(value) && _toString6.call(value) === "[object Uint16Array]";
}
function isUint32Array2(value) {
  return _isObjectLike6(value) && _toString6.call(value) === "[object Uint32Array]";
}
var {
  isDate: isDate7,
  isArgumentsObject: isArgumentsObject6,
  isBigIntObject: isBigIntObject6,
  isBooleanObject: isBooleanObject6,
  isNumberObject: isNumberObject6,
  isStringObject: isStringObject6,
  isSymbolObject: isSymbolObject6,
  isNativeError: isNativeError6,
  isRegExp: isRegExp7,
  isAsyncFunction: isAsyncFunction6,
  isGeneratorFunction: isGeneratorFunction6,
  isGeneratorObject: isGeneratorObject6,
  isPromise: isPromise6,
  isMap: isMap6,
  isSet: isSet6,
  isMapIterator: isMapIterator6,
  isSetIterator: isSetIterator6,
  isWeakMap: isWeakMap6,
  isWeakSet: isWeakSet6,
  isArrayBuffer: isArrayBuffer6,
  isDataView: isDataView6,
  isSharedArrayBuffer: isSharedArrayBuffer6,
  isModuleNamespaceObject: isModuleNamespaceObject6,
  isAnyArrayBuffer: isAnyArrayBuffer6,
  isBoxedPrimitive: isBoxedPrimitive6
} = types_exports4;

// deno:https://deno.land/std@0.146.0/node/internal/normalize_encoding.mjs
function normalizeEncoding5(enc) {
  if (enc == null || enc === "utf8" || enc === "utf-8")
    return "utf8";
  return slowCases4(enc);
}
function slowCases4(enc) {
  switch (enc.length) {
    case 4:
      if (enc === "UTF8")
        return "utf8";
      if (enc === "ucs2" || enc === "UCS2")
        return "utf16le";
      enc = `${enc}`.toLowerCase();
      if (enc === "utf8")
        return "utf8";
      if (enc === "ucs2")
        return "utf16le";
      break;
    case 3:
      if (enc === "hex" || enc === "HEX" || `${enc}`.toLowerCase() === "hex") {
        return "hex";
      }
      break;
    case 5:
      if (enc === "ascii")
        return "ascii";
      if (enc === "ucs-2")
        return "utf16le";
      if (enc === "UTF-8")
        return "utf8";
      if (enc === "ASCII")
        return "ascii";
      if (enc === "UCS-2")
        return "utf16le";
      enc = `${enc}`.toLowerCase();
      if (enc === "utf-8")
        return "utf8";
      if (enc === "ascii")
        return "ascii";
      if (enc === "ucs-2")
        return "utf16le";
      break;
    case 6:
      if (enc === "base64")
        return "base64";
      if (enc === "latin1" || enc === "binary")
        return "latin1";
      if (enc === "BASE64")
        return "base64";
      if (enc === "LATIN1" || enc === "BINARY")
        return "latin1";
      enc = `${enc}`.toLowerCase();
      if (enc === "base64")
        return "base64";
      if (enc === "latin1" || enc === "binary")
        return "latin1";
      break;
    case 7:
      if (enc === "utf16le" || enc === "UTF16LE" || `${enc}`.toLowerCase() === "utf16le") {
        return "utf16le";
      }
      break;
    case 8:
      if (enc === "utf-16le" || enc === "UTF-16LE" || `${enc}`.toLowerCase() === "utf-16le") {
        return "utf16le";
      }
      break;
    case 9:
      if (enc === "base64url" || enc === "BASE64URL" || `${enc}`.toLowerCase() === "base64url") {
        return "base64url";
      }
      break;
    default:
      if (enc === "")
        return "utf8";
  }
}

// deno:https://deno.land/std@0.146.0/node/internal/validators.mjs
function isInt323(value) {
  return value === (value | 0);
}
function isUint323(value) {
  return value === value >>> 0;
}
var validateBuffer3 = hideStackFrames3((buffer, name = "buffer") => {
  if (!isArrayBufferView3(buffer)) {
    throw new codes3.ERR_INVALID_ARG_TYPE(name, ["Buffer", "TypedArray", "DataView"], buffer);
  }
});
var validateInteger3 = hideStackFrames3((value, name, min4 = Number.MIN_SAFE_INTEGER, max2 = Number.MAX_SAFE_INTEGER) => {
  if (typeof value !== "number") {
    throw new codes3.ERR_INVALID_ARG_TYPE(name, "number", value);
  }
  if (!Number.isInteger(value)) {
    throw new codes3.ERR_OUT_OF_RANGE(name, "an integer", value);
  }
  if (value < min4 || value > max2) {
    throw new codes3.ERR_OUT_OF_RANGE(name, `>= ${min4} && <= ${max2}`, value);
  }
});
var validateObject3 = hideStackFrames3((value, name, options) => {
  const useDefaultOptions = options == null;
  const allowArray = useDefaultOptions ? false : options.allowArray;
  const allowFunction = useDefaultOptions ? false : options.allowFunction;
  const nullable = useDefaultOptions ? false : options.nullable;
  if (!nullable && value === null || !allowArray && Array.isArray(value) || typeof value !== "object" && (!allowFunction || typeof value !== "function")) {
    throw new codes3.ERR_INVALID_ARG_TYPE(name, "Object", value);
  }
});
var validateInt323 = hideStackFrames3((value, name, min4 = -2147483648, max2 = 2147483647) => {
  if (!isInt323(value)) {
    if (typeof value !== "number") {
      throw new codes3.ERR_INVALID_ARG_TYPE(name, "number", value);
    }
    if (!Number.isInteger(value)) {
      throw new codes3.ERR_OUT_OF_RANGE(name, "an integer", value);
    }
    throw new codes3.ERR_OUT_OF_RANGE(name, `>= ${min4} && <= ${max2}`, value);
  }
  if (value < min4 || value > max2) {
    throw new codes3.ERR_OUT_OF_RANGE(name, `>= ${min4} && <= ${max2}`, value);
  }
});
var validateUint323 = hideStackFrames3((value, name, positive) => {
  if (!isUint323(value)) {
    if (typeof value !== "number") {
      throw new codes3.ERR_INVALID_ARG_TYPE(name, "number", value);
    }
    if (!Number.isInteger(value)) {
      throw new codes3.ERR_OUT_OF_RANGE(name, "an integer", value);
    }
    const min4 = positive ? 1 : 0;
    throw new codes3.ERR_OUT_OF_RANGE(name, `>= ${min4} && < 4294967296`, value);
  }
  if (positive && value === 0) {
    throw new codes3.ERR_OUT_OF_RANGE(name, ">= 1 && < 4294967296", value);
  }
});
function validateString3(value, name) {
  if (typeof value !== "string") {
    throw new codes3.ERR_INVALID_ARG_TYPE(name, "string", value);
  }
}
var validateOneOf3 = hideStackFrames3((value, name, oneOf) => {
  if (!Array.prototype.includes.call(oneOf, value)) {
    const allowed = Array.prototype.join.call(Array.prototype.map.call(oneOf, (v2) => typeof v2 === "string" ? `'${v2}'` : String(v2)), ", ");
    const reason = "must be one of: " + allowed;
    throw new codes3.ERR_INVALID_ARG_VALUE(name, value, reason);
  }
});
var validateCallback3 = hideStackFrames3((callback) => {
  if (typeof callback !== "function") {
    throw new codes3.ERR_INVALID_CALLBACK(callback);
  }
});
var validateAbortSignal4 = hideStackFrames3((signal, name) => {
  if (signal !== void 0 && (signal === null || typeof signal !== "object" || !("aborted" in signal))) {
    throw new codes3.ERR_INVALID_ARG_TYPE(name, "AbortSignal", signal);
  }
});
var validateFunction3 = hideStackFrames3((value, name) => {
  if (typeof value !== "function") {
    throw new codes3.ERR_INVALID_ARG_TYPE(name, "Function", value);
  }
});
var validateArray3 = hideStackFrames3((value, name, minLength = 0) => {
  if (!Array.isArray(value)) {
    throw new codes3.ERR_INVALID_ARG_TYPE(name, "Array", value);
  }
  if (value.length < minLength) {
    const reason = `must be longer than ${minLength}`;
    throw new codes3.ERR_INVALID_ARG_VALUE(name, value, reason);
  }
});

// deno:https://deno.land/std@0.146.0/node/internal/util.mjs
var customInspectSymbol6 = Symbol.for("nodejs.util.inspect.custom");
var kEnumerableProperty3 = /* @__PURE__ */ Object.create(null);
kEnumerableProperty3.enumerable = true;
var codesWarned2 = /* @__PURE__ */ new Set();
function deprecate2(fn, msg, code2) {
  if (code2 !== void 0) {
    validateString3(code2, "code");
  }
  let warned = false;
  function deprecated(...args) {
    if (!warned) {
      warned = true;
      if (code2 !== void 0) {
        if (!codesWarned2.has(code2)) {
          process.emitWarning(msg, "DeprecationWarning", code2, deprecated);
          codesWarned2.add(code2);
        }
      } else {
        process.emitWarning(msg, "DeprecationWarning", deprecated);
      }
    }
    if (new.target) {
      return Reflect.construct(fn, args, new.target);
    }
    return Reflect.apply(fn, this, args);
  }
  Object.setPrototypeOf(deprecated, fn);
  if (fn.prototype) {
    deprecated.prototype = fn.prototype;
  }
  return deprecated;
}
var kCustomPromisifiedSymbol3 = Symbol.for("nodejs.util.promisify.custom");
var kCustomPromisifyArgsSymbol3 = Symbol.for("nodejs.util.promisify.customArgs");
function promisify3(original) {
  validateFunction3(original, "original");
  if (original[kCustomPromisifiedSymbol3]) {
    const fn2 = original[kCustomPromisifiedSymbol3];
    validateFunction3(fn2, "util.promisify.custom");
    return Object.defineProperty(fn2, kCustomPromisifiedSymbol3, {
      value: fn2,
      enumerable: false,
      writable: false,
      configurable: true
    });
  }
  const argumentNames = original[kCustomPromisifyArgsSymbol3];
  function fn(...args) {
    return new Promise((resolve7, reject) => {
      args.push((err, ...values) => {
        if (err) {
          return reject(err);
        }
        if (argumentNames !== void 0 && values.length > 1) {
          const obj2 = {};
          for (let i = 0; i < argumentNames.length; i++) {
            obj2[argumentNames[i]] = values[i];
          }
          resolve7(obj2);
        } else {
          resolve7(values[0]);
        }
      });
      Reflect.apply(original, this, args);
    });
  }
  Object.setPrototypeOf(fn, Object.getPrototypeOf(original));
  Object.defineProperty(fn, kCustomPromisifiedSymbol3, {
    value: fn,
    enumerable: false,
    writable: false,
    configurable: true
  });
  return Object.defineProperties(fn, Object.getOwnPropertyDescriptors(original));
}
promisify3.custom = kCustomPromisifiedSymbol3;

// deno:https://deno.land/std@0.146.0/node/_core.ts
var core2;
if (Deno?.core) {
  core2 = Deno.core;
} else {
  core2 = {
    setNextTickCallback: void 0,
    evalContext(_code, _filename) {
      throw new Error("Deno.core.evalContext is not supported in this environment");
    },
    encode(chunk) {
      return new TextEncoder().encode(chunk);
    }
  };
}

// deno:https://deno.land/std@0.146.0/node/_process/exiting.ts
var _exiting2 = false;

// deno:https://deno.land/std@0.146.0/node/internal/fixed_queue.ts
var kSize2 = 2048;
var kMask2 = kSize2 - 1;
var FixedCircularBuffer2 = class {
  constructor() {
    this.bottom = 0;
    this.top = 0;
    this.list = new Array(kSize2);
    this.next = null;
  }
  isEmpty() {
    return this.top === this.bottom;
  }
  isFull() {
    return (this.top + 1 & kMask2) === this.bottom;
  }
  push(data) {
    this.list[this.top] = data;
    this.top = this.top + 1 & kMask2;
  }
  shift() {
    const nextItem = this.list[this.bottom];
    if (nextItem === void 0) {
      return null;
    }
    this.list[this.bottom] = void 0;
    this.bottom = this.bottom + 1 & kMask2;
    return nextItem;
  }
};
var FixedQueue2 = class {
  constructor() {
    this.head = this.tail = new FixedCircularBuffer2();
  }
  isEmpty() {
    return this.head.isEmpty();
  }
  push(data) {
    if (this.head.isFull()) {
      this.head = this.head.next = new FixedCircularBuffer2();
    }
    this.head.push(data);
  }
  shift() {
    const tail = this.tail;
    const next = tail.shift();
    if (tail.isEmpty() && tail.next !== null) {
      this.tail = tail.next;
    }
    return next;
  }
};

// deno:https://deno.land/std@0.146.0/node/_next_tick.ts
var queue2 = new FixedQueue2();
var _nextTick2;
if (typeof core2.setNextTickCallback !== "undefined") {
  let runNextTicks = function() {
    if (!core2.hasTickScheduled()) {
      core2.runMicrotasks();
    }
    if (!core2.hasTickScheduled()) {
      return true;
    }
    processTicksAndRejections();
    return true;
  }, processTicksAndRejections = function() {
    let tock;
    do {
      while (tock = queue2.shift()) {
        try {
          const callback = tock.callback;
          if (tock.args === void 0) {
            callback();
          } else {
            const args = tock.args;
            switch (args.length) {
              case 1:
                callback(args[0]);
                break;
              case 2:
                callback(args[0], args[1]);
                break;
              case 3:
                callback(args[0], args[1], args[2]);
                break;
              case 4:
                callback(args[0], args[1], args[2], args[3]);
                break;
              default:
                callback(...args);
            }
          }
        } finally {
        }
      }
      core2.runMicrotasks();
    } while (!queue2.isEmpty());
    core2.setHasTickScheduled(false);
  }, __nextTickNative = function(callback, ...args) {
    validateCallback3(callback);
    if (_exiting2) {
      return;
    }
    let args_;
    switch (args.length) {
      case 0:
        break;
      case 1:
        args_ = [args[0]];
        break;
      case 2:
        args_ = [args[0], args[1]];
        break;
      case 3:
        args_ = [args[0], args[1], args[2]];
        break;
      default:
        args_ = new Array(args.length);
        for (let i = 0; i < args.length; i++) {
          args_[i] = args[i];
        }
    }
    if (queue2.isEmpty()) {
      core2.setHasTickScheduled(true);
    }
    const tickObject = {
      callback,
      args: args_
    };
    queue2.push(tickObject);
  };
  core2.setNextTickCallback(processTicksAndRejections);
  core2.setMacrotaskCallback(runNextTicks);
  _nextTick2 = __nextTickNative;
} else {
  let __nextTickQueueMicrotask = function(callback, ...args) {
    if (args) {
      queueMicrotask(() => callback.call(this, ...args));
    } else {
      queueMicrotask(callback);
    }
  };
  _nextTick2 = __nextTickQueueMicrotask;
}
function nextTick4(callback, ...args) {
  _nextTick2(callback, ...args);
}

// deno:https://deno.land/std@0.146.0/node/_util/_util_callbackify.ts
var NodeFalsyValueRejectionError2 = class extends Error {
  constructor(reason) {
    super("Promise was rejected with falsy value");
    this.code = "ERR_FALSY_VALUE_REJECTION";
    this.reason = reason;
  }
};
var NodeInvalidArgTypeError2 = class extends TypeError {
  constructor(argumentName) {
    super(`The ${argumentName} argument must be of type function.`);
    this.code = "ERR_INVALID_ARG_TYPE";
  }
};
function callbackify2(original) {
  if (typeof original !== "function") {
    throw new NodeInvalidArgTypeError2('"original"');
  }
  const callbackified = function(...args) {
    const maybeCb = args.pop();
    if (typeof maybeCb !== "function") {
      throw new NodeInvalidArgTypeError2("last");
    }
    const cb = (...args2) => {
      maybeCb.apply(this, args2);
    };
    original.apply(this, args).then((ret) => {
      nextTick4(cb.bind(this, null, ret));
    }, (rej) => {
      rej = rej || new NodeFalsyValueRejectionError2(rej);
      nextTick4(cb.bind(this, rej));
    });
  };
  const descriptors = Object.getOwnPropertyDescriptors(original);
  if (typeof descriptors.length.value === "number") {
    descriptors.length.value++;
  }
  if (typeof descriptors.name.value === "string") {
    descriptors.name.value += "Callbackified";
  }
  Object.defineProperties(callbackified, descriptors);
  return callbackified;
}

// deno:https://deno.land/std@0.146.0/fmt/printf.ts
var Flags2 = class {
  constructor() {
    this.width = -1;
    this.precision = -1;
  }
};
var min3 = Math.min;
var UNICODE_REPLACEMENT_CHARACTER2 = "\uFFFD";
var DEFAULT_PRECISION2 = 6;
var FLOAT_REGEXP2 = /(-?)(\d)\.?(\d*)e([+-])(\d+)/;
var Printf2 = class {
  constructor(format11, ...args) {
    this.state = 0 /* PASSTHROUGH */;
    this.verb = "";
    this.buf = "";
    this.argNum = 0;
    this.flags = new Flags2();
    this.format = format11;
    this.args = args;
    this.haveSeen = Array.from({ length: args.length });
    this.i = 0;
  }
  doPrintf() {
    for (; this.i < this.format.length; ++this.i) {
      const c5 = this.format[this.i];
      switch (this.state) {
        case 0 /* PASSTHROUGH */:
          if (c5 === "%") {
            this.state = 1 /* PERCENT */;
          } else {
            this.buf += c5;
          }
          break;
        case 1 /* PERCENT */:
          if (c5 === "%") {
            this.buf += c5;
            this.state = 0 /* PASSTHROUGH */;
          } else {
            this.handleFormat();
          }
          break;
        default:
          throw Error("Should be unreachable, certainly a bug in the lib.");
      }
    }
    let extras = false;
    let err = "%!(EXTRA";
    for (let i = 0; i !== this.haveSeen.length; ++i) {
      if (!this.haveSeen[i]) {
        extras = true;
        err += ` '${Deno.inspect(this.args[i])}'`;
      }
    }
    err += ")";
    if (extras) {
      this.buf += err;
    }
    return this.buf;
  }
  handleFormat() {
    this.flags = new Flags2();
    const flags = this.flags;
    for (; this.i < this.format.length; ++this.i) {
      const c5 = this.format[this.i];
      switch (this.state) {
        case 1 /* PERCENT */:
          switch (c5) {
            case "[":
              this.handlePositional();
              this.state = 2 /* POSITIONAL */;
              break;
            case "+":
              flags.plus = true;
              break;
            case "<":
              flags.lessthan = true;
              break;
            case "-":
              flags.dash = true;
              flags.zero = false;
              break;
            case "#":
              flags.sharp = true;
              break;
            case " ":
              flags.space = true;
              break;
            case "0":
              flags.zero = !flags.dash;
              break;
            default:
              if ("1" <= c5 && c5 <= "9" || c5 === "." || c5 === "*") {
                if (c5 === ".") {
                  this.flags.precision = 0;
                  this.state = 3 /* PRECISION */;
                  this.i++;
                } else {
                  this.state = 4 /* WIDTH */;
                }
                this.handleWidthAndPrecision(flags);
              } else {
                this.handleVerb();
                return;
              }
          }
          break;
        case 2 /* POSITIONAL */:
          if (c5 === "*") {
            const worp = this.flags.precision === -1 ? 0 /* WIDTH */ : 1 /* PRECISION */;
            this.handleWidthOrPrecisionRef(worp);
            this.state = 1 /* PERCENT */;
            break;
          } else {
            this.handleVerb();
            return;
          }
        default:
          throw new Error(`Should not be here ${this.state}, library bug!`);
      }
    }
  }
  handleWidthOrPrecisionRef(wOrP) {
    if (this.argNum >= this.args.length) {
      return;
    }
    const arg = this.args[this.argNum];
    this.haveSeen[this.argNum] = true;
    if (typeof arg === "number") {
      switch (wOrP) {
        case 0 /* WIDTH */:
          this.flags.width = arg;
          break;
        default:
          this.flags.precision = arg;
      }
    } else {
      const tmp = wOrP === 0 /* WIDTH */ ? "WIDTH" : "PREC";
      this.tmpError = `%!(BAD ${tmp} '${this.args[this.argNum]}')`;
    }
    this.argNum++;
  }
  handleWidthAndPrecision(flags) {
    const fmt = this.format;
    for (; this.i !== this.format.length; ++this.i) {
      const c5 = fmt[this.i];
      switch (this.state) {
        case 4 /* WIDTH */:
          switch (c5) {
            case ".":
              this.flags.precision = 0;
              this.state = 3 /* PRECISION */;
              break;
            case "*":
              this.handleWidthOrPrecisionRef(0 /* WIDTH */);
              break;
            default: {
              const val = parseInt(c5);
              if (isNaN(val)) {
                this.i--;
                this.state = 1 /* PERCENT */;
                return;
              }
              flags.width = flags.width == -1 ? 0 : flags.width;
              flags.width *= 10;
              flags.width += val;
            }
          }
          break;
        case 3 /* PRECISION */: {
          if (c5 === "*") {
            this.handleWidthOrPrecisionRef(1 /* PRECISION */);
            break;
          }
          const val = parseInt(c5);
          if (isNaN(val)) {
            this.i--;
            this.state = 1 /* PERCENT */;
            return;
          }
          flags.precision *= 10;
          flags.precision += val;
          break;
        }
        default:
          throw new Error("can't be here. bug.");
      }
    }
  }
  handlePositional() {
    if (this.format[this.i] !== "[") {
      throw new Error("Can't happen? Bug.");
    }
    let positional = 0;
    const format11 = this.format;
    this.i++;
    let err = false;
    for (; this.i !== this.format.length; ++this.i) {
      if (format11[this.i] === "]") {
        break;
      }
      positional *= 10;
      const val = parseInt(format11[this.i]);
      if (isNaN(val)) {
        this.tmpError = "%!(BAD INDEX)";
        err = true;
      }
      positional += val;
    }
    if (positional - 1 >= this.args.length) {
      this.tmpError = "%!(BAD INDEX)";
      err = true;
    }
    this.argNum = err ? this.argNum : positional - 1;
    return;
  }
  handleLessThan() {
    const arg = this.args[this.argNum];
    if ((arg || {}).constructor.name !== "Array") {
      throw new Error(`arg ${arg} is not an array. Todo better error handling`);
    }
    let str = "[ ";
    for (let i = 0; i !== arg.length; ++i) {
      if (i !== 0)
        str += ", ";
      str += this._handleVerb(arg[i]);
    }
    return str + " ]";
  }
  handleVerb() {
    const verb = this.format[this.i];
    this.verb = verb;
    if (this.tmpError) {
      this.buf += this.tmpError;
      this.tmpError = void 0;
      if (this.argNum < this.haveSeen.length) {
        this.haveSeen[this.argNum] = true;
      }
    } else if (this.args.length <= this.argNum) {
      this.buf += `%!(MISSING '${verb}')`;
    } else {
      const arg = this.args[this.argNum];
      this.haveSeen[this.argNum] = true;
      if (this.flags.lessthan) {
        this.buf += this.handleLessThan();
      } else {
        this.buf += this._handleVerb(arg);
      }
    }
    this.argNum++;
    this.state = 0 /* PASSTHROUGH */;
  }
  _handleVerb(arg) {
    switch (this.verb) {
      case "t":
        return this.pad(arg.toString());
      case "b":
        return this.fmtNumber(arg, 2);
      case "c":
        return this.fmtNumberCodePoint(arg);
      case "d":
        return this.fmtNumber(arg, 10);
      case "o":
        return this.fmtNumber(arg, 8);
      case "x":
        return this.fmtHex(arg);
      case "X":
        return this.fmtHex(arg, true);
      case "e":
        return this.fmtFloatE(arg);
      case "E":
        return this.fmtFloatE(arg, true);
      case "f":
      case "F":
        return this.fmtFloatF(arg);
      case "g":
        return this.fmtFloatG(arg);
      case "G":
        return this.fmtFloatG(arg, true);
      case "s":
        return this.fmtString(arg);
      case "T":
        return this.fmtString(typeof arg);
      case "v":
        return this.fmtV(arg);
      case "j":
        return this.fmtJ(arg);
      default:
        return `%!(BAD VERB '${this.verb}')`;
    }
  }
  pad(s) {
    const padding = this.flags.zero ? "0" : " ";
    if (this.flags.dash) {
      return s.padEnd(this.flags.width, padding);
    }
    return s.padStart(this.flags.width, padding);
  }
  padNum(nStr, neg3) {
    let sign2;
    if (neg3) {
      sign2 = "-";
    } else if (this.flags.plus || this.flags.space) {
      sign2 = this.flags.plus ? "+" : " ";
    } else {
      sign2 = "";
    }
    const zero = this.flags.zero;
    if (!zero) {
      nStr = sign2 + nStr;
    }
    const pad3 = zero ? "0" : " ";
    const len = zero ? this.flags.width - sign2.length : this.flags.width;
    if (this.flags.dash) {
      nStr = nStr.padEnd(len, pad3);
    } else {
      nStr = nStr.padStart(len, pad3);
    }
    if (zero) {
      nStr = sign2 + nStr;
    }
    return nStr;
  }
  fmtNumber(n, radix, upcase = false) {
    let num = Math.abs(n).toString(radix);
    const prec = this.flags.precision;
    if (prec !== -1) {
      this.flags.zero = false;
      num = n === 0 && prec === 0 ? "" : num;
      while (num.length < prec) {
        num = "0" + num;
      }
    }
    let prefix = "";
    if (this.flags.sharp) {
      switch (radix) {
        case 2:
          prefix += "0b";
          break;
        case 8:
          prefix += num.startsWith("0") ? "" : "0";
          break;
        case 16:
          prefix += "0x";
          break;
        default:
          throw new Error("cannot handle base: " + radix);
      }
    }
    num = num.length === 0 ? num : prefix + num;
    if (upcase) {
      num = num.toUpperCase();
    }
    return this.padNum(num, n < 0);
  }
  fmtNumberCodePoint(n) {
    let s = "";
    try {
      s = String.fromCodePoint(n);
    } catch {
      s = UNICODE_REPLACEMENT_CHARACTER2;
    }
    return this.pad(s);
  }
  fmtFloatSpecial(n) {
    if (isNaN(n)) {
      this.flags.zero = false;
      return this.padNum("NaN", false);
    }
    if (n === Number.POSITIVE_INFINITY) {
      this.flags.zero = false;
      this.flags.plus = true;
      return this.padNum("Inf", false);
    }
    if (n === Number.NEGATIVE_INFINITY) {
      this.flags.zero = false;
      return this.padNum("Inf", true);
    }
    return "";
  }
  roundFractionToPrecision(fractional, precision) {
    let round = false;
    if (fractional.length > precision) {
      fractional = "1" + fractional;
      let tmp = parseInt(fractional.substr(0, precision + 2)) / 10;
      tmp = Math.round(tmp);
      fractional = Math.floor(tmp).toString();
      round = fractional[0] === "2";
      fractional = fractional.substr(1);
    } else {
      while (fractional.length < precision) {
        fractional += "0";
      }
    }
    return [fractional, round];
  }
  fmtFloatE(n, upcase = false) {
    const special = this.fmtFloatSpecial(n);
    if (special !== "") {
      return special;
    }
    const m3 = n.toExponential().match(FLOAT_REGEXP2);
    if (!m3) {
      throw Error("can't happen, bug");
    }
    let fractional = m3[3 /* fractional */];
    const precision = this.flags.precision !== -1 ? this.flags.precision : DEFAULT_PRECISION2;
    let rounding = false;
    [fractional, rounding] = this.roundFractionToPrecision(fractional, precision);
    let e = m3[5 /* exponent */];
    let esign = m3[4 /* esign */];
    let mantissa = parseInt(m3[2 /* mantissa */]);
    if (rounding) {
      mantissa += 1;
      if (10 <= mantissa) {
        mantissa = 1;
        const r = parseInt(esign + e) + 1;
        e = r.toString();
        esign = r < 0 ? "-" : "+";
      }
    }
    e = e.length == 1 ? "0" + e : e;
    const val = `${mantissa}.${fractional}${upcase ? "E" : "e"}${esign}${e}`;
    return this.padNum(val, n < 0);
  }
  fmtFloatF(n) {
    const special = this.fmtFloatSpecial(n);
    if (special !== "") {
      return special;
    }
    function expandNumber(n2) {
      if (Number.isSafeInteger(n2)) {
        return n2.toString() + ".";
      }
      const t = n2.toExponential().split("e");
      let m3 = t[0].replace(".", "");
      const e = parseInt(t[1]);
      if (e < 0) {
        let nStr = "0.";
        for (let i = 0; i !== Math.abs(e) - 1; ++i) {
          nStr += "0";
        }
        return nStr += m3;
      } else {
        const splIdx = e + 1;
        while (m3.length < splIdx) {
          m3 += "0";
        }
        return m3.substr(0, splIdx) + "." + m3.substr(splIdx);
      }
    }
    const val = expandNumber(Math.abs(n));
    const arr = val.split(".");
    let dig = arr[0];
    let fractional = arr[1];
    const precision = this.flags.precision !== -1 ? this.flags.precision : DEFAULT_PRECISION2;
    let round = false;
    [fractional, round] = this.roundFractionToPrecision(fractional, precision);
    if (round) {
      dig = (parseInt(dig) + 1).toString();
    }
    return this.padNum(`${dig}.${fractional}`, n < 0);
  }
  fmtFloatG(n, upcase = false) {
    const special = this.fmtFloatSpecial(n);
    if (special !== "") {
      return special;
    }
    let P2 = this.flags.precision !== -1 ? this.flags.precision : DEFAULT_PRECISION2;
    P2 = P2 === 0 ? 1 : P2;
    const m3 = n.toExponential().match(FLOAT_REGEXP2);
    if (!m3) {
      throw Error("can't happen");
    }
    const X5 = parseInt(m3[5 /* exponent */]) * (m3[4 /* esign */] === "-" ? -1 : 1);
    let nStr = "";
    if (P2 > X5 && X5 >= -4) {
      this.flags.precision = P2 - (X5 + 1);
      nStr = this.fmtFloatF(n);
      if (!this.flags.sharp) {
        nStr = nStr.replace(/\.?0*$/, "");
      }
    } else {
      this.flags.precision = P2 - 1;
      nStr = this.fmtFloatE(n);
      if (!this.flags.sharp) {
        nStr = nStr.replace(/\.?0*e/, upcase ? "E" : "e");
      }
    }
    return nStr;
  }
  fmtString(s) {
    if (this.flags.precision !== -1) {
      s = s.substr(0, this.flags.precision);
    }
    return this.pad(s);
  }
  fmtHex(val, upper = false) {
    switch (typeof val) {
      case "number":
        return this.fmtNumber(val, 16, upper);
      case "string": {
        const sharp = this.flags.sharp && val.length !== 0;
        let hex = sharp ? "0x" : "";
        const prec = this.flags.precision;
        const end = prec !== -1 ? min3(prec, val.length) : val.length;
        for (let i = 0; i !== end; ++i) {
          if (i !== 0 && this.flags.space) {
            hex += sharp ? " 0x" : " ";
          }
          const c5 = (val.charCodeAt(i) & 255).toString(16);
          hex += c5.length === 1 ? `0${c5}` : c5;
        }
        if (upper) {
          hex = hex.toUpperCase();
        }
        return this.pad(hex);
      }
      default:
        throw new Error("currently only number and string are implemented for hex");
    }
  }
  fmtV(val) {
    if (this.flags.sharp) {
      const options = this.flags.precision !== -1 ? { depth: this.flags.precision } : {};
      return this.pad(Deno.inspect(val, options));
    } else {
      const p3 = this.flags.precision;
      return p3 === -1 ? val.toString() : val.toString().substr(0, p3);
    }
  }
  fmtJ(val) {
    return JSON.stringify(val);
  }
};
function sprintf2(format11, ...args) {
  const printf = new Printf2(format11, ...args);
  return printf.doPrintf();
}

// deno:https://deno.land/std@0.146.0/async/deferred.ts
function deferred2() {
  let methods2;
  let state = "pending";
  const promise = new Promise((resolve7, reject) => {
    methods2 = {
      async resolve(value) {
        await value;
        state = "fulfilled";
        resolve7(value);
      },
      reject(reason) {
        state = "rejected";
        reject(reason);
      }
    };
  });
  Object.defineProperty(promise, "state", { get: () => state });
  return Object.assign(promise, methods2);
}

// deno:https://deno.land/std@0.146.0/async/mux_async_iterator.ts
var MuxAsyncIterator2 = class {
  #iteratorCount = 0;
  #yields = [];
  #throws = [];
  #signal = deferred2();
  add(iterable) {
    ++this.#iteratorCount;
    this.#callIteratorNext(iterable[Symbol.asyncIterator]());
  }
  async #callIteratorNext(iterator) {
    try {
      const { value, done } = await iterator.next();
      if (done) {
        --this.#iteratorCount;
      } else {
        this.#yields.push({ iterator, value });
      }
    } catch (e) {
      this.#throws.push(e);
    }
    this.#signal.resolve();
  }
  async *iterate() {
    while (this.#iteratorCount > 0) {
      await this.#signal;
      for (let i = 0; i < this.#yields.length; i++) {
        const { iterator, value } = this.#yields[i];
        yield value;
        this.#callIteratorNext(iterator);
      }
      if (this.#throws.length) {
        for (const e of this.#throws) {
          throw e;
        }
        this.#throws.length = 0;
      }
      this.#yields.length = 0;
      this.#signal = deferred2();
    }
  }
  [Symbol.asyncIterator]() {
    return this.iterate();
  }
};

// deno:https://deno.land/std@0.146.0/fmt/colors.ts
var { Deno: Deno3 } = globalThis;
var noColor2 = typeof Deno3?.noColor === "boolean" ? Deno3.noColor : true;
var ANSI_PATTERN2 = new RegExp([
  "[\\u001B\\u009B][[\\]()#;?]*(?:(?:(?:(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]+)*|[a-zA-Z\\d]+(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]*)*)?\\u0007)",
  "(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PR-TZcf-nq-uy=><~]))"
].join("|"), "g");

// deno:https://deno.land/std@0.146.0/testing/asserts.ts
var AssertionError2 = class extends Error {
  constructor(message) {
    super(message);
    this.name = "AssertionError";
  }
};
function unreachable2() {
  throw new AssertionError2("unreachable");
}

// deno:https://deno.land/std@0.146.0/_util/assert.ts
var DenoStdInternalError2 = class extends Error {
  constructor(message) {
    super(message);
    this.name = "DenoStdInternalError";
  }
};
function assert4(expr, msg = "") {
  if (!expr) {
    throw new DenoStdInternalError2(msg);
  }
}

// deno:https://deno.land/std@0.146.0/bytes/mod.ts
function indexOfNeedle3(source, needle, start = 0) {
  if (start >= source.length) {
    return -1;
  }
  if (start < 0) {
    start = Math.max(0, source.length + start);
  }
  const s = needle[0];
  for (let i = start; i < source.length; i++) {
    if (source[i] !== s)
      continue;
    const pin = i;
    let matched = 1;
    let j2 = i;
    while (matched < needle.length) {
      j2++;
      if (source[j2] !== needle[j2 - pin]) {
        break;
      }
      matched++;
    }
    if (matched === needle.length) {
      return pin;
    }
  }
  return -1;
}

// deno:https://deno.land/std@0.146.0/io/buffer.ts
var MIN_READ2 = 32 * 1024;
var MAX_SIZE3 = 2 ** 32 - 2;
var CR2 = "\r".charCodeAt(0);
var LF2 = "\n".charCodeAt(0);

// deno:https://deno.land/std@0.146.0/streams/conversion.ts
var DEFAULT_BUFFER_SIZE2 = 32 * 1024;

// deno:https://deno.land/std@0.146.0/node/_utils.ts
var _TextDecoder2 = TextDecoder;
var _TextEncoder2 = TextEncoder;

// deno:https://deno.land/std@0.146.0/node/internal_binding/util.ts
var ALL_PROPERTIES2 = 0;
var ONLY_WRITABLE2 = 1;
var ONLY_ENUMERABLE2 = 2;
var ONLY_CONFIGURABLE2 = 4;
var SKIP_STRINGS2 = 8;
var SKIP_SYMBOLS2 = 16;
var isNumericLookup2 = {};
function isArrayIndex2(value) {
  switch (typeof value) {
    case "number":
      return value >= 0 && (value | 0) === value;
    case "string": {
      const result = isNumericLookup2[value];
      if (result !== void 0) {
        return result;
      }
      const length = value.length;
      if (length === 0) {
        return isNumericLookup2[value] = false;
      }
      let ch = 0;
      let i = 0;
      for (; i < length; ++i) {
        ch = value.charCodeAt(i);
        if (i === 0 && ch === 48 && length > 1 || ch < 48 || ch > 57) {
          return isNumericLookup2[value] = false;
        }
      }
      return isNumericLookup2[value] = true;
    }
    default:
      return false;
  }
}
function getOwnNonIndexProperties2(obj2, filter) {
  let allProperties = [
    ...Object.getOwnPropertyNames(obj2),
    ...Object.getOwnPropertySymbols(obj2)
  ];
  if (Array.isArray(obj2)) {
    allProperties = allProperties.filter((k6) => !isArrayIndex2(k6));
  }
  if (filter === ALL_PROPERTIES2) {
    return allProperties;
  }
  const result = [];
  for (const key2 of allProperties) {
    const desc = Object.getOwnPropertyDescriptor(obj2, key2);
    if (desc === void 0) {
      continue;
    }
    if (filter & ONLY_WRITABLE2 && !desc.writable) {
      continue;
    }
    if (filter & ONLY_ENUMERABLE2 && !desc.enumerable) {
      continue;
    }
    if (filter & ONLY_CONFIGURABLE2 && !desc.configurable) {
      continue;
    }
    if (filter & SKIP_STRINGS2 && typeof key2 === "string") {
      continue;
    }
    if (filter & SKIP_SYMBOLS2 && typeof key2 === "symbol") {
      continue;
    }
    result.push(key2);
  }
  return result;
}

// deno:https://deno.land/std@0.146.0/node/internal/util/inspect.mjs
var kObjectType2 = 0;
var kArrayType2 = 1;
var kArrayExtrasType2 = 2;
var kMinLineLength2 = 16;
var kWeak2 = 0;
var kIterator2 = 1;
var kMapEntries2 = 2;
var kPending2 = 0;
var kRejected2 = 2;
var meta2 = [
  "\\x00",
  "\\x01",
  "\\x02",
  "\\x03",
  "\\x04",
  "\\x05",
  "\\x06",
  "\\x07",
  "\\b",
  "\\t",
  "\\n",
  "\\x0B",
  "\\f",
  "\\r",
  "\\x0E",
  "\\x0F",
  "\\x10",
  "\\x11",
  "\\x12",
  "\\x13",
  "\\x14",
  "\\x15",
  "\\x16",
  "\\x17",
  "\\x18",
  "\\x19",
  "\\x1A",
  "\\x1B",
  "\\x1C",
  "\\x1D",
  "\\x1E",
  "\\x1F",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "\\'",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "\\\\",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "\\x7F",
  "\\x80",
  "\\x81",
  "\\x82",
  "\\x83",
  "\\x84",
  "\\x85",
  "\\x86",
  "\\x87",
  "\\x88",
  "\\x89",
  "\\x8A",
  "\\x8B",
  "\\x8C",
  "\\x8D",
  "\\x8E",
  "\\x8F",
  "\\x90",
  "\\x91",
  "\\x92",
  "\\x93",
  "\\x94",
  "\\x95",
  "\\x96",
  "\\x97",
  "\\x98",
  "\\x99",
  "\\x9A",
  "\\x9B",
  "\\x9C",
  "\\x9D",
  "\\x9E",
  "\\x9F"
];
var isUndetectableObject2 = (v2) => typeof v2 === "undefined" && v2 !== void 0;
var strEscapeSequencesRegExp2 = /[\x00-\x1f\x27\x5c\x7f-\x9f]/;
var strEscapeSequencesReplacer2 = /[\x00-\x1f\x27\x5c\x7f-\x9f]/g;
var strEscapeSequencesRegExpSingle2 = /[\x00-\x1f\x5c\x7f-\x9f]/;
var strEscapeSequencesReplacerSingle2 = /[\x00-\x1f\x5c\x7f-\x9f]/g;
var keyStrRegExp2 = /^[a-zA-Z_][a-zA-Z_0-9]*$/;
var numberRegExp2 = /^(0|[1-9][0-9]*)$/;
var nodeModulesRegExp2 = /[/\\]node_modules[/\\](.+?)(?=[/\\])/g;
var classRegExp3 = /^(\s+[^(]*?)\s*{/;
var stripCommentsRegExp2 = /(\/\/.*?\n)|(\/\*(.|\n)*?\*\/)/g;
var inspectDefaultOptions2 = {
  showHidden: false,
  depth: 2,
  colors: false,
  customInspect: true,
  showProxy: false,
  maxArrayLength: 100,
  maxStringLength: 1e4,
  breakLength: 80,
  compact: 3,
  sorted: false,
  getters: false
};
function getUserOptions2(ctx, isCrossContext) {
  const ret = {
    stylize: ctx.stylize,
    showHidden: ctx.showHidden,
    depth: ctx.depth,
    colors: ctx.colors,
    customInspect: ctx.customInspect,
    showProxy: ctx.showProxy,
    maxArrayLength: ctx.maxArrayLength,
    maxStringLength: ctx.maxStringLength,
    breakLength: ctx.breakLength,
    compact: ctx.compact,
    sorted: ctx.sorted,
    getters: ctx.getters,
    ...ctx.userOptions
  };
  if (isCrossContext) {
    Object.setPrototypeOf(ret, null);
    for (const key2 of Object.keys(ret)) {
      if ((typeof ret[key2] === "object" || typeof ret[key2] === "function") && ret[key2] !== null) {
        delete ret[key2];
      }
    }
    ret.stylize = Object.setPrototypeOf((value, flavour) => {
      let stylized;
      try {
        stylized = `${ctx.stylize(value, flavour)}`;
      } catch {
      }
      if (typeof stylized !== "string")
        return value;
      return stylized;
    }, null);
  }
  return ret;
}
function inspect5(value, opts) {
  const ctx = {
    budget: {},
    indentationLvl: 0,
    seen: [],
    currentDepth: 0,
    stylize: stylizeNoColor2,
    showHidden: inspectDefaultOptions2.showHidden,
    depth: inspectDefaultOptions2.depth,
    colors: inspectDefaultOptions2.colors,
    customInspect: inspectDefaultOptions2.customInspect,
    showProxy: inspectDefaultOptions2.showProxy,
    maxArrayLength: inspectDefaultOptions2.maxArrayLength,
    maxStringLength: inspectDefaultOptions2.maxStringLength,
    breakLength: inspectDefaultOptions2.breakLength,
    compact: inspectDefaultOptions2.compact,
    sorted: inspectDefaultOptions2.sorted,
    getters: inspectDefaultOptions2.getters
  };
  if (arguments.length > 1) {
    if (arguments.length > 2) {
      if (arguments[2] !== void 0) {
        ctx.depth = arguments[2];
      }
      if (arguments.length > 3 && arguments[3] !== void 0) {
        ctx.colors = arguments[3];
      }
    }
    if (typeof opts === "boolean") {
      ctx.showHidden = opts;
    } else if (opts) {
      const optKeys = Object.keys(opts);
      for (let i = 0; i < optKeys.length; ++i) {
        const key2 = optKeys[i];
        if (inspectDefaultOptions2.hasOwnProperty(key2) || key2 === "stylize") {
          ctx[key2] = opts[key2];
        } else if (ctx.userOptions === void 0) {
          ctx.userOptions = opts;
        }
      }
    }
  }
  if (ctx.colors)
    ctx.stylize = stylizeWithColor2;
  if (ctx.maxArrayLength === null)
    ctx.maxArrayLength = Infinity;
  if (ctx.maxStringLength === null)
    ctx.maxStringLength = Infinity;
  return formatValue2(ctx, value, 0);
}
var customInspectSymbol7 = Symbol.for("nodejs.util.inspect.custom");
inspect5.custom = customInspectSymbol7;
Object.defineProperty(inspect5, "defaultOptions", {
  get() {
    return inspectDefaultOptions2;
  },
  set(options) {
    validateObject3(options, "options");
    return Object.assign(inspectDefaultOptions2, options);
  }
});
var defaultFG2 = 39;
var defaultBG2 = 49;
inspect5.colors = Object.assign(/* @__PURE__ */ Object.create(null), {
  reset: [0, 0],
  bold: [1, 22],
  dim: [2, 22],
  italic: [3, 23],
  underline: [4, 24],
  blink: [5, 25],
  inverse: [7, 27],
  hidden: [8, 28],
  strikethrough: [9, 29],
  doubleunderline: [21, 24],
  black: [30, defaultFG2],
  red: [31, defaultFG2],
  green: [32, defaultFG2],
  yellow: [33, defaultFG2],
  blue: [34, defaultFG2],
  magenta: [35, defaultFG2],
  cyan: [36, defaultFG2],
  white: [37, defaultFG2],
  bgBlack: [40, defaultBG2],
  bgRed: [41, defaultBG2],
  bgGreen: [42, defaultBG2],
  bgYellow: [43, defaultBG2],
  bgBlue: [44, defaultBG2],
  bgMagenta: [45, defaultBG2],
  bgCyan: [46, defaultBG2],
  bgWhite: [47, defaultBG2],
  framed: [51, 54],
  overlined: [53, 55],
  gray: [90, defaultFG2],
  redBright: [91, defaultFG2],
  greenBright: [92, defaultFG2],
  yellowBright: [93, defaultFG2],
  blueBright: [94, defaultFG2],
  magentaBright: [95, defaultFG2],
  cyanBright: [96, defaultFG2],
  whiteBright: [97, defaultFG2],
  bgGray: [100, defaultBG2],
  bgRedBright: [101, defaultBG2],
  bgGreenBright: [102, defaultBG2],
  bgYellowBright: [103, defaultBG2],
  bgBlueBright: [104, defaultBG2],
  bgMagentaBright: [105, defaultBG2],
  bgCyanBright: [106, defaultBG2],
  bgWhiteBright: [107, defaultBG2]
});
function defineColorAlias2(target, alias) {
  Object.defineProperty(inspect5.colors, alias, {
    get() {
      return this[target];
    },
    set(value) {
      this[target] = value;
    },
    configurable: true,
    enumerable: false
  });
}
defineColorAlias2("gray", "grey");
defineColorAlias2("gray", "blackBright");
defineColorAlias2("bgGray", "bgGrey");
defineColorAlias2("bgGray", "bgBlackBright");
defineColorAlias2("dim", "faint");
defineColorAlias2("strikethrough", "crossedout");
defineColorAlias2("strikethrough", "strikeThrough");
defineColorAlias2("strikethrough", "crossedOut");
defineColorAlias2("hidden", "conceal");
defineColorAlias2("inverse", "swapColors");
defineColorAlias2("inverse", "swapcolors");
defineColorAlias2("doubleunderline", "doubleUnderline");
inspect5.styles = Object.assign(/* @__PURE__ */ Object.create(null), {
  special: "cyan",
  number: "yellow",
  bigint: "yellow",
  boolean: "yellow",
  undefined: "grey",
  null: "bold",
  string: "green",
  symbol: "green",
  date: "magenta",
  regexp: "red",
  module: "underline"
});
function addQuotes2(str, quotes) {
  if (quotes === -1) {
    return `"${str}"`;
  }
  if (quotes === -2) {
    return `\`${str}\``;
  }
  return `'${str}'`;
}
var escapeFn2 = (str) => meta2[str.charCodeAt(0)];
function strEscape2(str) {
  let escapeTest = strEscapeSequencesRegExp2;
  let escapeReplace = strEscapeSequencesReplacer2;
  let singleQuote = 39;
  if (str.includes("'")) {
    if (!str.includes('"')) {
      singleQuote = -1;
    } else if (!str.includes("`") && !str.includes("${")) {
      singleQuote = -2;
    }
    if (singleQuote !== 39) {
      escapeTest = strEscapeSequencesRegExpSingle2;
      escapeReplace = strEscapeSequencesReplacerSingle2;
    }
  }
  if (str.length < 5e3 && !escapeTest.test(str)) {
    return addQuotes2(str, singleQuote);
  }
  if (str.length > 100) {
    str = str.replace(escapeReplace, escapeFn2);
    return addQuotes2(str, singleQuote);
  }
  let result = "";
  let last = 0;
  const lastIndex = str.length;
  for (let i = 0; i < lastIndex; i++) {
    const point = str.charCodeAt(i);
    if (point === singleQuote || point === 92 || point < 32 || point > 126 && point < 160) {
      if (last === i) {
        result += meta2[point];
      } else {
        result += `${str.slice(last, i)}${meta2[point]}`;
      }
      last = i + 1;
    }
  }
  if (last !== lastIndex) {
    result += str.slice(last);
  }
  return addQuotes2(result, singleQuote);
}
function stylizeWithColor2(str, styleType) {
  const style = inspect5.styles[styleType];
  if (style !== void 0) {
    const color = inspect5.colors[style];
    if (color !== void 0) {
      return `\x1B[${color[0]}m${str}\x1B[${color[1]}m`;
    }
  }
  return str;
}
function stylizeNoColor2(str) {
  return str;
}
function formatValue2(ctx, value, recurseTimes, typedArray) {
  if (typeof value !== "object" && typeof value !== "function" && !isUndetectableObject2(value)) {
    return formatPrimitive2(ctx.stylize, value, ctx);
  }
  if (value === null) {
    return ctx.stylize("null", "null");
  }
  const context = value;
  const proxy = void 0;
  if (ctx.customInspect) {
    const maybeCustom = value[customInspectSymbol7];
    if (typeof maybeCustom === "function" && maybeCustom !== inspect5 && !(value.constructor && value.constructor.prototype === value)) {
      const depth = ctx.depth === null ? null : ctx.depth - recurseTimes;
      const isCrossContext = proxy !== void 0 || !(context instanceof Object);
      const ret = maybeCustom.call(context, depth, getUserOptions2(ctx, isCrossContext));
      if (ret !== context) {
        if (typeof ret !== "string") {
          return formatValue2(ctx, ret, recurseTimes);
        }
        return ret.replace(/\n/g, `
${" ".repeat(ctx.indentationLvl)}`);
      }
    }
  }
  if (ctx.seen.includes(value)) {
    let index = 1;
    if (ctx.circular === void 0) {
      ctx.circular = /* @__PURE__ */ new Map();
      ctx.circular.set(value, index);
    } else {
      index = ctx.circular.get(value);
      if (index === void 0) {
        index = ctx.circular.size + 1;
        ctx.circular.set(value, index);
      }
    }
    return ctx.stylize(`[Circular *${index}]`, "special");
  }
  return formatRaw2(ctx, value, recurseTimes, typedArray);
}
function formatRaw2(ctx, value, recurseTimes, typedArray) {
  let keys;
  let protoProps;
  if (ctx.showHidden && (recurseTimes <= ctx.depth || ctx.depth === null)) {
    protoProps = [];
  }
  const constructor = getConstructorName2(value, ctx, recurseTimes, protoProps);
  if (protoProps !== void 0 && protoProps.length === 0) {
    protoProps = void 0;
  }
  let tag2 = value[Symbol.toStringTag];
  if (typeof tag2 !== "string") {
    tag2 = "";
  }
  let base3 = "";
  let formatter = getEmptyFormatArray2;
  let braces;
  let noIterator = true;
  let i = 0;
  const filter = ctx.showHidden ? ALL_PROPERTIES2 : ONLY_ENUMERABLE2;
  let extrasType = kObjectType2;
  if (value[Symbol.iterator] || constructor === null) {
    noIterator = false;
    if (Array.isArray(value)) {
      const prefix = constructor !== "Array" || tag2 !== "" ? getPrefix2(constructor, tag2, "Array", `(${value.length})`) : "";
      keys = getOwnNonIndexProperties2(value, filter);
      braces = [`${prefix}[`, "]"];
      if (value.length === 0 && keys.length === 0 && protoProps === void 0) {
        return `${braces[0]}]`;
      }
      extrasType = kArrayExtrasType2;
      formatter = formatArray2;
    } else if (isSet6(value)) {
      const size = value.size;
      const prefix = getPrefix2(constructor, tag2, "Set", `(${size})`);
      keys = getKeys2(value, ctx.showHidden);
      formatter = constructor !== null ? formatSet2.bind(null, value) : formatSet2.bind(null, value.values());
      if (size === 0 && keys.length === 0 && protoProps === void 0) {
        return `${prefix}{}`;
      }
      braces = [`${prefix}{`, "}"];
    } else if (isMap6(value)) {
      const size = value.size;
      const prefix = getPrefix2(constructor, tag2, "Map", `(${size})`);
      keys = getKeys2(value, ctx.showHidden);
      formatter = constructor !== null ? formatMap2.bind(null, value) : formatMap2.bind(null, value.entries());
      if (size === 0 && keys.length === 0 && protoProps === void 0) {
        return `${prefix}{}`;
      }
      braces = [`${prefix}{`, "}"];
    } else if (isTypedArray2(value)) {
      keys = getOwnNonIndexProperties2(value, filter);
      const bound = value;
      const fallback = "";
      if (constructor === null) {
      }
      const size = value.length;
      const prefix = getPrefix2(constructor, tag2, fallback, `(${size})`);
      braces = [`${prefix}[`, "]"];
      if (value.length === 0 && keys.length === 0 && !ctx.showHidden) {
        return `${braces[0]}]`;
      }
      formatter = formatTypedArray2.bind(null, bound, size);
      extrasType = kArrayExtrasType2;
    } else if (isMapIterator6(value)) {
      keys = getKeys2(value, ctx.showHidden);
      braces = getIteratorBraces2("Map", tag2);
      formatter = formatIterator2.bind(null, braces);
    } else if (isSetIterator6(value)) {
      keys = getKeys2(value, ctx.showHidden);
      braces = getIteratorBraces2("Set", tag2);
      formatter = formatIterator2.bind(null, braces);
    } else {
      noIterator = true;
    }
  }
  if (noIterator) {
    keys = getKeys2(value, ctx.showHidden);
    braces = ["{", "}"];
    if (constructor === "Object") {
      if (isArgumentsObject6(value)) {
        braces[0] = "[Arguments] {";
      } else if (tag2 !== "") {
        braces[0] = `${getPrefix2(constructor, tag2, "Object")}{`;
      }
      if (keys.length === 0 && protoProps === void 0) {
        return `${braces[0]}}`;
      }
    } else if (typeof value === "function") {
      base3 = getFunctionBase2(value, constructor, tag2);
      if (keys.length === 0 && protoProps === void 0) {
        return ctx.stylize(base3, "special");
      }
    } else if (isRegExp7(value)) {
      base3 = RegExp(constructor !== null ? value : new RegExp(value)).toString();
      const prefix = getPrefix2(constructor, tag2, "RegExp");
      if (prefix !== "RegExp ") {
        base3 = `${prefix}${base3}`;
      }
      if (keys.length === 0 && protoProps === void 0 || recurseTimes > ctx.depth && ctx.depth !== null) {
        return ctx.stylize(base3, "regexp");
      }
    } else if (isDate7(value)) {
      base3 = Number.isNaN(value.getTime()) ? value.toString() : value.toISOString();
      const prefix = getPrefix2(constructor, tag2, "Date");
      if (prefix !== "Date ") {
        base3 = `${prefix}${base3}`;
      }
      if (keys.length === 0 && protoProps === void 0) {
        return ctx.stylize(base3, "date");
      }
    } else if (value instanceof Error) {
      base3 = formatError2(value, constructor, tag2, ctx, keys);
      if (keys.length === 0 && protoProps === void 0) {
        return base3;
      }
    } else if (isAnyArrayBuffer6(value)) {
      const arrayType = isArrayBuffer6(value) ? "ArrayBuffer" : "SharedArrayBuffer";
      const prefix = getPrefix2(constructor, tag2, arrayType);
      if (typedArray === void 0) {
        formatter = formatArrayBuffer2;
      } else if (keys.length === 0 && protoProps === void 0) {
        return prefix + `{ byteLength: ${formatNumber2(ctx.stylize, value.byteLength)} }`;
      }
      braces[0] = `${prefix}{`;
      Array.prototype.unshift.call(keys, "byteLength");
    } else if (isDataView6(value)) {
      braces[0] = `${getPrefix2(constructor, tag2, "DataView")}{`;
      Array.prototype.unshift.call(keys, "byteLength", "byteOffset", "buffer");
    } else if (isPromise6(value)) {
      braces[0] = `${getPrefix2(constructor, tag2, "Promise")}{`;
      formatter = formatPromise2;
    } else if (isWeakSet6(value)) {
      braces[0] = `${getPrefix2(constructor, tag2, "WeakSet")}{`;
      formatter = ctx.showHidden ? formatWeakSet2 : formatWeakCollection2;
    } else if (isWeakMap6(value)) {
      braces[0] = `${getPrefix2(constructor, tag2, "WeakMap")}{`;
      formatter = ctx.showHidden ? formatWeakMap2 : formatWeakCollection2;
    } else if (isModuleNamespaceObject6(value)) {
      braces[0] = `${getPrefix2(constructor, tag2, "Module")}{`;
      formatter = formatNamespaceObject2.bind(null, keys);
    } else if (isBoxedPrimitive6(value)) {
      base3 = getBoxedBase2(value, ctx, keys, constructor, tag2);
      if (keys.length === 0 && protoProps === void 0) {
        return base3;
      }
    } else {
      if (keys.length === 0 && protoProps === void 0) {
        return `${getCtxStyle2(value, constructor, tag2)}{}`;
      }
      braces[0] = `${getCtxStyle2(value, constructor, tag2)}{`;
    }
  }
  if (recurseTimes > ctx.depth && ctx.depth !== null) {
    let constructorName = getCtxStyle2(value, constructor, tag2).slice(0, -1);
    if (constructor !== null) {
      constructorName = `[${constructorName}]`;
    }
    return ctx.stylize(constructorName, "special");
  }
  recurseTimes += 1;
  ctx.seen.push(value);
  ctx.currentDepth = recurseTimes;
  let output;
  const indentationLvl = ctx.indentationLvl;
  try {
    output = formatter(ctx, value, recurseTimes);
    for (i = 0; i < keys.length; i++) {
      output.push(formatProperty2(ctx, value, recurseTimes, keys[i], extrasType));
    }
    if (protoProps !== void 0) {
      output.push(...protoProps);
    }
  } catch (err) {
    const constructorName = getCtxStyle2(value, constructor, tag2).slice(0, -1);
    return handleMaxCallStackSize2(ctx, err, constructorName, indentationLvl);
  }
  if (ctx.circular !== void 0) {
    const index = ctx.circular.get(value);
    if (index !== void 0) {
      const reference = ctx.stylize(`<ref *${index}>`, "special");
      if (ctx.compact !== true) {
        base3 = base3 === "" ? reference : `${reference} ${base3}`;
      } else {
        braces[0] = `${reference} ${braces[0]}`;
      }
    }
  }
  ctx.seen.pop();
  if (ctx.sorted) {
    const comparator = ctx.sorted === true ? void 0 : ctx.sorted;
    if (extrasType === kObjectType2) {
      output = output.sort(comparator);
    } else if (keys.length > 1) {
      const sorted = output.slice(output.length - keys.length).sort(comparator);
      output.splice(output.length - keys.length, keys.length, ...sorted);
    }
  }
  const res = reduceToSingleString2(ctx, output, base3, braces, extrasType, recurseTimes, value);
  const budget = ctx.budget[ctx.indentationLvl] || 0;
  const newLength = budget + res.length;
  ctx.budget[ctx.indentationLvl] = newLength;
  if (newLength > 2 ** 27) {
    ctx.depth = -1;
  }
  return res;
}
var builtInObjects2 = new Set(Object.getOwnPropertyNames(globalThis).filter((e) => /^[A-Z][a-zA-Z0-9]+$/.test(e)));
function addPrototypeProperties2(ctx, main, obj2, recurseTimes, output) {
  let depth = 0;
  let keys;
  let keySet;
  do {
    if (depth !== 0 || main === obj2) {
      obj2 = Object.getPrototypeOf(obj2);
      if (obj2 === null) {
        return;
      }
      const descriptor = Object.getOwnPropertyDescriptor(obj2, "constructor");
      if (descriptor !== void 0 && typeof descriptor.value === "function" && builtInObjects2.has(descriptor.value.name)) {
        return;
      }
    }
    if (depth === 0) {
      keySet = /* @__PURE__ */ new Set();
    } else {
      Array.prototype.forEach.call(keys, (key2) => keySet.add(key2));
    }
    keys = Reflect.ownKeys(obj2);
    Array.prototype.push.call(ctx.seen, main);
    for (const key2 of keys) {
      if (key2 === "constructor" || main.hasOwnProperty(key2) || depth !== 0 && keySet.has(key2)) {
        continue;
      }
      const desc = Object.getOwnPropertyDescriptor(obj2, key2);
      if (typeof desc.value === "function") {
        continue;
      }
      const value = formatProperty2(ctx, obj2, recurseTimes, key2, kObjectType2, desc, main);
      if (ctx.colors) {
        Array.prototype.push.call(output, `\x1B[2m${value}\x1B[22m`);
      } else {
        Array.prototype.push.call(output, value);
      }
    }
    Array.prototype.pop.call(ctx.seen);
  } while (++depth !== 3);
}
function getConstructorName2(obj2, ctx, recurseTimes, protoProps) {
  let firstProto;
  const tmp = obj2;
  while (obj2 || isUndetectableObject2(obj2)) {
    const descriptor = Object.getOwnPropertyDescriptor(obj2, "constructor");
    if (descriptor !== void 0 && typeof descriptor.value === "function" && descriptor.value.name !== "" && isInstanceof2(tmp, descriptor.value)) {
      if (protoProps !== void 0 && (firstProto !== obj2 || !builtInObjects2.has(descriptor.value.name))) {
        addPrototypeProperties2(ctx, tmp, firstProto || tmp, recurseTimes, protoProps);
      }
      return descriptor.value.name;
    }
    obj2 = Object.getPrototypeOf(obj2);
    if (firstProto === void 0) {
      firstProto = obj2;
    }
  }
  if (firstProto === null) {
    return null;
  }
  const res = void 0;
  if (recurseTimes > ctx.depth && ctx.depth !== null) {
    return `${res} <Complex prototype>`;
  }
  const protoConstr = getConstructorName2(firstProto, ctx, recurseTimes + 1, protoProps);
  if (protoConstr === null) {
    return `${res} <${inspect5(firstProto, {
      ...ctx,
      customInspect: false,
      depth: -1
    })}>`;
  }
  return `${res} <${protoConstr}>`;
}
function formatPrimitive2(fn, value, ctx) {
  if (typeof value === "string") {
    let trailer = "";
    if (value.length > ctx.maxStringLength) {
      const remaining = value.length - ctx.maxStringLength;
      value = value.slice(0, ctx.maxStringLength);
      trailer = `... ${remaining} more character${remaining > 1 ? "s" : ""}`;
    }
    if (ctx.compact !== true && value.length > kMinLineLength2 && value.length > ctx.breakLength - ctx.indentationLvl - 4) {
      return value.split(/(?<=\n)/).map((line) => fn(strEscape2(line), "string")).join(` +
${" ".repeat(ctx.indentationLvl + 2)}`) + trailer;
    }
    return fn(strEscape2(value), "string") + trailer;
  }
  if (typeof value === "number") {
    return formatNumber2(fn, value);
  }
  if (typeof value === "bigint") {
    return formatBigInt2(fn, value);
  }
  if (typeof value === "boolean") {
    return fn(`${value}`, "boolean");
  }
  if (typeof value === "undefined") {
    return fn("undefined", "undefined");
  }
  return fn(value.toString(), "symbol");
}
function getEmptyFormatArray2() {
  return [];
}
function isInstanceof2(object, proto) {
  try {
    return object instanceof proto;
  } catch {
    return false;
  }
}
function getPrefix2(constructor, tag2, fallback, size = "") {
  if (constructor === null) {
    if (tag2 !== "" && fallback !== tag2) {
      return `[${fallback}${size}: null prototype] [${tag2}] `;
    }
    return `[${fallback}${size}: null prototype] `;
  }
  if (tag2 !== "" && constructor !== tag2) {
    return `${constructor}${size} [${tag2}] `;
  }
  return `${constructor}${size} `;
}
function formatArray2(ctx, value, recurseTimes) {
  const valLen = value.length;
  const len = Math.min(Math.max(0, ctx.maxArrayLength), valLen);
  const remaining = valLen - len;
  const output = [];
  for (let i = 0; i < len; i++) {
    if (!value.hasOwnProperty(i)) {
      return formatSpecialArray2(ctx, value, recurseTimes, len, output, i);
    }
    output.push(formatProperty2(ctx, value, recurseTimes, i, kArrayType2));
  }
  if (remaining > 0) {
    output.push(`... ${remaining} more item${remaining > 1 ? "s" : ""}`);
  }
  return output;
}
function getCtxStyle2(_value, constructor, tag2) {
  let fallback = "";
  if (constructor === null) {
    if (fallback === tag2) {
      fallback = "Object";
    }
  }
  return getPrefix2(constructor, tag2, fallback);
}
function getKeys2(value, showHidden) {
  let keys;
  const symbols = Object.getOwnPropertySymbols(value);
  if (showHidden) {
    keys = Object.getOwnPropertyNames(value);
    if (symbols.length !== 0) {
      Array.prototype.push.apply(keys, symbols);
    }
  } else {
    try {
      keys = Object.keys(value);
    } catch (_err) {
      keys = Object.getOwnPropertyNames(value);
    }
    if (symbols.length !== 0) {
    }
  }
  return keys;
}
function formatSet2(value, ctx, _ignored, recurseTimes) {
  const output = [];
  ctx.indentationLvl += 2;
  for (const v2 of value) {
    Array.prototype.push.call(output, formatValue2(ctx, v2, recurseTimes));
  }
  ctx.indentationLvl -= 2;
  return output;
}
function formatMap2(value, ctx, _gnored, recurseTimes) {
  const output = [];
  ctx.indentationLvl += 2;
  for (const { 0: k6, 1: v2 } of value) {
    output.push(`${formatValue2(ctx, k6, recurseTimes)} => ${formatValue2(ctx, v2, recurseTimes)}`);
  }
  ctx.indentationLvl -= 2;
  return output;
}
function formatTypedArray2(value, length, ctx, _ignored, recurseTimes) {
  const maxLength = Math.min(Math.max(0, ctx.maxArrayLength), length);
  const remaining = value.length - maxLength;
  const output = new Array(maxLength);
  const elementFormatter = value.length > 0 && typeof value[0] === "number" ? formatNumber2 : formatBigInt2;
  for (let i = 0; i < maxLength; ++i) {
    output[i] = elementFormatter(ctx.stylize, value[i]);
  }
  if (remaining > 0) {
    output[maxLength] = `... ${remaining} more item${remaining > 1 ? "s" : ""}`;
  }
  if (ctx.showHidden) {
    ctx.indentationLvl += 2;
    for (const key2 of [
      "BYTES_PER_ELEMENT",
      "length",
      "byteLength",
      "byteOffset",
      "buffer"
    ]) {
      const str = formatValue2(ctx, value[key2], recurseTimes, true);
      Array.prototype.push.call(output, `[${key2}]: ${str}`);
    }
    ctx.indentationLvl -= 2;
  }
  return output;
}
function getIteratorBraces2(type, tag2) {
  if (tag2 !== `${type} Iterator`) {
    if (tag2 !== "") {
      tag2 += "] [";
    }
    tag2 += `${type} Iterator`;
  }
  return [`[${tag2}] {`, "}"];
}
function formatIterator2(braces, ctx, value, recurseTimes) {
  const { 0: entries, 1: isKeyValue } = value;
  if (isKeyValue) {
    braces[0] = braces[0].replace(/ Iterator] {$/, " Entries] {");
    return formatMapIterInner2(ctx, recurseTimes, entries, kMapEntries2);
  }
  return formatSetIterInner2(ctx, recurseTimes, entries, kIterator2);
}
function getFunctionBase2(value, constructor, tag2) {
  const stringified = Function.prototype.toString.call(value);
  if (stringified.slice(0, 5) === "class" && stringified.endsWith("}")) {
    const slice5 = stringified.slice(5, -1);
    const bracketIndex = slice5.indexOf("{");
    if (bracketIndex !== -1 && (!slice5.slice(0, bracketIndex).includes("(") || classRegExp3.test(slice5.replace(stripCommentsRegExp2)))) {
      return getClassBase2(value, constructor, tag2);
    }
  }
  let type = "Function";
  if (isGeneratorFunction6(value)) {
    type = `Generator${type}`;
  }
  if (isAsyncFunction6(value)) {
    type = `Async${type}`;
  }
  let base3 = `[${type}`;
  if (constructor === null) {
    base3 += " (null prototype)";
  }
  if (value.name === "") {
    base3 += " (anonymous)";
  } else {
    base3 += `: ${value.name}`;
  }
  base3 += "]";
  if (constructor !== type && constructor !== null) {
    base3 += ` ${constructor}`;
  }
  if (tag2 !== "" && constructor !== tag2) {
    base3 += ` [${tag2}]`;
  }
  return base3;
}
function formatError2(err, constructor, tag2, ctx, keys) {
  const name = err.name != null ? String(err.name) : "Error";
  let len = name.length;
  let stack = err.stack ? String(err.stack) : err.toString();
  if (!ctx.showHidden && keys.length !== 0) {
    for (const name2 of ["name", "message", "stack"]) {
      const index = keys.indexOf(name2);
      if (index !== -1 && stack.includes(err[name2])) {
        keys.splice(index, 1);
      }
    }
  }
  if (constructor === null || name.endsWith("Error") && stack.startsWith(name) && (stack.length === len || stack[len] === ":" || stack[len] === "\n")) {
    let fallback = "Error";
    if (constructor === null) {
      const start = stack.match(/^([A-Z][a-z_ A-Z0-9[\]()-]+)(?::|\n {4}at)/) || stack.match(/^([a-z_A-Z0-9-]*Error)$/);
      fallback = start && start[1] || "";
      len = fallback.length;
      fallback = fallback || "Error";
    }
    const prefix = getPrefix2(constructor, tag2, fallback).slice(0, -1);
    if (name !== prefix) {
      if (prefix.includes(name)) {
        if (len === 0) {
          stack = `${prefix}: ${stack}`;
        } else {
          stack = `${prefix}${stack.slice(len)}`;
        }
      } else {
        stack = `${prefix} [${name}]${stack.slice(len)}`;
      }
    }
  }
  let pos = err.message && stack.indexOf(err.message) || -1;
  if (pos !== -1) {
    pos += err.message.length;
  }
  const stackStart = stack.indexOf("\n    at", pos);
  if (stackStart === -1) {
    stack = `[${stack}]`;
  } else if (ctx.colors) {
    let newStack = stack.slice(0, stackStart);
    const lines = stack.slice(stackStart + 1).split("\n");
    for (const line of lines) {
      let nodeModule;
      newStack += "\n";
      let pos2 = 0;
      while (nodeModule = nodeModulesRegExp2.exec(line)) {
        newStack += line.slice(pos2, nodeModule.index + 14);
        newStack += ctx.stylize(nodeModule[1], "module");
        pos2 = nodeModule.index + nodeModule[0].length;
      }
      newStack += pos2 === 0 ? line : line.slice(pos2);
    }
    stack = newStack;
  }
  if (ctx.indentationLvl !== 0) {
    const indentation = " ".repeat(ctx.indentationLvl);
    stack = stack.replace(/\n/g, `
${indentation}`);
  }
  return stack;
}
var hexSlice4;
function formatArrayBuffer2(ctx, value) {
  let buffer;
  try {
    buffer = new Uint8Array(value);
  } catch {
    return [ctx.stylize("(detached)", "special")];
  }
  let str = hexSlice4(buffer, 0, Math.min(ctx.maxArrayLength, buffer.length)).replace(/(.{2})/g, "$1 ").trim();
  const remaining = buffer.length - ctx.maxArrayLength;
  if (remaining > 0) {
    str += ` ... ${remaining} more byte${remaining > 1 ? "s" : ""}`;
  }
  return [`${ctx.stylize("[Uint8Contents]", "special")}: <${str}>`];
}
function formatNumber2(fn, value) {
  return fn(Object.is(value, -0) ? "-0" : `${value}`, "number");
}
function formatPromise2(ctx, value, recurseTimes) {
  let output;
  const { 0: state, 1: result } = value;
  if (state === kPending2) {
    output = [ctx.stylize("<pending>", "special")];
  } else {
    ctx.indentationLvl += 2;
    const str = formatValue2(ctx, result, recurseTimes);
    ctx.indentationLvl -= 2;
    output = [
      state === kRejected2 ? `${ctx.stylize("<rejected>", "special")} ${str}` : str
    ];
  }
  return output;
}
function formatWeakCollection2(ctx) {
  return [ctx.stylize("<items unknown>", "special")];
}
function formatWeakSet2(ctx, value, recurseTimes) {
  const entries = value;
  return formatSetIterInner2(ctx, recurseTimes, entries, kWeak2);
}
function formatWeakMap2(ctx, value, recurseTimes) {
  const entries = value;
  return formatMapIterInner2(ctx, recurseTimes, entries, kWeak2);
}
function formatProperty2(ctx, value, recurseTimes, key2, type, desc, original = value) {
  let name, str;
  let extra = " ";
  desc = desc || Object.getOwnPropertyDescriptor(value, key2) || { value: value[key2], enumerable: true };
  if (desc.value !== void 0) {
    const diff3 = ctx.compact !== true || type !== kObjectType2 ? 2 : 3;
    ctx.indentationLvl += diff3;
    str = formatValue2(ctx, desc.value, recurseTimes);
    if (diff3 === 3 && ctx.breakLength < getStringWidth2(str, ctx.colors)) {
      extra = `
${" ".repeat(ctx.indentationLvl)}`;
    }
    ctx.indentationLvl -= diff3;
  } else if (desc.get !== void 0) {
    const label = desc.set !== void 0 ? "Getter/Setter" : "Getter";
    const s = ctx.stylize;
    const sp = "special";
    if (ctx.getters && (ctx.getters === true || ctx.getters === "get" && desc.set === void 0 || ctx.getters === "set" && desc.set !== void 0)) {
      try {
        const tmp = desc.get.call(original);
        ctx.indentationLvl += 2;
        if (tmp === null) {
          str = `${s(`[${label}:`, sp)} ${s("null", "null")}${s("]", sp)}`;
        } else if (typeof tmp === "object") {
          str = `${s(`[${label}]`, sp)} ${formatValue2(ctx, tmp, recurseTimes)}`;
        } else {
          const primitive = formatPrimitive2(s, tmp, ctx);
          str = `${s(`[${label}:`, sp)} ${primitive}${s("]", sp)}`;
        }
        ctx.indentationLvl -= 2;
      } catch (err) {
        const message = `<Inspection threw (${err.message})>`;
        str = `${s(`[${label}:`, sp)} ${message}${s("]", sp)}`;
      }
    } else {
      str = ctx.stylize(`[${label}]`, sp);
    }
  } else if (desc.set !== void 0) {
    str = ctx.stylize("[Setter]", "special");
  } else {
    str = ctx.stylize("undefined", "undefined");
  }
  if (type === kArrayType2) {
    return str;
  }
  if (typeof key2 === "symbol") {
    const tmp = key2.toString().replace(strEscapeSequencesReplacer2, escapeFn2);
    name = `[${ctx.stylize(tmp, "symbol")}]`;
  } else if (key2 === "__proto__") {
    name = "['__proto__']";
  } else if (desc.enumerable === false) {
    const tmp = key2.replace(strEscapeSequencesReplacer2, escapeFn2);
    name = `[${tmp}]`;
  } else if (keyStrRegExp2.test(key2)) {
    name = ctx.stylize(key2, "name");
  } else {
    name = ctx.stylize(strEscape2(key2), "string");
  }
  return `${name}:${extra}${str}`;
}
function handleMaxCallStackSize2(_ctx, _err, _constructorName, _indentationLvl) {
}
var colorRegExp2 = /\u001b\[\d\d?m/g;
function removeColors2(str) {
  return str.replace(colorRegExp2, "");
}
function isBelowBreakLength2(ctx, output, start, base3) {
  let totalLength = output.length + start;
  if (totalLength + output.length > ctx.breakLength) {
    return false;
  }
  for (let i = 0; i < output.length; i++) {
    if (ctx.colors) {
      totalLength += removeColors2(output[i]).length;
    } else {
      totalLength += output[i].length;
    }
    if (totalLength > ctx.breakLength) {
      return false;
    }
  }
  return base3 === "" || !base3.includes("\n");
}
function formatBigInt2(fn, value) {
  return fn(`${value}n`, "bigint");
}
function formatNamespaceObject2(keys, ctx, value, recurseTimes) {
  const output = new Array(keys.length);
  for (let i = 0; i < keys.length; i++) {
    try {
      output[i] = formatProperty2(ctx, value, recurseTimes, keys[i], kObjectType2);
    } catch (_err) {
      const tmp = { [keys[i]]: "" };
      output[i] = formatProperty2(ctx, tmp, recurseTimes, keys[i], kObjectType2);
      const pos = output[i].lastIndexOf(" ");
      output[i] = output[i].slice(0, pos + 1) + ctx.stylize("<uninitialized>", "special");
    }
  }
  keys.length = 0;
  return output;
}
function formatSpecialArray2(ctx, value, recurseTimes, maxLength, output, i) {
  const keys = Object.keys(value);
  let index = i;
  for (; i < keys.length && output.length < maxLength; i++) {
    const key2 = keys[i];
    const tmp = +key2;
    if (tmp > 2 ** 32 - 2) {
      break;
    }
    if (`${index}` !== key2) {
      if (!numberRegExp2.test(key2)) {
        break;
      }
      const emptyItems = tmp - index;
      const ending = emptyItems > 1 ? "s" : "";
      const message = `<${emptyItems} empty item${ending}>`;
      output.push(ctx.stylize(message, "undefined"));
      index = tmp;
      if (output.length === maxLength) {
        break;
      }
    }
    output.push(formatProperty2(ctx, value, recurseTimes, key2, kArrayType2));
    index++;
  }
  const remaining = value.length - index;
  if (output.length !== maxLength) {
    if (remaining > 0) {
      const ending = remaining > 1 ? "s" : "";
      const message = `<${remaining} empty item${ending}>`;
      output.push(ctx.stylize(message, "undefined"));
    }
  } else if (remaining > 0) {
    output.push(`... ${remaining} more item${remaining > 1 ? "s" : ""}`);
  }
  return output;
}
function getBoxedBase2(value, ctx, keys, constructor, tag2) {
  let type;
  if (isNumberObject6(value)) {
    type = "Number";
  } else if (isStringObject6(value)) {
    type = "String";
    keys.splice(0, value.length);
  } else if (isBooleanObject6(value)) {
    type = "Boolean";
  } else if (isBigIntObject6(value)) {
    type = "BigInt";
  } else {
    type = "Symbol";
  }
  let base3 = `[${type}`;
  if (type !== constructor) {
    if (constructor === null) {
      base3 += " (null prototype)";
    } else {
      base3 += ` (${constructor})`;
    }
  }
  base3 += `: ${formatPrimitive2(stylizeNoColor2, value.valueOf(), ctx)}]`;
  if (tag2 !== "" && tag2 !== constructor) {
    base3 += ` [${tag2}]`;
  }
  if (keys.length !== 0 || ctx.stylize === stylizeNoColor2) {
    return base3;
  }
  return ctx.stylize(base3, type.toLowerCase());
}
function getClassBase2(value, constructor, tag2) {
  const hasName = value.hasOwnProperty("name");
  const name = hasName && value.name || "(anonymous)";
  let base3 = `class ${name}`;
  if (constructor !== "Function" && constructor !== null) {
    base3 += ` [${constructor}]`;
  }
  if (tag2 !== "" && constructor !== tag2) {
    base3 += ` [${tag2}]`;
  }
  if (constructor !== null) {
    const superName = Object.getPrototypeOf(value).name;
    if (superName) {
      base3 += ` extends ${superName}`;
    }
  } else {
    base3 += " extends [null prototype]";
  }
  return `[${base3}]`;
}
function reduceToSingleString2(ctx, output, base3, braces, extrasType, recurseTimes, value) {
  if (ctx.compact !== true) {
    if (typeof ctx.compact === "number" && ctx.compact >= 1) {
      const entries = output.length;
      if (extrasType === kArrayExtrasType2 && entries > 6) {
        output = groupArrayElements2(ctx, output, value);
      }
      if (ctx.currentDepth - recurseTimes < ctx.compact && entries === output.length) {
        const start = output.length + ctx.indentationLvl + braces[0].length + base3.length + 10;
        if (isBelowBreakLength2(ctx, output, start, base3)) {
          return `${base3 ? `${base3} ` : ""}${braces[0]} ${join7(output, ", ")} ${braces[1]}`;
        }
      }
    }
    const indentation2 = `
${" ".repeat(ctx.indentationLvl)}`;
    return `${base3 ? `${base3} ` : ""}${braces[0]}${indentation2}  ${join7(output, `,${indentation2}  `)}${indentation2}${braces[1]}`;
  }
  if (isBelowBreakLength2(ctx, output, 0, base3)) {
    return `${braces[0]}${base3 ? ` ${base3}` : ""} ${join7(output, ", ")} ` + braces[1];
  }
  const indentation = " ".repeat(ctx.indentationLvl);
  const ln = base3 === "" && braces[0].length === 1 ? " " : `${base3 ? ` ${base3}` : ""}
${indentation}  `;
  return `${braces[0]}${ln}${join7(output, `,
${indentation}  `)} ${braces[1]}`;
}
function join7(output, separator) {
  let str = "";
  if (output.length !== 0) {
    const lastIndex = output.length - 1;
    for (let i = 0; i < lastIndex; i++) {
      str += output[i];
      str += separator;
    }
    str += output[lastIndex];
  }
  return str;
}
function groupArrayElements2(ctx, output, value) {
  let totalLength = 0;
  let maxLength = 0;
  let i = 0;
  let outputLength = output.length;
  if (ctx.maxArrayLength < output.length) {
    outputLength--;
  }
  const separatorSpace = 2;
  const dataLen = new Array(outputLength);
  for (; i < outputLength; i++) {
    const len = getStringWidth2(output[i], ctx.colors);
    dataLen[i] = len;
    totalLength += len + separatorSpace;
    if (maxLength < len) {
      maxLength = len;
    }
  }
  const actualMax = maxLength + separatorSpace;
  if (actualMax * 3 + ctx.indentationLvl < ctx.breakLength && (totalLength / actualMax > 5 || maxLength <= 6)) {
    const approxCharHeights = 2.5;
    const averageBias = Math.sqrt(actualMax - totalLength / output.length);
    const biasedMax = Math.max(actualMax - 3 - averageBias, 1);
    const columns = Math.min(Math.round(Math.sqrt(approxCharHeights * biasedMax * outputLength) / biasedMax), Math.floor((ctx.breakLength - ctx.indentationLvl) / actualMax), ctx.compact * 4, 15);
    if (columns <= 1) {
      return output;
    }
    const tmp = [];
    const maxLineLength = [];
    for (let i2 = 0; i2 < columns; i2++) {
      let lineMaxLength = 0;
      for (let j2 = i2; j2 < output.length; j2 += columns) {
        if (dataLen[j2] > lineMaxLength) {
          lineMaxLength = dataLen[j2];
        }
      }
      lineMaxLength += separatorSpace;
      maxLineLength[i2] = lineMaxLength;
    }
    let order = String.prototype.padStart;
    if (value !== void 0) {
      for (let i2 = 0; i2 < output.length; i2++) {
        if (typeof value[i2] !== "number" && typeof value[i2] !== "bigint") {
          order = String.prototype.padEnd;
          break;
        }
      }
    }
    for (let i2 = 0; i2 < outputLength; i2 += columns) {
      const max2 = Math.min(i2 + columns, outputLength);
      let str = "";
      let j2 = i2;
      for (; j2 < max2 - 1; j2++) {
        const padding = maxLineLength[j2 - i2] + output[j2].length - dataLen[j2];
        str += `${output[j2]}, `.padStart(padding, " ");
      }
      if (order === String.prototype.padStart) {
        const padding = maxLineLength[j2 - i2] + output[j2].length - dataLen[j2] - separatorSpace;
        str += output[j2].padStart(padding, " ");
      } else {
        str += output[j2];
      }
      Array.prototype.push.call(tmp, str);
    }
    if (ctx.maxArrayLength < output.length) {
      Array.prototype.push.call(tmp, output[outputLength]);
    }
    output = tmp;
  }
  return output;
}
function formatMapIterInner2(ctx, recurseTimes, entries, state) {
  const maxArrayLength = Math.max(ctx.maxArrayLength, 0);
  const len = entries.length / 2;
  const remaining = len - maxArrayLength;
  const maxLength = Math.min(maxArrayLength, len);
  let output = new Array(maxLength);
  let i = 0;
  ctx.indentationLvl += 2;
  if (state === kWeak2) {
    for (; i < maxLength; i++) {
      const pos = i * 2;
      output[i] = `${formatValue2(ctx, entries[pos], recurseTimes)} => ${formatValue2(ctx, entries[pos + 1], recurseTimes)}`;
    }
    if (!ctx.sorted) {
      output = output.sort();
    }
  } else {
    for (; i < maxLength; i++) {
      const pos = i * 2;
      const res = [
        formatValue2(ctx, entries[pos], recurseTimes),
        formatValue2(ctx, entries[pos + 1], recurseTimes)
      ];
      output[i] = reduceToSingleString2(ctx, res, "", ["[", "]"], kArrayExtrasType2, recurseTimes);
    }
  }
  ctx.indentationLvl -= 2;
  if (remaining > 0) {
    output.push(`... ${remaining} more item${remaining > 1 ? "s" : ""}`);
  }
  return output;
}
function formatSetIterInner2(ctx, recurseTimes, entries, state) {
  const maxArrayLength = Math.max(ctx.maxArrayLength, 0);
  const maxLength = Math.min(maxArrayLength, entries.length);
  const output = new Array(maxLength);
  ctx.indentationLvl += 2;
  for (let i = 0; i < maxLength; i++) {
    output[i] = formatValue2(ctx, entries[i], recurseTimes);
  }
  ctx.indentationLvl -= 2;
  if (state === kWeak2 && !ctx.sorted) {
    output.sort();
  }
  const remaining = entries.length - maxLength;
  if (remaining > 0) {
    Array.prototype.push.call(output, `... ${remaining} more item${remaining > 1 ? "s" : ""}`);
  }
  return output;
}
var ansiPattern2 = "[\\u001B\\u009B][[\\]()#;?]*(?:(?:(?:(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]+)*|[a-zA-Z\\d]+(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]*)*)?\\u0007)|(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PR-TZcf-ntqry=><~]))";
var ansi2 = new RegExp(ansiPattern2, "g");
function getStringWidth2(str, removeControlChars = true) {
  let width = 0;
  if (removeControlChars) {
    str = stripVTControlCharacters2(str);
  }
  str = str.normalize("NFC");
  for (const char of str[Symbol.iterator]()) {
    const code2 = char.codePointAt(0);
    if (isFullWidthCodePoint2(code2)) {
      width += 2;
    } else if (!isZeroWidthCodePoint2(code2)) {
      width++;
    }
  }
  return width;
}
var isFullWidthCodePoint2 = (code2) => {
  return code2 >= 4352 && (code2 <= 4447 || code2 === 9001 || code2 === 9002 || code2 >= 11904 && code2 <= 12871 && code2 !== 12351 || code2 >= 12880 && code2 <= 19903 || code2 >= 19968 && code2 <= 42182 || code2 >= 43360 && code2 <= 43388 || code2 >= 44032 && code2 <= 55203 || code2 >= 63744 && code2 <= 64255 || code2 >= 65040 && code2 <= 65049 || code2 >= 65072 && code2 <= 65131 || code2 >= 65281 && code2 <= 65376 || code2 >= 65504 && code2 <= 65510 || code2 >= 110592 && code2 <= 110593 || code2 >= 127488 && code2 <= 127569 || code2 >= 127744 && code2 <= 128591 || code2 >= 131072 && code2 <= 262141);
};
var isZeroWidthCodePoint2 = (code2) => {
  return code2 <= 31 || code2 >= 127 && code2 <= 159 || code2 >= 768 && code2 <= 879 || code2 >= 8203 && code2 <= 8207 || code2 >= 8400 && code2 <= 8447 || code2 >= 65024 && code2 <= 65039 || code2 >= 65056 && code2 <= 65071 || code2 >= 917760 && code2 <= 917999;
};
function hasBuiltInToString2(value) {
  const proxyTarget = void 0;
  if (proxyTarget !== void 0) {
    value = proxyTarget;
  }
  if (typeof value.toString !== "function") {
    return true;
  }
  if (Object.prototype.hasOwnProperty.call(value, "toString")) {
    return false;
  }
  let pointer = value;
  do {
    pointer = Object.getPrototypeOf(pointer);
  } while (!Object.prototype.hasOwnProperty.call(pointer, "toString"));
  const descriptor = Object.getOwnPropertyDescriptor(pointer, "constructor");
  return descriptor !== void 0 && typeof descriptor.value === "function" && builtInObjects2.has(descriptor.value.name);
}
var firstErrorLine2 = (error3) => error3.message.split("\n", 1)[0];
var CIRCULAR_ERROR_MESSAGE2;
function tryStringify2(arg) {
  try {
    return JSON.stringify(arg);
  } catch (err) {
    if (!CIRCULAR_ERROR_MESSAGE2) {
      try {
        const a = {};
        a.a = a;
        JSON.stringify(a);
      } catch (circularError) {
        CIRCULAR_ERROR_MESSAGE2 = firstErrorLine2(circularError);
      }
    }
    if (err.name === "TypeError" && firstErrorLine2(err) === CIRCULAR_ERROR_MESSAGE2) {
      return "[Circular]";
    }
    throw err;
  }
}
function format7(...args) {
  return formatWithOptionsInternal2(void 0, args);
}
function formatWithOptions2(inspectOptions, ...args) {
  if (typeof inspectOptions !== "object" || inspectOptions === null) {
    throw new codes3.ERR_INVALID_ARG_TYPE("inspectOptions", "object", inspectOptions);
  }
  return formatWithOptionsInternal2(inspectOptions, args);
}
function formatNumberNoColor2(number, options) {
  return formatNumber2(stylizeNoColor2, number, options?.numericSeparator ?? inspectDefaultOptions2.numericSeparator);
}
function formatBigIntNoColor2(bigint, options) {
  return formatBigInt2(stylizeNoColor2, bigint, options?.numericSeparator ?? inspectDefaultOptions2.numericSeparator);
}
function formatWithOptionsInternal2(inspectOptions, args) {
  const first = args[0];
  let a = 0;
  let str = "";
  let join12 = "";
  if (typeof first === "string") {
    if (args.length === 1) {
      return first;
    }
    let tempStr;
    let lastPos = 0;
    for (let i = 0; i < first.length - 1; i++) {
      if (first.charCodeAt(i) === 37) {
        const nextChar = first.charCodeAt(++i);
        if (a + 1 !== args.length) {
          switch (nextChar) {
            case 115:
              const tempArg = args[++a];
              if (typeof tempArg === "number") {
                tempStr = formatNumberNoColor2(tempArg, inspectOptions);
              } else if (typeof tempArg === "bigint") {
                tempStr = formatBigIntNoColor2(tempArg, inspectOptions);
              } else if (typeof tempArg !== "object" || tempArg === null || !hasBuiltInToString2(tempArg)) {
                tempStr = String(tempArg);
              } else {
                tempStr = inspect5(tempArg, {
                  ...inspectOptions,
                  compact: 3,
                  colors: false,
                  depth: 0
                });
              }
              break;
            case 106:
              tempStr = tryStringify2(args[++a]);
              break;
            case 100:
              const tempNum = args[++a];
              if (typeof tempNum === "bigint") {
                tempStr = formatBigIntNoColor2(tempNum, inspectOptions);
              } else if (typeof tempNum === "symbol") {
                tempStr = "NaN";
              } else {
                tempStr = formatNumberNoColor2(Number(tempNum), inspectOptions);
              }
              break;
            case 79:
              tempStr = inspect5(args[++a], inspectOptions);
              break;
            case 111:
              tempStr = inspect5(args[++a], {
                ...inspectOptions,
                showHidden: true,
                showProxy: true,
                depth: 4
              });
              break;
            case 105:
              const tempInteger = args[++a];
              if (typeof tempInteger === "bigint") {
                tempStr = formatBigIntNoColor2(tempInteger, inspectOptions);
              } else if (typeof tempInteger === "symbol") {
                tempStr = "NaN";
              } else {
                tempStr = formatNumberNoColor2(Number.parseInt(tempInteger), inspectOptions);
              }
              break;
            case 102:
              const tempFloat = args[++a];
              if (typeof tempFloat === "symbol") {
                tempStr = "NaN";
              } else {
                tempStr = formatNumberNoColor2(Number.parseFloat(tempFloat), inspectOptions);
              }
              break;
            case 99:
              a += 1;
              tempStr = "";
              break;
            case 37:
              str += first.slice(lastPos, i);
              lastPos = i + 1;
              continue;
            default:
              continue;
          }
          if (lastPos !== i - 1) {
            str += first.slice(lastPos, i - 1);
          }
          str += tempStr;
          lastPos = i + 1;
        } else if (nextChar === 37) {
          str += first.slice(lastPos, i);
          lastPos = i + 1;
        }
      }
    }
    if (lastPos !== 0) {
      a++;
      join12 = " ";
      if (lastPos < first.length) {
        str += first.slice(lastPos);
      }
    }
  }
  while (a < args.length) {
    const value = args[a];
    str += join12;
    str += typeof value !== "string" ? inspect5(value, inspectOptions) : value;
    join12 = " ";
    a++;
  }
  return str;
}
function stripVTControlCharacters2(str) {
  validateString3(str, "str");
  return str.replace(ansi2, "");
}

// deno:https://deno.land/std@0.146.0/node/internal/util/debuglog.ts
var debugImpls2;
var testEnabled2;
function initializeDebugEnv2(debugEnv3) {
  debugImpls2 = /* @__PURE__ */ Object.create(null);
  if (debugEnv3) {
    debugEnv3 = debugEnv3.replace(/[|\\{}()[\]^$+?.]/g, "\\$&").replaceAll("*", ".*").replaceAll(",", "$|^");
    const debugEnvRegex = new RegExp(`^${debugEnv3}$`, "i");
    testEnabled2 = (str) => debugEnvRegex.exec(str) !== null;
  } else {
    testEnabled2 = () => false;
  }
}
function emitWarningIfNeeded2(set) {
  if (set === "HTTP" || set === "HTTP2") {
    console.warn("Setting the NODE_DEBUG environment variable to '" + set.toLowerCase() + "' can expose sensitive data (such as passwords, tokens and authentication headers) in the resulting log.");
  }
}
var noop2 = () => {
};
function debuglogImpl2(enabled2, set) {
  if (debugImpls2[set] === void 0) {
    if (enabled2) {
      emitWarningIfNeeded2(set);
      debugImpls2[set] = function debug2(...args) {
        const msg = args.map((arg) => inspect5(arg)).join(" ");
        console.error(sprintf2("%s %s: %s", set, String(Deno.pid), msg));
      };
    } else {
      debugImpls2[set] = noop2;
    }
  }
  return debugImpls2[set];
}
function debuglog2(set, cb) {
  function init4() {
    set = set.toUpperCase();
    enabled2 = testEnabled2(set);
  }
  let debug2 = (...args) => {
    init4();
    debug2 = debuglogImpl2(enabled2, set);
    if (typeof cb === "function") {
      cb(debug2);
    }
    return debug2(...args);
  };
  let enabled2;
  let test = () => {
    init4();
    test = () => enabled2;
    return enabled2;
  };
  const logger = (...args) => debug2(...args);
  Object.defineProperty(logger, "enabled", {
    get() {
      return test();
    },
    configurable: true,
    enumerable: true
  });
  return logger;
}
var debugEnv2;
try {
  debugEnv2 = Deno.env.get("NODE_DEBUG") ?? "";
} catch (error3) {
  if (error3 instanceof Deno.errors.PermissionDenied) {
    debugEnv2 = "";
  } else {
    throw error3;
  }
}
initializeDebugEnv2(debugEnv2);

// deno:https://deno.land/std@0.146.0/_util/os.ts
var osType2 = (() => {
  const { Deno: Deno4 } = globalThis;
  if (typeof Deno4?.build?.os === "string") {
    return Deno4.build.os;
  }
  const { navigator } = globalThis;
  if (navigator?.appVersion?.includes?.("Win")) {
    return "windows";
  }
  return "linux";
})();
var isWindows2 = osType2 === "windows";

// deno:https://deno.land/std@0.146.0/node/internal_binding/constants.ts
var os2 = {
  UV_UDP_IPV6ONLY: 1,
  UV_UDP_PARTIAL: 2,
  UV_UDP_REUSEADDR: 4,
  UV_UDP_MMSG_CHUNK: 8,
  UV_UDP_MMSG_FREE: 16,
  UV_UDP_LINUX_RECVERR: 32,
  UV_UDP_RECVMMSG: 256,
  dlopen: {
    RTLD_LAZY: 1,
    RTLD_NOW: 2,
    RTLD_GLOBAL: 8,
    RTLD_LOCAL: 4
  },
  errno: {
    E2BIG: 7,
    EACCES: 13,
    EADDRINUSE: 48,
    EADDRNOTAVAIL: 49,
    EAFNOSUPPORT: 47,
    EAGAIN: 35,
    EALREADY: 37,
    EBADF: 9,
    EBADMSG: 94,
    EBUSY: 16,
    ECANCELED: 89,
    ECHILD: 10,
    ECONNABORTED: 53,
    ECONNREFUSED: 61,
    ECONNRESET: 54,
    EDEADLK: 11,
    EDESTADDRREQ: 39,
    EDOM: 33,
    EDQUOT: 69,
    EEXIST: 17,
    EFAULT: 14,
    EFBIG: 27,
    EHOSTUNREACH: 65,
    EIDRM: 90,
    EILSEQ: 92,
    EINPROGRESS: 36,
    EINTR: 4,
    EINVAL: 22,
    EIO: 5,
    EISCONN: 56,
    EISDIR: 21,
    ELOOP: 62,
    EMFILE: 24,
    EMLINK: 31,
    EMSGSIZE: 40,
    EMULTIHOP: 95,
    ENAMETOOLONG: 63,
    ENETDOWN: 50,
    ENETRESET: 52,
    ENETUNREACH: 51,
    ENFILE: 23,
    ENOBUFS: 55,
    ENODATA: 96,
    ENODEV: 19,
    ENOENT: 2,
    ENOEXEC: 8,
    ENOLCK: 77,
    ENOLINK: 97,
    ENOMEM: 12,
    ENOMSG: 91,
    ENOPROTOOPT: 42,
    ENOSPC: 28,
    ENOSR: 98,
    ENOSTR: 99,
    ENOSYS: 78,
    ENOTCONN: 57,
    ENOTDIR: 20,
    ENOTEMPTY: 66,
    ENOTSOCK: 38,
    ENOTSUP: 45,
    ENOTTY: 25,
    ENXIO: 6,
    EOPNOTSUPP: 102,
    EOVERFLOW: 84,
    EPERM: 1,
    EPIPE: 32,
    EPROTO: 100,
    EPROTONOSUPPORT: 43,
    EPROTOTYPE: 41,
    ERANGE: 34,
    EROFS: 30,
    ESPIPE: 29,
    ESRCH: 3,
    ESTALE: 70,
    ETIME: 101,
    ETIMEDOUT: 60,
    ETXTBSY: 26,
    EWOULDBLOCK: 35,
    EXDEV: 18
  },
  signals: {
    SIGHUP: 1,
    SIGINT: 2,
    SIGQUIT: 3,
    SIGILL: 4,
    SIGTRAP: 5,
    SIGABRT: 6,
    SIGIOT: 6,
    SIGBUS: 10,
    SIGFPE: 8,
    SIGKILL: 9,
    SIGUSR1: 30,
    SIGSEGV: 11,
    SIGUSR2: 31,
    SIGPIPE: 13,
    SIGALRM: 14,
    SIGTERM: 15,
    SIGCHLD: 20,
    SIGCONT: 19,
    SIGSTOP: 17,
    SIGTSTP: 18,
    SIGTTIN: 21,
    SIGBREAK: 21,
    SIGTTOU: 22,
    SIGURG: 16,
    SIGXCPU: 24,
    SIGXFSZ: 25,
    SIGVTALRM: 26,
    SIGPROF: 27,
    SIGWINCH: 28,
    SIGIO: 23,
    SIGINFO: 29,
    SIGSYS: 12,
    SIGEMT: 7,
    SIGPWR: 30,
    SIGSTKFLT: 16
  },
  priority: {
    PRIORITY_LOW: 19,
    PRIORITY_BELOW_NORMAL: 10,
    PRIORITY_NORMAL: 0,
    PRIORITY_ABOVE_NORMAL: -7,
    PRIORITY_HIGH: -14,
    PRIORITY_HIGHEST: -20
  }
};

// deno:https://deno.land/std@0.146.0/node/internal_binding/uv.ts
var UV_EEXIST2 = os2.errno.EEXIST;
var UV_ENOENT2 = os2.errno.ENOENT;
var codeToErrorWindows2 = [
  [-4093, ["E2BIG", "argument list too long"]],
  [-4092, ["EACCES", "permission denied"]],
  [-4091, ["EADDRINUSE", "address already in use"]],
  [-4090, ["EADDRNOTAVAIL", "address not available"]],
  [-4089, ["EAFNOSUPPORT", "address family not supported"]],
  [-4088, ["EAGAIN", "resource temporarily unavailable"]],
  [-3e3, ["EAI_ADDRFAMILY", "address family not supported"]],
  [-3001, ["EAI_AGAIN", "temporary failure"]],
  [-3002, ["EAI_BADFLAGS", "bad ai_flags value"]],
  [-3013, ["EAI_BADHINTS", "invalid value for hints"]],
  [-3003, ["EAI_CANCELED", "request canceled"]],
  [-3004, ["EAI_FAIL", "permanent failure"]],
  [-3005, ["EAI_FAMILY", "ai_family not supported"]],
  [-3006, ["EAI_MEMORY", "out of memory"]],
  [-3007, ["EAI_NODATA", "no address"]],
  [-3008, ["EAI_NONAME", "unknown node or service"]],
  [-3009, ["EAI_OVERFLOW", "argument buffer overflow"]],
  [-3014, ["EAI_PROTOCOL", "resolved protocol is unknown"]],
  [-3010, ["EAI_SERVICE", "service not available for socket type"]],
  [-3011, ["EAI_SOCKTYPE", "socket type not supported"]],
  [-4084, ["EALREADY", "connection already in progress"]],
  [-4083, ["EBADF", "bad file descriptor"]],
  [-4082, ["EBUSY", "resource busy or locked"]],
  [-4081, ["ECANCELED", "operation canceled"]],
  [-4080, ["ECHARSET", "invalid Unicode character"]],
  [-4079, ["ECONNABORTED", "software caused connection abort"]],
  [-4078, ["ECONNREFUSED", "connection refused"]],
  [-4077, ["ECONNRESET", "connection reset by peer"]],
  [-4076, ["EDESTADDRREQ", "destination address required"]],
  [-4075, ["EEXIST", "file already exists"]],
  [-4074, ["EFAULT", "bad address in system call argument"]],
  [-4036, ["EFBIG", "file too large"]],
  [-4073, ["EHOSTUNREACH", "host is unreachable"]],
  [-4072, ["EINTR", "interrupted system call"]],
  [-4071, ["EINVAL", "invalid argument"]],
  [-4070, ["EIO", "i/o error"]],
  [-4069, ["EISCONN", "socket is already connected"]],
  [-4068, ["EISDIR", "illegal operation on a directory"]],
  [-4067, ["ELOOP", "too many symbolic links encountered"]],
  [-4066, ["EMFILE", "too many open files"]],
  [-4065, ["EMSGSIZE", "message too long"]],
  [-4064, ["ENAMETOOLONG", "name too long"]],
  [-4063, ["ENETDOWN", "network is down"]],
  [-4062, ["ENETUNREACH", "network is unreachable"]],
  [-4061, ["ENFILE", "file table overflow"]],
  [-4060, ["ENOBUFS", "no buffer space available"]],
  [-4059, ["ENODEV", "no such device"]],
  [-4058, ["ENOENT", "no such file or directory"]],
  [-4057, ["ENOMEM", "not enough memory"]],
  [-4056, ["ENONET", "machine is not on the network"]],
  [-4035, ["ENOPROTOOPT", "protocol not available"]],
  [-4055, ["ENOSPC", "no space left on device"]],
  [-4054, ["ENOSYS", "function not implemented"]],
  [-4053, ["ENOTCONN", "socket is not connected"]],
  [-4052, ["ENOTDIR", "not a directory"]],
  [-4051, ["ENOTEMPTY", "directory not empty"]],
  [-4050, ["ENOTSOCK", "socket operation on non-socket"]],
  [-4049, ["ENOTSUP", "operation not supported on socket"]],
  [-4048, ["EPERM", "operation not permitted"]],
  [-4047, ["EPIPE", "broken pipe"]],
  [-4046, ["EPROTO", "protocol error"]],
  [-4045, ["EPROTONOSUPPORT", "protocol not supported"]],
  [-4044, ["EPROTOTYPE", "protocol wrong type for socket"]],
  [-4034, ["ERANGE", "result too large"]],
  [-4043, ["EROFS", "read-only file system"]],
  [-4042, ["ESHUTDOWN", "cannot send after transport endpoint shutdown"]],
  [-4041, ["ESPIPE", "invalid seek"]],
  [-4040, ["ESRCH", "no such process"]],
  [-4039, ["ETIMEDOUT", "connection timed out"]],
  [-4038, ["ETXTBSY", "text file is busy"]],
  [-4037, ["EXDEV", "cross-device link not permitted"]],
  [-4094, ["UNKNOWN", "unknown error"]],
  [-4095, ["EOF", "end of file"]],
  [-4033, ["ENXIO", "no such device or address"]],
  [-4032, ["EMLINK", "too many links"]],
  [-4031, ["EHOSTDOWN", "host is down"]],
  [-4030, ["EREMOTEIO", "remote I/O error"]],
  [-4029, ["ENOTTY", "inappropriate ioctl for device"]],
  [-4028, ["EFTYPE", "inappropriate file type or format"]],
  [-4027, ["EILSEQ", "illegal byte sequence"]]
];
var errorToCodeWindows2 = codeToErrorWindows2.map(([status, [error3]]) => [error3, status]);
var codeToErrorDarwin2 = [
  [-7, ["E2BIG", "argument list too long"]],
  [-13, ["EACCES", "permission denied"]],
  [-48, ["EADDRINUSE", "address already in use"]],
  [-49, ["EADDRNOTAVAIL", "address not available"]],
  [-47, ["EAFNOSUPPORT", "address family not supported"]],
  [-35, ["EAGAIN", "resource temporarily unavailable"]],
  [-3e3, ["EAI_ADDRFAMILY", "address family not supported"]],
  [-3001, ["EAI_AGAIN", "temporary failure"]],
  [-3002, ["EAI_BADFLAGS", "bad ai_flags value"]],
  [-3013, ["EAI_BADHINTS", "invalid value for hints"]],
  [-3003, ["EAI_CANCELED", "request canceled"]],
  [-3004, ["EAI_FAIL", "permanent failure"]],
  [-3005, ["EAI_FAMILY", "ai_family not supported"]],
  [-3006, ["EAI_MEMORY", "out of memory"]],
  [-3007, ["EAI_NODATA", "no address"]],
  [-3008, ["EAI_NONAME", "unknown node or service"]],
  [-3009, ["EAI_OVERFLOW", "argument buffer overflow"]],
  [-3014, ["EAI_PROTOCOL", "resolved protocol is unknown"]],
  [-3010, ["EAI_SERVICE", "service not available for socket type"]],
  [-3011, ["EAI_SOCKTYPE", "socket type not supported"]],
  [-37, ["EALREADY", "connection already in progress"]],
  [-9, ["EBADF", "bad file descriptor"]],
  [-16, ["EBUSY", "resource busy or locked"]],
  [-89, ["ECANCELED", "operation canceled"]],
  [-4080, ["ECHARSET", "invalid Unicode character"]],
  [-53, ["ECONNABORTED", "software caused connection abort"]],
  [-61, ["ECONNREFUSED", "connection refused"]],
  [-54, ["ECONNRESET", "connection reset by peer"]],
  [-39, ["EDESTADDRREQ", "destination address required"]],
  [-17, ["EEXIST", "file already exists"]],
  [-14, ["EFAULT", "bad address in system call argument"]],
  [-27, ["EFBIG", "file too large"]],
  [-65, ["EHOSTUNREACH", "host is unreachable"]],
  [-4, ["EINTR", "interrupted system call"]],
  [-22, ["EINVAL", "invalid argument"]],
  [-5, ["EIO", "i/o error"]],
  [-56, ["EISCONN", "socket is already connected"]],
  [-21, ["EISDIR", "illegal operation on a directory"]],
  [-62, ["ELOOP", "too many symbolic links encountered"]],
  [-24, ["EMFILE", "too many open files"]],
  [-40, ["EMSGSIZE", "message too long"]],
  [-63, ["ENAMETOOLONG", "name too long"]],
  [-50, ["ENETDOWN", "network is down"]],
  [-51, ["ENETUNREACH", "network is unreachable"]],
  [-23, ["ENFILE", "file table overflow"]],
  [-55, ["ENOBUFS", "no buffer space available"]],
  [-19, ["ENODEV", "no such device"]],
  [-2, ["ENOENT", "no such file or directory"]],
  [-12, ["ENOMEM", "not enough memory"]],
  [-4056, ["ENONET", "machine is not on the network"]],
  [-42, ["ENOPROTOOPT", "protocol not available"]],
  [-28, ["ENOSPC", "no space left on device"]],
  [-78, ["ENOSYS", "function not implemented"]],
  [-57, ["ENOTCONN", "socket is not connected"]],
  [-20, ["ENOTDIR", "not a directory"]],
  [-66, ["ENOTEMPTY", "directory not empty"]],
  [-38, ["ENOTSOCK", "socket operation on non-socket"]],
  [-45, ["ENOTSUP", "operation not supported on socket"]],
  [-1, ["EPERM", "operation not permitted"]],
  [-32, ["EPIPE", "broken pipe"]],
  [-100, ["EPROTO", "protocol error"]],
  [-43, ["EPROTONOSUPPORT", "protocol not supported"]],
  [-41, ["EPROTOTYPE", "protocol wrong type for socket"]],
  [-34, ["ERANGE", "result too large"]],
  [-30, ["EROFS", "read-only file system"]],
  [-58, ["ESHUTDOWN", "cannot send after transport endpoint shutdown"]],
  [-29, ["ESPIPE", "invalid seek"]],
  [-3, ["ESRCH", "no such process"]],
  [-60, ["ETIMEDOUT", "connection timed out"]],
  [-26, ["ETXTBSY", "text file is busy"]],
  [-18, ["EXDEV", "cross-device link not permitted"]],
  [-4094, ["UNKNOWN", "unknown error"]],
  [-4095, ["EOF", "end of file"]],
  [-6, ["ENXIO", "no such device or address"]],
  [-31, ["EMLINK", "too many links"]],
  [-64, ["EHOSTDOWN", "host is down"]],
  [-4030, ["EREMOTEIO", "remote I/O error"]],
  [-25, ["ENOTTY", "inappropriate ioctl for device"]],
  [-79, ["EFTYPE", "inappropriate file type or format"]],
  [-92, ["EILSEQ", "illegal byte sequence"]]
];
var errorToCodeDarwin2 = codeToErrorDarwin2.map(([status, [code2]]) => [code2, status]);
var codeToErrorLinux2 = [
  [-7, ["E2BIG", "argument list too long"]],
  [-13, ["EACCES", "permission denied"]],
  [-98, ["EADDRINUSE", "address already in use"]],
  [-99, ["EADDRNOTAVAIL", "address not available"]],
  [-97, ["EAFNOSUPPORT", "address family not supported"]],
  [-11, ["EAGAIN", "resource temporarily unavailable"]],
  [-3e3, ["EAI_ADDRFAMILY", "address family not supported"]],
  [-3001, ["EAI_AGAIN", "temporary failure"]],
  [-3002, ["EAI_BADFLAGS", "bad ai_flags value"]],
  [-3013, ["EAI_BADHINTS", "invalid value for hints"]],
  [-3003, ["EAI_CANCELED", "request canceled"]],
  [-3004, ["EAI_FAIL", "permanent failure"]],
  [-3005, ["EAI_FAMILY", "ai_family not supported"]],
  [-3006, ["EAI_MEMORY", "out of memory"]],
  [-3007, ["EAI_NODATA", "no address"]],
  [-3008, ["EAI_NONAME", "unknown node or service"]],
  [-3009, ["EAI_OVERFLOW", "argument buffer overflow"]],
  [-3014, ["EAI_PROTOCOL", "resolved protocol is unknown"]],
  [-3010, ["EAI_SERVICE", "service not available for socket type"]],
  [-3011, ["EAI_SOCKTYPE", "socket type not supported"]],
  [-114, ["EALREADY", "connection already in progress"]],
  [-9, ["EBADF", "bad file descriptor"]],
  [-16, ["EBUSY", "resource busy or locked"]],
  [-125, ["ECANCELED", "operation canceled"]],
  [-4080, ["ECHARSET", "invalid Unicode character"]],
  [-103, ["ECONNABORTED", "software caused connection abort"]],
  [-111, ["ECONNREFUSED", "connection refused"]],
  [-104, ["ECONNRESET", "connection reset by peer"]],
  [-89, ["EDESTADDRREQ", "destination address required"]],
  [-17, ["EEXIST", "file already exists"]],
  [-14, ["EFAULT", "bad address in system call argument"]],
  [-27, ["EFBIG", "file too large"]],
  [-113, ["EHOSTUNREACH", "host is unreachable"]],
  [-4, ["EINTR", "interrupted system call"]],
  [-22, ["EINVAL", "invalid argument"]],
  [-5, ["EIO", "i/o error"]],
  [-106, ["EISCONN", "socket is already connected"]],
  [-21, ["EISDIR", "illegal operation on a directory"]],
  [-40, ["ELOOP", "too many symbolic links encountered"]],
  [-24, ["EMFILE", "too many open files"]],
  [-90, ["EMSGSIZE", "message too long"]],
  [-36, ["ENAMETOOLONG", "name too long"]],
  [-100, ["ENETDOWN", "network is down"]],
  [-101, ["ENETUNREACH", "network is unreachable"]],
  [-23, ["ENFILE", "file table overflow"]],
  [-105, ["ENOBUFS", "no buffer space available"]],
  [-19, ["ENODEV", "no such device"]],
  [-2, ["ENOENT", "no such file or directory"]],
  [-12, ["ENOMEM", "not enough memory"]],
  [-64, ["ENONET", "machine is not on the network"]],
  [-92, ["ENOPROTOOPT", "protocol not available"]],
  [-28, ["ENOSPC", "no space left on device"]],
  [-38, ["ENOSYS", "function not implemented"]],
  [-107, ["ENOTCONN", "socket is not connected"]],
  [-20, ["ENOTDIR", "not a directory"]],
  [-39, ["ENOTEMPTY", "directory not empty"]],
  [-88, ["ENOTSOCK", "socket operation on non-socket"]],
  [-95, ["ENOTSUP", "operation not supported on socket"]],
  [-1, ["EPERM", "operation not permitted"]],
  [-32, ["EPIPE", "broken pipe"]],
  [-71, ["EPROTO", "protocol error"]],
  [-93, ["EPROTONOSUPPORT", "protocol not supported"]],
  [-91, ["EPROTOTYPE", "protocol wrong type for socket"]],
  [-34, ["ERANGE", "result too large"]],
  [-30, ["EROFS", "read-only file system"]],
  [-108, ["ESHUTDOWN", "cannot send after transport endpoint shutdown"]],
  [-29, ["ESPIPE", "invalid seek"]],
  [-3, ["ESRCH", "no such process"]],
  [-110, ["ETIMEDOUT", "connection timed out"]],
  [-26, ["ETXTBSY", "text file is busy"]],
  [-18, ["EXDEV", "cross-device link not permitted"]],
  [-4094, ["UNKNOWN", "unknown error"]],
  [-4095, ["EOF", "end of file"]],
  [-6, ["ENXIO", "no such device or address"]],
  [-31, ["EMLINK", "too many links"]],
  [-112, ["EHOSTDOWN", "host is down"]],
  [-121, ["EREMOTEIO", "remote I/O error"]],
  [-25, ["ENOTTY", "inappropriate ioctl for device"]],
  [-4028, ["EFTYPE", "inappropriate file type or format"]],
  [-84, ["EILSEQ", "illegal byte sequence"]]
];
var errorToCodeLinux2 = codeToErrorLinux2.map(([status, [code2]]) => [code2, status]);
var errorMap2 = new Map(osType2 === "windows" ? codeToErrorWindows2 : osType2 === "darwin" ? codeToErrorDarwin2 : osType2 === "linux" ? codeToErrorLinux2 : unreachable2());
var codeMap2 = new Map(osType2 === "windows" ? errorToCodeWindows2 : osType2 === "darwin" ? errorToCodeDarwin2 : osType2 === "linux" ? errorToCodeLinux2 : unreachable2());
var UV_EAI_MEMORY2 = codeMap2.get("EAI_MEMORY");
var UV_UNKNOWN2 = codeMap2.get("UNKNOWN");
var UV_EBADF2 = codeMap2.get("EBADF");
var UV_EINVAL2 = codeMap2.get("EINVAL");
var UV_ENOTSOCK2 = codeMap2.get("ENOTSOCK");

// deno:https://deno.land/std@0.146.0/node/util/types.ts
var types_default5 = { ...types_exports5 };

// deno:https://deno.land/std@0.146.0/node/internal_binding/_node.ts
var Encodings3 = /* @__PURE__ */ ((Encodings4) => {
  Encodings4[Encodings4["ASCII"] = 0] = "ASCII";
  Encodings4[Encodings4["UTF8"] = 1] = "UTF8";
  Encodings4[Encodings4["BASE64"] = 2] = "BASE64";
  Encodings4[Encodings4["UCS2"] = 3] = "UCS2";
  Encodings4[Encodings4["BINARY"] = 4] = "BINARY";
  Encodings4[Encodings4["HEX"] = 5] = "HEX";
  Encodings4[Encodings4["BUFFER"] = 6] = "BUFFER";
  Encodings4[Encodings4["BASE64URL"] = 7] = "BASE64URL";
  Encodings4[Encodings4["LATIN1"] = 4] = "LATIN1";
  return Encodings4;
})(Encodings3 || {});

// deno:https://deno.land/std@0.146.0/node/internal_binding/string_decoder.ts
var encodings3 = [];
encodings3[0 /* ASCII */] = "ascii";
encodings3[2 /* BASE64 */] = "base64";
encodings3[7 /* BASE64URL */] = "base64url";
encodings3[6 /* BUFFER */] = "buffer";
encodings3[5 /* HEX */] = "hex";
encodings3[4 /* LATIN1 */] = "latin1";
encodings3[3 /* UCS2 */] = "utf16le";
encodings3[1 /* UTF8 */] = "utf8";

// deno:https://deno.land/std@0.146.0/node/internal_binding/buffer.ts
function numberToBytes3(n) {
  if (n === 0)
    return new Uint8Array([0]);
  const bytes = [];
  bytes.unshift(n & 255);
  while (n >= 256) {
    n = n >>> 8;
    bytes.unshift(n & 255);
  }
  return new Uint8Array(bytes);
}
function findLastIndex3(targetBuffer, buffer, offset) {
  offset = offset > targetBuffer.length ? targetBuffer.length : offset;
  const searchableBuffer = targetBuffer.slice(0, offset + buffer.length);
  const searchableBufferLastIndex = searchableBuffer.length - 1;
  const bufferLastIndex = buffer.length - 1;
  let lastMatchIndex = -1;
  let matches = 0;
  let index = -1;
  for (let x = 0; x <= searchableBufferLastIndex; x++) {
    if (searchableBuffer[searchableBufferLastIndex - x] === buffer[bufferLastIndex - matches]) {
      if (lastMatchIndex === -1) {
        lastMatchIndex = x;
      }
      matches++;
    } else {
      matches = 0;
      if (lastMatchIndex !== -1) {
        x = lastMatchIndex + 1;
        lastMatchIndex = -1;
      }
      continue;
    }
    if (matches === buffer.length) {
      index = x;
      break;
    }
  }
  if (index === -1)
    return index;
  return searchableBufferLastIndex - index;
}
function indexOfBuffer3(targetBuffer, buffer, byteOffset, encoding, forwardDirection) {
  if (!Encodings3[encoding] === void 0) {
    throw new Error(`Unknown encoding code ${encoding}`);
  }
  if (!forwardDirection) {
    if (byteOffset < 0) {
      byteOffset = targetBuffer.length + byteOffset;
    }
    if (buffer.length === 0) {
      return byteOffset <= targetBuffer.length ? byteOffset : targetBuffer.length;
    }
    return findLastIndex3(targetBuffer, buffer, byteOffset);
  }
  if (buffer.length === 0) {
    return byteOffset <= targetBuffer.length ? byteOffset : targetBuffer.length;
  }
  return indexOfNeedle3(targetBuffer, buffer, byteOffset);
}
function indexOfNumber3(targetBuffer, number, byteOffset, forwardDirection) {
  const bytes = numberToBytes3(number);
  if (bytes.length > 1) {
    throw new Error("Multi byte number search is not supported");
  }
  return indexOfBuffer3(targetBuffer, numberToBytes3(number), byteOffset, 1 /* UTF8 */, forwardDirection);
}

// deno:https://deno.land/std@0.146.0/encoding/base64.ts
var base64abc3 = [
  "A",
  "B",
  "C",
  "D",
  "E",
  "F",
  "G",
  "H",
  "I",
  "J",
  "K",
  "L",
  "M",
  "N",
  "O",
  "P",
  "Q",
  "R",
  "S",
  "T",
  "U",
  "V",
  "W",
  "X",
  "Y",
  "Z",
  "a",
  "b",
  "c",
  "d",
  "e",
  "f",
  "g",
  "h",
  "i",
  "j",
  "k",
  "l",
  "m",
  "n",
  "o",
  "p",
  "q",
  "r",
  "s",
  "t",
  "u",
  "v",
  "w",
  "x",
  "y",
  "z",
  "0",
  "1",
  "2",
  "3",
  "4",
  "5",
  "6",
  "7",
  "8",
  "9",
  "+",
  "/"
];
function encode11(data) {
  const uint8 = typeof data === "string" ? new TextEncoder().encode(data) : data instanceof Uint8Array ? data : new Uint8Array(data);
  let result = "", i;
  const l = uint8.length;
  for (i = 2; i < l; i += 3) {
    result += base64abc3[uint8[i - 2] >> 2];
    result += base64abc3[(uint8[i - 2] & 3) << 4 | uint8[i - 1] >> 4];
    result += base64abc3[(uint8[i - 1] & 15) << 2 | uint8[i] >> 6];
    result += base64abc3[uint8[i] & 63];
  }
  if (i === l + 1) {
    result += base64abc3[uint8[i - 2] >> 2];
    result += base64abc3[(uint8[i - 2] & 3) << 4];
    result += "==";
  }
  if (i === l) {
    result += base64abc3[uint8[i - 2] >> 2];
    result += base64abc3[(uint8[i - 2] & 3) << 4 | uint8[i - 1] >> 4];
    result += base64abc3[(uint8[i - 1] & 15) << 2];
    result += "=";
  }
  return result;
}
function decode9(b64) {
  const binString = atob(b64);
  const size = binString.length;
  const bytes = new Uint8Array(size);
  for (let i = 0; i < size; i++) {
    bytes[i] = binString.charCodeAt(i);
  }
  return bytes;
}

// deno:https://deno.land/std@0.146.0/encoding/base64url.ts
function addPaddingToBase64url3(base64url) {
  if (base64url.length % 4 === 2)
    return base64url + "==";
  if (base64url.length % 4 === 3)
    return base64url + "=";
  if (base64url.length % 4 === 1) {
    throw new TypeError("Illegal base64url string!");
  }
  return base64url;
}
function convertBase64urlToBase643(b64url) {
  if (!/^[-_A-Z0-9]*?={0,2}$/i.test(b64url)) {
    throw new TypeError("Failed to decode base64url: invalid character");
  }
  return addPaddingToBase64url3(b64url).replace(/\-/g, "+").replace(/_/g, "/");
}
function convertBase64ToBase64url3(b64) {
  return b64.replace(/=/g, "").replace(/\+/g, "-").replace(/\//g, "_");
}
function encode12(data) {
  return convertBase64ToBase64url3(encode11(data));
}
function decode10(b64url) {
  return decode9(convertBase64urlToBase643(b64url));
}

// deno:https://deno.land/std@0.146.0/node/internal_binding/_utils.ts
function asciiToBytes3(str) {
  const byteArray = [];
  for (let i = 0; i < str.length; ++i) {
    byteArray.push(str.charCodeAt(i) & 255);
  }
  return new Uint8Array(byteArray);
}
function base64ToBytes3(str) {
  str = base64clean3(str);
  str = str.replaceAll("-", "+").replaceAll("_", "/");
  return decode9(str);
}
var INVALID_BASE64_RE3 = /[^+/0-9A-Za-z-_]/g;
function base64clean3(str) {
  str = str.split("=")[0];
  str = str.trim().replace(INVALID_BASE64_RE3, "");
  if (str.length < 2)
    return "";
  while (str.length % 4 !== 0) {
    str = str + "=";
  }
  return str;
}
function base64UrlToBytes3(str) {
  str = base64clean3(str);
  str = str.replaceAll("+", "-").replaceAll("/", "_");
  return decode10(str);
}
function hexToBytes3(str) {
  const byteArray = new Uint8Array(Math.floor((str || "").length / 2));
  let i;
  for (i = 0; i < byteArray.length; i++) {
    const a = Number.parseInt(str[i * 2], 16);
    const b2 = Number.parseInt(str[i * 2 + 1], 16);
    if (Number.isNaN(a) && Number.isNaN(b2)) {
      break;
    }
    byteArray[i] = a << 4 | b2;
  }
  return new Uint8Array(i === byteArray.length ? byteArray : byteArray.slice(0, i));
}
function utf16leToBytes3(str, units) {
  let c5, hi2, lo3;
  const byteArray = [];
  for (let i = 0; i < str.length; ++i) {
    if ((units -= 2) < 0) {
      break;
    }
    c5 = str.charCodeAt(i);
    hi2 = c5 >> 8;
    lo3 = c5 % 256;
    byteArray.push(lo3);
    byteArray.push(hi2);
  }
  return new Uint8Array(byteArray);
}
function bytesToAscii3(bytes) {
  let ret = "";
  for (let i = 0; i < bytes.length; ++i) {
    ret += String.fromCharCode(bytes[i] & 127);
  }
  return ret;
}
function bytesToUtf16le3(bytes) {
  let res = "";
  for (let i = 0; i < bytes.length - 1; i += 2) {
    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);
  }
  return res;
}

// deno:https://deno.land/std@0.146.0/node/internal/buffer.mjs
var utf8Encoder3 = new TextEncoder();
var float32Array3 = new Float32Array(1);
var uInt8Float32Array3 = new Uint8Array(float32Array3.buffer);
var float64Array3 = new Float64Array(1);
var uInt8Float64Array3 = new Uint8Array(float64Array3.buffer);
float32Array3[0] = -1;
var bigEndian3 = uInt8Float32Array3[3] === 0;
function readUInt48LE3(buf, offset = 0) {
  validateNumber3(offset, "offset");
  const first = buf[offset];
  const last = buf[offset + 5];
  if (first === void 0 || last === void 0) {
    boundsError3(offset, buf.length - 6);
  }
  return first + buf[++offset] * 2 ** 8 + buf[++offset] * 2 ** 16 + buf[++offset] * 2 ** 24 + (buf[++offset] + last * 2 ** 8) * 2 ** 32;
}
function readUInt40LE3(buf, offset = 0) {
  validateNumber3(offset, "offset");
  const first = buf[offset];
  const last = buf[offset + 4];
  if (first === void 0 || last === void 0) {
    boundsError3(offset, buf.length - 5);
  }
  return first + buf[++offset] * 2 ** 8 + buf[++offset] * 2 ** 16 + buf[++offset] * 2 ** 24 + last * 2 ** 32;
}
function readUInt24LE3(buf, offset = 0) {
  validateNumber3(offset, "offset");
  const first = buf[offset];
  const last = buf[offset + 2];
  if (first === void 0 || last === void 0) {
    boundsError3(offset, buf.length - 3);
  }
  return first + buf[++offset] * 2 ** 8 + last * 2 ** 16;
}
function readUInt48BE3(buf, offset = 0) {
  validateNumber3(offset, "offset");
  const first = buf[offset];
  const last = buf[offset + 5];
  if (first === void 0 || last === void 0) {
    boundsError3(offset, buf.length - 6);
  }
  return (first * 2 ** 8 + buf[++offset]) * 2 ** 32 + buf[++offset] * 2 ** 24 + buf[++offset] * 2 ** 16 + buf[++offset] * 2 ** 8 + last;
}
function readUInt40BE3(buf, offset = 0) {
  validateNumber3(offset, "offset");
  const first = buf[offset];
  const last = buf[offset + 4];
  if (first === void 0 || last === void 0) {
    boundsError3(offset, buf.length - 5);
  }
  return first * 2 ** 32 + buf[++offset] * 2 ** 24 + buf[++offset] * 2 ** 16 + buf[++offset] * 2 ** 8 + last;
}
function readUInt24BE3(buf, offset = 0) {
  validateNumber3(offset, "offset");
  const first = buf[offset];
  const last = buf[offset + 2];
  if (first === void 0 || last === void 0) {
    boundsError3(offset, buf.length - 3);
  }
  return first * 2 ** 16 + buf[++offset] * 2 ** 8 + last;
}
function readUInt16BE3(offset = 0) {
  validateNumber3(offset, "offset");
  const first = this[offset];
  const last = this[offset + 1];
  if (first === void 0 || last === void 0) {
    boundsError3(offset, this.length - 2);
  }
  return first * 2 ** 8 + last;
}
function readUInt32BE3(offset = 0) {
  validateNumber3(offset, "offset");
  const first = this[offset];
  const last = this[offset + 3];
  if (first === void 0 || last === void 0) {
    boundsError3(offset, this.length - 4);
  }
  return first * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + last;
}
function readDoubleBackwards3(buffer, offset = 0) {
  validateNumber3(offset, "offset");
  const first = buffer[offset];
  const last = buffer[offset + 7];
  if (first === void 0 || last === void 0) {
    boundsError3(offset, buffer.length - 8);
  }
  uInt8Float64Array3[7] = first;
  uInt8Float64Array3[6] = buffer[++offset];
  uInt8Float64Array3[5] = buffer[++offset];
  uInt8Float64Array3[4] = buffer[++offset];
  uInt8Float64Array3[3] = buffer[++offset];
  uInt8Float64Array3[2] = buffer[++offset];
  uInt8Float64Array3[1] = buffer[++offset];
  uInt8Float64Array3[0] = last;
  return float64Array3[0];
}
function readDoubleForwards3(buffer, offset = 0) {
  validateNumber3(offset, "offset");
  const first = buffer[offset];
  const last = buffer[offset + 7];
  if (first === void 0 || last === void 0) {
    boundsError3(offset, buffer.length - 8);
  }
  uInt8Float64Array3[0] = first;
  uInt8Float64Array3[1] = buffer[++offset];
  uInt8Float64Array3[2] = buffer[++offset];
  uInt8Float64Array3[3] = buffer[++offset];
  uInt8Float64Array3[4] = buffer[++offset];
  uInt8Float64Array3[5] = buffer[++offset];
  uInt8Float64Array3[6] = buffer[++offset];
  uInt8Float64Array3[7] = last;
  return float64Array3[0];
}
function writeDoubleForwards3(buffer, val, offset = 0) {
  val = +val;
  checkBounds5(buffer, offset, 7);
  float64Array3[0] = val;
  buffer[offset++] = uInt8Float64Array3[0];
  buffer[offset++] = uInt8Float64Array3[1];
  buffer[offset++] = uInt8Float64Array3[2];
  buffer[offset++] = uInt8Float64Array3[3];
  buffer[offset++] = uInt8Float64Array3[4];
  buffer[offset++] = uInt8Float64Array3[5];
  buffer[offset++] = uInt8Float64Array3[6];
  buffer[offset++] = uInt8Float64Array3[7];
  return offset;
}
function writeDoubleBackwards3(buffer, val, offset = 0) {
  val = +val;
  checkBounds5(buffer, offset, 7);
  float64Array3[0] = val;
  buffer[offset++] = uInt8Float64Array3[7];
  buffer[offset++] = uInt8Float64Array3[6];
  buffer[offset++] = uInt8Float64Array3[5];
  buffer[offset++] = uInt8Float64Array3[4];
  buffer[offset++] = uInt8Float64Array3[3];
  buffer[offset++] = uInt8Float64Array3[2];
  buffer[offset++] = uInt8Float64Array3[1];
  buffer[offset++] = uInt8Float64Array3[0];
  return offset;
}
function readFloatBackwards3(buffer, offset = 0) {
  validateNumber3(offset, "offset");
  const first = buffer[offset];
  const last = buffer[offset + 3];
  if (first === void 0 || last === void 0) {
    boundsError3(offset, buffer.length - 4);
  }
  uInt8Float32Array3[3] = first;
  uInt8Float32Array3[2] = buffer[++offset];
  uInt8Float32Array3[1] = buffer[++offset];
  uInt8Float32Array3[0] = last;
  return float32Array3[0];
}
function readFloatForwards3(buffer, offset = 0) {
  validateNumber3(offset, "offset");
  const first = buffer[offset];
  const last = buffer[offset + 3];
  if (first === void 0 || last === void 0) {
    boundsError3(offset, buffer.length - 4);
  }
  uInt8Float32Array3[0] = first;
  uInt8Float32Array3[1] = buffer[++offset];
  uInt8Float32Array3[2] = buffer[++offset];
  uInt8Float32Array3[3] = last;
  return float32Array3[0];
}
function writeFloatForwards3(buffer, val, offset = 0) {
  val = +val;
  checkBounds5(buffer, offset, 3);
  float32Array3[0] = val;
  buffer[offset++] = uInt8Float32Array3[0];
  buffer[offset++] = uInt8Float32Array3[1];
  buffer[offset++] = uInt8Float32Array3[2];
  buffer[offset++] = uInt8Float32Array3[3];
  return offset;
}
function writeFloatBackwards3(buffer, val, offset = 0) {
  val = +val;
  checkBounds5(buffer, offset, 3);
  float32Array3[0] = val;
  buffer[offset++] = uInt8Float32Array3[3];
  buffer[offset++] = uInt8Float32Array3[2];
  buffer[offset++] = uInt8Float32Array3[1];
  buffer[offset++] = uInt8Float32Array3[0];
  return offset;
}
function readInt24LE3(buf, offset = 0) {
  validateNumber3(offset, "offset");
  const first = buf[offset];
  const last = buf[offset + 2];
  if (first === void 0 || last === void 0) {
    boundsError3(offset, buf.length - 3);
  }
  const val = first + buf[++offset] * 2 ** 8 + last * 2 ** 16;
  return val | (val & 2 ** 23) * 510;
}
function readInt40LE3(buf, offset = 0) {
  validateNumber3(offset, "offset");
  const first = buf[offset];
  const last = buf[offset + 4];
  if (first === void 0 || last === void 0) {
    boundsError3(offset, buf.length - 5);
  }
  return (last | (last & 2 ** 7) * 33554430) * 2 ** 32 + first + buf[++offset] * 2 ** 8 + buf[++offset] * 2 ** 16 + buf[++offset] * 2 ** 24;
}
function readInt48LE3(buf, offset = 0) {
  validateNumber3(offset, "offset");
  const first = buf[offset];
  const last = buf[offset + 5];
  if (first === void 0 || last === void 0) {
    boundsError3(offset, buf.length - 6);
  }
  const val = buf[offset + 4] + last * 2 ** 8;
  return (val | (val & 2 ** 15) * 131070) * 2 ** 32 + first + buf[++offset] * 2 ** 8 + buf[++offset] * 2 ** 16 + buf[++offset] * 2 ** 24;
}
function readInt24BE3(buf, offset = 0) {
  validateNumber3(offset, "offset");
  const first = buf[offset];
  const last = buf[offset + 2];
  if (first === void 0 || last === void 0) {
    boundsError3(offset, buf.length - 3);
  }
  const val = first * 2 ** 16 + buf[++offset] * 2 ** 8 + last;
  return val | (val & 2 ** 23) * 510;
}
function readInt48BE3(buf, offset = 0) {
  validateNumber3(offset, "offset");
  const first = buf[offset];
  const last = buf[offset + 5];
  if (first === void 0 || last === void 0) {
    boundsError3(offset, buf.length - 6);
  }
  const val = buf[++offset] + first * 2 ** 8;
  return (val | (val & 2 ** 15) * 131070) * 2 ** 32 + buf[++offset] * 2 ** 24 + buf[++offset] * 2 ** 16 + buf[++offset] * 2 ** 8 + last;
}
function readInt40BE3(buf, offset = 0) {
  validateNumber3(offset, "offset");
  const first = buf[offset];
  const last = buf[offset + 4];
  if (first === void 0 || last === void 0) {
    boundsError3(offset, buf.length - 5);
  }
  return (first | (first & 2 ** 7) * 33554430) * 2 ** 32 + buf[++offset] * 2 ** 24 + buf[++offset] * 2 ** 16 + buf[++offset] * 2 ** 8 + last;
}
function byteLengthUtf83(str) {
  return utf8Encoder3.encode(str).length;
}
function base64ByteLength3(str, bytes) {
  if (str.charCodeAt(bytes - 1) === 61) {
    bytes--;
  }
  if (bytes > 1 && str.charCodeAt(bytes - 1) === 61) {
    bytes--;
  }
  return bytes * 3 >>> 2;
}
var encodingsMap3 = /* @__PURE__ */ Object.create(null);
for (let i = 0; i < encodings3.length; ++i) {
  encodingsMap3[encodings3[i]] = i;
}
var encodingOps3 = {
  ascii: {
    byteLength: (string) => string.length,
    encoding: "ascii",
    encodingVal: encodingsMap3.ascii,
    indexOf: (buf, val, byteOffset, dir) => indexOfBuffer3(buf, asciiToBytes3(val), byteOffset, encodingsMap3.ascii, dir),
    slice: (buf, start, end) => buf.asciiSlice(start, end),
    write: (buf, string, offset, len) => buf.asciiWrite(string, offset, len)
  },
  base64: {
    byteLength: (string) => base64ByteLength3(string, string.length),
    encoding: "base64",
    encodingVal: encodingsMap3.base64,
    indexOf: (buf, val, byteOffset, dir) => indexOfBuffer3(buf, base64ToBytes3(val), byteOffset, encodingsMap3.base64, dir),
    slice: (buf, start, end) => buf.base64Slice(start, end),
    write: (buf, string, offset, len) => buf.base64Write(string, offset, len)
  },
  base64url: {
    byteLength: (string) => base64ByteLength3(string, string.length),
    encoding: "base64url",
    encodingVal: encodingsMap3.base64url,
    indexOf: (buf, val, byteOffset, dir) => indexOfBuffer3(buf, base64UrlToBytes3(val), byteOffset, encodingsMap3.base64url, dir),
    slice: (buf, start, end) => buf.base64urlSlice(start, end),
    write: (buf, string, offset, len) => buf.base64urlWrite(string, offset, len)
  },
  hex: {
    byteLength: (string) => string.length >>> 1,
    encoding: "hex",
    encodingVal: encodingsMap3.hex,
    indexOf: (buf, val, byteOffset, dir) => indexOfBuffer3(buf, hexToBytes3(val), byteOffset, encodingsMap3.hex, dir),
    slice: (buf, start, end) => buf.hexSlice(start, end),
    write: (buf, string, offset, len) => buf.hexWrite(string, offset, len)
  },
  latin1: {
    byteLength: (string) => string.length,
    encoding: "latin1",
    encodingVal: encodingsMap3.latin1,
    indexOf: (buf, val, byteOffset, dir) => indexOfBuffer3(buf, asciiToBytes3(val), byteOffset, encodingsMap3.latin1, dir),
    slice: (buf, start, end) => buf.latin1Slice(start, end),
    write: (buf, string, offset, len) => buf.latin1Write(string, offset, len)
  },
  ucs2: {
    byteLength: (string) => string.length * 2,
    encoding: "ucs2",
    encodingVal: encodingsMap3.utf16le,
    indexOf: (buf, val, byteOffset, dir) => indexOfBuffer3(buf, utf16leToBytes3(val), byteOffset, encodingsMap3.utf16le, dir),
    slice: (buf, start, end) => buf.ucs2Slice(start, end),
    write: (buf, string, offset, len) => buf.ucs2Write(string, offset, len)
  },
  utf8: {
    byteLength: byteLengthUtf83,
    encoding: "utf8",
    encodingVal: encodingsMap3.utf8,
    indexOf: (buf, val, byteOffset, dir) => indexOfBuffer3(buf, utf8Encoder3.encode(val), byteOffset, encodingsMap3.utf8, dir),
    slice: (buf, start, end) => buf.utf8Slice(start, end),
    write: (buf, string, offset, len) => buf.utf8Write(string, offset, len)
  },
  utf16le: {
    byteLength: (string) => string.length * 2,
    encoding: "utf16le",
    encodingVal: encodingsMap3.utf16le,
    indexOf: (buf, val, byteOffset, dir) => indexOfBuffer3(buf, utf16leToBytes3(val), byteOffset, encodingsMap3.utf16le, dir),
    slice: (buf, start, end) => buf.ucs2Slice(start, end),
    write: (buf, string, offset, len) => buf.ucs2Write(string, offset, len)
  }
};
function getEncodingOps3(encoding) {
  encoding = String(encoding).toLowerCase();
  switch (encoding.length) {
    case 4:
      if (encoding === "utf8")
        return encodingOps3.utf8;
      if (encoding === "ucs2")
        return encodingOps3.ucs2;
      break;
    case 5:
      if (encoding === "utf-8")
        return encodingOps3.utf8;
      if (encoding === "ascii")
        return encodingOps3.ascii;
      if (encoding === "ucs-2")
        return encodingOps3.ucs2;
      break;
    case 7:
      if (encoding === "utf16le") {
        return encodingOps3.utf16le;
      }
      break;
    case 8:
      if (encoding === "utf-16le") {
        return encodingOps3.utf16le;
      }
      break;
    case 6:
      if (encoding === "latin1" || encoding === "binary") {
        return encodingOps3.latin1;
      }
      if (encoding === "base64")
        return encodingOps3.base64;
    case 3:
      if (encoding === "hex") {
        return encodingOps3.hex;
      }
      break;
    case 9:
      if (encoding === "base64url") {
        return encodingOps3.base64url;
      }
      break;
  }
}
function _copyActual3(source, target, targetStart, sourceStart, sourceEnd) {
  if (sourceEnd - sourceStart > target.length - targetStart) {
    sourceEnd = sourceStart + target.length - targetStart;
  }
  let nb = sourceEnd - sourceStart;
  const sourceLen = source.length - sourceStart;
  if (nb > sourceLen) {
    nb = sourceLen;
  }
  if (sourceStart !== 0 || sourceEnd < source.length) {
    source = new Uint8Array(source.buffer, source.byteOffset + sourceStart, nb);
  }
  target.set(source, targetStart);
  return nb;
}
function boundsError3(value, length, type) {
  if (Math.floor(value) !== value) {
    validateNumber3(value, type);
    throw new codes3.ERR_OUT_OF_RANGE(type || "offset", "an integer", value);
  }
  if (length < 0) {
    throw new codes3.ERR_BUFFER_OUT_OF_BOUNDS();
  }
  throw new codes3.ERR_OUT_OF_RANGE(type || "offset", `>= ${type ? 1 : 0} and <= ${length}`, value);
}
function validateNumber3(value, name) {
  if (typeof value !== "number") {
    throw new codes3.ERR_INVALID_ARG_TYPE(name, "number", value);
  }
}
function checkBounds5(buf, offset, byteLength6) {
  validateNumber3(offset, "offset");
  if (buf[offset] === void 0 || buf[offset + byteLength6] === void 0) {
    boundsError3(offset, buf.length - (byteLength6 + 1));
  }
}
function checkInt3(value, min4, max2, buf, offset, byteLength6) {
  if (value > max2 || value < min4) {
    const n = typeof min4 === "bigint" ? "n" : "";
    let range;
    if (byteLength6 > 3) {
      if (min4 === 0 || min4 === 0n) {
        range = `>= 0${n} and < 2${n} ** ${(byteLength6 + 1) * 8}${n}`;
      } else {
        range = `>= -(2${n} ** ${(byteLength6 + 1) * 8 - 1}${n}) and < 2${n} ** ${(byteLength6 + 1) * 8 - 1}${n}`;
      }
    } else {
      range = `>= ${min4}${n} and <= ${max2}${n}`;
    }
    throw new codes3.ERR_OUT_OF_RANGE("value", range, value);
  }
  checkBounds5(buf, offset, byteLength6);
}
function toInteger3(n, defaultVal) {
  n = +n;
  if (!Number.isNaN(n) && n >= Number.MIN_SAFE_INTEGER && n <= Number.MAX_SAFE_INTEGER) {
    return n % 1 === 0 ? n : Math.floor(n);
  }
  return defaultVal;
}
function writeU_Int83(buf, value, offset, min4, max2) {
  value = +value;
  validateNumber3(offset, "offset");
  if (value > max2 || value < min4) {
    throw new codes3.ERR_OUT_OF_RANGE("value", `>= ${min4} and <= ${max2}`, value);
  }
  if (buf[offset] === void 0) {
    boundsError3(offset, buf.length - 1);
  }
  buf[offset] = value;
  return offset + 1;
}
function writeU_Int16BE3(buf, value, offset, min4, max2) {
  value = +value;
  checkInt3(value, min4, max2, buf, offset, 1);
  buf[offset++] = value >>> 8;
  buf[offset++] = value;
  return offset;
}
function _writeUInt32LE3(buf, value, offset, min4, max2) {
  value = +value;
  checkInt3(value, min4, max2, buf, offset, 3);
  buf[offset++] = value;
  value = value >>> 8;
  buf[offset++] = value;
  value = value >>> 8;
  buf[offset++] = value;
  value = value >>> 8;
  buf[offset++] = value;
  return offset;
}
function writeU_Int16LE3(buf, value, offset, min4, max2) {
  value = +value;
  checkInt3(value, min4, max2, buf, offset, 1);
  buf[offset++] = value;
  buf[offset++] = value >>> 8;
  return offset;
}
function _writeUInt32BE3(buf, value, offset, min4, max2) {
  value = +value;
  checkInt3(value, min4, max2, buf, offset, 3);
  buf[offset + 3] = value;
  value = value >>> 8;
  buf[offset + 2] = value;
  value = value >>> 8;
  buf[offset + 1] = value;
  value = value >>> 8;
  buf[offset] = value;
  return offset + 4;
}
function writeU_Int48BE3(buf, value, offset, min4, max2) {
  value = +value;
  checkInt3(value, min4, max2, buf, offset, 5);
  const newVal = Math.floor(value * 2 ** -32);
  buf[offset++] = newVal >>> 8;
  buf[offset++] = newVal;
  buf[offset + 3] = value;
  value = value >>> 8;
  buf[offset + 2] = value;
  value = value >>> 8;
  buf[offset + 1] = value;
  value = value >>> 8;
  buf[offset] = value;
  return offset + 4;
}
function writeU_Int40BE3(buf, value, offset, min4, max2) {
  value = +value;
  checkInt3(value, min4, max2, buf, offset, 4);
  buf[offset++] = Math.floor(value * 2 ** -32);
  buf[offset + 3] = value;
  value = value >>> 8;
  buf[offset + 2] = value;
  value = value >>> 8;
  buf[offset + 1] = value;
  value = value >>> 8;
  buf[offset] = value;
  return offset + 4;
}
function writeU_Int32BE3(buf, value, offset, min4, max2) {
  value = +value;
  checkInt3(value, min4, max2, buf, offset, 3);
  buf[offset + 3] = value;
  value = value >>> 8;
  buf[offset + 2] = value;
  value = value >>> 8;
  buf[offset + 1] = value;
  value = value >>> 8;
  buf[offset] = value;
  return offset + 4;
}
function writeU_Int24BE3(buf, value, offset, min4, max2) {
  value = +value;
  checkInt3(value, min4, max2, buf, offset, 2);
  buf[offset + 2] = value;
  value = value >>> 8;
  buf[offset + 1] = value;
  value = value >>> 8;
  buf[offset] = value;
  return offset + 3;
}
function validateOffset3(value, name, min4 = 0, max2 = Number.MAX_SAFE_INTEGER) {
  if (typeof value !== "number") {
    throw new codes3.ERR_INVALID_ARG_TYPE(name, "number", value);
  }
  if (!Number.isInteger(value)) {
    throw new codes3.ERR_OUT_OF_RANGE(name, "an integer", value);
  }
  if (value < min4 || value > max2) {
    throw new codes3.ERR_OUT_OF_RANGE(name, `>= ${min4} && <= ${max2}`, value);
  }
}
function writeU_Int48LE3(buf, value, offset, min4, max2) {
  value = +value;
  checkInt3(value, min4, max2, buf, offset, 5);
  const newVal = Math.floor(value * 2 ** -32);
  buf[offset++] = value;
  value = value >>> 8;
  buf[offset++] = value;
  value = value >>> 8;
  buf[offset++] = value;
  value = value >>> 8;
  buf[offset++] = value;
  buf[offset++] = newVal;
  buf[offset++] = newVal >>> 8;
  return offset;
}
function writeU_Int40LE3(buf, value, offset, min4, max2) {
  value = +value;
  checkInt3(value, min4, max2, buf, offset, 4);
  const newVal = value;
  buf[offset++] = value;
  value = value >>> 8;
  buf[offset++] = value;
  value = value >>> 8;
  buf[offset++] = value;
  value = value >>> 8;
  buf[offset++] = value;
  buf[offset++] = Math.floor(newVal * 2 ** -32);
  return offset;
}
function writeU_Int32LE3(buf, value, offset, min4, max2) {
  value = +value;
  checkInt3(value, min4, max2, buf, offset, 3);
  buf[offset++] = value;
  value = value >>> 8;
  buf[offset++] = value;
  value = value >>> 8;
  buf[offset++] = value;
  value = value >>> 8;
  buf[offset++] = value;
  return offset;
}
function writeU_Int24LE3(buf, value, offset, min4, max2) {
  value = +value;
  checkInt3(value, min4, max2, buf, offset, 2);
  buf[offset++] = value;
  value = value >>> 8;
  buf[offset++] = value;
  value = value >>> 8;
  buf[offset++] = value;
  return offset;
}

// deno:https://deno.land/std@0.146.0/node/_buffer.mjs
var kMaxLength3 = 2147483647;
var MAX_UINT324 = 2 ** 32;
var customInspectSymbol8 = typeof Symbol === "function" && typeof Symbol["for"] === "function" ? Symbol["for"]("nodejs.util.inspect.custom") : null;
var INSPECT_MAX_BYTES3 = 50;
Object.defineProperty(Buffer6.prototype, "parent", {
  enumerable: true,
  get: function() {
    if (!Buffer6.isBuffer(this)) {
      return void 0;
    }
    return this.buffer;
  }
});
Object.defineProperty(Buffer6.prototype, "offset", {
  enumerable: true,
  get: function() {
    if (!Buffer6.isBuffer(this)) {
      return void 0;
    }
    return this.byteOffset;
  }
});
function createBuffer3(length) {
  if (length > kMaxLength3) {
    throw new RangeError('The value "' + length + '" is invalid for option "size"');
  }
  const buf = new Uint8Array(length);
  Object.setPrototypeOf(buf, Buffer6.prototype);
  return buf;
}
function Buffer6(arg, encodingOrOffset, length) {
  if (typeof arg === "number") {
    if (typeof encodingOrOffset === "string") {
      throw new codes3.ERR_INVALID_ARG_TYPE("string", "string", arg);
    }
    return _allocUnsafe3(arg);
  }
  return _from4(arg, encodingOrOffset, length);
}
Buffer6.poolSize = 8192;
function _from4(value, encodingOrOffset, length) {
  if (typeof value === "string") {
    return fromString3(value, encodingOrOffset);
  }
  if (typeof value === "object" && value !== null) {
    if (isAnyArrayBuffer6(value)) {
      return fromArrayBuffer3(value, encodingOrOffset, length);
    }
    const valueOf = value.valueOf && value.valueOf();
    if (valueOf != null && valueOf !== value && (typeof valueOf === "string" || typeof valueOf === "object")) {
      return _from4(valueOf, encodingOrOffset, length);
    }
    const b2 = fromObject3(value);
    if (b2) {
      return b2;
    }
    if (typeof value[Symbol.toPrimitive] === "function") {
      const primitive = value[Symbol.toPrimitive]("string");
      if (typeof primitive === "string") {
        return fromString3(primitive, encodingOrOffset);
      }
    }
  }
  throw new codes3.ERR_INVALID_ARG_TYPE("first argument", ["string", "Buffer", "ArrayBuffer", "Array", "Array-like Object"], value);
}
Buffer6.from = function from3(value, encodingOrOffset, length) {
  return _from4(value, encodingOrOffset, length);
};
Object.setPrototypeOf(Buffer6.prototype, Uint8Array.prototype);
Object.setPrototypeOf(Buffer6, Uint8Array);
function assertSize4(size) {
  validateNumber3(size, "size");
  if (!(size >= 0 && size <= kMaxLength3)) {
    throw new codes3.ERR_INVALID_ARG_VALUE.RangeError("size", size);
  }
}
function _alloc3(size, fill5, encoding) {
  assertSize4(size);
  const buffer = createBuffer3(size);
  if (fill5 !== void 0) {
    if (encoding !== void 0 && typeof encoding !== "string") {
      throw new codes3.ERR_INVALID_ARG_TYPE("encoding", "string", encoding);
    }
    return buffer.fill(fill5, encoding);
  }
  return buffer;
}
Buffer6.alloc = function alloc3(size, fill5, encoding) {
  return _alloc3(size, fill5, encoding);
};
function _allocUnsafe3(size) {
  assertSize4(size);
  return createBuffer3(size < 0 ? 0 : checked3(size) | 0);
}
Buffer6.allocUnsafe = function allocUnsafe3(size) {
  return _allocUnsafe3(size);
};
Buffer6.allocUnsafeSlow = function allocUnsafeSlow3(size) {
  return _allocUnsafe3(size);
};
function fromString3(string, encoding) {
  if (typeof encoding !== "string" || encoding === "") {
    encoding = "utf8";
  }
  if (!Buffer6.isEncoding(encoding)) {
    throw new codes3.ERR_UNKNOWN_ENCODING(encoding);
  }
  const length = byteLength4(string, encoding) | 0;
  let buf = createBuffer3(length);
  const actual = buf.write(string, encoding);
  if (actual !== length) {
    buf = buf.slice(0, actual);
  }
  return buf;
}
function fromArrayLike3(array) {
  const length = array.length < 0 ? 0 : checked3(array.length) | 0;
  const buf = createBuffer3(length);
  for (let i = 0; i < length; i += 1) {
    buf[i] = array[i] & 255;
  }
  return buf;
}
function fromObject3(obj2) {
  if (obj2.length !== void 0 || isAnyArrayBuffer6(obj2.buffer)) {
    if (typeof obj2.length !== "number") {
      return createBuffer3(0);
    }
    return fromArrayLike3(obj2);
  }
  if (obj2.type === "Buffer" && Array.isArray(obj2.data)) {
    return fromArrayLike3(obj2.data);
  }
}
function checked3(length) {
  if (length >= kMaxLength3) {
    throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + kMaxLength3.toString(16) + " bytes");
  }
  return length | 0;
}
function SlowBuffer3(length) {
  assertSize4(length);
  return Buffer6.alloc(+length);
}
Object.setPrototypeOf(SlowBuffer3.prototype, Uint8Array.prototype);
Object.setPrototypeOf(SlowBuffer3, Uint8Array);
Buffer6.isBuffer = function isBuffer4(b2) {
  return b2 != null && b2._isBuffer === true && b2 !== Buffer6.prototype;
};
Buffer6.compare = function compare6(a, b2) {
  if (isInstance3(a, Uint8Array)) {
    a = Buffer6.from(a, a.offset, a.byteLength);
  }
  if (isInstance3(b2, Uint8Array)) {
    b2 = Buffer6.from(b2, b2.offset, b2.byteLength);
  }
  if (!Buffer6.isBuffer(a) || !Buffer6.isBuffer(b2)) {
    throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');
  }
  if (a === b2) {
    return 0;
  }
  let x = a.length;
  let y4 = b2.length;
  for (let i = 0, len = Math.min(x, y4); i < len; ++i) {
    if (a[i] !== b2[i]) {
      x = a[i];
      y4 = b2[i];
      break;
    }
  }
  if (x < y4) {
    return -1;
  }
  if (y4 < x) {
    return 1;
  }
  return 0;
};
Buffer6.isEncoding = function isEncoding3(encoding) {
  return typeof encoding === "string" && encoding.length !== 0 && normalizeEncoding5(encoding) !== void 0;
};
Buffer6.concat = function concat5(list, length) {
  if (!Array.isArray(list)) {
    throw new codes3.ERR_INVALID_ARG_TYPE("list", "Array", list);
  }
  if (list.length === 0) {
    return Buffer6.alloc(0);
  }
  if (length === void 0) {
    length = 0;
    for (let i = 0; i < list.length; i++) {
      if (list[i].length) {
        length += list[i].length;
      }
    }
  } else {
    validateOffset3(length, "length");
  }
  const buffer = Buffer6.allocUnsafe(length);
  let pos = 0;
  for (let i = 0; i < list.length; i++) {
    const buf = list[i];
    if (!isUint8Array3(buf)) {
      throw new codes3.ERR_INVALID_ARG_TYPE(`list[${i}]`, ["Buffer", "Uint8Array"], list[i]);
    }
    pos += _copyActual3(buf, buffer, pos, 0, buf.length);
  }
  if (pos < length) {
    buffer.fill(0, pos, length);
  }
  return buffer;
};
function byteLength4(string, encoding) {
  if (typeof string !== "string") {
    if (isArrayBufferView3(string) || isAnyArrayBuffer6(string)) {
      return string.byteLength;
    }
    throw new codes3.ERR_INVALID_ARG_TYPE("string", ["string", "Buffer", "ArrayBuffer"], string);
  }
  const len = string.length;
  const mustMatch = arguments.length > 2 && arguments[2] === true;
  if (!mustMatch && len === 0) {
    return 0;
  }
  if (!encoding) {
    return mustMatch ? -1 : byteLengthUtf83(string);
  }
  const ops = getEncodingOps3(encoding);
  if (ops === void 0) {
    return mustMatch ? -1 : byteLengthUtf83(string);
  }
  return ops.byteLength(string);
}
Buffer6.byteLength = byteLength4;
Buffer6.prototype._isBuffer = true;
function swap3(b2, n, m3) {
  const i = b2[n];
  b2[n] = b2[m3];
  b2[m3] = i;
}
Buffer6.prototype.swap16 = function swap163() {
  const len = this.length;
  if (len % 2 !== 0) {
    throw new RangeError("Buffer size must be a multiple of 16-bits");
  }
  for (let i = 0; i < len; i += 2) {
    swap3(this, i, i + 1);
  }
  return this;
};
Buffer6.prototype.swap32 = function swap323() {
  const len = this.length;
  if (len % 4 !== 0) {
    throw new RangeError("Buffer size must be a multiple of 32-bits");
  }
  for (let i = 0; i < len; i += 4) {
    swap3(this, i, i + 3);
    swap3(this, i + 1, i + 2);
  }
  return this;
};
Buffer6.prototype.swap64 = function swap643() {
  const len = this.length;
  if (len % 8 !== 0) {
    throw new RangeError("Buffer size must be a multiple of 64-bits");
  }
  for (let i = 0; i < len; i += 8) {
    swap3(this, i, i + 7);
    swap3(this, i + 1, i + 6);
    swap3(this, i + 2, i + 5);
    swap3(this, i + 3, i + 4);
  }
  return this;
};
Buffer6.prototype.toString = function toString4(encoding, start, end) {
  if (arguments.length === 0) {
    return this.utf8Slice(0, this.length);
  }
  const len = this.length;
  if (start <= 0) {
    start = 0;
  } else if (start >= len) {
    return "";
  } else {
    start |= 0;
  }
  if (end === void 0 || end > len) {
    end = len;
  } else {
    end |= 0;
  }
  if (end <= start) {
    return "";
  }
  if (encoding === void 0) {
    return this.utf8Slice(start, end);
  }
  const ops = getEncodingOps3(encoding);
  if (ops === void 0) {
    throw new codes3.ERR_UNKNOWN_ENCODING(encoding);
  }
  return ops.slice(this, start, end);
};
Buffer6.prototype.toLocaleString = Buffer6.prototype.toString;
Buffer6.prototype.equals = function equals6(b2) {
  if (!isUint8Array3(b2)) {
    throw new codes3.ERR_INVALID_ARG_TYPE("otherBuffer", ["Buffer", "Uint8Array"], b2);
  }
  if (this === b2) {
    return true;
  }
  return Buffer6.compare(this, b2) === 0;
};
Buffer6.prototype.inspect = function inspect6() {
  let str = "";
  const max2 = INSPECT_MAX_BYTES3;
  str = this.toString("hex", 0, max2).replace(/(.{2})/g, "$1 ").trim();
  if (this.length > max2) {
    str += " ... ";
  }
  return "<Buffer " + str + ">";
};
if (customInspectSymbol8) {
  Buffer6.prototype[customInspectSymbol8] = Buffer6.prototype.inspect;
}
Buffer6.prototype.compare = function compare7(target, start, end, thisStart, thisEnd) {
  if (isInstance3(target, Uint8Array)) {
    target = Buffer6.from(target, target.offset, target.byteLength);
  }
  if (!Buffer6.isBuffer(target)) {
    throw new codes3.ERR_INVALID_ARG_TYPE("target", ["Buffer", "Uint8Array"], target);
  }
  if (start === void 0) {
    start = 0;
  } else {
    validateOffset3(start, "targetStart", 0, kMaxLength3);
  }
  if (end === void 0) {
    end = target.length;
  } else {
    validateOffset3(end, "targetEnd", 0, target.length);
  }
  if (thisStart === void 0) {
    thisStart = 0;
  } else {
    validateOffset3(start, "sourceStart", 0, kMaxLength3);
  }
  if (thisEnd === void 0) {
    thisEnd = this.length;
  } else {
    validateOffset3(end, "sourceEnd", 0, this.length);
  }
  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
    throw new codes3.ERR_OUT_OF_RANGE("out of range index", "range");
  }
  if (thisStart >= thisEnd && start >= end) {
    return 0;
  }
  if (thisStart >= thisEnd) {
    return -1;
  }
  if (start >= end) {
    return 1;
  }
  start >>>= 0;
  end >>>= 0;
  thisStart >>>= 0;
  thisEnd >>>= 0;
  if (this === target) {
    return 0;
  }
  let x = thisEnd - thisStart;
  let y4 = end - start;
  const len = Math.min(x, y4);
  const thisCopy = this.slice(thisStart, thisEnd);
  const targetCopy = target.slice(start, end);
  for (let i = 0; i < len; ++i) {
    if (thisCopy[i] !== targetCopy[i]) {
      x = thisCopy[i];
      y4 = targetCopy[i];
      break;
    }
  }
  if (x < y4) {
    return -1;
  }
  if (y4 < x) {
    return 1;
  }
  return 0;
};
function bidirectionalIndexOf3(buffer, val, byteOffset, encoding, dir) {
  validateBuffer3(buffer);
  if (typeof byteOffset === "string") {
    encoding = byteOffset;
    byteOffset = void 0;
  } else if (byteOffset > 2147483647) {
    byteOffset = 2147483647;
  } else if (byteOffset < -2147483648) {
    byteOffset = -2147483648;
  }
  byteOffset = +byteOffset;
  if (Number.isNaN(byteOffset)) {
    byteOffset = dir ? 0 : buffer.length || buffer.byteLength;
  }
  dir = !!dir;
  if (typeof val === "number") {
    return indexOfNumber3(buffer, val >>> 0, byteOffset, dir);
  }
  let ops;
  if (encoding === void 0) {
    ops = encodingOps3.utf8;
  } else {
    ops = getEncodingOps3(encoding);
  }
  if (typeof val === "string") {
    if (ops === void 0) {
      throw new codes3.ERR_UNKNOWN_ENCODING(encoding);
    }
    return ops.indexOf(buffer, val, byteOffset, dir);
  }
  if (isUint8Array3(val)) {
    const encodingVal = ops === void 0 ? encodingsMap3.utf8 : ops.encodingVal;
    return indexOfBuffer3(buffer, val, byteOffset, encodingVal, dir);
  }
  throw new codes3.ERR_INVALID_ARG_TYPE("value", ["number", "string", "Buffer", "Uint8Array"], val);
}
Buffer6.prototype.includes = function includes3(val, byteOffset, encoding) {
  return this.indexOf(val, byteOffset, encoding) !== -1;
};
Buffer6.prototype.indexOf = function indexOf3(val, byteOffset, encoding) {
  return bidirectionalIndexOf3(this, val, byteOffset, encoding, true);
};
Buffer6.prototype.lastIndexOf = function lastIndexOf3(val, byteOffset, encoding) {
  return bidirectionalIndexOf3(this, val, byteOffset, encoding, false);
};
Buffer6.prototype.asciiSlice = function asciiSlice3(offset, length) {
  if (offset === 0 && length === this.length) {
    return bytesToAscii3(this);
  } else {
    return bytesToAscii3(this.slice(offset, length));
  }
};
Buffer6.prototype.asciiWrite = function asciiWrite3(string, offset, length) {
  return blitBuffer3(asciiToBytes3(string), this, offset, length);
};
Buffer6.prototype.base64Slice = function base64Slice3(offset, length) {
  if (offset === 0 && length === this.length) {
    return encode11(this);
  } else {
    return encode11(this.slice(offset, length));
  }
};
Buffer6.prototype.base64Write = function base64Write3(string, offset, length) {
  return blitBuffer3(base64ToBytes3(string), this, offset, length);
};
Buffer6.prototype.base64urlSlice = function base64urlSlice3(offset, length) {
  if (offset === 0 && length === this.length) {
    return encode12(this);
  } else {
    return encode12(this.slice(offset, length));
  }
};
Buffer6.prototype.base64urlWrite = function base64urlWrite3(string, offset, length) {
  return blitBuffer3(base64UrlToBytes3(string), this, offset, length);
};
Buffer6.prototype.hexWrite = function hexWrite3(string, offset, length) {
  return blitBuffer3(hexToBytes3(string, this.length - offset), this, offset, length);
};
Buffer6.prototype.hexSlice = function hexSlice5(string, offset, length) {
  return _hexSlice3(this, string, offset, length);
};
Buffer6.prototype.latin1Slice = function latin1Slice3(string, offset, length) {
  return _latin1Slice3(this, string, offset, length);
};
Buffer6.prototype.latin1Write = function latin1Write3(string, offset, length) {
  return blitBuffer3(asciiToBytes3(string), this, offset, length);
};
Buffer6.prototype.ucs2Slice = function ucs2Slice3(offset, length) {
  if (offset === 0 && length === this.length) {
    return bytesToUtf16le3(this);
  } else {
    return bytesToUtf16le3(this.slice(offset, length));
  }
};
Buffer6.prototype.ucs2Write = function ucs2Write3(string, offset, length) {
  return blitBuffer3(utf16leToBytes3(string, this.length - offset), this, offset, length);
};
Buffer6.prototype.utf8Slice = function utf8Slice3(string, offset, length) {
  return _utf8Slice3(this, string, offset, length);
};
Buffer6.prototype.utf8Write = function utf8Write4(string, offset, length) {
  return blitBuffer3(utf8ToBytes3(string, this.length - offset), this, offset, length);
};
Buffer6.prototype.write = function write3(string, offset, length, encoding) {
  if (offset === void 0) {
    return this.utf8Write(string, 0, this.length);
  }
  if (length === void 0 && typeof offset === "string") {
    encoding = offset;
    length = this.length;
    offset = 0;
  } else {
    validateOffset3(offset, "offset", 0, this.length);
    const remaining = this.length - offset;
    if (length === void 0) {
      length = remaining;
    } else if (typeof length === "string") {
      encoding = length;
      length = remaining;
    } else {
      validateOffset3(length, "length", 0, this.length);
      if (length > remaining) {
        length = remaining;
      }
    }
  }
  if (!encoding) {
    return this.utf8Write(string, offset, length);
  }
  const ops = getEncodingOps3(encoding);
  if (ops === void 0) {
    throw new codes3.ERR_UNKNOWN_ENCODING(encoding);
  }
  return ops.write(this, string, offset, length);
};
Buffer6.prototype.toJSON = function toJSON4() {
  return {
    type: "Buffer",
    data: Array.prototype.slice.call(this._arr || this, 0)
  };
};
function fromArrayBuffer3(obj2, byteOffset, length) {
  if (byteOffset === void 0) {
    byteOffset = 0;
  } else {
    byteOffset = +byteOffset;
    if (Number.isNaN(byteOffset)) {
      byteOffset = 0;
    }
  }
  const maxLength = obj2.byteLength - byteOffset;
  if (maxLength < 0) {
    throw new codes3.ERR_BUFFER_OUT_OF_BOUNDS("offset");
  }
  if (length === void 0) {
    length = maxLength;
  } else {
    length = +length;
    if (length > 0) {
      if (length > maxLength) {
        throw new codes3.ERR_BUFFER_OUT_OF_BOUNDS("length");
      }
    } else {
      length = 0;
    }
  }
  const buffer = new Uint8Array(obj2, byteOffset, length);
  Object.setPrototypeOf(buffer, Buffer6.prototype);
  return buffer;
}
function _utf8Slice3(buf, start, end) {
  end = Math.min(buf.length, end);
  const res = [];
  let i = start;
  while (i < end) {
    const firstByte = buf[i];
    let codePoint = null;
    let bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;
    if (i + bytesPerSequence <= end) {
      let secondByte, thirdByte, fourthByte, tempCodePoint;
      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 128) {
            codePoint = firstByte;
          }
          break;
        case 2:
          secondByte = buf[i + 1];
          if ((secondByte & 192) === 128) {
            tempCodePoint = (firstByte & 31) << 6 | secondByte & 63;
            if (tempCodePoint > 127) {
              codePoint = tempCodePoint;
            }
          }
          break;
        case 3:
          secondByte = buf[i + 1];
          thirdByte = buf[i + 2];
          if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {
            tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63;
            if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) {
              codePoint = tempCodePoint;
            }
          }
          break;
        case 4:
          secondByte = buf[i + 1];
          thirdByte = buf[i + 2];
          fourthByte = buf[i + 3];
          if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {
            tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63;
            if (tempCodePoint > 65535 && tempCodePoint < 1114112) {
              codePoint = tempCodePoint;
            }
          }
      }
    }
    if (codePoint === null) {
      codePoint = 65533;
      bytesPerSequence = 1;
    } else if (codePoint > 65535) {
      codePoint -= 65536;
      res.push(codePoint >>> 10 & 1023 | 55296);
      codePoint = 56320 | codePoint & 1023;
    }
    res.push(codePoint);
    i += bytesPerSequence;
  }
  return decodeCodePointsArray3(res);
}
var MAX_ARGUMENTS_LENGTH3 = 4096;
function decodeCodePointsArray3(codePoints) {
  const len = codePoints.length;
  if (len <= MAX_ARGUMENTS_LENGTH3) {
    return String.fromCharCode.apply(String, codePoints);
  }
  let res = "";
  let i = 0;
  while (i < len) {
    res += String.fromCharCode.apply(String, codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH3));
  }
  return res;
}
function _latin1Slice3(buf, start, end) {
  let ret = "";
  end = Math.min(buf.length, end);
  for (let i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i]);
  }
  return ret;
}
function _hexSlice3(buf, start, end) {
  const len = buf.length;
  if (!start || start < 0) {
    start = 0;
  }
  if (!end || end < 0 || end > len) {
    end = len;
  }
  let out = "";
  for (let i = start; i < end; ++i) {
    out += hexSliceLookupTable3[buf[i]];
  }
  return out;
}
Buffer6.prototype.slice = function slice3(start, end) {
  const len = this.length;
  start = ~~start;
  end = end === void 0 ? len : ~~end;
  if (start < 0) {
    start += len;
    if (start < 0) {
      start = 0;
    }
  } else if (start > len) {
    start = len;
  }
  if (end < 0) {
    end += len;
    if (end < 0) {
      end = 0;
    }
  } else if (end > len) {
    end = len;
  }
  if (end < start) {
    end = start;
  }
  const newBuf = this.subarray(start, end);
  Object.setPrototypeOf(newBuf, Buffer6.prototype);
  return newBuf;
};
Buffer6.prototype.readUintLE = Buffer6.prototype.readUIntLE = function readUIntLE3(offset, byteLength6) {
  if (offset === void 0) {
    throw new codes3.ERR_INVALID_ARG_TYPE("offset", "number", offset);
  }
  if (byteLength6 === 6) {
    return readUInt48LE3(this, offset);
  }
  if (byteLength6 === 5) {
    return readUInt40LE3(this, offset);
  }
  if (byteLength6 === 3) {
    return readUInt24LE3(this, offset);
  }
  if (byteLength6 === 4) {
    return this.readUInt32LE(offset);
  }
  if (byteLength6 === 2) {
    return this.readUInt16LE(offset);
  }
  if (byteLength6 === 1) {
    return this.readUInt8(offset);
  }
  boundsError3(byteLength6, 6, "byteLength");
};
Buffer6.prototype.readUintBE = Buffer6.prototype.readUIntBE = function readUIntBE3(offset, byteLength6) {
  if (offset === void 0) {
    throw new codes3.ERR_INVALID_ARG_TYPE("offset", "number", offset);
  }
  if (byteLength6 === 6) {
    return readUInt48BE3(this, offset);
  }
  if (byteLength6 === 5) {
    return readUInt40BE3(this, offset);
  }
  if (byteLength6 === 3) {
    return readUInt24BE3(this, offset);
  }
  if (byteLength6 === 4) {
    return this.readUInt32BE(offset);
  }
  if (byteLength6 === 2) {
    return this.readUInt16BE(offset);
  }
  if (byteLength6 === 1) {
    return this.readUInt8(offset);
  }
  boundsError3(byteLength6, 6, "byteLength");
};
Buffer6.prototype.readUint8 = Buffer6.prototype.readUInt8 = function readUInt84(offset = 0) {
  validateNumber3(offset, "offset");
  const val = this[offset];
  if (val === void 0) {
    boundsError3(offset, this.length - 1);
  }
  return val;
};
Buffer6.prototype.readUint16BE = Buffer6.prototype.readUInt16BE = readUInt16BE3;
Buffer6.prototype.readUint16LE = Buffer6.prototype.readUInt16LE = function readUInt16LE3(offset = 0) {
  validateNumber3(offset, "offset");
  const first = this[offset];
  const last = this[offset + 1];
  if (first === void 0 || last === void 0) {
    boundsError3(offset, this.length - 2);
  }
  return first + last * 2 ** 8;
};
Buffer6.prototype.readUint32LE = Buffer6.prototype.readUInt32LE = function readUInt32LE3(offset = 0) {
  validateNumber3(offset, "offset");
  const first = this[offset];
  const last = this[offset + 3];
  if (first === void 0 || last === void 0) {
    boundsError3(offset, this.length - 4);
  }
  return first + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + last * 2 ** 24;
};
Buffer6.prototype.readUint32BE = Buffer6.prototype.readUInt32BE = readUInt32BE3;
Buffer6.prototype.readBigUint64LE = Buffer6.prototype.readBigUInt64LE = defineBigIntMethod3(function readBigUInt64LE3(offset) {
  offset = offset >>> 0;
  validateNumber3(offset, "offset");
  const first = this[offset];
  const last = this[offset + 7];
  if (first === void 0 || last === void 0) {
    boundsError3(offset, this.length - 8);
  }
  const lo3 = first + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 24;
  const hi2 = this[++offset] + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + last * 2 ** 24;
  return BigInt(lo3) + (BigInt(hi2) << BigInt(32));
});
Buffer6.prototype.readBigUint64BE = Buffer6.prototype.readBigUInt64BE = defineBigIntMethod3(function readBigUInt64BE3(offset) {
  offset = offset >>> 0;
  validateNumber3(offset, "offset");
  const first = this[offset];
  const last = this[offset + 7];
  if (first === void 0 || last === void 0) {
    boundsError3(offset, this.length - 8);
  }
  const hi2 = first * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + this[++offset];
  const lo3 = this[++offset] * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + last;
  return (BigInt(hi2) << BigInt(32)) + BigInt(lo3);
});
Buffer6.prototype.readIntLE = function readIntLE3(offset, byteLength6) {
  if (offset === void 0) {
    throw new codes3.ERR_INVALID_ARG_TYPE("offset", "number", offset);
  }
  if (byteLength6 === 6) {
    return readInt48LE3(this, offset);
  }
  if (byteLength6 === 5) {
    return readInt40LE3(this, offset);
  }
  if (byteLength6 === 3) {
    return readInt24LE3(this, offset);
  }
  if (byteLength6 === 4) {
    return this.readInt32LE(offset);
  }
  if (byteLength6 === 2) {
    return this.readInt16LE(offset);
  }
  if (byteLength6 === 1) {
    return this.readInt8(offset);
  }
  boundsError3(byteLength6, 6, "byteLength");
};
Buffer6.prototype.readIntBE = function readIntBE3(offset, byteLength6) {
  if (offset === void 0) {
    throw new codes3.ERR_INVALID_ARG_TYPE("offset", "number", offset);
  }
  if (byteLength6 === 6) {
    return readInt48BE3(this, offset);
  }
  if (byteLength6 === 5) {
    return readInt40BE3(this, offset);
  }
  if (byteLength6 === 3) {
    return readInt24BE3(this, offset);
  }
  if (byteLength6 === 4) {
    return this.readInt32BE(offset);
  }
  if (byteLength6 === 2) {
    return this.readInt16BE(offset);
  }
  if (byteLength6 === 1) {
    return this.readInt8(offset);
  }
  boundsError3(byteLength6, 6, "byteLength");
};
Buffer6.prototype.readInt8 = function readInt83(offset = 0) {
  validateNumber3(offset, "offset");
  const val = this[offset];
  if (val === void 0) {
    boundsError3(offset, this.length - 1);
  }
  return val | (val & 2 ** 7) * 33554430;
};
Buffer6.prototype.readInt16LE = function readInt16LE3(offset = 0) {
  validateNumber3(offset, "offset");
  const first = this[offset];
  const last = this[offset + 1];
  if (first === void 0 || last === void 0) {
    boundsError3(offset, this.length - 2);
  }
  const val = first + last * 2 ** 8;
  return val | (val & 2 ** 15) * 131070;
};
Buffer6.prototype.readInt16BE = function readInt16BE3(offset = 0) {
  validateNumber3(offset, "offset");
  const first = this[offset];
  const last = this[offset + 1];
  if (first === void 0 || last === void 0) {
    boundsError3(offset, this.length - 2);
  }
  const val = first * 2 ** 8 + last;
  return val | (val & 2 ** 15) * 131070;
};
Buffer6.prototype.readInt32LE = function readInt32LE3(offset = 0) {
  validateNumber3(offset, "offset");
  const first = this[offset];
  const last = this[offset + 3];
  if (first === void 0 || last === void 0) {
    boundsError3(offset, this.length - 4);
  }
  return first + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + (last << 24);
};
Buffer6.prototype.readInt32BE = function readInt32BE3(offset = 0) {
  validateNumber3(offset, "offset");
  const first = this[offset];
  const last = this[offset + 3];
  if (first === void 0 || last === void 0) {
    boundsError3(offset, this.length - 4);
  }
  return (first << 24) + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + last;
};
Buffer6.prototype.readBigInt64LE = defineBigIntMethod3(function readBigInt64LE3(offset) {
  offset = offset >>> 0;
  validateNumber3(offset, "offset");
  const first = this[offset];
  const last = this[offset + 7];
  if (first === void 0 || last === void 0) {
    boundsError3(offset, this.length - 8);
  }
  const val = this[offset + 4] + this[offset + 5] * 2 ** 8 + this[offset + 6] * 2 ** 16 + (last << 24);
  return (BigInt(val) << BigInt(32)) + BigInt(first + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 24);
});
Buffer6.prototype.readBigInt64BE = defineBigIntMethod3(function readBigInt64BE3(offset) {
  offset = offset >>> 0;
  validateNumber3(offset, "offset");
  const first = this[offset];
  const last = this[offset + 7];
  if (first === void 0 || last === void 0) {
    boundsError3(offset, this.length - 8);
  }
  const val = (first << 24) + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + this[++offset];
  return (BigInt(val) << BigInt(32)) + BigInt(this[++offset] * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + last);
});
Buffer6.prototype.readFloatLE = function readFloatLE3(offset) {
  return bigEndian3 ? readFloatBackwards3(this, offset) : readFloatForwards3(this, offset);
};
Buffer6.prototype.readFloatBE = function readFloatBE3(offset) {
  return bigEndian3 ? readFloatForwards3(this, offset) : readFloatBackwards3(this, offset);
};
Buffer6.prototype.readDoubleLE = function readDoubleLE3(offset) {
  return bigEndian3 ? readDoubleBackwards3(this, offset) : readDoubleForwards3(this, offset);
};
Buffer6.prototype.readDoubleBE = function readDoubleBE3(offset) {
  return bigEndian3 ? readDoubleForwards3(this, offset) : readDoubleBackwards3(this, offset);
};
Buffer6.prototype.writeUintLE = Buffer6.prototype.writeUIntLE = function writeUIntLE3(value, offset, byteLength6) {
  if (byteLength6 === 6) {
    return writeU_Int48LE3(this, value, offset, 0, 281474976710655);
  }
  if (byteLength6 === 5) {
    return writeU_Int40LE3(this, value, offset, 0, 1099511627775);
  }
  if (byteLength6 === 3) {
    return writeU_Int24LE3(this, value, offset, 0, 16777215);
  }
  if (byteLength6 === 4) {
    return writeU_Int32LE3(this, value, offset, 0, 4294967295);
  }
  if (byteLength6 === 2) {
    return writeU_Int16LE3(this, value, offset, 0, 65535);
  }
  if (byteLength6 === 1) {
    return writeU_Int83(this, value, offset, 0, 255);
  }
  boundsError3(byteLength6, 6, "byteLength");
};
Buffer6.prototype.writeUintBE = Buffer6.prototype.writeUIntBE = function writeUIntBE3(value, offset, byteLength6) {
  if (byteLength6 === 6) {
    return writeU_Int48BE3(this, value, offset, 0, 281474976710655);
  }
  if (byteLength6 === 5) {
    return writeU_Int40BE3(this, value, offset, 0, 1099511627775);
  }
  if (byteLength6 === 3) {
    return writeU_Int24BE3(this, value, offset, 0, 16777215);
  }
  if (byteLength6 === 4) {
    return writeU_Int32BE3(this, value, offset, 0, 4294967295);
  }
  if (byteLength6 === 2) {
    return writeU_Int16BE3(this, value, offset, 0, 65535);
  }
  if (byteLength6 === 1) {
    return writeU_Int83(this, value, offset, 0, 255);
  }
  boundsError3(byteLength6, 6, "byteLength");
};
Buffer6.prototype.writeUint8 = Buffer6.prototype.writeUInt8 = function writeUInt83(value, offset = 0) {
  return writeU_Int83(this, value, offset, 0, 255);
};
Buffer6.prototype.writeUint16LE = Buffer6.prototype.writeUInt16LE = function writeUInt16LE3(value, offset = 0) {
  return writeU_Int16LE3(this, value, offset, 0, 65535);
};
Buffer6.prototype.writeUint16BE = Buffer6.prototype.writeUInt16BE = function writeUInt16BE3(value, offset = 0) {
  return writeU_Int16BE3(this, value, offset, 0, 65535);
};
Buffer6.prototype.writeUint32LE = Buffer6.prototype.writeUInt32LE = function writeUInt32LE3(value, offset = 0) {
  return _writeUInt32LE3(this, value, offset, 0, 4294967295);
};
Buffer6.prototype.writeUint32BE = Buffer6.prototype.writeUInt32BE = function writeUInt32BE3(value, offset = 0) {
  return _writeUInt32BE3(this, value, offset, 0, 4294967295);
};
function wrtBigUInt64LE3(buf, value, offset, min4, max2) {
  checkIntBI3(value, min4, max2, buf, offset, 7);
  let lo3 = Number(value & BigInt(4294967295));
  buf[offset++] = lo3;
  lo3 = lo3 >> 8;
  buf[offset++] = lo3;
  lo3 = lo3 >> 8;
  buf[offset++] = lo3;
  lo3 = lo3 >> 8;
  buf[offset++] = lo3;
  let hi2 = Number(value >> BigInt(32) & BigInt(4294967295));
  buf[offset++] = hi2;
  hi2 = hi2 >> 8;
  buf[offset++] = hi2;
  hi2 = hi2 >> 8;
  buf[offset++] = hi2;
  hi2 = hi2 >> 8;
  buf[offset++] = hi2;
  return offset;
}
function wrtBigUInt64BE3(buf, value, offset, min4, max2) {
  checkIntBI3(value, min4, max2, buf, offset, 7);
  let lo3 = Number(value & BigInt(4294967295));
  buf[offset + 7] = lo3;
  lo3 = lo3 >> 8;
  buf[offset + 6] = lo3;
  lo3 = lo3 >> 8;
  buf[offset + 5] = lo3;
  lo3 = lo3 >> 8;
  buf[offset + 4] = lo3;
  let hi2 = Number(value >> BigInt(32) & BigInt(4294967295));
  buf[offset + 3] = hi2;
  hi2 = hi2 >> 8;
  buf[offset + 2] = hi2;
  hi2 = hi2 >> 8;
  buf[offset + 1] = hi2;
  hi2 = hi2 >> 8;
  buf[offset] = hi2;
  return offset + 8;
}
Buffer6.prototype.writeBigUint64LE = Buffer6.prototype.writeBigUInt64LE = defineBigIntMethod3(function writeBigUInt64LE3(value, offset = 0) {
  return wrtBigUInt64LE3(this, value, offset, BigInt(0), BigInt("0xffffffffffffffff"));
});
Buffer6.prototype.writeBigUint64BE = Buffer6.prototype.writeBigUInt64BE = defineBigIntMethod3(function writeBigUInt64BE3(value, offset = 0) {
  return wrtBigUInt64BE3(this, value, offset, BigInt(0), BigInt("0xffffffffffffffff"));
});
Buffer6.prototype.writeIntLE = function writeIntLE3(value, offset, byteLength6) {
  if (byteLength6 === 6) {
    return writeU_Int48LE3(this, value, offset, -140737488355328, 140737488355327);
  }
  if (byteLength6 === 5) {
    return writeU_Int40LE3(this, value, offset, -549755813888, 549755813887);
  }
  if (byteLength6 === 3) {
    return writeU_Int24LE3(this, value, offset, -8388608, 8388607);
  }
  if (byteLength6 === 4) {
    return writeU_Int32LE3(this, value, offset, -2147483648, 2147483647);
  }
  if (byteLength6 === 2) {
    return writeU_Int16LE3(this, value, offset, -32768, 32767);
  }
  if (byteLength6 === 1) {
    return writeU_Int83(this, value, offset, -128, 127);
  }
  boundsError3(byteLength6, 6, "byteLength");
};
Buffer6.prototype.writeIntBE = function writeIntBE3(value, offset, byteLength6) {
  if (byteLength6 === 6) {
    return writeU_Int48BE3(this, value, offset, -140737488355328, 140737488355327);
  }
  if (byteLength6 === 5) {
    return writeU_Int40BE3(this, value, offset, -549755813888, 549755813887);
  }
  if (byteLength6 === 3) {
    return writeU_Int24BE3(this, value, offset, -8388608, 8388607);
  }
  if (byteLength6 === 4) {
    return writeU_Int32BE3(this, value, offset, -2147483648, 2147483647);
  }
  if (byteLength6 === 2) {
    return writeU_Int16BE3(this, value, offset, -32768, 32767);
  }
  if (byteLength6 === 1) {
    return writeU_Int83(this, value, offset, -128, 127);
  }
  boundsError3(byteLength6, 6, "byteLength");
};
Buffer6.prototype.writeInt8 = function writeInt83(value, offset = 0) {
  return writeU_Int83(this, value, offset, -128, 127);
};
Buffer6.prototype.writeInt16LE = function writeInt16LE3(value, offset = 0) {
  return writeU_Int16LE3(this, value, offset, -32768, 32767);
};
Buffer6.prototype.writeInt16BE = function writeInt16BE3(value, offset = 0) {
  return writeU_Int16BE3(this, value, offset, -32768, 32767);
};
Buffer6.prototype.writeInt32LE = function writeInt32LE3(value, offset = 0) {
  return writeU_Int32LE3(this, value, offset, -2147483648, 2147483647);
};
Buffer6.prototype.writeInt32BE = function writeInt32BE3(value, offset = 0) {
  return writeU_Int32BE3(this, value, offset, -2147483648, 2147483647);
};
Buffer6.prototype.writeBigInt64LE = defineBigIntMethod3(function writeBigInt64LE3(value, offset = 0) {
  return wrtBigUInt64LE3(this, value, offset, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
});
Buffer6.prototype.writeBigInt64BE = defineBigIntMethod3(function writeBigInt64BE3(value, offset = 0) {
  return wrtBigUInt64BE3(this, value, offset, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
});
Buffer6.prototype.writeFloatLE = function writeFloatLE3(value, offset) {
  return bigEndian3 ? writeFloatBackwards3(this, value, offset) : writeFloatForwards3(this, value, offset);
};
Buffer6.prototype.writeFloatBE = function writeFloatBE3(value, offset) {
  return bigEndian3 ? writeFloatForwards3(this, value, offset) : writeFloatBackwards3(this, value, offset);
};
Buffer6.prototype.writeDoubleLE = function writeDoubleLE3(value, offset) {
  return bigEndian3 ? writeDoubleBackwards3(this, value, offset) : writeDoubleForwards3(this, value, offset);
};
Buffer6.prototype.writeDoubleBE = function writeDoubleBE3(value, offset) {
  return bigEndian3 ? writeDoubleForwards3(this, value, offset) : writeDoubleBackwards3(this, value, offset);
};
Buffer6.prototype.copy = function copy6(target, targetStart, sourceStart, sourceEnd) {
  if (!isUint8Array3(this)) {
    throw new codes3.ERR_INVALID_ARG_TYPE("source", ["Buffer", "Uint8Array"], this);
  }
  if (!isUint8Array3(target)) {
    throw new codes3.ERR_INVALID_ARG_TYPE("target", ["Buffer", "Uint8Array"], target);
  }
  if (targetStart === void 0) {
    targetStart = 0;
  } else {
    targetStart = toInteger3(targetStart, 0);
    if (targetStart < 0) {
      throw new codes3.ERR_OUT_OF_RANGE("targetStart", ">= 0", targetStart);
    }
  }
  if (sourceStart === void 0) {
    sourceStart = 0;
  } else {
    sourceStart = toInteger3(sourceStart, 0);
    if (sourceStart < 0) {
      throw new codes3.ERR_OUT_OF_RANGE("sourceStart", ">= 0", sourceStart);
    }
    if (sourceStart >= MAX_UINT324) {
      throw new codes3.ERR_OUT_OF_RANGE("sourceStart", `< ${MAX_UINT324}`, sourceStart);
    }
  }
  if (sourceEnd === void 0) {
    sourceEnd = this.length;
  } else {
    sourceEnd = toInteger3(sourceEnd, 0);
    if (sourceEnd < 0) {
      throw new codes3.ERR_OUT_OF_RANGE("sourceEnd", ">= 0", sourceEnd);
    }
    if (sourceEnd >= MAX_UINT324) {
      throw new codes3.ERR_OUT_OF_RANGE("sourceEnd", `< ${MAX_UINT324}`, sourceEnd);
    }
  }
  if (targetStart >= target.length) {
    return 0;
  }
  if (sourceEnd > 0 && sourceEnd < sourceStart) {
    sourceEnd = sourceStart;
  }
  if (sourceEnd === sourceStart) {
    return 0;
  }
  if (target.length === 0 || this.length === 0) {
    return 0;
  }
  if (sourceEnd > this.length) {
    sourceEnd = this.length;
  }
  if (target.length - targetStart < sourceEnd - sourceStart) {
    sourceEnd = target.length - targetStart + sourceStart;
  }
  const len = sourceEnd - sourceStart;
  if (this === target && typeof Uint8Array.prototype.copyWithin === "function") {
    this.copyWithin(targetStart, sourceStart, sourceEnd);
  } else {
    Uint8Array.prototype.set.call(target, this.subarray(sourceStart, sourceEnd), targetStart);
  }
  return len;
};
Buffer6.prototype.fill = function fill3(val, start, end, encoding) {
  if (typeof val === "string") {
    if (typeof start === "string") {
      encoding = start;
      start = 0;
      end = this.length;
    } else if (typeof end === "string") {
      encoding = end;
      end = this.length;
    }
    if (encoding !== void 0 && typeof encoding !== "string") {
      throw new TypeError("encoding must be a string");
    }
    if (typeof encoding === "string" && !Buffer6.isEncoding(encoding)) {
      throw new TypeError("Unknown encoding: " + encoding);
    }
    if (val.length === 1) {
      const code2 = val.charCodeAt(0);
      if (encoding === "utf8" && code2 < 128 || encoding === "latin1") {
        val = code2;
      }
    }
  } else if (typeof val === "number") {
    val = val & 255;
  } else if (typeof val === "boolean") {
    val = Number(val);
  }
  if (start < 0 || this.length < start || this.length < end) {
    throw new RangeError("Out of range index");
  }
  if (end <= start) {
    return this;
  }
  start = start >>> 0;
  end = end === void 0 ? this.length : end >>> 0;
  if (!val) {
    val = 0;
  }
  let i;
  if (typeof val === "number") {
    for (i = start; i < end; ++i) {
      this[i] = val;
    }
  } else {
    const bytes = Buffer6.isBuffer(val) ? val : Buffer6.from(val, encoding);
    const len = bytes.length;
    if (len === 0) {
      throw new codes3.ERR_INVALID_ARG_VALUE("value", val);
    }
    for (i = 0; i < end - start; ++i) {
      this[i + start] = bytes[i % len];
    }
  }
  return this;
};
function checkBounds6(buf, offset, byteLength22) {
  validateNumber3(offset, "offset");
  if (buf[offset] === void 0 || buf[offset + byteLength22] === void 0) {
    boundsError3(offset, buf.length - (byteLength22 + 1));
  }
}
function checkIntBI3(value, min4, max2, buf, offset, byteLength22) {
  if (value > max2 || value < min4) {
    const n = typeof min4 === "bigint" ? "n" : "";
    let range;
    if (byteLength22 > 3) {
      if (min4 === 0 || min4 === BigInt(0)) {
        range = `>= 0${n} and < 2${n} ** ${(byteLength22 + 1) * 8}${n}`;
      } else {
        range = `>= -(2${n} ** ${(byteLength22 + 1) * 8 - 1}${n}) and < 2 ** ${(byteLength22 + 1) * 8 - 1}${n}`;
      }
    } else {
      range = `>= ${min4}${n} and <= ${max2}${n}`;
    }
    throw new codes3.ERR_OUT_OF_RANGE("value", range, value);
  }
  checkBounds6(buf, offset, byteLength22);
}
function utf8ToBytes3(string, units) {
  units = units || Infinity;
  let codePoint;
  const length = string.length;
  let leadSurrogate = null;
  const bytes = [];
  for (let i = 0; i < length; ++i) {
    codePoint = string.charCodeAt(i);
    if (codePoint > 55295 && codePoint < 57344) {
      if (!leadSurrogate) {
        if (codePoint > 56319) {
          if ((units -= 3) > -1) {
            bytes.push(239, 191, 189);
          }
          continue;
        } else if (i + 1 === length) {
          if ((units -= 3) > -1) {
            bytes.push(239, 191, 189);
          }
          continue;
        }
        leadSurrogate = codePoint;
        continue;
      }
      if (codePoint < 56320) {
        if ((units -= 3) > -1) {
          bytes.push(239, 191, 189);
        }
        leadSurrogate = codePoint;
        continue;
      }
      codePoint = (leadSurrogate - 55296 << 10 | codePoint - 56320) + 65536;
    } else if (leadSurrogate) {
      if ((units -= 3) > -1) {
        bytes.push(239, 191, 189);
      }
    }
    leadSurrogate = null;
    if (codePoint < 128) {
      if ((units -= 1) < 0) {
        break;
      }
      bytes.push(codePoint);
    } else if (codePoint < 2048) {
      if ((units -= 2) < 0) {
        break;
      }
      bytes.push(codePoint >> 6 | 192, codePoint & 63 | 128);
    } else if (codePoint < 65536) {
      if ((units -= 3) < 0) {
        break;
      }
      bytes.push(codePoint >> 12 | 224, codePoint >> 6 & 63 | 128, codePoint & 63 | 128);
    } else if (codePoint < 1114112) {
      if ((units -= 4) < 0) {
        break;
      }
      bytes.push(codePoint >> 18 | 240, codePoint >> 12 & 63 | 128, codePoint >> 6 & 63 | 128, codePoint & 63 | 128);
    } else {
      throw new Error("Invalid code point");
    }
  }
  return bytes;
}
function blitBuffer3(src, dst, offset, byteLength6) {
  let i;
  const length = byteLength6 === void 0 ? src.length : byteLength6;
  for (i = 0; i < length; ++i) {
    if (i + offset >= dst.length || i >= src.length) {
      break;
    }
    dst[i + offset] = src[i];
  }
  return i;
}
function isInstance3(obj2, type) {
  return obj2 instanceof type || obj2 != null && obj2.constructor != null && obj2.constructor.name != null && obj2.constructor.name === type.name;
}
var hexSliceLookupTable3 = function() {
  const alphabet = "0123456789abcdef";
  const table = new Array(256);
  for (let i = 0; i < 16; ++i) {
    const i16 = i * 16;
    for (let j2 = 0; j2 < 16; ++j2) {
      table[i16 + j2] = alphabet[i] + alphabet[j2];
    }
  }
  return table;
}();
function defineBigIntMethod3(fn) {
  return typeof BigInt === "undefined" ? BufferBigIntNotDefined3 : fn;
}
function BufferBigIntNotDefined3() {
  throw new Error("BigInt not supported");
}
var atob4 = globalThis.atob;
var Blob4 = globalThis.Blob;
var btoa3 = globalThis.btoa;

// deno:https://deno.land/std@0.146.0/node/internal/util/comparisons.ts
var memo2;
function isDeepStrictEqual2(val1, val2) {
  return innerDeepEqual2(val1, val2, true);
}
function innerDeepEqual2(val1, val2, strict, memos = memo2) {
  if (val1 === val2) {
    if (val1 !== 0)
      return true;
    return strict ? Object.is(val1, val2) : true;
  }
  if (strict) {
    if (typeof val1 !== "object") {
      return typeof val1 === "number" && Number.isNaN(val1) && Number.isNaN(val2);
    }
    if (typeof val2 !== "object" || val1 === null || val2 === null) {
      return false;
    }
    if (Object.getPrototypeOf(val1) !== Object.getPrototypeOf(val2)) {
      return false;
    }
  } else {
    if (val1 === null || typeof val1 !== "object") {
      if (val2 === null || typeof val2 !== "object") {
        return val1 == val2 || Number.isNaN(val1) && Number.isNaN(val2);
      }
      return false;
    }
    if (val2 === null || typeof val2 !== "object") {
      return false;
    }
  }
  const val1Tag = Object.prototype.toString.call(val1);
  const val2Tag = Object.prototype.toString.call(val2);
  if (val1Tag !== val2Tag) {
    return false;
  }
  if (Array.isArray(val1)) {
    if (!Array.isArray(val2) || val1.length !== val2.length) {
      return false;
    }
    const filter = strict ? ONLY_ENUMERABLE2 : ONLY_ENUMERABLE2 | SKIP_SYMBOLS2;
    const keys1 = getOwnNonIndexProperties2(val1, filter);
    const keys2 = getOwnNonIndexProperties2(val2, filter);
    if (keys1.length !== keys2.length) {
      return false;
    }
    return keyCheck2(val1, val2, strict, memos, 1 /* isArray */, keys1);
  } else if (val1Tag === "[object Object]") {
    return keyCheck2(val1, val2, strict, memos, 0 /* noIterator */);
  } else if (val1 instanceof Date) {
    if (!(val2 instanceof Date) || val1.getTime() !== val2.getTime()) {
      return false;
    }
  } else if (val1 instanceof RegExp) {
    if (!(val2 instanceof RegExp) || !areSimilarRegExps2(val1, val2)) {
      return false;
    }
  } else if (isNativeError6(val1) || val1 instanceof Error) {
    if (!isNativeError6(val2) && !(val2 instanceof Error) || val1.message !== val2.message || val1.name !== val2.name) {
      return false;
    }
  } else if (isArrayBufferView3(val1)) {
    const TypedArrayPrototypeGetSymbolToStringTag = (val) => Object.getOwnPropertySymbols(val).map((item) => item.toString()).toString();
    if (isTypedArray2(val1) && isTypedArray2(val2) && TypedArrayPrototypeGetSymbolToStringTag(val1) !== TypedArrayPrototypeGetSymbolToStringTag(val2)) {
      return false;
    }
    if (!strict && (isFloat32Array2(val1) || isFloat64Array2(val1))) {
      if (!areSimilarFloatArrays2(val1, val2)) {
        return false;
      }
    } else if (!areSimilarTypedArrays2(val1, val2)) {
      return false;
    }
    const filter = strict ? ONLY_ENUMERABLE2 : ONLY_ENUMERABLE2 | SKIP_SYMBOLS2;
    const keysVal1 = getOwnNonIndexProperties2(val1, filter);
    const keysVal2 = getOwnNonIndexProperties2(val2, filter);
    if (keysVal1.length !== keysVal2.length) {
      return false;
    }
    return keyCheck2(val1, val2, strict, memos, 0 /* noIterator */, keysVal1);
  } else if (isSet6(val1)) {
    if (!isSet6(val2) || val1.size !== val2.size) {
      return false;
    }
    return keyCheck2(val1, val2, strict, memos, 2 /* isSet */);
  } else if (isMap6(val1)) {
    if (!isMap6(val2) || val1.size !== val2.size) {
      return false;
    }
    return keyCheck2(val1, val2, strict, memos, 3 /* isMap */);
  } else if (isAnyArrayBuffer6(val1)) {
    if (!isAnyArrayBuffer6(val2) || !areEqualArrayBuffers2(val1, val2)) {
      return false;
    }
  } else if (isBoxedPrimitive6(val1)) {
    if (!isEqualBoxedPrimitive2(val1, val2)) {
      return false;
    }
  } else if (Array.isArray(val2) || isArrayBufferView3(val2) || isSet6(val2) || isMap6(val2) || isDate7(val2) || isRegExp7(val2) || isAnyArrayBuffer6(val2) || isBoxedPrimitive6(val2) || isNativeError6(val2) || val2 instanceof Error) {
    return false;
  }
  return keyCheck2(val1, val2, strict, memos, 0 /* noIterator */);
}
function keyCheck2(val1, val2, strict, memos, iterationType, aKeys = []) {
  if (arguments.length === 5) {
    aKeys = Object.keys(val1);
    const bKeys = Object.keys(val2);
    if (aKeys.length !== bKeys.length) {
      return false;
    }
  }
  let i = 0;
  for (; i < aKeys.length; i++) {
    if (!val2.propertyIsEnumerable(aKeys[i])) {
      return false;
    }
  }
  if (strict && arguments.length === 5) {
    const symbolKeysA = Object.getOwnPropertySymbols(val1);
    if (symbolKeysA.length !== 0) {
      let count = 0;
      for (i = 0; i < symbolKeysA.length; i++) {
        const key2 = symbolKeysA[i];
        if (val1.propertyIsEnumerable(key2)) {
          if (!val2.propertyIsEnumerable(key2)) {
            return false;
          }
          aKeys.push(key2.toString());
          count++;
        } else if (val2.propertyIsEnumerable(key2)) {
          return false;
        }
      }
      const symbolKeysB = Object.getOwnPropertySymbols(val2);
      if (symbolKeysA.length !== symbolKeysB.length && getEnumerables2(val2, symbolKeysB).length !== count) {
        return false;
      }
    } else {
      const symbolKeysB = Object.getOwnPropertySymbols(val2);
      if (symbolKeysB.length !== 0 && getEnumerables2(val2, symbolKeysB).length !== 0) {
        return false;
      }
    }
  }
  if (aKeys.length === 0 && (iterationType === 0 /* noIterator */ || iterationType === 1 /* isArray */ && val1.length === 0 || val1.size === 0)) {
    return true;
  }
  if (memos === void 0) {
    memos = {
      val1: /* @__PURE__ */ new Map(),
      val2: /* @__PURE__ */ new Map(),
      position: 0
    };
  } else {
    const val2MemoA = memos.val1.get(val1);
    if (val2MemoA !== void 0) {
      const val2MemoB = memos.val2.get(val2);
      if (val2MemoB !== void 0) {
        return val2MemoA === val2MemoB;
      }
    }
    memos.position++;
  }
  memos.val1.set(val1, memos.position);
  memos.val2.set(val2, memos.position);
  const areEq = objEquiv2(val1, val2, strict, aKeys, memos, iterationType);
  memos.val1.delete(val1);
  memos.val2.delete(val2);
  return areEq;
}
function areSimilarRegExps2(a, b2) {
  return a.source === b2.source && a.flags === b2.flags && a.lastIndex === b2.lastIndex;
}
function areSimilarFloatArrays2(arr1, arr2) {
  if (arr1.byteLength !== arr2.byteLength) {
    return false;
  }
  for (let i = 0; i < arr1.byteLength; i++) {
    if (arr1[i] !== arr2[i]) {
      return false;
    }
  }
  return true;
}
function areSimilarTypedArrays2(arr1, arr2) {
  if (arr1.byteLength !== arr2.byteLength) {
    return false;
  }
  return Buffer6.compare(new Uint8Array(arr1.buffer, arr1.byteOffset, arr1.byteLength), new Uint8Array(arr2.buffer, arr2.byteOffset, arr2.byteLength)) === 0;
}
function areEqualArrayBuffers2(buf1, buf2) {
  return buf1.byteLength === buf2.byteLength && Buffer6.compare(new Uint8Array(buf1), new Uint8Array(buf2)) === 0;
}
function isEqualBoxedPrimitive2(a, b2) {
  if (Object.getOwnPropertyNames(a).length !== Object.getOwnPropertyNames(b2).length) {
    return false;
  }
  if (Object.getOwnPropertySymbols(a).length !== Object.getOwnPropertySymbols(b2).length) {
    return false;
  }
  if (isNumberObject6(a)) {
    return isNumberObject6(b2) && Object.is(Number.prototype.valueOf.call(a), Number.prototype.valueOf.call(b2));
  }
  if (isStringObject6(a)) {
    return isStringObject6(b2) && String.prototype.valueOf.call(a) === String.prototype.valueOf.call(b2);
  }
  if (isBooleanObject6(a)) {
    return isBooleanObject6(b2) && Boolean.prototype.valueOf.call(a) === Boolean.prototype.valueOf.call(b2);
  }
  if (isBigIntObject6(a)) {
    return isBigIntObject6(b2) && BigInt.prototype.valueOf.call(a) === BigInt.prototype.valueOf.call(b2);
  }
  if (isSymbolObject6(a)) {
    return isSymbolObject6(b2) && Symbol.prototype.valueOf.call(a) === Symbol.prototype.valueOf.call(b2);
  }
  throw Error(`Unknown boxed type`);
}
function getEnumerables2(val, keys) {
  return keys.filter((key2) => val.propertyIsEnumerable(key2));
}
function objEquiv2(obj1, obj2, strict, keys, memos, iterationType) {
  let i = 0;
  if (iterationType === 2 /* isSet */) {
    if (!setEquiv2(obj1, obj2, strict, memos)) {
      return false;
    }
  } else if (iterationType === 3 /* isMap */) {
    if (!mapEquiv2(obj1, obj2, strict, memos)) {
      return false;
    }
  } else if (iterationType === 1 /* isArray */) {
    for (; i < obj1.length; i++) {
      if (obj1.hasOwnProperty(i)) {
        if (!obj2.hasOwnProperty(i) || !innerDeepEqual2(obj1[i], obj2[i], strict, memos)) {
          return false;
        }
      } else if (obj2.hasOwnProperty(i)) {
        return false;
      } else {
        const keys1 = Object.keys(obj1);
        for (; i < keys1.length; i++) {
          const key2 = keys1[i];
          if (!obj2.hasOwnProperty(key2) || !innerDeepEqual2(obj1[key2], obj2[key2], strict, memos)) {
            return false;
          }
        }
        if (keys1.length !== Object.keys(obj2).length) {
          return false;
        }
        if (keys1.length !== Object.keys(obj2).length) {
          return false;
        }
        return true;
      }
    }
  }
  for (i = 0; i < keys.length; i++) {
    const key2 = keys[i];
    if (!innerDeepEqual2(obj1[key2], obj2[key2], strict, memos)) {
      return false;
    }
  }
  return true;
}
function findLooseMatchingPrimitives2(primitive) {
  switch (typeof primitive) {
    case "undefined":
      return null;
    case "object":
      return void 0;
    case "symbol":
      return false;
    case "string":
      primitive = +primitive;
    case "number":
      if (Number.isNaN(primitive)) {
        return false;
      }
  }
  return true;
}
function setMightHaveLoosePrim2(set1, set2, primitive) {
  const altValue = findLooseMatchingPrimitives2(primitive);
  if (altValue != null)
    return altValue;
  return set2.has(altValue) && !set1.has(altValue);
}
function setHasEqualElement2(set, val1, strict, memos) {
  for (const val2 of set) {
    if (innerDeepEqual2(val1, val2, strict, memos)) {
      set.delete(val2);
      return true;
    }
  }
  return false;
}
function setEquiv2(set1, set2, strict, memos) {
  let set = null;
  for (const item of set1) {
    if (typeof item === "object" && item !== null) {
      if (set === null) {
        set = /* @__PURE__ */ new Set();
      }
      set.add(item);
    } else if (!set2.has(item)) {
      if (strict)
        return false;
      if (!setMightHaveLoosePrim2(set1, set2, item)) {
        return false;
      }
      if (set === null) {
        set = /* @__PURE__ */ new Set();
      }
      set.add(item);
    }
  }
  if (set !== null) {
    for (const item of set2) {
      if (typeof item === "object" && item !== null) {
        if (!setHasEqualElement2(set, item, strict, memos))
          return false;
      } else if (!strict && !set1.has(item) && !setHasEqualElement2(set, item, strict, memos)) {
        return false;
      }
    }
    return set.size === 0;
  }
  return true;
}
function mapMightHaveLoosePrimitive2(map1, map2, primitive, item, memos) {
  const altValue = findLooseMatchingPrimitives2(primitive);
  if (altValue != null) {
    return altValue;
  }
  const curB = map2.get(altValue);
  if (curB === void 0 && !map2.has(altValue) || !innerDeepEqual2(item, curB, false, memo2)) {
    return false;
  }
  return !map1.has(altValue) && innerDeepEqual2(item, curB, false, memos);
}
function mapEquiv2(map1, map2, strict, memos) {
  let set = null;
  for (const { 0: key2, 1: item1 } of map1) {
    if (typeof key2 === "object" && key2 !== null) {
      if (set === null) {
        set = /* @__PURE__ */ new Set();
      }
      set.add(key2);
    } else {
      const item2 = map2.get(key2);
      if (item2 === void 0 && !map2.has(key2) || !innerDeepEqual2(item1, item2, strict, memos)) {
        if (strict)
          return false;
        if (!mapMightHaveLoosePrimitive2(map1, map2, key2, item1, memos)) {
          return false;
        }
        if (set === null) {
          set = /* @__PURE__ */ new Set();
        }
        set.add(key2);
      }
    }
  }
  if (set !== null) {
    for (const { 0: key2, 1: item } of map2) {
      if (typeof key2 === "object" && key2 !== null) {
        if (!mapHasEqualEntry2(set, map1, key2, item, strict, memos)) {
          return false;
        }
      } else if (!strict && (!map1.has(key2) || !innerDeepEqual2(map1.get(key2), item, false, memos)) && !mapHasEqualEntry2(set, map1, key2, item, false, memos)) {
        return false;
      }
    }
    return set.size === 0;
  }
  return true;
}
function mapHasEqualEntry2(set, map, key1, item1, strict, memos) {
  for (const key2 of set) {
    if (innerDeepEqual2(key1, key2, strict, memos) && innerDeepEqual2(item1, map.get(key2), strict, memos)) {
      set.delete(key2);
      return true;
    }
  }
  return false;
}

// deno:https://deno.land/std@0.146.0/node/util.ts
var NumberIsSafeInteger2 = Number.isSafeInteger;
function isArray2(value) {
  return Array.isArray(value);
}
function isBoolean2(value) {
  return typeof value === "boolean" || value instanceof Boolean;
}
function isNull2(value) {
  return value === null;
}
function isNullOrUndefined2(value) {
  return value === null || value === void 0;
}
function isNumber3(value) {
  return typeof value === "number" || value instanceof Number;
}
function isString2(value) {
  return typeof value === "string" || value instanceof String;
}
function isSymbol2(value) {
  return typeof value === "symbol";
}
function isUndefined2(value) {
  return value === void 0;
}
function isObject2(value) {
  return value !== null && typeof value === "object";
}
function isError3(e) {
  return e instanceof Error;
}
function isFunction2(value) {
  return typeof value === "function";
}
function isRegExp8(value) {
  return types_default5.isRegExp(value);
}
function isDate8(value) {
  return types_default5.isDate(value);
}
function isPrimitive2(value) {
  return value === null || typeof value !== "object" && typeof value !== "function";
}
function isBuffer5(value) {
  return Buffer6.isBuffer(value);
}
function _extend2(target, source) {
  if (source === null || typeof source !== "object")
    return target;
  const keys = Object.keys(source);
  let i = keys.length;
  while (i--) {
    target[keys[i]] = source[keys[i]];
  }
  return target;
}
function getSystemErrorName2(code2) {
  if (typeof code2 !== "number") {
    throw new codes3.ERR_INVALID_ARG_TYPE("err", "number", code2);
  }
  if (code2 >= 0 || !NumberIsSafeInteger2(code2)) {
    throw new codes3.ERR_OUT_OF_RANGE("err", "a negative integer", code2);
  }
  return errorMap2.get(code2)?.[0];
}
function inherits3(ctor, superCtor) {
  if (ctor === void 0 || ctor === null) {
    throw new codes3.ERR_INVALID_ARG_TYPE("ctor", "Function", ctor);
  }
  if (superCtor === void 0 || superCtor === null) {
    throw new codes3.ERR_INVALID_ARG_TYPE("superCtor", "Function", superCtor);
  }
  if (superCtor.prototype === void 0) {
    throw new codes3.ERR_INVALID_ARG_TYPE("superCtor.prototype", "Object", superCtor.prototype);
  }
  Object.defineProperty(ctor, "super_", {
    value: superCtor,
    writable: true,
    configurable: true
  });
  Object.setPrototypeOf(ctor.prototype, superCtor.prototype);
}
var TextDecoder3 = _TextDecoder2;
var TextEncoder3 = _TextEncoder2;
function pad2(n) {
  return n.toString().padStart(2, "0");
}
var months2 = [
  "Jan",
  "Feb",
  "Mar",
  "Apr",
  "May",
  "Jun",
  "Jul",
  "Aug",
  "Sep",
  "Oct",
  "Nov",
  "Dec"
];
function timestamp2() {
  const d4 = new Date();
  const t = [
    pad2(d4.getHours()),
    pad2(d4.getMinutes()),
    pad2(d4.getSeconds())
  ].join(":");
  return `${d4.getDate()} ${months2[d4.getMonth()]} ${t}`;
}
function log2(...args) {
  console.log("%s - %s", timestamp2(), format7(...args));
}
var util_default2 = {
  format: format7,
  formatWithOptions: formatWithOptions2,
  inspect: inspect5,
  isArray: isArray2,
  isBoolean: isBoolean2,
  isNull: isNull2,
  isNullOrUndefined: isNullOrUndefined2,
  isNumber: isNumber3,
  isString: isString2,
  isSymbol: isSymbol2,
  isUndefined: isUndefined2,
  isObject: isObject2,
  isError: isError3,
  isFunction: isFunction2,
  isRegExp: isRegExp8,
  isDate: isDate8,
  isPrimitive: isPrimitive2,
  isBuffer: isBuffer5,
  _extend: _extend2,
  getSystemErrorName: getSystemErrorName2,
  deprecate: deprecate2,
  callbackify: callbackify2,
  promisify: promisify3,
  inherits: inherits3,
  types: types_default5,
  stripVTControlCharacters: stripVTControlCharacters2,
  TextDecoder: TextDecoder3,
  TextEncoder: TextEncoder3,
  log: log2,
  debuglog: debuglog2,
  isDeepStrictEqual: isDeepStrictEqual2
};

// deno:https://deno.land/std@0.146.0/node/internal/errors.ts
var {
  errno: { ENOTDIR: ENOTDIR2, ENOENT: ENOENT2 }
} = os2;
var kIsNodeError2 = Symbol("kIsNodeError");
var classRegExp4 = /^([A-Z][a-z0-9]*)+$/;
var kTypes2 = [
  "string",
  "function",
  "number",
  "object",
  "Function",
  "Object",
  "boolean",
  "bigint",
  "symbol"
];
function addNumericalSeparator2(val) {
  let res = "";
  let i = val.length;
  const start = val[0] === "-" ? 1 : 0;
  for (; i >= start + 4; i -= 3) {
    res = `_${val.slice(i - 3, i)}${res}`;
  }
  return `${val.slice(0, i)}${res}`;
}
var captureLargerStackTrace3 = hideStackFrames3(function captureLargerStackTrace4(err) {
  Error.captureStackTrace(err);
  return err;
});
var uvExceptionWithHostPort3 = hideStackFrames3(function uvExceptionWithHostPort4(err, syscall, address, port) {
  const { 0: code2, 1: uvmsg } = uvErrmapGet2(err) || uvUnmappedError2;
  const message = `${syscall} ${code2}: ${uvmsg}`;
  let details = "";
  if (port && port > 0) {
    details = ` ${address}:${port}`;
  } else if (address) {
    details = ` ${address}`;
  }
  const ex = new Error(`${message}${details}`);
  ex.code = code2;
  ex.errno = err;
  ex.syscall = syscall;
  ex.address = address;
  if (port) {
    ex.port = port;
  }
  return captureLargerStackTrace3(ex);
});
var errnoException3 = hideStackFrames3(function errnoException4(err, syscall, original) {
  const code2 = getSystemErrorName2(err);
  const message = original ? `${syscall} ${code2} ${original}` : `${syscall} ${code2}`;
  const ex = new Error(message);
  ex.errno = err;
  ex.code = code2;
  ex.syscall = syscall;
  return captureLargerStackTrace3(ex);
});
function uvErrmapGet2(name) {
  return errorMap2.get(name);
}
var uvUnmappedError2 = ["UNKNOWN", "unknown error"];
var uvException3 = hideStackFrames3(function uvException4(ctx) {
  const { 0: code2, 1: uvmsg } = uvErrmapGet2(ctx.errno) || uvUnmappedError2;
  let message = `${code2}: ${ctx.message || uvmsg}, ${ctx.syscall}`;
  let path6;
  let dest;
  if (ctx.path) {
    path6 = ctx.path.toString();
    message += ` '${path6}'`;
  }
  if (ctx.dest) {
    dest = ctx.dest.toString();
    message += ` -> '${dest}'`;
  }
  const err = new Error(message);
  for (const prop of Object.keys(ctx)) {
    if (prop === "message" || prop === "path" || prop === "dest") {
      continue;
    }
    err[prop] = ctx[prop];
  }
  err.code = code2;
  if (path6) {
    err.path = path6;
  }
  if (dest) {
    err.dest = dest;
  }
  return captureLargerStackTrace3(err);
});
var exceptionWithHostPort3 = hideStackFrames3(function exceptionWithHostPort4(err, syscall, address, port, additional) {
  const code2 = getSystemErrorName2(err);
  let details = "";
  if (port && port > 0) {
    details = ` ${address}:${port}`;
  } else if (address) {
    details = ` ${address}`;
  }
  if (additional) {
    details += ` - Local (${additional})`;
  }
  const ex = new Error(`${syscall} ${code2}${details}`);
  ex.errno = err;
  ex.code = code2;
  ex.syscall = syscall;
  ex.address = address;
  if (port) {
    ex.port = port;
  }
  return captureLargerStackTrace3(ex);
});
var dnsException2 = hideStackFrames3(function(code2, syscall, hostname) {
  let errno;
  if (typeof code2 === "number") {
    errno = code2;
    if (code2 === codeMap2.get("EAI_NODATA") || code2 === codeMap2.get("EAI_NONAME")) {
      code2 = "ENOTFOUND";
    } else {
      code2 = getSystemErrorName2(code2);
    }
  }
  const message = `${syscall} ${code2}${hostname ? ` ${hostname}` : ""}`;
  const ex = new Error(message);
  ex.errno = errno;
  ex.code = code2;
  ex.syscall = syscall;
  if (hostname) {
    ex.hostname = hostname;
  }
  return captureLargerStackTrace3(ex);
});
var NodeErrorAbstraction2 = class extends Error {
  constructor(name, code2, message) {
    super(message);
    this.code = code2;
    this.name = name;
    this.stack = this.stack && `${name} [${this.code}]${this.stack.slice(20)}`;
  }
  toString() {
    return `${this.name} [${this.code}]: ${this.message}`;
  }
};
var NodeError2 = class extends NodeErrorAbstraction2 {
  constructor(code2, message) {
    super(Error.prototype.name, code2, message);
  }
};
var NodeRangeError2 = class extends NodeErrorAbstraction2 {
  constructor(code2, message) {
    super(RangeError.prototype.name, code2, message);
    Object.setPrototypeOf(this, RangeError.prototype);
    this.toString = function() {
      return `${this.name} [${this.code}]: ${this.message}`;
    };
  }
};
var NodeTypeError2 = class extends NodeErrorAbstraction2 {
  constructor(code2, message) {
    super(TypeError.prototype.name, code2, message);
    Object.setPrototypeOf(this, TypeError.prototype);
    this.toString = function() {
      return `${this.name} [${this.code}]: ${this.message}`;
    };
  }
};
var NodeURIError = class extends NodeErrorAbstraction2 {
  constructor(code2, message) {
    super(URIError.prototype.name, code2, message);
    Object.setPrototypeOf(this, URIError.prototype);
    this.toString = function() {
      return `${this.name} [${this.code}]: ${this.message}`;
    };
  }
};
var NodeSystemError2 = class extends NodeErrorAbstraction2 {
  constructor(key2, context, msgPrefix) {
    let message = `${msgPrefix}: ${context.syscall} returned ${context.code} (${context.message})`;
    if (context.path !== void 0) {
      message += ` ${context.path}`;
    }
    if (context.dest !== void 0) {
      message += ` => ${context.dest}`;
    }
    super("SystemError", key2, message);
    captureLargerStackTrace3(this);
    Object.defineProperties(this, {
      [kIsNodeError2]: {
        value: true,
        enumerable: false,
        writable: false,
        configurable: true
      },
      info: {
        value: context,
        enumerable: true,
        configurable: true,
        writable: false
      },
      errno: {
        get() {
          return context.errno;
        },
        set: (value) => {
          context.errno = value;
        },
        enumerable: true,
        configurable: true
      },
      syscall: {
        get() {
          return context.syscall;
        },
        set: (value) => {
          context.syscall = value;
        },
        enumerable: true,
        configurable: true
      }
    });
    if (context.path !== void 0) {
      Object.defineProperty(this, "path", {
        get() {
          return context.path;
        },
        set: (value) => {
          context.path = value;
        },
        enumerable: true,
        configurable: true
      });
    }
    if (context.dest !== void 0) {
      Object.defineProperty(this, "dest", {
        get() {
          return context.dest;
        },
        set: (value) => {
          context.dest = value;
        },
        enumerable: true,
        configurable: true
      });
    }
  }
  toString() {
    return `${this.name} [${this.code}]: ${this.message}`;
  }
};
function makeSystemErrorWithCode2(key2, msgPrfix) {
  return class NodeError extends NodeSystemError2 {
    constructor(ctx) {
      super(key2, ctx, msgPrfix);
    }
  };
}
var ERR_FS_EISDIR2 = makeSystemErrorWithCode2("ERR_FS_EISDIR", "Path is a directory");
function createInvalidArgType2(name, expected) {
  expected = Array.isArray(expected) ? expected : [expected];
  let msg = "The ";
  if (name.endsWith(" argument")) {
    msg += `${name} `;
  } else {
    const type = name.includes(".") ? "property" : "argument";
    msg += `"${name}" ${type} `;
  }
  msg += "must be ";
  const types = [];
  const instances = [];
  const other = [];
  for (const value of expected) {
    if (kTypes2.includes(value)) {
      types.push(value.toLocaleLowerCase());
    } else if (classRegExp4.test(value)) {
      instances.push(value);
    } else {
      other.push(value);
    }
  }
  if (instances.length > 0) {
    const pos = types.indexOf("object");
    if (pos !== -1) {
      types.splice(pos, 1);
      instances.push("Object");
    }
  }
  if (types.length > 0) {
    if (types.length > 2) {
      const last = types.pop();
      msg += `one of type ${types.join(", ")}, or ${last}`;
    } else if (types.length === 2) {
      msg += `one of type ${types[0]} or ${types[1]}`;
    } else {
      msg += `of type ${types[0]}`;
    }
    if (instances.length > 0 || other.length > 0) {
      msg += " or ";
    }
  }
  if (instances.length > 0) {
    if (instances.length > 2) {
      const last = instances.pop();
      msg += `an instance of ${instances.join(", ")}, or ${last}`;
    } else {
      msg += `an instance of ${instances[0]}`;
      if (instances.length === 2) {
        msg += ` or ${instances[1]}`;
      }
    }
    if (other.length > 0) {
      msg += " or ";
    }
  }
  if (other.length > 0) {
    if (other.length > 2) {
      const last = other.pop();
      msg += `one of ${other.join(", ")}, or ${last}`;
    } else if (other.length === 2) {
      msg += `one of ${other[0]} or ${other[1]}`;
    } else {
      if (other[0].toLowerCase() !== other[0]) {
        msg += "an ";
      }
      msg += `${other[0]}`;
    }
  }
  return msg;
}
var ERR_INVALID_ARG_TYPE_RANGE2 = class extends NodeRangeError2 {
  constructor(name, expected, actual) {
    const msg = createInvalidArgType2(name, expected);
    super("ERR_INVALID_ARG_TYPE", `${msg}.${invalidArgTypeHelper2(actual)}`);
  }
};
var ERR_INVALID_ARG_TYPE2 = class extends NodeTypeError2 {
  constructor(name, expected, actual) {
    const msg = createInvalidArgType2(name, expected);
    super("ERR_INVALID_ARG_TYPE", `${msg}.${invalidArgTypeHelper2(actual)}`);
  }
};
ERR_INVALID_ARG_TYPE2.RangeError = ERR_INVALID_ARG_TYPE_RANGE2;
var ERR_INVALID_ARG_VALUE_RANGE2 = class extends NodeRangeError2 {
  constructor(name, value, reason = "is invalid") {
    const type = name.includes(".") ? "property" : "argument";
    const inspected = inspect5(value);
    super("ERR_INVALID_ARG_VALUE", `The ${type} '${name}' ${reason}. Received ${inspected}`);
  }
};
var ERR_INVALID_ARG_VALUE2 = class extends NodeTypeError2 {
  constructor(name, value, reason = "is invalid") {
    const type = name.includes(".") ? "property" : "argument";
    const inspected = inspect5(value);
    super("ERR_INVALID_ARG_VALUE", `The ${type} '${name}' ${reason}. Received ${inspected}`);
  }
};
ERR_INVALID_ARG_VALUE2.RangeError = ERR_INVALID_ARG_VALUE_RANGE2;
function invalidArgTypeHelper2(input) {
  if (input == null) {
    return ` Received ${input}`;
  }
  if (typeof input === "function" && input.name) {
    return ` Received function ${input.name}`;
  }
  if (typeof input === "object") {
    if (input.constructor && input.constructor.name) {
      return ` Received an instance of ${input.constructor.name}`;
    }
    return ` Received ${inspect5(input, { depth: -1 })}`;
  }
  let inspected = inspect5(input, { colors: false });
  if (inspected.length > 25) {
    inspected = `${inspected.slice(0, 25)}...`;
  }
  return ` Received type ${typeof input} (${inspected})`;
}
var ERR_OUT_OF_RANGE2 = class extends RangeError {
  constructor(str, range, input, replaceDefaultBoolean = false) {
    assert4(range, 'Missing "range" argument');
    let msg = replaceDefaultBoolean ? str : `The value of "${str}" is out of range.`;
    let received;
    if (Number.isInteger(input) && Math.abs(input) > 2 ** 32) {
      received = addNumericalSeparator2(String(input));
    } else if (typeof input === "bigint") {
      received = String(input);
      if (input > 2n ** 32n || input < -(2n ** 32n)) {
        received = addNumericalSeparator2(received);
      }
      received += "n";
    } else {
      received = inspect5(input);
    }
    msg += ` It must be ${range}. Received ${received}`;
    super(msg);
    this.code = "ERR_OUT_OF_RANGE";
    const { name } = this;
    this.name = `${name} [${this.code}]`;
    this.stack;
    this.name = name;
  }
};
var ERR_BUFFER_OUT_OF_BOUNDS2 = class extends NodeRangeError2 {
  constructor(name) {
    super("ERR_BUFFER_OUT_OF_BOUNDS", name ? `"${name}" is outside of buffer bounds` : "Attempt to access memory outside buffer bounds");
  }
};
var ERR_INVALID_CALLBACK2 = class extends NodeTypeError2 {
  constructor(object) {
    super("ERR_INVALID_CALLBACK", `Callback must be a function. Received ${inspect5(object)}`);
  }
};
var ERR_INVALID_URI = class extends NodeURIError {
  constructor() {
    super("ERR_INVALID_URI", `URI malformed`);
  }
};
var ERR_IPC_CHANNEL_CLOSED2 = class extends NodeError2 {
  constructor() {
    super("ERR_IPC_CHANNEL_CLOSED", `Channel closed`);
  }
};
var ERR_SOCKET_BAD_PORT2 = class extends NodeRangeError2 {
  constructor(name, port, allowZero = true) {
    assert4(typeof allowZero === "boolean", "The 'allowZero' argument must be of type boolean.");
    const operator = allowZero ? ">=" : ">";
    super("ERR_SOCKET_BAD_PORT", `${name} should be ${operator} 0 and < 65536. Received ${port}.`);
  }
};
var ERR_UNKNOWN_ENCODING2 = class extends NodeTypeError2 {
  constructor(x) {
    super("ERR_UNKNOWN_ENCODING", `Unknown encoding: ${x}`);
  }
};
codes3.ERR_IPC_CHANNEL_CLOSED = ERR_IPC_CHANNEL_CLOSED2;
codes3.ERR_INVALID_ARG_TYPE = ERR_INVALID_ARG_TYPE2;
codes3.ERR_INVALID_ARG_VALUE = ERR_INVALID_ARG_VALUE2;
codes3.ERR_INVALID_CALLBACK = ERR_INVALID_CALLBACK2;
codes3.ERR_OUT_OF_RANGE = ERR_OUT_OF_RANGE2;
codes3.ERR_SOCKET_BAD_PORT = ERR_SOCKET_BAD_PORT2;
codes3.ERR_BUFFER_OUT_OF_BOUNDS = ERR_BUFFER_OUT_OF_BOUNDS2;
codes3.ERR_UNKNOWN_ENCODING = ERR_UNKNOWN_ENCODING2;
var genericNodeError3 = hideStackFrames3(function genericNodeError4(message, errorProperties) {
  const err = new Error(message);
  Object.assign(err, errorProperties);
  return err;
});

// deno:https://deno.land/std@0.146.0/path/_constants.ts
var CHAR_UPPERCASE_A2 = 65;
var CHAR_LOWERCASE_A2 = 97;
var CHAR_UPPERCASE_Z2 = 90;
var CHAR_LOWERCASE_Z2 = 122;
var CHAR_DOT2 = 46;
var CHAR_FORWARD_SLASH2 = 47;
var CHAR_BACKWARD_SLASH2 = 92;
var CHAR_VERTICAL_LINE = 124;
var CHAR_QUESTION_MARK2 = 63;
var CHAR_UNDERSCORE = 95;
var CHAR_LINE_FEED = 10;
var CHAR_CARRIAGE_RETURN = 13;
var CHAR_TAB = 9;
var CHAR_FORM_FEED = 12;
var CHAR_HASH = 35;
var CHAR_SPACE = 32;
var CHAR_NO_BREAK_SPACE = 160;
var CHAR_ZERO_WIDTH_NOBREAK_SPACE = 65279;
var CHAR_LEFT_SQUARE_BRACKET = 91;
var CHAR_RIGHT_SQUARE_BRACKET = 93;
var CHAR_LEFT_ANGLE_BRACKET = 60;
var CHAR_RIGHT_ANGLE_BRACKET = 62;
var CHAR_LEFT_CURLY_BRACKET = 123;
var CHAR_RIGHT_CURLY_BRACKET = 125;
var CHAR_HYPHEN_MINUS = 45;
var CHAR_PLUS = 43;
var CHAR_DOUBLE_QUOTE = 34;
var CHAR_SINGLE_QUOTE = 39;
var CHAR_PERCENT = 37;
var CHAR_SEMICOLON = 59;
var CHAR_CIRCUMFLEX_ACCENT = 94;
var CHAR_GRAVE_ACCENT = 96;
var CHAR_AT = 64;
var CHAR_0 = 48;
var CHAR_9 = 57;

// deno:https://deno.land/std@0.146.0/node/path/mod.ts
var mod_exports3 = {};
__export(mod_exports3, {
  SEP: () => SEP2,
  SEP_PATTERN: () => SEP_PATTERN2,
  basename: () => basename6,
  common: () => common,
  delimiter: () => delimiter6,
  dirname: () => dirname6,
  extname: () => extname6,
  format: () => format10,
  fromFileUrl: () => fromFileUrl6,
  globToRegExp: () => globToRegExp,
  isAbsolute: () => isAbsolute6,
  isGlob: () => isGlob,
  join: () => join11,
  joinGlobs: () => joinGlobs,
  normalize: () => normalize8,
  normalizeGlob: () => normalizeGlob,
  parse: () => parse7,
  posix: () => posix,
  relative: () => relative6,
  resolve: () => resolve6,
  sep: () => sep6,
  toFileUrl: () => toFileUrl6,
  toNamespacedPath: () => toNamespacedPath6,
  win32: () => win32
});

// deno:https://deno.land/std@0.146.0/node/path/win32.ts
var win32_exports2 = {};
__export(win32_exports2, {
  basename: () => basename4,
  default: () => win32_default,
  delimiter: () => delimiter4,
  dirname: () => dirname4,
  extname: () => extname4,
  format: () => format8,
  fromFileUrl: () => fromFileUrl4,
  isAbsolute: () => isAbsolute4,
  join: () => join8,
  normalize: () => normalize5,
  parse: () => parse5,
  relative: () => relative4,
  resolve: () => resolve4,
  sep: () => sep4,
  toFileUrl: () => toFileUrl4,
  toNamespacedPath: () => toNamespacedPath4
});

// deno:https://deno.land/std@0.146.0/node/path/_constants.ts
var CHAR_UPPERCASE_A3 = 65;
var CHAR_LOWERCASE_A3 = 97;
var CHAR_UPPERCASE_Z3 = 90;
var CHAR_LOWERCASE_Z3 = 122;
var CHAR_DOT3 = 46;
var CHAR_FORWARD_SLASH3 = 47;
var CHAR_BACKWARD_SLASH3 = 92;
var CHAR_COLON2 = 58;
var CHAR_QUESTION_MARK3 = 63;

// deno:https://deno.land/std@0.146.0/node/path/_util.ts
function assertPath2(path6) {
  if (typeof path6 !== "string") {
    throw new ERR_INVALID_ARG_TYPE2("path", ["string"], path6);
  }
}
function isPosixPathSeparator2(code2) {
  return code2 === CHAR_FORWARD_SLASH3;
}
function isPathSeparator2(code2) {
  return isPosixPathSeparator2(code2) || code2 === CHAR_BACKWARD_SLASH3;
}
function isWindowsDeviceRoot2(code2) {
  return code2 >= CHAR_LOWERCASE_A3 && code2 <= CHAR_LOWERCASE_Z3 || code2 >= CHAR_UPPERCASE_A3 && code2 <= CHAR_UPPERCASE_Z3;
}
function normalizeString2(path6, allowAboveRoot, separator, isPathSeparator3) {
  let res = "";
  let lastSegmentLength = 0;
  let lastSlash = -1;
  let dots = 0;
  let code2;
  for (let i = 0, len = path6.length; i <= len; ++i) {
    if (i < len)
      code2 = path6.charCodeAt(i);
    else if (isPathSeparator3(code2))
      break;
    else
      code2 = CHAR_FORWARD_SLASH3;
    if (isPathSeparator3(code2)) {
      if (lastSlash === i - 1 || dots === 1) {
      } else if (lastSlash !== i - 1 && dots === 2) {
        if (res.length < 2 || lastSegmentLength !== 2 || res.charCodeAt(res.length - 1) !== CHAR_DOT3 || res.charCodeAt(res.length - 2) !== CHAR_DOT3) {
          if (res.length > 2) {
            const lastSlashIndex = res.lastIndexOf(separator);
            if (lastSlashIndex === -1) {
              res = "";
              lastSegmentLength = 0;
            } else {
              res = res.slice(0, lastSlashIndex);
              lastSegmentLength = res.length - 1 - res.lastIndexOf(separator);
            }
            lastSlash = i;
            dots = 0;
            continue;
          } else if (res.length === 2 || res.length === 1) {
            res = "";
            lastSegmentLength = 0;
            lastSlash = i;
            dots = 0;
            continue;
          }
        }
        if (allowAboveRoot) {
          if (res.length > 0)
            res += `${separator}..`;
          else
            res = "..";
          lastSegmentLength = 2;
        }
      } else {
        if (res.length > 0)
          res += separator + path6.slice(lastSlash + 1, i);
        else
          res = path6.slice(lastSlash + 1, i);
        lastSegmentLength = i - lastSlash - 1;
      }
      lastSlash = i;
      dots = 0;
    } else if (code2 === CHAR_DOT3 && dots !== -1) {
      ++dots;
    } else {
      dots = -1;
    }
  }
  return res;
}
function _format2(sep7, pathObject) {
  const dir = pathObject.dir || pathObject.root;
  const base3 = pathObject.base || (pathObject.name || "") + (pathObject.ext || "");
  if (!dir)
    return base3;
  if (dir === pathObject.root)
    return dir + base3;
  return dir + sep7 + base3;
}
var WHITESPACE_ENCODINGS2 = {
  "	": "%09",
  "\n": "%0A",
  "\v": "%0B",
  "\f": "%0C",
  "\r": "%0D",
  " ": "%20"
};
function encodeWhitespace2(string) {
  return string.replaceAll(/[\s]/g, (c5) => {
    return WHITESPACE_ENCODINGS2[c5] ?? c5;
  });
}

// deno:https://deno.land/std@0.146.0/node/path/win32.ts
var sep4 = "\\";
var delimiter4 = ";";
function resolve4(...pathSegments) {
  let resolvedDevice = "";
  let resolvedTail = "";
  let resolvedAbsolute = false;
  for (let i = pathSegments.length - 1; i >= -1; i--) {
    let path6;
    const { Deno: Deno4 } = globalThis;
    if (i >= 0) {
      path6 = pathSegments[i];
    } else if (!resolvedDevice) {
      if (typeof Deno4?.cwd !== "function") {
        throw new TypeError("Resolved a drive-letter-less path without a CWD.");
      }
      path6 = Deno4.cwd();
    } else {
      if (typeof Deno4?.env?.get !== "function" || typeof Deno4?.cwd !== "function") {
        throw new TypeError("Resolved a relative path without a CWD.");
      }
      path6 = Deno4.cwd();
      if (path6 === void 0 || path6.slice(0, 3).toLowerCase() !== `${resolvedDevice.toLowerCase()}\\`) {
        path6 = `${resolvedDevice}\\`;
      }
    }
    assertPath2(path6);
    const len = path6.length;
    if (len === 0)
      continue;
    let rootEnd = 0;
    let device = "";
    let isAbsolute7 = false;
    const code2 = path6.charCodeAt(0);
    if (len > 1) {
      if (isPathSeparator2(code2)) {
        isAbsolute7 = true;
        if (isPathSeparator2(path6.charCodeAt(1))) {
          let j2 = 2;
          let last = j2;
          for (; j2 < len; ++j2) {
            if (isPathSeparator2(path6.charCodeAt(j2)))
              break;
          }
          if (j2 < len && j2 !== last) {
            const firstPart = path6.slice(last, j2);
            last = j2;
            for (; j2 < len; ++j2) {
              if (!isPathSeparator2(path6.charCodeAt(j2)))
                break;
            }
            if (j2 < len && j2 !== last) {
              last = j2;
              for (; j2 < len; ++j2) {
                if (isPathSeparator2(path6.charCodeAt(j2)))
                  break;
              }
              if (j2 === len) {
                device = `\\\\${firstPart}\\${path6.slice(last)}`;
                rootEnd = j2;
              } else if (j2 !== last) {
                device = `\\\\${firstPart}\\${path6.slice(last, j2)}`;
                rootEnd = j2;
              }
            }
          }
        } else {
          rootEnd = 1;
        }
      } else if (isWindowsDeviceRoot2(code2)) {
        if (path6.charCodeAt(1) === CHAR_COLON2) {
          device = path6.slice(0, 2);
          rootEnd = 2;
          if (len > 2) {
            if (isPathSeparator2(path6.charCodeAt(2))) {
              isAbsolute7 = true;
              rootEnd = 3;
            }
          }
        }
      }
    } else if (isPathSeparator2(code2)) {
      rootEnd = 1;
      isAbsolute7 = true;
    }
    if (device.length > 0 && resolvedDevice.length > 0 && device.toLowerCase() !== resolvedDevice.toLowerCase()) {
      continue;
    }
    if (resolvedDevice.length === 0 && device.length > 0) {
      resolvedDevice = device;
    }
    if (!resolvedAbsolute) {
      resolvedTail = `${path6.slice(rootEnd)}\\${resolvedTail}`;
      resolvedAbsolute = isAbsolute7;
    }
    if (resolvedAbsolute && resolvedDevice.length > 0)
      break;
  }
  resolvedTail = normalizeString2(resolvedTail, !resolvedAbsolute, "\\", isPathSeparator2);
  return resolvedDevice + (resolvedAbsolute ? "\\" : "") + resolvedTail || ".";
}
function normalize5(path6) {
  assertPath2(path6);
  const len = path6.length;
  if (len === 0)
    return ".";
  let rootEnd = 0;
  let device;
  let isAbsolute7 = false;
  const code2 = path6.charCodeAt(0);
  if (len > 1) {
    if (isPathSeparator2(code2)) {
      isAbsolute7 = true;
      if (isPathSeparator2(path6.charCodeAt(1))) {
        let j2 = 2;
        let last = j2;
        for (; j2 < len; ++j2) {
          if (isPathSeparator2(path6.charCodeAt(j2)))
            break;
        }
        if (j2 < len && j2 !== last) {
          const firstPart = path6.slice(last, j2);
          last = j2;
          for (; j2 < len; ++j2) {
            if (!isPathSeparator2(path6.charCodeAt(j2)))
              break;
          }
          if (j2 < len && j2 !== last) {
            last = j2;
            for (; j2 < len; ++j2) {
              if (isPathSeparator2(path6.charCodeAt(j2)))
                break;
            }
            if (j2 === len) {
              return `\\\\${firstPart}\\${path6.slice(last)}\\`;
            } else if (j2 !== last) {
              device = `\\\\${firstPart}\\${path6.slice(last, j2)}`;
              rootEnd = j2;
            }
          }
        }
      } else {
        rootEnd = 1;
      }
    } else if (isWindowsDeviceRoot2(code2)) {
      if (path6.charCodeAt(1) === CHAR_COLON2) {
        device = path6.slice(0, 2);
        rootEnd = 2;
        if (len > 2) {
          if (isPathSeparator2(path6.charCodeAt(2))) {
            isAbsolute7 = true;
            rootEnd = 3;
          }
        }
      }
    }
  } else if (isPathSeparator2(code2)) {
    return "\\";
  }
  let tail;
  if (rootEnd < len) {
    tail = normalizeString2(path6.slice(rootEnd), !isAbsolute7, "\\", isPathSeparator2);
  } else {
    tail = "";
  }
  if (tail.length === 0 && !isAbsolute7)
    tail = ".";
  if (tail.length > 0 && isPathSeparator2(path6.charCodeAt(len - 1))) {
    tail += "\\";
  }
  if (device === void 0) {
    if (isAbsolute7) {
      if (tail.length > 0)
        return `\\${tail}`;
      else
        return "\\";
    } else if (tail.length > 0) {
      return tail;
    } else {
      return "";
    }
  } else if (isAbsolute7) {
    if (tail.length > 0)
      return `${device}\\${tail}`;
    else
      return `${device}\\`;
  } else if (tail.length > 0) {
    return device + tail;
  } else {
    return device;
  }
}
function isAbsolute4(path6) {
  assertPath2(path6);
  const len = path6.length;
  if (len === 0)
    return false;
  const code2 = path6.charCodeAt(0);
  if (isPathSeparator2(code2)) {
    return true;
  } else if (isWindowsDeviceRoot2(code2)) {
    if (len > 2 && path6.charCodeAt(1) === CHAR_COLON2) {
      if (isPathSeparator2(path6.charCodeAt(2)))
        return true;
    }
  }
  return false;
}
function join8(...paths) {
  const pathsCount = paths.length;
  if (pathsCount === 0)
    return ".";
  let joined;
  let firstPart = null;
  for (let i = 0; i < pathsCount; ++i) {
    const path6 = paths[i];
    assertPath2(path6);
    if (path6.length > 0) {
      if (joined === void 0)
        joined = firstPart = path6;
      else
        joined += `\\${path6}`;
    }
  }
  if (joined === void 0)
    return ".";
  let needsReplace = true;
  let slashCount = 0;
  assert4(firstPart != null);
  if (isPathSeparator2(firstPart.charCodeAt(0))) {
    ++slashCount;
    const firstLen = firstPart.length;
    if (firstLen > 1) {
      if (isPathSeparator2(firstPart.charCodeAt(1))) {
        ++slashCount;
        if (firstLen > 2) {
          if (isPathSeparator2(firstPart.charCodeAt(2)))
            ++slashCount;
          else {
            needsReplace = false;
          }
        }
      }
    }
  }
  if (needsReplace) {
    for (; slashCount < joined.length; ++slashCount) {
      if (!isPathSeparator2(joined.charCodeAt(slashCount)))
        break;
    }
    if (slashCount >= 2)
      joined = `\\${joined.slice(slashCount)}`;
  }
  return normalize5(joined);
}
function relative4(from5, to2) {
  assertPath2(from5);
  assertPath2(to2);
  if (from5 === to2)
    return "";
  const fromOrig = resolve4(from5);
  const toOrig = resolve4(to2);
  if (fromOrig === toOrig)
    return "";
  from5 = fromOrig.toLowerCase();
  to2 = toOrig.toLowerCase();
  if (from5 === to2)
    return "";
  let fromStart = 0;
  let fromEnd = from5.length;
  for (; fromStart < fromEnd; ++fromStart) {
    if (from5.charCodeAt(fromStart) !== CHAR_BACKWARD_SLASH3)
      break;
  }
  for (; fromEnd - 1 > fromStart; --fromEnd) {
    if (from5.charCodeAt(fromEnd - 1) !== CHAR_BACKWARD_SLASH3)
      break;
  }
  const fromLen = fromEnd - fromStart;
  let toStart = 0;
  let toEnd = to2.length;
  for (; toStart < toEnd; ++toStart) {
    if (to2.charCodeAt(toStart) !== CHAR_BACKWARD_SLASH3)
      break;
  }
  for (; toEnd - 1 > toStart; --toEnd) {
    if (to2.charCodeAt(toEnd - 1) !== CHAR_BACKWARD_SLASH3)
      break;
  }
  const toLen = toEnd - toStart;
  const length = fromLen < toLen ? fromLen : toLen;
  let lastCommonSep = -1;
  let i = 0;
  for (; i <= length; ++i) {
    if (i === length) {
      if (toLen > length) {
        if (to2.charCodeAt(toStart + i) === CHAR_BACKWARD_SLASH3) {
          return toOrig.slice(toStart + i + 1);
        } else if (i === 2) {
          return toOrig.slice(toStart + i);
        }
      }
      if (fromLen > length) {
        if (from5.charCodeAt(fromStart + i) === CHAR_BACKWARD_SLASH3) {
          lastCommonSep = i;
        } else if (i === 2) {
          lastCommonSep = 3;
        }
      }
      break;
    }
    const fromCode = from5.charCodeAt(fromStart + i);
    const toCode = to2.charCodeAt(toStart + i);
    if (fromCode !== toCode)
      break;
    else if (fromCode === CHAR_BACKWARD_SLASH3)
      lastCommonSep = i;
  }
  if (i !== length && lastCommonSep === -1) {
    return toOrig;
  }
  let out = "";
  if (lastCommonSep === -1)
    lastCommonSep = 0;
  for (i = fromStart + lastCommonSep + 1; i <= fromEnd; ++i) {
    if (i === fromEnd || from5.charCodeAt(i) === CHAR_BACKWARD_SLASH3) {
      if (out.length === 0)
        out += "..";
      else
        out += "\\..";
    }
  }
  if (out.length > 0) {
    return out + toOrig.slice(toStart + lastCommonSep, toEnd);
  } else {
    toStart += lastCommonSep;
    if (toOrig.charCodeAt(toStart) === CHAR_BACKWARD_SLASH3)
      ++toStart;
    return toOrig.slice(toStart, toEnd);
  }
}
function toNamespacedPath4(path6) {
  if (typeof path6 !== "string")
    return path6;
  if (path6.length === 0)
    return "";
  const resolvedPath = resolve4(path6);
  if (resolvedPath.length >= 3) {
    if (resolvedPath.charCodeAt(0) === CHAR_BACKWARD_SLASH3) {
      if (resolvedPath.charCodeAt(1) === CHAR_BACKWARD_SLASH3) {
        const code2 = resolvedPath.charCodeAt(2);
        if (code2 !== CHAR_QUESTION_MARK3 && code2 !== CHAR_DOT3) {
          return `\\\\?\\UNC\\${resolvedPath.slice(2)}`;
        }
      }
    } else if (isWindowsDeviceRoot2(resolvedPath.charCodeAt(0))) {
      if (resolvedPath.charCodeAt(1) === CHAR_COLON2 && resolvedPath.charCodeAt(2) === CHAR_BACKWARD_SLASH3) {
        return `\\\\?\\${resolvedPath}`;
      }
    }
  }
  return path6;
}
function dirname4(path6) {
  assertPath2(path6);
  const len = path6.length;
  if (len === 0)
    return ".";
  let rootEnd = -1;
  let end = -1;
  let matchedSlash = true;
  let offset = 0;
  const code2 = path6.charCodeAt(0);
  if (len > 1) {
    if (isPathSeparator2(code2)) {
      rootEnd = offset = 1;
      if (isPathSeparator2(path6.charCodeAt(1))) {
        let j2 = 2;
        let last = j2;
        for (; j2 < len; ++j2) {
          if (isPathSeparator2(path6.charCodeAt(j2)))
            break;
        }
        if (j2 < len && j2 !== last) {
          last = j2;
          for (; j2 < len; ++j2) {
            if (!isPathSeparator2(path6.charCodeAt(j2)))
              break;
          }
          if (j2 < len && j2 !== last) {
            last = j2;
            for (; j2 < len; ++j2) {
              if (isPathSeparator2(path6.charCodeAt(j2)))
                break;
            }
            if (j2 === len) {
              return path6;
            }
            if (j2 !== last) {
              rootEnd = offset = j2 + 1;
            }
          }
        }
      }
    } else if (isWindowsDeviceRoot2(code2)) {
      if (path6.charCodeAt(1) === CHAR_COLON2) {
        rootEnd = offset = 2;
        if (len > 2) {
          if (isPathSeparator2(path6.charCodeAt(2)))
            rootEnd = offset = 3;
        }
      }
    }
  } else if (isPathSeparator2(code2)) {
    return path6;
  }
  for (let i = len - 1; i >= offset; --i) {
    if (isPathSeparator2(path6.charCodeAt(i))) {
      if (!matchedSlash) {
        end = i;
        break;
      }
    } else {
      matchedSlash = false;
    }
  }
  if (end === -1) {
    if (rootEnd === -1)
      return ".";
    else
      end = rootEnd;
  }
  return path6.slice(0, end);
}
function basename4(path6, ext = "") {
  if (ext !== void 0 && typeof ext !== "string") {
    throw new ERR_INVALID_ARG_TYPE2("ext", ["string"], ext);
  }
  assertPath2(path6);
  let start = 0;
  let end = -1;
  let matchedSlash = true;
  let i;
  if (path6.length >= 2) {
    const drive = path6.charCodeAt(0);
    if (isWindowsDeviceRoot2(drive)) {
      if (path6.charCodeAt(1) === CHAR_COLON2)
        start = 2;
    }
  }
  if (ext !== void 0 && ext.length > 0 && ext.length <= path6.length) {
    if (ext.length === path6.length && ext === path6)
      return "";
    let extIdx = ext.length - 1;
    let firstNonSlashEnd = -1;
    for (i = path6.length - 1; i >= start; --i) {
      const code2 = path6.charCodeAt(i);
      if (isPathSeparator2(code2)) {
        if (!matchedSlash) {
          start = i + 1;
          break;
        }
      } else {
        if (firstNonSlashEnd === -1) {
          matchedSlash = false;
          firstNonSlashEnd = i + 1;
        }
        if (extIdx >= 0) {
          if (code2 === ext.charCodeAt(extIdx)) {
            if (--extIdx === -1) {
              end = i;
            }
          } else {
            extIdx = -1;
            end = firstNonSlashEnd;
          }
        }
      }
    }
    if (start === end)
      end = firstNonSlashEnd;
    else if (end === -1)
      end = path6.length;
    return path6.slice(start, end);
  } else {
    for (i = path6.length - 1; i >= start; --i) {
      if (isPathSeparator2(path6.charCodeAt(i))) {
        if (!matchedSlash) {
          start = i + 1;
          break;
        }
      } else if (end === -1) {
        matchedSlash = false;
        end = i + 1;
      }
    }
    if (end === -1)
      return "";
    return path6.slice(start, end);
  }
}
function extname4(path6) {
  assertPath2(path6);
  let start = 0;
  let startDot = -1;
  let startPart = 0;
  let end = -1;
  let matchedSlash = true;
  let preDotState = 0;
  if (path6.length >= 2 && path6.charCodeAt(1) === CHAR_COLON2 && isWindowsDeviceRoot2(path6.charCodeAt(0))) {
    start = startPart = 2;
  }
  for (let i = path6.length - 1; i >= start; --i) {
    const code2 = path6.charCodeAt(i);
    if (isPathSeparator2(code2)) {
      if (!matchedSlash) {
        startPart = i + 1;
        break;
      }
      continue;
    }
    if (end === -1) {
      matchedSlash = false;
      end = i + 1;
    }
    if (code2 === CHAR_DOT3) {
      if (startDot === -1)
        startDot = i;
      else if (preDotState !== 1)
        preDotState = 1;
    } else if (startDot !== -1) {
      preDotState = -1;
    }
  }
  if (startDot === -1 || end === -1 || preDotState === 0 || preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
    return "";
  }
  return path6.slice(startDot, end);
}
function format8(pathObject) {
  if (pathObject === null || typeof pathObject !== "object") {
    throw new ERR_INVALID_ARG_TYPE2("pathObject", ["Object"], pathObject);
  }
  return _format2("\\", pathObject);
}
function parse5(path6) {
  assertPath2(path6);
  const ret = { root: "", dir: "", base: "", ext: "", name: "" };
  const len = path6.length;
  if (len === 0)
    return ret;
  let rootEnd = 0;
  let code2 = path6.charCodeAt(0);
  if (len > 1) {
    if (isPathSeparator2(code2)) {
      rootEnd = 1;
      if (isPathSeparator2(path6.charCodeAt(1))) {
        let j2 = 2;
        let last = j2;
        for (; j2 < len; ++j2) {
          if (isPathSeparator2(path6.charCodeAt(j2)))
            break;
        }
        if (j2 < len && j2 !== last) {
          last = j2;
          for (; j2 < len; ++j2) {
            if (!isPathSeparator2(path6.charCodeAt(j2)))
              break;
          }
          if (j2 < len && j2 !== last) {
            last = j2;
            for (; j2 < len; ++j2) {
              if (isPathSeparator2(path6.charCodeAt(j2)))
                break;
            }
            if (j2 === len) {
              rootEnd = j2;
            } else if (j2 !== last) {
              rootEnd = j2 + 1;
            }
          }
        }
      }
    } else if (isWindowsDeviceRoot2(code2)) {
      if (path6.charCodeAt(1) === CHAR_COLON2) {
        rootEnd = 2;
        if (len > 2) {
          if (isPathSeparator2(path6.charCodeAt(2))) {
            if (len === 3) {
              ret.root = ret.dir = path6;
              return ret;
            }
            rootEnd = 3;
          }
        } else {
          ret.root = ret.dir = path6;
          return ret;
        }
      }
    }
  } else if (isPathSeparator2(code2)) {
    ret.root = ret.dir = path6;
    return ret;
  }
  if (rootEnd > 0)
    ret.root = path6.slice(0, rootEnd);
  let startDot = -1;
  let startPart = rootEnd;
  let end = -1;
  let matchedSlash = true;
  let i = path6.length - 1;
  let preDotState = 0;
  for (; i >= rootEnd; --i) {
    code2 = path6.charCodeAt(i);
    if (isPathSeparator2(code2)) {
      if (!matchedSlash) {
        startPart = i + 1;
        break;
      }
      continue;
    }
    if (end === -1) {
      matchedSlash = false;
      end = i + 1;
    }
    if (code2 === CHAR_DOT3) {
      if (startDot === -1)
        startDot = i;
      else if (preDotState !== 1)
        preDotState = 1;
    } else if (startDot !== -1) {
      preDotState = -1;
    }
  }
  if (startDot === -1 || end === -1 || preDotState === 0 || preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
    if (end !== -1) {
      ret.base = ret.name = path6.slice(startPart, end);
    }
  } else {
    ret.name = path6.slice(startPart, startDot);
    ret.base = path6.slice(startPart, end);
    ret.ext = path6.slice(startDot, end);
  }
  if (startPart > 0 && startPart !== rootEnd) {
    ret.dir = path6.slice(0, startPart - 1);
  } else
    ret.dir = ret.root;
  return ret;
}
function fromFileUrl4(url) {
  url = url instanceof URL ? url : new URL(url);
  if (url.protocol != "file:") {
    throw new TypeError("Must be a file URL.");
  }
  let path6 = decodeURIComponent(url.pathname.replace(/\//g, "\\").replace(/%(?![0-9A-Fa-f]{2})/g, "%25")).replace(/^\\*([A-Za-z]:)(\\|$)/, "$1\\");
  if (url.hostname != "") {
    path6 = `\\\\${url.hostname}${path6}`;
  }
  return path6;
}
function toFileUrl4(path6) {
  if (!isAbsolute4(path6)) {
    throw new TypeError("Must be an absolute path.");
  }
  const [, hostname, pathname] = path6.match(/^(?:[/\\]{2}([^/\\]+)(?=[/\\](?:[^/\\]|$)))?(.*)/);
  const url = new URL("file:///");
  url.pathname = encodeWhitespace2(pathname.replace(/%/g, "%25"));
  if (hostname != null && hostname != "localhost") {
    url.hostname = hostname;
    if (!url.hostname) {
      throw new TypeError("Invalid hostname.");
    }
  }
  return url;
}
var win32_default = {
  basename: basename4,
  delimiter: delimiter4,
  dirname: dirname4,
  extname: extname4,
  format: format8,
  fromFileUrl: fromFileUrl4,
  isAbsolute: isAbsolute4,
  join: join8,
  normalize: normalize5,
  parse: parse5,
  relative: relative4,
  resolve: resolve4,
  sep: sep4,
  toFileUrl: toFileUrl4,
  toNamespacedPath: toNamespacedPath4
};

// deno:https://deno.land/std@0.146.0/node/path/posix.ts
var posix_exports2 = {};
__export(posix_exports2, {
  basename: () => basename5,
  default: () => posix_default,
  delimiter: () => delimiter5,
  dirname: () => dirname5,
  extname: () => extname5,
  format: () => format9,
  fromFileUrl: () => fromFileUrl5,
  isAbsolute: () => isAbsolute5,
  join: () => join9,
  normalize: () => normalize6,
  parse: () => parse6,
  relative: () => relative5,
  resolve: () => resolve5,
  sep: () => sep5,
  toFileUrl: () => toFileUrl5,
  toNamespacedPath: () => toNamespacedPath5
});
var sep5 = "/";
var delimiter5 = ":";
function resolve5(...pathSegments) {
  let resolvedPath = "";
  let resolvedAbsolute = false;
  for (let i = pathSegments.length - 1; i >= -1 && !resolvedAbsolute; i--) {
    let path6;
    if (i >= 0)
      path6 = pathSegments[i];
    else {
      const { Deno: Deno4 } = globalThis;
      if (typeof Deno4?.cwd !== "function") {
        throw new TypeError("Resolved a relative path without a CWD.");
      }
      path6 = Deno4.cwd();
    }
    assertPath2(path6);
    if (path6.length === 0) {
      continue;
    }
    resolvedPath = `${path6}/${resolvedPath}`;
    resolvedAbsolute = path6.charCodeAt(0) === CHAR_FORWARD_SLASH3;
  }
  resolvedPath = normalizeString2(resolvedPath, !resolvedAbsolute, "/", isPosixPathSeparator2);
  if (resolvedAbsolute) {
    if (resolvedPath.length > 0)
      return `/${resolvedPath}`;
    else
      return "/";
  } else if (resolvedPath.length > 0)
    return resolvedPath;
  else
    return ".";
}
function normalize6(path6) {
  assertPath2(path6);
  if (path6.length === 0)
    return ".";
  const isAbsolute7 = path6.charCodeAt(0) === CHAR_FORWARD_SLASH3;
  const trailingSeparator = path6.charCodeAt(path6.length - 1) === CHAR_FORWARD_SLASH3;
  path6 = normalizeString2(path6, !isAbsolute7, "/", isPosixPathSeparator2);
  if (path6.length === 0 && !isAbsolute7)
    path6 = ".";
  if (path6.length > 0 && trailingSeparator)
    path6 += "/";
  if (isAbsolute7)
    return `/${path6}`;
  return path6;
}
function isAbsolute5(path6) {
  assertPath2(path6);
  return path6.length > 0 && path6.charCodeAt(0) === CHAR_FORWARD_SLASH3;
}
function join9(...paths) {
  if (paths.length === 0)
    return ".";
  let joined;
  for (let i = 0, len = paths.length; i < len; ++i) {
    const path6 = paths[i];
    assertPath2(path6);
    if (path6.length > 0) {
      if (!joined)
        joined = path6;
      else
        joined += `/${path6}`;
    }
  }
  if (!joined)
    return ".";
  return normalize6(joined);
}
function relative5(from5, to2) {
  assertPath2(from5);
  assertPath2(to2);
  if (from5 === to2)
    return "";
  from5 = resolve5(from5);
  to2 = resolve5(to2);
  if (from5 === to2)
    return "";
  let fromStart = 1;
  const fromEnd = from5.length;
  for (; fromStart < fromEnd; ++fromStart) {
    if (from5.charCodeAt(fromStart) !== CHAR_FORWARD_SLASH3)
      break;
  }
  const fromLen = fromEnd - fromStart;
  let toStart = 1;
  const toEnd = to2.length;
  for (; toStart < toEnd; ++toStart) {
    if (to2.charCodeAt(toStart) !== CHAR_FORWARD_SLASH3)
      break;
  }
  const toLen = toEnd - toStart;
  const length = fromLen < toLen ? fromLen : toLen;
  let lastCommonSep = -1;
  let i = 0;
  for (; i <= length; ++i) {
    if (i === length) {
      if (toLen > length) {
        if (to2.charCodeAt(toStart + i) === CHAR_FORWARD_SLASH3) {
          return to2.slice(toStart + i + 1);
        } else if (i === 0) {
          return to2.slice(toStart + i);
        }
      } else if (fromLen > length) {
        if (from5.charCodeAt(fromStart + i) === CHAR_FORWARD_SLASH3) {
          lastCommonSep = i;
        } else if (i === 0) {
          lastCommonSep = 0;
        }
      }
      break;
    }
    const fromCode = from5.charCodeAt(fromStart + i);
    const toCode = to2.charCodeAt(toStart + i);
    if (fromCode !== toCode)
      break;
    else if (fromCode === CHAR_FORWARD_SLASH3)
      lastCommonSep = i;
  }
  let out = "";
  for (i = fromStart + lastCommonSep + 1; i <= fromEnd; ++i) {
    if (i === fromEnd || from5.charCodeAt(i) === CHAR_FORWARD_SLASH3) {
      if (out.length === 0)
        out += "..";
      else
        out += "/..";
    }
  }
  if (out.length > 0)
    return out + to2.slice(toStart + lastCommonSep);
  else {
    toStart += lastCommonSep;
    if (to2.charCodeAt(toStart) === CHAR_FORWARD_SLASH3)
      ++toStart;
    return to2.slice(toStart);
  }
}
function toNamespacedPath5(path6) {
  return path6;
}
function dirname5(path6) {
  assertPath2(path6);
  if (path6.length === 0)
    return ".";
  const hasRoot = path6.charCodeAt(0) === CHAR_FORWARD_SLASH3;
  let end = -1;
  let matchedSlash = true;
  for (let i = path6.length - 1; i >= 1; --i) {
    if (path6.charCodeAt(i) === CHAR_FORWARD_SLASH3) {
      if (!matchedSlash) {
        end = i;
        break;
      }
    } else {
      matchedSlash = false;
    }
  }
  if (end === -1)
    return hasRoot ? "/" : ".";
  if (hasRoot && end === 1)
    return "//";
  return path6.slice(0, end);
}
function basename5(path6, ext = "") {
  if (ext !== void 0 && typeof ext !== "string") {
    throw new ERR_INVALID_ARG_TYPE2("ext", ["string"], ext);
  }
  assertPath2(path6);
  let start = 0;
  let end = -1;
  let matchedSlash = true;
  let i;
  if (ext !== void 0 && ext.length > 0 && ext.length <= path6.length) {
    if (ext.length === path6.length && ext === path6)
      return "";
    let extIdx = ext.length - 1;
    let firstNonSlashEnd = -1;
    for (i = path6.length - 1; i >= 0; --i) {
      const code2 = path6.charCodeAt(i);
      if (code2 === CHAR_FORWARD_SLASH3) {
        if (!matchedSlash) {
          start = i + 1;
          break;
        }
      } else {
        if (firstNonSlashEnd === -1) {
          matchedSlash = false;
          firstNonSlashEnd = i + 1;
        }
        if (extIdx >= 0) {
          if (code2 === ext.charCodeAt(extIdx)) {
            if (--extIdx === -1) {
              end = i;
            }
          } else {
            extIdx = -1;
            end = firstNonSlashEnd;
          }
        }
      }
    }
    if (start === end)
      end = firstNonSlashEnd;
    else if (end === -1)
      end = path6.length;
    return path6.slice(start, end);
  } else {
    for (i = path6.length - 1; i >= 0; --i) {
      if (path6.charCodeAt(i) === CHAR_FORWARD_SLASH3) {
        if (!matchedSlash) {
          start = i + 1;
          break;
        }
      } else if (end === -1) {
        matchedSlash = false;
        end = i + 1;
      }
    }
    if (end === -1)
      return "";
    return path6.slice(start, end);
  }
}
function extname5(path6) {
  assertPath2(path6);
  let startDot = -1;
  let startPart = 0;
  let end = -1;
  let matchedSlash = true;
  let preDotState = 0;
  for (let i = path6.length - 1; i >= 0; --i) {
    const code2 = path6.charCodeAt(i);
    if (code2 === CHAR_FORWARD_SLASH3) {
      if (!matchedSlash) {
        startPart = i + 1;
        break;
      }
      continue;
    }
    if (end === -1) {
      matchedSlash = false;
      end = i + 1;
    }
    if (code2 === CHAR_DOT3) {
      if (startDot === -1)
        startDot = i;
      else if (preDotState !== 1)
        preDotState = 1;
    } else if (startDot !== -1) {
      preDotState = -1;
    }
  }
  if (startDot === -1 || end === -1 || preDotState === 0 || preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
    return "";
  }
  return path6.slice(startDot, end);
}
function format9(pathObject) {
  if (pathObject === null || typeof pathObject !== "object") {
    throw new ERR_INVALID_ARG_TYPE2("pathObject", ["Object"], pathObject);
  }
  return _format2("/", pathObject);
}
function parse6(path6) {
  assertPath2(path6);
  const ret = { root: "", dir: "", base: "", ext: "", name: "" };
  if (path6.length === 0)
    return ret;
  const isAbsolute7 = path6.charCodeAt(0) === CHAR_FORWARD_SLASH3;
  let start;
  if (isAbsolute7) {
    ret.root = "/";
    start = 1;
  } else {
    start = 0;
  }
  let startDot = -1;
  let startPart = 0;
  let end = -1;
  let matchedSlash = true;
  let i = path6.length - 1;
  let preDotState = 0;
  for (; i >= start; --i) {
    const code2 = path6.charCodeAt(i);
    if (code2 === CHAR_FORWARD_SLASH3) {
      if (!matchedSlash) {
        startPart = i + 1;
        break;
      }
      continue;
    }
    if (end === -1) {
      matchedSlash = false;
      end = i + 1;
    }
    if (code2 === CHAR_DOT3) {
      if (startDot === -1)
        startDot = i;
      else if (preDotState !== 1)
        preDotState = 1;
    } else if (startDot !== -1) {
      preDotState = -1;
    }
  }
  if (startDot === -1 || end === -1 || preDotState === 0 || preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
    if (end !== -1) {
      if (startPart === 0 && isAbsolute7) {
        ret.base = ret.name = path6.slice(1, end);
      } else {
        ret.base = ret.name = path6.slice(startPart, end);
      }
    }
  } else {
    if (startPart === 0 && isAbsolute7) {
      ret.name = path6.slice(1, startDot);
      ret.base = path6.slice(1, end);
    } else {
      ret.name = path6.slice(startPart, startDot);
      ret.base = path6.slice(startPart, end);
    }
    ret.ext = path6.slice(startDot, end);
  }
  if (startPart > 0)
    ret.dir = path6.slice(0, startPart - 1);
  else if (isAbsolute7)
    ret.dir = "/";
  return ret;
}
function fromFileUrl5(url) {
  url = url instanceof URL ? url : new URL(url);
  if (url.protocol != "file:") {
    throw new TypeError("Must be a file URL.");
  }
  return decodeURIComponent(url.pathname.replace(/%(?![0-9A-Fa-f]{2})/g, "%25"));
}
function toFileUrl5(path6) {
  if (!isAbsolute5(path6)) {
    throw new TypeError("Must be an absolute path.");
  }
  const url = new URL("file:///");
  url.pathname = encodeWhitespace2(path6.replace(/%/g, "%25").replace(/\\/g, "%5C"));
  return url;
}
var posix_default = {
  basename: basename5,
  delimiter: delimiter5,
  dirname: dirname5,
  extname: extname5,
  format: format9,
  fromFileUrl: fromFileUrl5,
  isAbsolute: isAbsolute5,
  join: join9,
  normalize: normalize6,
  parse: parse6,
  relative: relative5,
  resolve: resolve5,
  sep: sep5,
  toFileUrl: toFileUrl5,
  toNamespacedPath: toNamespacedPath5
};

// deno:https://deno.land/std@0.146.0/node/path/separator.ts
var SEP2 = isWindows2 ? "\\" : "/";
var SEP_PATTERN2 = isWindows2 ? /[\\/]+/ : /\/+/;

// deno:https://deno.land/std@0.146.0/node/path/common.ts
function common(paths, sep7 = SEP2) {
  const [first = "", ...remaining] = paths;
  if (first === "" || remaining.length === 0) {
    return first.substring(0, first.lastIndexOf(sep7) + 1);
  }
  const parts = first.split(sep7);
  let endOfPrefix = parts.length;
  for (const path6 of remaining) {
    const compare9 = path6.split(sep7);
    for (let i = 0; i < endOfPrefix; i++) {
      if (compare9[i] !== parts[i]) {
        endOfPrefix = i;
      }
    }
    if (endOfPrefix === 0) {
      return "";
    }
  }
  const prefix = parts.slice(0, endOfPrefix).join(sep7);
  return prefix.endsWith(sep7) ? prefix : `${prefix}${sep7}`;
}

// deno:https://deno.land/std@0.146.0/node/path/glob.ts
var path4 = isWindows2 ? win32_exports2 : posix_exports2;
var { join: join10, normalize: normalize7 } = path4;
var regExpEscapeChars = [
  "!",
  "$",
  "(",
  ")",
  "*",
  "+",
  ".",
  "=",
  "?",
  "[",
  "\\",
  "^",
  "{",
  "|"
];
var rangeEscapeChars = ["-", "\\", "]"];
function globToRegExp(glob, {
  extended = true,
  globstar: globstarOption = true,
  os: os3 = osType2,
  caseInsensitive = false
} = {}) {
  if (glob == "") {
    return /(?!)/;
  }
  const sep7 = os3 == "windows" ? "(?:\\\\|/)+" : "/+";
  const sepMaybe = os3 == "windows" ? "(?:\\\\|/)*" : "/*";
  const seps = os3 == "windows" ? ["\\", "/"] : ["/"];
  const globstar = os3 == "windows" ? "(?:[^\\\\/]*(?:\\\\|/|$)+)*" : "(?:[^/]*(?:/|$)+)*";
  const wildcard = os3 == "windows" ? "[^\\\\/]*" : "[^/]*";
  const escapePrefix = os3 == "windows" ? "`" : "\\";
  let newLength = glob.length;
  for (; newLength > 1 && seps.includes(glob[newLength - 1]); newLength--)
    ;
  glob = glob.slice(0, newLength);
  let regExpString = "";
  for (let j2 = 0; j2 < glob.length; ) {
    let segment = "";
    const groupStack = [];
    let inRange = false;
    let inEscape = false;
    let endsWithSep = false;
    let i = j2;
    for (; i < glob.length && !seps.includes(glob[i]); i++) {
      if (inEscape) {
        inEscape = false;
        const escapeChars = inRange ? rangeEscapeChars : regExpEscapeChars;
        segment += escapeChars.includes(glob[i]) ? `\\${glob[i]}` : glob[i];
        continue;
      }
      if (glob[i] == escapePrefix) {
        inEscape = true;
        continue;
      }
      if (glob[i] == "[") {
        if (!inRange) {
          inRange = true;
          segment += "[";
          if (glob[i + 1] == "!") {
            i++;
            segment += "^";
          } else if (glob[i + 1] == "^") {
            i++;
            segment += "\\^";
          }
          continue;
        } else if (glob[i + 1] == ":") {
          let k6 = i + 1;
          let value = "";
          while (glob[k6 + 1] != null && glob[k6 + 1] != ":") {
            value += glob[k6 + 1];
            k6++;
          }
          if (glob[k6 + 1] == ":" && glob[k6 + 2] == "]") {
            i = k6 + 2;
            if (value == "alnum")
              segment += "\\dA-Za-z";
            else if (value == "alpha")
              segment += "A-Za-z";
            else if (value == "ascii")
              segment += "\0-\x7F";
            else if (value == "blank")
              segment += "	 ";
            else if (value == "cntrl")
              segment += "\0-\x7F";
            else if (value == "digit")
              segment += "\\d";
            else if (value == "graph")
              segment += "!-~";
            else if (value == "lower")
              segment += "a-z";
            else if (value == "print")
              segment += " -~";
            else if (value == "punct") {
              segment += `!"#$%&'()*+,\\-./:;<=>?@[\\\\\\]^_\u2018{|}~`;
            } else if (value == "space")
              segment += "\\s\v";
            else if (value == "upper")
              segment += "A-Z";
            else if (value == "word")
              segment += "\\w";
            else if (value == "xdigit")
              segment += "\\dA-Fa-f";
            continue;
          }
        }
      }
      if (glob[i] == "]" && inRange) {
        inRange = false;
        segment += "]";
        continue;
      }
      if (inRange) {
        if (glob[i] == "\\") {
          segment += `\\\\`;
        } else {
          segment += glob[i];
        }
        continue;
      }
      if (glob[i] == ")" && groupStack.length > 0 && groupStack[groupStack.length - 1] != "BRACE") {
        segment += ")";
        const type = groupStack.pop();
        if (type == "!") {
          segment += wildcard;
        } else if (type != "@") {
          segment += type;
        }
        continue;
      }
      if (glob[i] == "|" && groupStack.length > 0 && groupStack[groupStack.length - 1] != "BRACE") {
        segment += "|";
        continue;
      }
      if (glob[i] == "+" && extended && glob[i + 1] == "(") {
        i++;
        groupStack.push("+");
        segment += "(?:";
        continue;
      }
      if (glob[i] == "@" && extended && glob[i + 1] == "(") {
        i++;
        groupStack.push("@");
        segment += "(?:";
        continue;
      }
      if (glob[i] == "?") {
        if (extended && glob[i + 1] == "(") {
          i++;
          groupStack.push("?");
          segment += "(?:";
        } else {
          segment += ".";
        }
        continue;
      }
      if (glob[i] == "!" && extended && glob[i + 1] == "(") {
        i++;
        groupStack.push("!");
        segment += "(?!";
        continue;
      }
      if (glob[i] == "{") {
        groupStack.push("BRACE");
        segment += "(?:";
        continue;
      }
      if (glob[i] == "}" && groupStack[groupStack.length - 1] == "BRACE") {
        groupStack.pop();
        segment += ")";
        continue;
      }
      if (glob[i] == "," && groupStack[groupStack.length - 1] == "BRACE") {
        segment += "|";
        continue;
      }
      if (glob[i] == "*") {
        if (extended && glob[i + 1] == "(") {
          i++;
          groupStack.push("*");
          segment += "(?:";
        } else {
          const prevChar = glob[i - 1];
          let numStars = 1;
          while (glob[i + 1] == "*") {
            i++;
            numStars++;
          }
          const nextChar = glob[i + 1];
          if (globstarOption && numStars == 2 && [...seps, void 0].includes(prevChar) && [...seps, void 0].includes(nextChar)) {
            segment += globstar;
            endsWithSep = true;
          } else {
            segment += wildcard;
          }
        }
        continue;
      }
      segment += regExpEscapeChars.includes(glob[i]) ? `\\${glob[i]}` : glob[i];
    }
    if (groupStack.length > 0 || inRange || inEscape) {
      segment = "";
      for (const c5 of glob.slice(j2, i)) {
        segment += regExpEscapeChars.includes(c5) ? `\\${c5}` : c5;
        endsWithSep = false;
      }
    }
    regExpString += segment;
    if (!endsWithSep) {
      regExpString += i < glob.length ? sep7 : sepMaybe;
      endsWithSep = true;
    }
    while (seps.includes(glob[i]))
      i++;
    if (!(i > j2)) {
      throw new Error("Assertion failure: i > j (potential infinite loop)");
    }
    j2 = i;
  }
  regExpString = `^${regExpString}$`;
  return new RegExp(regExpString, caseInsensitive ? "i" : "");
}
function isGlob(str) {
  const chars = { "{": "}", "(": ")", "[": "]" };
  const regex = /\\(.)|(^!|\*|\?|[\].+)]\?|\[[^\\\]]+\]|\{[^\\}]+\}|\(\?[:!=][^\\)]+\)|\([^|]+\|[^\\)]+\))/;
  if (str === "") {
    return false;
  }
  let match;
  while (match = regex.exec(str)) {
    if (match[2])
      return true;
    let idx = match.index + match[0].length;
    const open = match[1];
    const close = open ? chars[open] : null;
    if (open && close) {
      const n = str.indexOf(close, idx);
      if (n !== -1) {
        idx = n + 1;
      }
    }
    str = str.slice(idx);
  }
  return false;
}
function normalizeGlob(glob, { globstar = false } = {}) {
  if (glob.match(/\0/g)) {
    throw new Error(`Glob contains invalid characters: "${glob}"`);
  }
  if (!globstar) {
    return normalize7(glob);
  }
  const s = SEP_PATTERN2.source;
  const badParentPattern = new RegExp(`(?<=(${s}|^)\\*\\*${s})\\.\\.(?=${s}|$)`, "g");
  return normalize7(glob.replace(badParentPattern, "\0")).replace(/\0/g, "..");
}
function joinGlobs(globs, { extended = true, globstar = false } = {}) {
  if (!globstar || globs.length == 0) {
    return join10(...globs);
  }
  if (globs.length === 0)
    return ".";
  let joined;
  for (const glob of globs) {
    const path6 = glob;
    if (path6.length > 0) {
      if (!joined)
        joined = path6;
      else
        joined += `${SEP2}${path6}`;
    }
  }
  if (!joined)
    return ".";
  return normalizeGlob(joined, { extended, globstar });
}

// deno:https://deno.land/std@0.146.0/node/path/mod.ts
var path5 = isWindows2 ? win32_default : posix_default;
var win32 = win32_default;
var posix = posix_default;
var {
  basename: basename6,
  delimiter: delimiter6,
  dirname: dirname6,
  extname: extname6,
  format: format10,
  fromFileUrl: fromFileUrl6,
  isAbsolute: isAbsolute6,
  join: join11,
  normalize: normalize8,
  parse: parse7,
  relative: relative6,
  resolve: resolve6,
  sep: sep6,
  toFileUrl: toFileUrl6,
  toNamespacedPath: toNamespacedPath6
} = path5;

// deno:https://deno.land/std@0.146.0/node/path.ts
var path_default = { ...mod_exports3 };

// deno:https://deno.land/std@0.146.0/node/internal/idna.ts
var maxInt = 2147483647;
var base2 = 36;
var tMin = 1;
var tMax = 26;
var skew = 38;
var damp = 700;
var initialBias = 72;
var initialN = 128;
var delimiter7 = "-";
var regexNonASCII = /[^\0-\x7E]/;
var regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g;
var errors = {
  "overflow": "Overflow: input needs wider integers to process",
  "not-basic": "Illegal input >= 0x80 (not a basic code point)",
  "invalid-input": "Invalid input"
};
var baseMinusTMin = base2 - tMin;
function error2(type) {
  throw new RangeError(errors[type]);
}
function mapDomain(str, fn) {
  const parts = str.split("@");
  let result = "";
  if (parts.length > 1) {
    result = parts[0] + "@";
    str = parts[1];
  }
  str = str.replace(regexSeparators, ".");
  const labels = str.split(".");
  const encoded = labels.map(fn).join(".");
  return result + encoded;
}
function ucs2decode(str) {
  const output = [];
  let counter = 0;
  const length = str.length;
  while (counter < length) {
    const value = str.charCodeAt(counter++);
    if (value >= 55296 && value <= 56319 && counter < length) {
      const extra = str.charCodeAt(counter++);
      if ((extra & 64512) == 56320) {
        output.push(((value & 1023) << 10) + (extra & 1023) + 65536);
      } else {
        output.push(value);
        counter--;
      }
    } else {
      output.push(value);
    }
  }
  return output;
}
function digitToBasic(digit, flag) {
  return digit + 22 + 75 * Number(digit < 26) - (Number(flag != 0) << 5);
}
function adapt(delta, numPoints, firstTime) {
  let k6 = 0;
  delta = firstTime ? Math.floor(delta / damp) : delta >> 1;
  delta += Math.floor(delta / numPoints);
  for (; delta > baseMinusTMin * tMax >> 1; k6 += base2) {
    delta = Math.floor(delta / baseMinusTMin);
  }
  return Math.floor(k6 + (baseMinusTMin + 1) * delta / (delta + skew));
}
function encode13(str) {
  const output = [];
  const input = ucs2decode(str);
  const inputLength = input.length;
  let n = initialN;
  let delta = 0;
  let bias = initialBias;
  for (const currentValue of input) {
    if (currentValue < 128) {
      output.push(String.fromCharCode(currentValue));
    }
  }
  const basicLength = output.length;
  let handledCPCount = basicLength;
  if (basicLength) {
    output.push(delimiter7);
  }
  while (handledCPCount < inputLength) {
    let m3 = maxInt;
    for (const currentValue of input) {
      if (currentValue >= n && currentValue < m3) {
        m3 = currentValue;
      }
    }
    const handledCPCountPlusOne = handledCPCount + 1;
    if (m3 - n > Math.floor((maxInt - delta) / handledCPCountPlusOne)) {
      error2("overflow");
    }
    delta += (m3 - n) * handledCPCountPlusOne;
    n = m3;
    for (const currentValue of input) {
      if (currentValue < n && ++delta > maxInt) {
        error2("overflow");
      }
      if (currentValue == n) {
        let q = delta;
        for (let k6 = base2; ; k6 += base2) {
          const t = k6 <= bias ? tMin : k6 >= bias + tMax ? tMax : k6 - bias;
          if (q < t) {
            break;
          }
          const qMinusT = q - t;
          const baseMinusT = base2 - t;
          output.push(String.fromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0)));
          q = Math.floor(qMinusT / baseMinusT);
        }
        output.push(String.fromCharCode(digitToBasic(q, 0)));
        bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
        delta = 0;
        ++handledCPCount;
      }
    }
    ++delta;
    ++n;
  }
  return output.join("");
}
function toASCII(input) {
  return mapDomain(input, function(str) {
    return regexNonASCII.test(str) ? "xn--" + encode13(str) : str;
  });
}

// deno:https://deno.land/std@0.146.0/node/internal/querystring.ts
var hexTable2 = new Array(256);
for (let i = 0; i < 256; ++i) {
  hexTable2[i] = "%" + ((i < 16 ? "0" : "") + i.toString(16)).toUpperCase();
}
var isHexTable = new Int8Array([
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  1,
  1,
  1,
  1,
  1,
  1,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  1,
  1,
  1,
  1,
  1,
  1,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0
]);
function encodeStr2(str, noEscapeTable, hexTable3) {
  const len = str.length;
  if (len === 0)
    return "";
  let out = "";
  let lastPos = 0;
  for (let i = 0; i < len; i++) {
    let c5 = str.charCodeAt(i);
    if (c5 < 128) {
      if (noEscapeTable[c5] === 1)
        continue;
      if (lastPos < i)
        out += str.slice(lastPos, i);
      lastPos = i + 1;
      out += hexTable3[c5];
      continue;
    }
    if (lastPos < i)
      out += str.slice(lastPos, i);
    if (c5 < 2048) {
      lastPos = i + 1;
      out += hexTable3[192 | c5 >> 6] + hexTable3[128 | c5 & 63];
      continue;
    }
    if (c5 < 55296 || c5 >= 57344) {
      lastPos = i + 1;
      out += hexTable3[224 | c5 >> 12] + hexTable3[128 | c5 >> 6 & 63] + hexTable3[128 | c5 & 63];
      continue;
    }
    ++i;
    if (i >= len)
      throw new ERR_INVALID_URI();
    const c22 = str.charCodeAt(i) & 1023;
    lastPos = i + 1;
    c5 = 65536 + ((c5 & 1023) << 10 | c22);
    out += hexTable3[240 | c5 >> 18] + hexTable3[128 | c5 >> 12 & 63] + hexTable3[128 | c5 >> 6 & 63] + hexTable3[128 | c5 & 63];
  }
  if (lastPos === 0)
    return str;
  if (lastPos < len)
    return out + str.slice(lastPos);
  return out;
}

// deno:https://deno.land/std@0.146.0/node/querystring.ts
var decode11 = parse8;
var encode14 = stringify;
function qsEscape(str) {
  if (typeof str !== "string") {
    if (typeof str === "object") {
      str = String(str);
    } else {
      str += "";
    }
  }
  return encodeStr2(str, noEscape, hexTable2);
}
var escape = qsEscape;
var isHexTable2 = new Int8Array([
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  1,
  1,
  1,
  1,
  1,
  1,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  1,
  1,
  1,
  1,
  1,
  1,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0
]);
function charCodes(str) {
  const ret = new Array(str.length);
  for (let i = 0; i < str.length; ++i) {
    ret[i] = str.charCodeAt(i);
  }
  return ret;
}
function addKeyVal(obj2, key2, value, keyEncoded, valEncoded, decode14) {
  if (key2.length > 0 && keyEncoded) {
    key2 = decode14(key2);
  }
  if (value.length > 0 && valEncoded) {
    value = decode14(value);
  }
  if (obj2[key2] === void 0) {
    obj2[key2] = value;
  } else {
    const curValue = obj2[key2];
    if (curValue.pop) {
      curValue[curValue.length] = value;
    } else {
      obj2[key2] = [curValue, value];
    }
  }
}
function parse8(str, sep7 = "&", eq2 = "=", { decodeURIComponent: decodeURIComponent2 = unescape, maxKeys = 1e3 } = {}) {
  const obj2 = /* @__PURE__ */ Object.create(null);
  if (typeof str !== "string" || str.length === 0) {
    return obj2;
  }
  const sepCodes = !sep7 ? [38] : charCodes(String(sep7));
  const eqCodes = !eq2 ? [61] : charCodes(String(eq2));
  const sepLen = sepCodes.length;
  const eqLen = eqCodes.length;
  let pairs = 1e3;
  if (typeof maxKeys === "number") {
    pairs = maxKeys > 0 ? maxKeys : -1;
  }
  let decode14 = unescape;
  if (decodeURIComponent2) {
    decode14 = decodeURIComponent2;
  }
  const customDecode = decode14 !== unescape;
  let lastPos = 0;
  let sepIdx = 0;
  let eqIdx = 0;
  let key2 = "";
  let value = "";
  let keyEncoded = customDecode;
  let valEncoded = customDecode;
  const plusChar = customDecode ? "%20" : " ";
  let encodeCheck = 0;
  for (let i = 0; i < str.length; ++i) {
    const code2 = str.charCodeAt(i);
    if (code2 === sepCodes[sepIdx]) {
      if (++sepIdx === sepLen) {
        const end = i - sepIdx + 1;
        if (eqIdx < eqLen) {
          if (lastPos < end) {
            key2 += str.slice(lastPos, end);
          } else if (key2.length === 0) {
            if (--pairs === 0) {
              return obj2;
            }
            lastPos = i + 1;
            sepIdx = eqIdx = 0;
            continue;
          }
        } else if (lastPos < end) {
          value += str.slice(lastPos, end);
        }
        addKeyVal(obj2, key2, value, keyEncoded, valEncoded, decode14);
        if (--pairs === 0) {
          return obj2;
        }
        key2 = value = "";
        encodeCheck = 0;
        lastPos = i + 1;
        sepIdx = eqIdx = 0;
      }
    } else {
      sepIdx = 0;
      if (eqIdx < eqLen) {
        if (code2 === eqCodes[eqIdx]) {
          if (++eqIdx === eqLen) {
            const end = i - eqIdx + 1;
            if (lastPos < end) {
              key2 += str.slice(lastPos, end);
            }
            encodeCheck = 0;
            lastPos = i + 1;
          }
          continue;
        } else {
          eqIdx = 0;
          if (!keyEncoded) {
            if (code2 === 37) {
              encodeCheck = 1;
              continue;
            } else if (encodeCheck > 0) {
              if (isHexTable2[code2] === 1) {
                if (++encodeCheck === 3) {
                  keyEncoded = true;
                }
                continue;
              } else {
                encodeCheck = 0;
              }
            }
          }
        }
        if (code2 === 43) {
          if (lastPos < i) {
            key2 += str.slice(lastPos, i);
          }
          key2 += plusChar;
          lastPos = i + 1;
          continue;
        }
      }
      if (code2 === 43) {
        if (lastPos < i) {
          value += str.slice(lastPos, i);
        }
        value += plusChar;
        lastPos = i + 1;
      } else if (!valEncoded) {
        if (code2 === 37) {
          encodeCheck = 1;
        } else if (encodeCheck > 0) {
          if (isHexTable2[code2] === 1) {
            if (++encodeCheck === 3) {
              valEncoded = true;
            }
          } else {
            encodeCheck = 0;
          }
        }
      }
    }
  }
  if (lastPos < str.length) {
    if (eqIdx < eqLen) {
      key2 += str.slice(lastPos);
    } else if (sepIdx < sepLen) {
      value += str.slice(lastPos);
    }
  } else if (eqIdx === 0 && key2.length === 0) {
    return obj2;
  }
  addKeyVal(obj2, key2, value, keyEncoded, valEncoded, decode14);
  return obj2;
}
var noEscape = new Int8Array([
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  1,
  0,
  0,
  0,
  0,
  0,
  1,
  1,
  1,
  1,
  0,
  0,
  1,
  1,
  0,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  0,
  0,
  0,
  0,
  1,
  0,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  0,
  0,
  0,
  1,
  0
]);
function stringifyPrimitive(v2) {
  if (typeof v2 === "string") {
    return v2;
  }
  if (typeof v2 === "number" && isFinite(v2)) {
    return "" + v2;
  }
  if (typeof v2 === "bigint") {
    return "" + v2;
  }
  if (typeof v2 === "boolean") {
    return v2 ? "true" : "false";
  }
  return "";
}
function encodeStringifiedCustom(v2, encode16) {
  return encode16(stringifyPrimitive(v2));
}
function encodeStringified(v2, encode16) {
  if (typeof v2 === "string") {
    return v2.length ? encode16(v2) : "";
  }
  if (typeof v2 === "number" && isFinite(v2)) {
    return Math.abs(v2) < 1e21 ? "" + v2 : encode16("" + v2);
  }
  if (typeof v2 === "bigint") {
    return "" + v2;
  }
  if (typeof v2 === "boolean") {
    return v2 ? "true" : "false";
  }
  return "";
}
function stringify(obj2, sep7, eq2, options) {
  sep7 ||= "&";
  eq2 ||= "=";
  const encode16 = options ? options.encodeURIComponent : qsEscape;
  const convert = options ? encodeStringifiedCustom : encodeStringified;
  if (obj2 !== null && typeof obj2 === "object") {
    const keys = Object.keys(obj2);
    const len = keys.length;
    let fields = "";
    for (let i = 0; i < len; ++i) {
      const k6 = keys[i];
      const v2 = obj2[k6];
      let ks3 = convert(k6, encode16);
      ks3 += eq2;
      if (Array.isArray(v2)) {
        const vlen = v2.length;
        if (vlen === 0)
          continue;
        if (fields) {
          fields += sep7;
        }
        for (let j2 = 0; j2 < vlen; ++j2) {
          if (j2) {
            fields += sep7;
          }
          fields += ks3;
          fields += convert(v2[j2], encode16);
        }
      } else {
        if (fields) {
          fields += sep7;
        }
        fields += ks3;
        fields += convert(v2, encode16);
      }
    }
    return fields;
  }
  return "";
}
var unhexTable = new Int8Array([
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  0,
  1,
  2,
  3,
  4,
  5,
  6,
  7,
  8,
  9,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  10,
  11,
  12,
  13,
  14,
  15,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  10,
  11,
  12,
  13,
  14,
  15,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1
]);
function unescapeBuffer(s, decodeSpaces = false) {
  const out = new Buffer6(s.length);
  let index = 0;
  let outIndex = 0;
  let currentChar;
  let nextChar;
  let hexHigh;
  let hexLow;
  const maxLength = s.length - 2;
  let hasHex = false;
  while (index < s.length) {
    currentChar = s.charCodeAt(index);
    if (currentChar === 43 && decodeSpaces) {
      out[outIndex++] = 32;
      index++;
      continue;
    }
    if (currentChar === 37 && index < maxLength) {
      currentChar = s.charCodeAt(++index);
      hexHigh = unhexTable[currentChar];
      if (!(hexHigh >= 0)) {
        out[outIndex++] = 37;
        continue;
      } else {
        nextChar = s.charCodeAt(++index);
        hexLow = unhexTable[nextChar];
        if (!(hexLow >= 0)) {
          out[outIndex++] = 37;
          index--;
        } else {
          hasHex = true;
          currentChar = hexHigh * 16 + hexLow;
        }
      }
    }
    out[outIndex++] = currentChar;
    index++;
  }
  return hasHex ? out.slice(0, outIndex) : out;
}
function qsUnescape(s) {
  try {
    return decodeURIComponent(s);
  } catch {
    return unescapeBuffer(s).toString();
  }
}
var unescape = qsUnescape;
var querystring_default = {
  parse: parse8,
  stringify,
  decode: decode11,
  encode: encode14,
  unescape,
  escape,
  unescapeBuffer
};

// deno:https://deno.land/std@0.146.0/node/url.ts
var protocolPattern = /^[a-z0-9.+-]+:/i;
var portPattern = /:[0-9]*$/;
var hostPattern = /^\/\/[^@/]+@[^@/]+/;
var simplePathPattern = /^(\/\/?(?!\/)[^?\s]*)(\?[^\s]*)?$/;
var unsafeProtocol = /* @__PURE__ */ new Set(["javascript", "javascript:"]);
var hostlessProtocol = /* @__PURE__ */ new Set(["javascript", "javascript:"]);
var slashedProtocol = /* @__PURE__ */ new Set([
  "http",
  "http:",
  "https",
  "https:",
  "ftp",
  "ftp:",
  "gopher",
  "gopher:",
  "file",
  "file:",
  "ws",
  "ws:",
  "wss",
  "wss:"
]);
var hostnameMaxLen = 255;
var noEscapeAuth = new Int8Array([
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  1,
  0,
  0,
  0,
  0,
  0,
  1,
  1,
  1,
  1,
  0,
  0,
  1,
  1,
  0,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  0,
  0,
  0,
  0,
  0,
  0,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  0,
  0,
  0,
  0,
  1,
  0,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  0,
  0,
  0,
  1,
  0
]);
var Url = class {
  constructor() {
    this.protocol = null;
    this.slashes = null;
    this.auth = null;
    this.host = null;
    this.port = null;
    this.hostname = null;
    this.hash = null;
    this.search = null;
    this.query = null;
    this.pathname = null;
    this.path = null;
    this.href = null;
  }
  #parseHost() {
    let host = this.host || "";
    let port = portPattern.exec(host);
    if (port) {
      port = port[0];
      if (port !== ":") {
        this.port = port.slice(1);
      }
      host = host.slice(0, host.length - port.length);
    }
    if (host)
      this.hostname = host;
  }
  resolve(relative7) {
    return this.resolveObject(parse9(relative7, false, true)).format();
  }
  resolveObject(relative7) {
    if (typeof relative7 === "string") {
      const rel = new Url();
      rel.urlParse(relative7, false, true);
      relative7 = rel;
    }
    const result = new Url();
    const tkeys = Object.keys(this);
    for (let tk = 0; tk < tkeys.length; tk++) {
      const tkey = tkeys[tk];
      result[tkey] = this[tkey];
    }
    result.hash = relative7.hash;
    if (relative7.href === "") {
      result.href = result.format();
      return result;
    }
    if (relative7.slashes && !relative7.protocol) {
      const rkeys = Object.keys(relative7);
      for (let rk = 0; rk < rkeys.length; rk++) {
        const rkey = rkeys[rk];
        if (rkey !== "protocol")
          result[rkey] = relative7[rkey];
      }
      if (result.protocol && slashedProtocol.has(result.protocol) && result.hostname && !result.pathname) {
        result.path = result.pathname = "/";
      }
      result.href = result.format();
      return result;
    }
    if (relative7.protocol && relative7.protocol !== result.protocol) {
      if (!slashedProtocol.has(relative7.protocol)) {
        const keys = Object.keys(relative7);
        for (let v2 = 0; v2 < keys.length; v2++) {
          const k6 = keys[v2];
          result[k6] = relative7[k6];
        }
        result.href = result.format();
        return result;
      }
      result.protocol = relative7.protocol;
      if (!relative7.host && !/^file:?$/.test(relative7.protocol) && !hostlessProtocol.has(relative7.protocol)) {
        const relPath2 = (relative7.pathname || "").split("/");
        while (relPath2.length && !(relative7.host = relPath2.shift() || null))
          ;
        if (!relative7.host)
          relative7.host = "";
        if (!relative7.hostname)
          relative7.hostname = "";
        if (relPath2[0] !== "")
          relPath2.unshift("");
        if (relPath2.length < 2)
          relPath2.unshift("");
        result.pathname = relPath2.join("/");
      } else {
        result.pathname = relative7.pathname;
      }
      result.search = relative7.search;
      result.query = relative7.query;
      result.host = relative7.host || "";
      result.auth = relative7.auth;
      result.hostname = relative7.hostname || relative7.host;
      result.port = relative7.port;
      if (result.pathname || result.search) {
        const p3 = result.pathname || "";
        const s = result.search || "";
        result.path = p3 + s;
      }
      result.slashes = result.slashes || relative7.slashes;
      result.href = result.format();
      return result;
    }
    const isSourceAbs = result.pathname && result.pathname.charAt(0) === "/";
    const isRelAbs = relative7.host || relative7.pathname && relative7.pathname.charAt(0) === "/";
    let mustEndAbs = isRelAbs || isSourceAbs || result.host && relative7.pathname;
    const removeAllDots = mustEndAbs;
    let srcPath = result.pathname && result.pathname.split("/") || [];
    const relPath = relative7.pathname && relative7.pathname.split("/") || [];
    const noLeadingSlashes = result.protocol && !slashedProtocol.has(result.protocol);
    if (noLeadingSlashes) {
      result.hostname = "";
      result.port = null;
      if (result.host) {
        if (srcPath[0] === "")
          srcPath[0] = result.host;
        else
          srcPath.unshift(result.host);
      }
      result.host = "";
      if (relative7.protocol) {
        relative7.hostname = null;
        relative7.port = null;
        result.auth = null;
        if (relative7.host) {
          if (relPath[0] === "")
            relPath[0] = relative7.host;
          else
            relPath.unshift(relative7.host);
        }
        relative7.host = null;
      }
      mustEndAbs = mustEndAbs && (relPath[0] === "" || srcPath[0] === "");
    }
    if (isRelAbs) {
      if (relative7.host || relative7.host === "") {
        if (result.host !== relative7.host)
          result.auth = null;
        result.host = relative7.host;
        result.port = relative7.port;
      }
      if (relative7.hostname || relative7.hostname === "") {
        if (result.hostname !== relative7.hostname)
          result.auth = null;
        result.hostname = relative7.hostname;
      }
      result.search = relative7.search;
      result.query = relative7.query;
      srcPath = relPath;
    } else if (relPath.length) {
      if (!srcPath)
        srcPath = [];
      srcPath.pop();
      srcPath = srcPath.concat(relPath);
      result.search = relative7.search;
      result.query = relative7.query;
    } else if (relative7.search !== null && relative7.search !== void 0) {
      if (noLeadingSlashes) {
        result.hostname = result.host = srcPath.shift() || null;
        const authInHost = result.host && result.host.indexOf("@") > 0 && result.host.split("@");
        if (authInHost) {
          result.auth = authInHost.shift() || null;
          result.host = result.hostname = authInHost.shift() || null;
        }
      }
      result.search = relative7.search;
      result.query = relative7.query;
      if (result.pathname !== null || result.search !== null) {
        result.path = (result.pathname ? result.pathname : "") + (result.search ? result.search : "");
      }
      result.href = result.format();
      return result;
    }
    if (!srcPath.length) {
      result.pathname = null;
      if (result.search) {
        result.path = "/" + result.search;
      } else {
        result.path = null;
      }
      result.href = result.format();
      return result;
    }
    let last = srcPath.slice(-1)[0];
    const hasTrailingSlash = (result.host || relative7.host || srcPath.length > 1) && (last === "." || last === "..") || last === "";
    let up = 0;
    for (let i = srcPath.length - 1; i >= 0; i--) {
      last = srcPath[i];
      if (last === ".") {
        srcPath.splice(i, 1);
      } else if (last === "..") {
        srcPath.splice(i, 1);
        up++;
      } else if (up) {
        srcPath.splice(i, 1);
        up--;
      }
    }
    if (!mustEndAbs && !removeAllDots) {
      while (up--) {
        srcPath.unshift("..");
      }
    }
    if (mustEndAbs && srcPath[0] !== "" && (!srcPath[0] || srcPath[0].charAt(0) !== "/")) {
      srcPath.unshift("");
    }
    if (hasTrailingSlash && srcPath.join("/").substr(-1) !== "/") {
      srcPath.push("");
    }
    const isAbsolute7 = srcPath[0] === "" || srcPath[0] && srcPath[0].charAt(0) === "/";
    if (noLeadingSlashes) {
      result.hostname = result.host = isAbsolute7 ? "" : srcPath.length ? srcPath.shift() || null : "";
      const authInHost = result.host && result.host.indexOf("@") > 0 ? result.host.split("@") : false;
      if (authInHost) {
        result.auth = authInHost.shift() || null;
        result.host = result.hostname = authInHost.shift() || null;
      }
    }
    mustEndAbs = mustEndAbs || result.host && srcPath.length;
    if (mustEndAbs && !isAbsolute7) {
      srcPath.unshift("");
    }
    if (!srcPath.length) {
      result.pathname = null;
      result.path = null;
    } else {
      result.pathname = srcPath.join("/");
    }
    if (result.pathname !== null || result.search !== null) {
      result.path = (result.pathname ? result.pathname : "") + (result.search ? result.search : "");
    }
    result.auth = relative7.auth || result.auth;
    result.slashes = result.slashes || relative7.slashes;
    result.href = result.format();
    return result;
  }
  format() {
    let auth = this.auth || "";
    if (auth) {
      auth = encodeStr2(auth, noEscapeAuth, hexTable2);
      auth += "@";
    }
    let protocol = this.protocol || "";
    let pathname = this.pathname || "";
    let hash = this.hash || "";
    let host = "";
    let query = "";
    if (this.host) {
      host = auth + this.host;
    } else if (this.hostname) {
      host = auth + (this.hostname.includes(":") && !isIpv6Hostname(this.hostname) ? "[" + this.hostname + "]" : this.hostname);
      if (this.port) {
        host += ":" + this.port;
      }
    }
    if (this.query !== null && typeof this.query === "object") {
      query = querystring_default.stringify(this.query);
    }
    let search = this.search || query && "?" + query || "";
    if (protocol && protocol.charCodeAt(protocol.length - 1) !== 58) {
      protocol += ":";
    }
    let newPathname = "";
    let lastPos = 0;
    for (let i = 0; i < pathname.length; ++i) {
      switch (pathname.charCodeAt(i)) {
        case CHAR_HASH:
          if (i - lastPos > 0) {
            newPathname += pathname.slice(lastPos, i);
          }
          newPathname += "%23";
          lastPos = i + 1;
          break;
        case CHAR_QUESTION_MARK2:
          if (i - lastPos > 0) {
            newPathname += pathname.slice(lastPos, i);
          }
          newPathname += "%3F";
          lastPos = i + 1;
          break;
      }
    }
    if (lastPos > 0) {
      if (lastPos !== pathname.length) {
        pathname = newPathname + pathname.slice(lastPos);
      } else
        pathname = newPathname;
    }
    if (this.slashes || slashedProtocol.has(protocol)) {
      if (this.slashes || host) {
        if (pathname && pathname.charCodeAt(0) !== CHAR_FORWARD_SLASH2) {
          pathname = "/" + pathname;
        }
        host = "//" + host;
      } else if (protocol.length >= 4 && protocol.charCodeAt(0) === 102 && protocol.charCodeAt(1) === 105 && protocol.charCodeAt(2) === 108 && protocol.charCodeAt(3) === 101) {
        host = "//";
      }
    }
    search = search.replace(/#/g, "%23");
    if (hash && hash.charCodeAt(0) !== CHAR_HASH) {
      hash = "#" + hash;
    }
    if (search && search.charCodeAt(0) !== CHAR_QUESTION_MARK2) {
      search = "?" + search;
    }
    return protocol + host + pathname + search + hash;
  }
  urlParse(url, parseQueryString, slashesDenoteHost) {
    let hasHash = false;
    let start = -1;
    let end = -1;
    let rest = "";
    let lastPos = 0;
    for (let i = 0, inWs = false, split3 = false; i < url.length; ++i) {
      const code2 = url.charCodeAt(i);
      const isWs = code2 === CHAR_SPACE || code2 === CHAR_TAB || code2 === CHAR_CARRIAGE_RETURN || code2 === CHAR_LINE_FEED || code2 === CHAR_FORM_FEED || code2 === CHAR_NO_BREAK_SPACE || code2 === CHAR_ZERO_WIDTH_NOBREAK_SPACE;
      if (start === -1) {
        if (isWs)
          continue;
        lastPos = start = i;
      } else if (inWs) {
        if (!isWs) {
          end = -1;
          inWs = false;
        }
      } else if (isWs) {
        end = i;
        inWs = true;
      }
      if (!split3) {
        switch (code2) {
          case CHAR_HASH:
            hasHash = true;
          case CHAR_QUESTION_MARK2:
            split3 = true;
            break;
          case CHAR_BACKWARD_SLASH2:
            if (i - lastPos > 0)
              rest += url.slice(lastPos, i);
            rest += "/";
            lastPos = i + 1;
            break;
        }
      } else if (!hasHash && code2 === CHAR_HASH) {
        hasHash = true;
      }
    }
    if (start !== -1) {
      if (lastPos === start) {
        if (end === -1) {
          if (start === 0)
            rest = url;
          else
            rest = url.slice(start);
        } else {
          rest = url.slice(start, end);
        }
      } else if (end === -1 && lastPos < url.length) {
        rest += url.slice(lastPos);
      } else if (end !== -1 && lastPos < end) {
        rest += url.slice(lastPos, end);
      }
    }
    if (!slashesDenoteHost && !hasHash) {
      const simplePath = simplePathPattern.exec(rest);
      if (simplePath) {
        this.path = rest;
        this.href = rest;
        this.pathname = simplePath[1];
        if (simplePath[2]) {
          this.search = simplePath[2];
          if (parseQueryString) {
            this.query = querystring_default.parse(this.search.slice(1));
          } else {
            this.query = this.search.slice(1);
          }
        } else if (parseQueryString) {
          this.search = null;
          this.query = /* @__PURE__ */ Object.create(null);
        }
        return this;
      }
    }
    let proto = protocolPattern.exec(rest);
    let lowerProto = "";
    if (proto) {
      proto = proto[0];
      lowerProto = proto.toLowerCase();
      this.protocol = lowerProto;
      rest = rest.slice(proto.length);
    }
    let slashes;
    if (slashesDenoteHost || proto || hostPattern.test(rest)) {
      slashes = rest.charCodeAt(0) === CHAR_FORWARD_SLASH2 && rest.charCodeAt(1) === CHAR_FORWARD_SLASH2;
      if (slashes && !(proto && hostlessProtocol.has(lowerProto))) {
        rest = rest.slice(2);
        this.slashes = true;
      }
    }
    if (!hostlessProtocol.has(lowerProto) && (slashes || proto && !slashedProtocol.has(proto))) {
      let hostEnd = -1;
      let atSign = -1;
      let nonHost = -1;
      for (let i = 0; i < rest.length; ++i) {
        switch (rest.charCodeAt(i)) {
          case CHAR_TAB:
          case CHAR_LINE_FEED:
          case CHAR_CARRIAGE_RETURN:
          case CHAR_SPACE:
          case CHAR_DOUBLE_QUOTE:
          case CHAR_PERCENT:
          case CHAR_SINGLE_QUOTE:
          case CHAR_SEMICOLON:
          case CHAR_LEFT_ANGLE_BRACKET:
          case CHAR_RIGHT_ANGLE_BRACKET:
          case CHAR_BACKWARD_SLASH2:
          case CHAR_CIRCUMFLEX_ACCENT:
          case CHAR_GRAVE_ACCENT:
          case CHAR_LEFT_CURLY_BRACKET:
          case CHAR_VERTICAL_LINE:
          case CHAR_RIGHT_CURLY_BRACKET:
            if (nonHost === -1)
              nonHost = i;
            break;
          case CHAR_HASH:
          case CHAR_FORWARD_SLASH2:
          case CHAR_QUESTION_MARK2:
            if (nonHost === -1)
              nonHost = i;
            hostEnd = i;
            break;
          case CHAR_AT:
            atSign = i;
            nonHost = -1;
            break;
        }
        if (hostEnd !== -1)
          break;
      }
      start = 0;
      if (atSign !== -1) {
        this.auth = decodeURIComponent(rest.slice(0, atSign));
        start = atSign + 1;
      }
      if (nonHost === -1) {
        this.host = rest.slice(start);
        rest = "";
      } else {
        this.host = rest.slice(start, nonHost);
        rest = rest.slice(nonHost);
      }
      this.#parseHost();
      if (typeof this.hostname !== "string")
        this.hostname = "";
      const hostname = this.hostname;
      const ipv6Hostname = isIpv6Hostname(hostname);
      if (!ipv6Hostname) {
        rest = getHostname(this, rest, hostname);
      }
      if (this.hostname.length > hostnameMaxLen) {
        this.hostname = "";
      } else {
        this.hostname = this.hostname.toLowerCase();
      }
      if (!ipv6Hostname) {
        this.hostname = toASCII(this.hostname);
      }
      const p3 = this.port ? ":" + this.port : "";
      const h = this.hostname || "";
      this.host = h + p3;
      if (ipv6Hostname) {
        this.hostname = this.hostname.slice(1, -1);
        if (rest[0] !== "/") {
          rest = "/" + rest;
        }
      }
    }
    if (!unsafeProtocol.has(lowerProto)) {
      rest = autoEscapeStr(rest);
    }
    let questionIdx = -1;
    let hashIdx = -1;
    for (let i = 0; i < rest.length; ++i) {
      const code2 = rest.charCodeAt(i);
      if (code2 === CHAR_HASH) {
        this.hash = rest.slice(i);
        hashIdx = i;
        break;
      } else if (code2 === CHAR_QUESTION_MARK2 && questionIdx === -1) {
        questionIdx = i;
      }
    }
    if (questionIdx !== -1) {
      if (hashIdx === -1) {
        this.search = rest.slice(questionIdx);
        this.query = rest.slice(questionIdx + 1);
      } else {
        this.search = rest.slice(questionIdx, hashIdx);
        this.query = rest.slice(questionIdx + 1, hashIdx);
      }
      if (parseQueryString) {
        this.query = querystring_default.parse(this.query);
      }
    } else if (parseQueryString) {
      this.search = null;
      this.query = /* @__PURE__ */ Object.create(null);
    }
    const useQuestionIdx = questionIdx !== -1 && (hashIdx === -1 || questionIdx < hashIdx);
    const firstIdx = useQuestionIdx ? questionIdx : hashIdx;
    if (firstIdx === -1) {
      if (rest.length > 0)
        this.pathname = rest;
    } else if (firstIdx > 0) {
      this.pathname = rest.slice(0, firstIdx);
    }
    if (slashedProtocol.has(lowerProto) && this.hostname && !this.pathname) {
      this.pathname = "/";
    }
    if (this.pathname || this.search) {
      const p3 = this.pathname || "";
      const s = this.search || "";
      this.path = p3 + s;
    }
    this.href = this.format();
    return this;
  }
};
function isIpv6Hostname(hostname) {
  return hostname.charCodeAt(0) === CHAR_LEFT_SQUARE_BRACKET && hostname.charCodeAt(hostname.length - 1) === CHAR_RIGHT_SQUARE_BRACKET;
}
function getHostname(self2, rest, hostname) {
  for (let i = 0; i < hostname.length; ++i) {
    const code2 = hostname.charCodeAt(i);
    const isValid = code2 >= CHAR_LOWERCASE_A2 && code2 <= CHAR_LOWERCASE_Z2 || code2 === CHAR_DOT2 || code2 >= CHAR_UPPERCASE_A2 && code2 <= CHAR_UPPERCASE_Z2 || code2 >= CHAR_0 && code2 <= CHAR_9 || code2 === CHAR_HYPHEN_MINUS || code2 === CHAR_PLUS || code2 === CHAR_UNDERSCORE || code2 > 127;
    if (!isValid) {
      self2.hostname = hostname.slice(0, i);
      return `/${hostname.slice(i)}${rest}`;
    }
  }
  return rest;
}
var escapedCodes = [
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "%09",
  "%0A",
  "",
  "",
  "%0D",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "%20",
  "",
  "%22",
  "",
  "",
  "",
  "",
  "%27",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "%3C",
  "",
  "%3E",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "%5C",
  "",
  "%5E",
  "",
  "%60",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "%7B",
  "%7C",
  "%7D"
];
function autoEscapeStr(rest) {
  let escaped = "";
  let lastEscapedPos = 0;
  for (let i = 0; i < rest.length; ++i) {
    const escapedChar = escapedCodes[rest.charCodeAt(i)];
    if (escapedChar) {
      if (i > lastEscapedPos) {
        escaped += rest.slice(lastEscapedPos, i);
      }
      escaped += escapedChar;
      lastEscapedPos = i + 1;
    }
  }
  if (lastEscapedPos === 0) {
    return rest;
  }
  if (lastEscapedPos < rest.length) {
    escaped += rest.slice(lastEscapedPos);
  }
  return escaped;
}
function parse9(url, parseQueryString, slashesDenoteHost) {
  if (url instanceof Url)
    return url;
  const urlObject = new Url();
  urlObject.urlParse(url, parseQueryString, slashesDenoteHost);
  return urlObject;
}

// deno:https://esm.sh/v86/node_events.js
var P = Object.create;
var d = Object.defineProperty;
var T = Object.getOwnPropertyDescriptor;
var F = Object.getOwnPropertyNames;
var I = Object.getPrototypeOf;
var K2 = Object.prototype.hasOwnProperty;
var o = (t, e) => d(t, "name", { value: e, configurable: true });
var W = (t, e) => () => (e || t((e = { exports: {} }).exports, e), e.exports);
var $ = (t, e, n, r) => {
  if (e && typeof e == "object" || typeof e == "function")
    for (let i of F(e))
      !K2.call(t, i) && i !== n && d(t, i, { get: () => e[i], enumerable: !(r = T(e, i)) || r.enumerable });
  return t;
};
var y = (t, e, n) => (n = t != null ? P(I(t)) : {}, $(e || !t || !t.__esModule ? d(n, "default", { value: t, enumerable: true }) : n, t));
var m = W((J3, h) => {
  "use strict";
  var c5 = typeof Reflect == "object" ? Reflect : null, g2 = c5 && typeof c5.apply == "function" ? c5.apply : o(function(e, n, r) {
    return Function.prototype.apply.call(e, n, r);
  }, "ReflectApply"), v2;
  c5 && typeof c5.ownKeys == "function" ? v2 = c5.ownKeys : Object.getOwnPropertySymbols ? v2 = o(function(e) {
    return Object.getOwnPropertyNames(e).concat(Object.getOwnPropertySymbols(e));
  }, "ReflectOwnKeys") : v2 = o(function(e) {
    return Object.getOwnPropertyNames(e);
  }, "ReflectOwnKeys");
  function S3(t) {
    console && console.warn && console.warn(t);
  }
  o(S3, "ProcessEmitWarning");
  var w2 = Number.isNaN || o(function(e) {
    return e !== e;
  }, "NumberIsNaN");
  function f() {
    f.init.call(this);
  }
  o(f, "EventEmitter");
  h.exports = f;
  h.exports.once = q;
  f.EventEmitter = f;
  f.prototype._events = void 0;
  f.prototype._eventsCount = 0;
  f.prototype._maxListeners = void 0;
  var _2 = 10;
  function p3(t) {
    if (typeof t != "function")
      throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof t);
  }
  o(p3, "checkListener");
  Object.defineProperty(f, "defaultMaxListeners", { enumerable: true, get: function() {
    return _2;
  }, set: function(t) {
    if (typeof t != "number" || t < 0 || w2(t))
      throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + t + ".");
    _2 = t;
  } });
  f.init = function() {
    (this._events === void 0 || this._events === Object.getPrototypeOf(this)._events) && (this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0), this._maxListeners = this._maxListeners || void 0;
  };
  f.prototype.setMaxListeners = o(function(e) {
    if (typeof e != "number" || e < 0 || w2(e))
      throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + e + ".");
    return this._maxListeners = e, this;
  }, "setMaxListeners");
  function b2(t) {
    return t._maxListeners === void 0 ? f.defaultMaxListeners : t._maxListeners;
  }
  o(b2, "_getMaxListeners");
  f.prototype.getMaxListeners = o(function() {
    return b2(this);
  }, "getMaxListeners");
  f.prototype.emit = o(function(e) {
    for (var n = [], r = 1; r < arguments.length; r++)
      n.push(arguments[r]);
    var i = e === "error", u = this._events;
    if (u !== void 0)
      i = i && u.error === void 0;
    else if (!i)
      return false;
    if (i) {
      var s;
      if (n.length > 0 && (s = n[0]), s instanceof Error)
        throw s;
      var a = new Error("Unhandled error." + (s ? " (" + s.message + ")" : ""));
      throw a.context = s, a;
    }
    var l = u[e];
    if (l === void 0)
      return false;
    if (typeof l == "function")
      g2(l, this, n);
    else
      for (var L4 = l.length, A4 = j2(l, L4), r = 0; r < L4; ++r)
        g2(A4[r], this, n);
    return true;
  }, "emit");
  function E2(t, e, n, r) {
    var i, u, s;
    if (p3(n), u = t._events, u === void 0 ? (u = t._events = /* @__PURE__ */ Object.create(null), t._eventsCount = 0) : (u.newListener !== void 0 && (t.emit("newListener", e, n.listener ? n.listener : n), u = t._events), s = u[e]), s === void 0)
      s = u[e] = n, ++t._eventsCount;
    else if (typeof s == "function" ? s = u[e] = r ? [n, s] : [s, n] : r ? s.unshift(n) : s.push(n), i = b2(t), i > 0 && s.length > i && !s.warned) {
      s.warned = true;
      var a = new Error("Possible EventEmitter memory leak detected. " + s.length + " " + String(e) + " listeners added. Use emitter.setMaxListeners() to increase limit");
      a.name = "MaxListenersExceededWarning", a.emitter = t, a.type = e, a.count = s.length, S3(a);
    }
    return t;
  }
  o(E2, "_addListener");
  f.prototype.addListener = o(function(e, n) {
    return E2(this, e, n, false);
  }, "addListener");
  f.prototype.on = f.prototype.addListener;
  f.prototype.prependListener = o(function(e, n) {
    return E2(this, e, n, true);
  }, "prependListener");
  function U2() {
    if (!this.fired)
      return this.target.removeListener(this.type, this.wrapFn), this.fired = true, arguments.length === 0 ? this.listener.call(this.target) : this.listener.apply(this.target, arguments);
  }
  o(U2, "onceWrapper");
  function O(t, e, n) {
    var r = { fired: false, wrapFn: void 0, target: t, type: e, listener: n }, i = U2.bind(r);
    return i.listener = n, r.wrapFn = i, i;
  }
  o(O, "_onceWrap");
  f.prototype.once = o(function(e, n) {
    return p3(n), this.on(e, O(this, e, n)), this;
  }, "once");
  f.prototype.prependOnceListener = o(function(e, n) {
    return p3(n), this.prependListener(e, O(this, e, n)), this;
  }, "prependOnceListener");
  f.prototype.removeListener = o(function(e, n) {
    var r, i, u, s, a;
    if (p3(n), i = this._events, i === void 0)
      return this;
    if (r = i[e], r === void 0)
      return this;
    if (r === n || r.listener === n)
      --this._eventsCount === 0 ? this._events = /* @__PURE__ */ Object.create(null) : (delete i[e], i.removeListener && this.emit("removeListener", e, r.listener || n));
    else if (typeof r != "function") {
      for (u = -1, s = r.length - 1; s >= 0; s--)
        if (r[s] === n || r[s].listener === n) {
          a = r[s].listener, u = s;
          break;
        }
      if (u < 0)
        return this;
      u === 0 ? r.shift() : k6(r, u), r.length === 1 && (i[e] = r[0]), i.removeListener !== void 0 && this.emit("removeListener", e, a || n);
    }
    return this;
  }, "removeListener");
  f.prototype.off = f.prototype.removeListener;
  f.prototype.removeAllListeners = o(function(e) {
    var n, r, i;
    if (r = this._events, r === void 0)
      return this;
    if (r.removeListener === void 0)
      return arguments.length === 0 ? (this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0) : r[e] !== void 0 && (--this._eventsCount === 0 ? this._events = /* @__PURE__ */ Object.create(null) : delete r[e]), this;
    if (arguments.length === 0) {
      var u = Object.keys(r), s;
      for (i = 0; i < u.length; ++i)
        s = u[i], s !== "removeListener" && this.removeAllListeners(s);
      return this.removeAllListeners("removeListener"), this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0, this;
    }
    if (n = r[e], typeof n == "function")
      this.removeListener(e, n);
    else if (n !== void 0)
      for (i = n.length - 1; i >= 0; i--)
        this.removeListener(e, n[i]);
    return this;
  }, "removeAllListeners");
  function x(t, e, n) {
    var r = t._events;
    if (r === void 0)
      return [];
    var i = r[e];
    return i === void 0 ? [] : typeof i == "function" ? n ? [i.listener || i] : [i] : n ? H3(i) : j2(i, i.length);
  }
  o(x, "_listeners");
  f.prototype.listeners = o(function(e) {
    return x(this, e, true);
  }, "listeners");
  f.prototype.rawListeners = o(function(e) {
    return x(this, e, false);
  }, "rawListeners");
  f.listenerCount = function(t, e) {
    return typeof t.listenerCount == "function" ? t.listenerCount(e) : C.call(t, e);
  };
  f.prototype.listenerCount = C;
  function C(t) {
    var e = this._events;
    if (e !== void 0) {
      var n = e[t];
      if (typeof n == "function")
        return 1;
      if (n !== void 0)
        return n.length;
    }
    return 0;
  }
  o(C, "listenerCount");
  f.prototype.eventNames = o(function() {
    return this._eventsCount > 0 ? v2(this._events) : [];
  }, "eventNames");
  function j2(t, e) {
    for (var n = new Array(e), r = 0; r < e; ++r)
      n[r] = t[r];
    return n;
  }
  o(j2, "arrayClone");
  function k6(t, e) {
    for (; e + 1 < t.length; e++)
      t[e] = t[e + 1];
    t.pop();
  }
  o(k6, "spliceOne");
  function H3(t) {
    for (var e = new Array(t.length), n = 0; n < e.length; ++n)
      e[n] = t[n].listener || t[n];
    return e;
  }
  o(H3, "unwrapListeners");
  function q(t, e) {
    return new Promise(function(n, r) {
      function i(s) {
        t.removeListener(e, u), r(s);
      }
      o(i, "errorListener");
      function u() {
        typeof t.removeListener == "function" && t.removeListener("error", i), n([].slice.call(arguments));
      }
      o(u, "resolver"), R3(t, e, u, { once: true }), e !== "error" && z(t, i, { once: true });
    });
  }
  o(q, "once");
  function z(t, e, n) {
    typeof t.on == "function" && R3(t, "error", e, n);
  }
  o(z, "addErrorHandlerIfEventEmitter");
  function R3(t, e, n, r) {
    if (typeof t.on == "function")
      r.once ? t.once(e, n) : t.on(e, n);
    else if (typeof t.addEventListener == "function")
      t.addEventListener(e, o(function i(u) {
        r.once && t.removeEventListener(e, i), n(u);
      }, "wrapListener"));
    else
      throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof t);
  }
  o(R3, "eventTargetAgnosticAddListener");
});
var N2 = y(m());
var M = y(m());
var { EventEmitter: Q, init: V, listenerCount: X2, once: Y } = M;
var { default: B, ...D } = M;
var Z = N2.default ?? B ?? D;

// deno:https://esm.sh/v86/node_process.js
var events = new Q();
events.setMaxListeners(1 << 10);
var cachedSetTimeout;
var cachedClearTimeout;
function defaultSetTimeout() {
  throw new Error("setTimeout has not been defined");
}
function defaultClearTimeout() {
  throw new Error("clearTimeout has not been defined");
}
(function() {
  try {
    if (typeof setTimeout === "function") {
      cachedSetTimeout = setTimeout;
    } else {
      cachedSetTimeout = defaultSetTimeout;
    }
  } catch (e) {
    cachedSetTimeout = defaultSetTimeout;
  }
  try {
    if (typeof clearTimeout === "function") {
      cachedClearTimeout = clearTimeout;
    } else {
      cachedClearTimeout = defaultClearTimeout;
    }
  } catch (e) {
    cachedClearTimeout = defaultClearTimeout;
  }
})();
function runTimeout(fn) {
  if (cachedSetTimeout === setTimeout) {
    return setTimeout(fn, 0);
  }
  if ((cachedSetTimeout === defaultSetTimeout || !cachedSetTimeout) && setTimeout) {
    cachedSetTimeout = setTimeout;
    return setTimeout(fn, 0);
  }
  try {
    return cachedSetTimeout(fn, 0);
  } catch (e) {
    try {
      return cachedSetTimeout.call(null, fn, 0);
    } catch (e2) {
      return cachedSetTimeout.call(this, fn, 0);
    }
  }
}
function runClearTimeout(marker) {
  if (cachedClearTimeout === clearTimeout) {
    return clearTimeout(marker);
  }
  if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
    cachedClearTimeout = clearTimeout;
    return clearTimeout(marker);
  }
  try {
    return cachedClearTimeout(marker);
  } catch (e) {
    try {
      return cachedClearTimeout.call(null, marker);
    } catch (e2) {
      return cachedClearTimeout.call(this, marker);
    }
  }
}
var queue3 = [];
var queueIndex = -1;
var currentQueue;
var draining = false;
function cleanUpNextTick() {
  if (!draining || !currentQueue) {
    return;
  }
  draining = false;
  if (currentQueue.length) {
    queue3 = currentQueue.concat(queue3);
  } else {
    queueIndex = -1;
  }
  if (queue3.length) {
    drainQueue();
  }
}
function drainQueue() {
  if (draining) {
    return;
  }
  let timeout = runTimeout(cleanUpNextTick);
  draining = true;
  let len = queue3.length;
  while (len) {
    currentQueue = queue3;
    queue3 = [];
    while (++queueIndex < len) {
      if (currentQueue) {
        currentQueue[queueIndex].run();
      }
    }
    queueIndex = -1;
    len = queue3.length;
  }
  currentQueue = null;
  draining = false;
  runClearTimeout(timeout);
}
var Item = class {
  constructor(fn, array) {
    this.fn = fn;
    this.array = array;
  }
  run() {
    this.fn.apply(null, this.array);
  }
};
var deno = typeof Deno !== "undefined";
var node_process_default = {
  title: deno ? "deno" : "browser",
  browser: true,
  env: deno ? new Proxy({}, {
    get(_target, prop) {
      return Deno.env.get(String(prop));
    },
    ownKeys: () => Reflect.ownKeys(Deno.env.toObject()),
    getOwnPropertyDescriptor: (_target, name) => {
      const e = Deno.env.toObject();
      if (name in Deno.env.toObject()) {
        const o2 = { enumerable: true, configurable: true };
        if (typeof name === "string") {
          o2.value = e[name];
        }
        return o2;
      }
    },
    set(_target, prop, value) {
      Deno.env.set(String(prop), String(value));
      return value;
    }
  }) : {},
  argv: deno ? Deno.args ?? [] : [],
  pid: deno ? Deno.pid ?? 0 : 0,
  version: "v16.14.0",
  versions: {
    node: "16.14.0",
    v8: "9.4.146.24-node.20",
    uv: "1.43.0",
    zlib: "1.2.11",
    brotli: "1.0.9",
    ares: "1.18.1",
    modules: "93",
    nghttp2: "1.45.1",
    napi: "8",
    llhttp: "6.0.4",
    openssl: "1.1.1m+quic",
    cldr: "40.0",
    icu: "70.1",
    tz: "2021a3",
    unicode: "14.0",
    ...deno ? Deno.version ?? { deno: "1.0.0-denodeploy.beta-4" } : {}
  },
  on: (...args) => events.on(...args),
  addListener: (...args) => events.addListener(...args),
  once: (...args) => events.once(...args),
  off: (...args) => events.off(...args),
  removeListener: (...args) => events.removeListener(...args),
  removeAllListeners: (...args) => events.removeAllListeners(...args),
  emit: (...args) => events.emit(...args),
  prependListener: (...args) => events.prependListener(...args),
  prependOnceListener: (...args) => events.prependOnceListener(...args),
  listeners: () => [],
  emitWarning: () => {
    throw new Error("process.emitWarning is not supported");
  },
  binding: () => {
    throw new Error("process.binding is not supported");
  },
  cwd: () => deno ? Deno.cwd?.() ?? "/" : "/",
  chdir: (path6) => {
    if (deno) {
      Deno.chdir(path6);
    } else {
      throw new Error("process.chdir is not supported");
    }
  },
  umask: () => deno ? Deno.umask ?? 0 : 0,
  nextTick: function(fn) {
    let args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
      for (let i = 1; i < arguments.length; i++) {
        args[i - 1] = arguments[i];
      }
    }
    queue3.push(new Item(fn, args));
    if (queue3.length === 1 && !draining) {
      runTimeout(drainQueue);
    }
  }
};

// deno:https://esm.sh/v86/string_decoder@1.3.0/es2019/string_decoder.bundle.js
var E = Object.create;
var d2 = Object.defineProperty;
var B2 = Object.getOwnPropertyDescriptor;
var k3 = Object.getOwnPropertyNames;
var L = Object.getPrototypeOf;
var U = Object.prototype.hasOwnProperty;
var A = ((t) => typeof require != "undefined" ? require : typeof Proxy != "undefined" ? new Proxy(t, { get: (e, r) => (typeof require != "undefined" ? require : e)[r] }) : t)(function(t) {
  if (typeof require != "undefined")
    return require.apply(this, arguments);
  throw new Error('Dynamic require of "' + t + '" is not supported');
});
var g = (t, e) => () => (e || t((e = { exports: {} }).exports, e), e.exports);
var D2 = (t, e, r, s) => {
  if (e && typeof e == "object" || typeof e == "function")
    for (let n of k3(e))
      !U.call(t, n) && n !== r && d2(t, n, { get: () => e[n], enumerable: !(s = B2(e, n)) || s.enumerable });
  return t;
};
var p = (t, e, r) => (r = t != null ? E(L(t)) : {}, D2(e || !t || !t.__esModule ? d2(r, "default", { value: t, enumerable: true }) : r, t));
var w = g((o2, m3) => {
  var h = export_default, i = h.Buffer;
  function N4(t, e) {
    for (var r in t)
      e[r] = t[r];
  }
  i.from && i.alloc && i.allocUnsafe && i.allocUnsafeSlow ? m3.exports = h : (N4(h, o2), o2.Buffer = a);
  function a(t, e, r) {
    return i(t, e, r);
  }
  a.prototype = Object.create(i.prototype);
  N4(i, a);
  a.from = function(t, e, r) {
    if (typeof t == "number")
      throw new TypeError("Argument must not be a number");
    return i(t, e, r);
  };
  a.alloc = function(t, e, r) {
    if (typeof t != "number")
      throw new TypeError("Argument must be a number");
    var s = i(t);
    return e !== void 0 ? typeof r == "string" ? s.fill(e, r) : s.fill(e) : s.fill(0), s;
  };
  a.allocUnsafe = function(t) {
    if (typeof t != "number")
      throw new TypeError("Argument must be a number");
    return i(t);
  };
  a.allocUnsafeSlow = function(t) {
    if (typeof t != "number")
      throw new TypeError("Argument must be a number");
    return h.SlowBuffer(t);
  };
});
var c = g((C) => {
  "use strict";
  var f = w().Buffer, x = f.isEncoding || function(t) {
    switch (t = "" + t, t && t.toLowerCase()) {
      case "hex":
      case "utf8":
      case "utf-8":
      case "ascii":
      case "binary":
      case "base64":
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
      case "raw":
        return true;
      default:
        return false;
    }
  };
  function F4(t) {
    if (!t)
      return "utf8";
    for (var e; ; )
      switch (t) {
        case "utf8":
        case "utf-8":
          return "utf8";
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return "utf16le";
        case "latin1":
        case "binary":
          return "latin1";
        case "base64":
        case "ascii":
        case "hex":
          return t;
        default:
          if (e)
            return;
          t = ("" + t).toLowerCase(), e = true;
      }
  }
  function $4(t) {
    var e = F4(t);
    if (typeof e != "string" && (f.isEncoding === x || !x(t)))
      throw new Error("Unknown encoding: " + t);
    return e || t;
  }
  C.StringDecoder = l;
  function l(t) {
    this.encoding = $4(t);
    var e;
    switch (this.encoding) {
      case "utf16le":
        this.text = W4, this.end = _2, e = 4;
        break;
      case "utf8":
        this.fillLast = I3, e = 4;
        break;
      case "base64":
        this.text = G4, this.end = H3, e = 3;
        break;
      default:
        this.write = J3, this.end = K4;
        return;
    }
    this.lastNeed = 0, this.lastTotal = 0, this.lastChar = f.allocUnsafe(e);
  }
  l.prototype.write = function(t) {
    if (t.length === 0)
      return "";
    var e, r;
    if (this.lastNeed) {
      if (e = this.fillLast(t), e === void 0)
        return "";
      r = this.lastNeed, this.lastNeed = 0;
    } else
      r = 0;
    return r < t.length ? e ? e + this.text(t, r) : this.text(t, r) : e || "";
  };
  l.prototype.end = P2;
  l.prototype.text = O;
  l.prototype.fillLast = function(t) {
    if (this.lastNeed <= t.length)
      return t.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed), this.lastChar.toString(this.encoding, 0, this.lastTotal);
    t.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, t.length), this.lastNeed -= t.length;
  };
  function u(t) {
    return t <= 127 ? 0 : t >> 5 === 6 ? 2 : t >> 4 === 14 ? 3 : t >> 3 === 30 ? 4 : t >> 6 === 2 ? -1 : -2;
  }
  function j2(t, e, r) {
    var s = e.length - 1;
    if (s < r)
      return 0;
    var n = u(e[s]);
    return n >= 0 ? (n > 0 && (t.lastNeed = n - 1), n) : --s < r || n === -2 ? 0 : (n = u(e[s]), n >= 0 ? (n > 0 && (t.lastNeed = n - 2), n) : --s < r || n === -2 ? 0 : (n = u(e[s]), n >= 0 ? (n > 0 && (n === 2 ? n = 0 : t.lastNeed = n - 3), n) : 0));
  }
  function q(t, e, r) {
    if ((e[0] & 192) !== 128)
      return t.lastNeed = 0, "\uFFFD";
    if (t.lastNeed > 1 && e.length > 1) {
      if ((e[1] & 192) !== 128)
        return t.lastNeed = 1, "\uFFFD";
      if (t.lastNeed > 2 && e.length > 2 && (e[2] & 192) !== 128)
        return t.lastNeed = 2, "\uFFFD";
    }
  }
  function I3(t) {
    var e = this.lastTotal - this.lastNeed, r = q(this, t, e);
    if (r !== void 0)
      return r;
    if (this.lastNeed <= t.length)
      return t.copy(this.lastChar, e, 0, this.lastNeed), this.lastChar.toString(this.encoding, 0, this.lastTotal);
    t.copy(this.lastChar, e, 0, t.length), this.lastNeed -= t.length;
  }
  function O(t, e) {
    var r = j2(this, t, e);
    if (!this.lastNeed)
      return t.toString("utf8", e);
    this.lastTotal = r;
    var s = t.length - (r - this.lastNeed);
    return t.copy(this.lastChar, 0, s), t.toString("utf8", e, s);
  }
  function P2(t) {
    var e = t && t.length ? this.write(t) : "";
    return this.lastNeed ? e + "\uFFFD" : e;
  }
  function W4(t, e) {
    if ((t.length - e) % 2 === 0) {
      var r = t.toString("utf16le", e);
      if (r) {
        var s = r.charCodeAt(r.length - 1);
        if (s >= 55296 && s <= 56319)
          return this.lastNeed = 2, this.lastTotal = 4, this.lastChar[0] = t[t.length - 2], this.lastChar[1] = t[t.length - 1], r.slice(0, -1);
      }
      return r;
    }
    return this.lastNeed = 1, this.lastTotal = 2, this.lastChar[0] = t[t.length - 1], t.toString("utf16le", e, t.length - 1);
  }
  function _2(t) {
    var e = t && t.length ? this.write(t) : "";
    if (this.lastNeed) {
      var r = this.lastTotal - this.lastNeed;
      return e + this.lastChar.toString("utf16le", 0, r);
    }
    return e;
  }
  function G4(t, e) {
    var r = (t.length - e) % 3;
    return r === 0 ? t.toString("base64", e) : (this.lastNeed = 3 - r, this.lastTotal = 3, r === 1 ? this.lastChar[0] = t[t.length - 1] : (this.lastChar[0] = t[t.length - 2], this.lastChar[1] = t[t.length - 1]), t.toString("base64", e, t.length - r));
  }
  function H3(t) {
    var e = t && t.length ? this.write(t) : "";
    return this.lastNeed ? e + this.lastChar.toString("base64", 0, 3 - this.lastNeed) : e;
  }
  function J3(t) {
    return t.toString(this.encoding);
  }
  function K4(t) {
    return t && t.length ? this.write(t) : "";
  }
});
var S = p(c());
var T2 = p(c());
var { StringDecoder: X3 } = T2;
var { default: M2, ...Q2 } = T2;
var v;
var y2;
var Y2 = (y2 = (v = S.default) != null ? v : M2) != null ? y2 : Q2;

// deno:https://esm.sh/v86/events@3.3.0/es2019/events.bundle.js
var T3 = Object.create;
var m2 = Object.defineProperty;
var F2 = Object.getOwnPropertyDescriptor;
var I2 = Object.getOwnPropertyNames;
var K3 = Object.getPrototypeOf;
var W2 = Object.prototype.hasOwnProperty;
var $2 = (t, e) => () => (e || t((e = { exports: {} }).exports, e), e.exports);
var S2 = (t, e, n, r) => {
  if (e && typeof e == "object" || typeof e == "function")
    for (let i of I2(e))
      !W2.call(t, i) && i !== n && m2(t, i, { get: () => e[i], enumerable: !(r = F2(e, i)) || r.enumerable });
  return t;
};
var L2 = (t, e, n) => (n = t != null ? T3(K3(t)) : {}, S2(e || !t || !t.__esModule ? m2(n, "default", { value: t, enumerable: true }) : n, t));
var d3 = $2((Q3, p3) => {
  "use strict";
  var a = typeof Reflect == "object" ? Reflect : null, y4 = a && typeof a.apply == "function" ? a.apply : function(e, n, r) {
    return Function.prototype.apply.call(e, n, r);
  }, l;
  a && typeof a.ownKeys == "function" ? l = a.ownKeys : Object.getOwnPropertySymbols ? l = function(e) {
    return Object.getOwnPropertyNames(e).concat(Object.getOwnPropertySymbols(e));
  } : l = function(e) {
    return Object.getOwnPropertyNames(e);
  };
  function U2(t) {
    console && console.warn && console.warn(t);
  }
  var _2 = Number.isNaN || function(e) {
    return e !== e;
  };
  function o2() {
    o2.init.call(this);
  }
  p3.exports = o2;
  p3.exports.once = z;
  o2.EventEmitter = o2;
  o2.prototype._events = void 0;
  o2.prototype._eventsCount = 0;
  o2.prototype._maxListeners = void 0;
  var g2 = 10;
  function v2(t) {
    if (typeof t != "function")
      throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof t);
  }
  Object.defineProperty(o2, "defaultMaxListeners", { enumerable: true, get: function() {
    return g2;
  }, set: function(t) {
    if (typeof t != "number" || t < 0 || _2(t))
      throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + t + ".");
    g2 = t;
  } });
  o2.init = function() {
    (this._events === void 0 || this._events === Object.getPrototypeOf(this)._events) && (this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0), this._maxListeners = this._maxListeners || void 0;
  };
  o2.prototype.setMaxListeners = function(e) {
    if (typeof e != "number" || e < 0 || _2(e))
      throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + e + ".");
    return this._maxListeners = e, this;
  };
  function w2(t) {
    return t._maxListeners === void 0 ? o2.defaultMaxListeners : t._maxListeners;
  }
  o2.prototype.getMaxListeners = function() {
    return w2(this);
  };
  o2.prototype.emit = function(e) {
    for (var n = [], r = 1; r < arguments.length; r++)
      n.push(arguments[r]);
    var i = e === "error", f = this._events;
    if (f !== void 0)
      i = i && f.error === void 0;
    else if (!i)
      return false;
    if (i) {
      var s;
      if (n.length > 0 && (s = n[0]), s instanceof Error)
        throw s;
      var u = new Error("Unhandled error." + (s ? " (" + s.message + ")" : ""));
      throw u.context = s, u;
    }
    var c5 = f[e];
    if (c5 === void 0)
      return false;
    if (typeof c5 == "function")
      y4(c5, this, n);
    else
      for (var h = c5.length, P2 = C(c5, h), r = 0; r < h; ++r)
        y4(P2[r], this, n);
    return true;
  };
  function b2(t, e, n, r) {
    var i, f, s;
    if (v2(n), f = t._events, f === void 0 ? (f = t._events = /* @__PURE__ */ Object.create(null), t._eventsCount = 0) : (f.newListener !== void 0 && (t.emit("newListener", e, n.listener ? n.listener : n), f = t._events), s = f[e]), s === void 0)
      s = f[e] = n, ++t._eventsCount;
    else if (typeof s == "function" ? s = f[e] = r ? [n, s] : [s, n] : r ? s.unshift(n) : s.push(n), i = w2(t), i > 0 && s.length > i && !s.warned) {
      s.warned = true;
      var u = new Error("Possible EventEmitter memory leak detected. " + s.length + " " + String(e) + " listeners added. Use emitter.setMaxListeners() to increase limit");
      u.name = "MaxListenersExceededWarning", u.emitter = t, u.type = e, u.count = s.length, U2(u);
    }
    return t;
  }
  o2.prototype.addListener = function(e, n) {
    return b2(this, e, n, false);
  };
  o2.prototype.on = o2.prototype.addListener;
  o2.prototype.prependListener = function(e, n) {
    return b2(this, e, n, true);
  };
  function k6() {
    if (!this.fired)
      return this.target.removeListener(this.type, this.wrapFn), this.fired = true, arguments.length === 0 ? this.listener.call(this.target) : this.listener.apply(this.target, arguments);
  }
  function E2(t, e, n) {
    var r = { fired: false, wrapFn: void 0, target: t, type: e, listener: n }, i = k6.bind(r);
    return i.listener = n, r.wrapFn = i, i;
  }
  o2.prototype.once = function(e, n) {
    return v2(n), this.on(e, E2(this, e, n)), this;
  };
  o2.prototype.prependOnceListener = function(e, n) {
    return v2(n), this.prependListener(e, E2(this, e, n)), this;
  };
  o2.prototype.removeListener = function(e, n) {
    var r, i, f, s, u;
    if (v2(n), i = this._events, i === void 0)
      return this;
    if (r = i[e], r === void 0)
      return this;
    if (r === n || r.listener === n)
      --this._eventsCount === 0 ? this._events = /* @__PURE__ */ Object.create(null) : (delete i[e], i.removeListener && this.emit("removeListener", e, r.listener || n));
    else if (typeof r != "function") {
      for (f = -1, s = r.length - 1; s >= 0; s--)
        if (r[s] === n || r[s].listener === n) {
          u = r[s].listener, f = s;
          break;
        }
      if (f < 0)
        return this;
      f === 0 ? r.shift() : H3(r, f), r.length === 1 && (i[e] = r[0]), i.removeListener !== void 0 && this.emit("removeListener", e, u || n);
    }
    return this;
  };
  o2.prototype.off = o2.prototype.removeListener;
  o2.prototype.removeAllListeners = function(e) {
    var n, r, i;
    if (r = this._events, r === void 0)
      return this;
    if (r.removeListener === void 0)
      return arguments.length === 0 ? (this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0) : r[e] !== void 0 && (--this._eventsCount === 0 ? this._events = /* @__PURE__ */ Object.create(null) : delete r[e]), this;
    if (arguments.length === 0) {
      var f = Object.keys(r), s;
      for (i = 0; i < f.length; ++i)
        s = f[i], s !== "removeListener" && this.removeAllListeners(s);
      return this.removeAllListeners("removeListener"), this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0, this;
    }
    if (n = r[e], typeof n == "function")
      this.removeListener(e, n);
    else if (n !== void 0)
      for (i = n.length - 1; i >= 0; i--)
        this.removeListener(e, n[i]);
    return this;
  };
  function O(t, e, n) {
    var r = t._events;
    if (r === void 0)
      return [];
    var i = r[e];
    return i === void 0 ? [] : typeof i == "function" ? n ? [i.listener || i] : [i] : n ? q(i) : C(i, i.length);
  }
  o2.prototype.listeners = function(e) {
    return O(this, e, true);
  };
  o2.prototype.rawListeners = function(e) {
    return O(this, e, false);
  };
  o2.listenerCount = function(t, e) {
    return typeof t.listenerCount == "function" ? t.listenerCount(e) : x.call(t, e);
  };
  o2.prototype.listenerCount = x;
  function x(t) {
    var e = this._events;
    if (e !== void 0) {
      var n = e[t];
      if (typeof n == "function")
        return 1;
      if (n !== void 0)
        return n.length;
    }
    return 0;
  }
  o2.prototype.eventNames = function() {
    return this._eventsCount > 0 ? l(this._events) : [];
  };
  function C(t, e) {
    for (var n = new Array(e), r = 0; r < e; ++r)
      n[r] = t[r];
    return n;
  }
  function H3(t, e) {
    for (; e + 1 < t.length; e++)
      t[e] = t[e + 1];
    t.pop();
  }
  function q(t) {
    for (var e = new Array(t.length), n = 0; n < e.length; ++n)
      e[n] = t[n].listener || t[n];
    return e;
  }
  function z(t, e) {
    return new Promise(function(n, r) {
      function i(s) {
        t.removeListener(e, f), r(s);
      }
      function f() {
        typeof t.removeListener == "function" && t.removeListener("error", i), n([].slice.call(arguments));
      }
      j2(t, e, f, { once: true }), e !== "error" && B3(t, i, { once: true });
    });
  }
  function B3(t, e, n) {
    typeof t.on == "function" && j2(t, "error", e, n);
  }
  function j2(t, e, n, r) {
    if (typeof t.on == "function")
      r.once ? t.once(e, n) : t.on(e, n);
    else if (typeof t.addEventListener == "function")
      t.addEventListener(e, function i(f) {
        r.once && t.removeEventListener(e, i), n(f);
      });
    else
      throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof t);
  }
});
var M3 = L2(d3());
var A2 = L2(d3());
var { EventEmitter: V2, init: X4, listenerCount: Y3, once: Z2 } = A2;
var { default: D3, ...G2 } = A2;
var R2;
var N3;
var ee = (N3 = (R2 = M3.default) != null ? R2 : D3) != null ? N3 : G2;

// deno:https://esm.sh/v86/util@0.12.4/es2019/util.bundle.js
var __global$2 = globalThis || (typeof window !== "undefined" ? window : self);
var ut2 = Object.create;
var qr = Object.defineProperty;
var st = Object.getOwnPropertyDescriptor;
var yt = Object.getOwnPropertyNames;
var pt = Object.getPrototypeOf;
var ct2 = Object.prototype.hasOwnProperty;
var c2 = (r, e) => () => (e || r((e = { exports: {} }).exports, e), e.exports);
var lt2 = (r, e, t, n) => {
  if (e && typeof e == "object" || typeof e == "function")
    for (let o2 of yt(e))
      !ct2.call(r, o2) && o2 !== t && qr(r, o2, { get: () => e[o2], enumerable: !(n = st(e, o2)) || n.enumerable });
  return r;
};
var Gr = (r, e, t) => (t = r != null ? ut2(pt(r)) : {}, lt2(e || !r || !r.__esModule ? qr(t, "default", { value: r, enumerable: true }) : t, r));
var pr = c2((io, Cr2) => {
  "use strict";
  Cr2.exports = function() {
    if (typeof Symbol != "function" || typeof Object.getOwnPropertySymbols != "function")
      return false;
    if (typeof Symbol.iterator == "symbol")
      return true;
    var e = {}, t = Symbol("test"), n = Object(t);
    if (typeof t == "string" || Object.prototype.toString.call(t) !== "[object Symbol]" || Object.prototype.toString.call(n) !== "[object Symbol]")
      return false;
    var o2 = 42;
    e[t] = o2;
    for (t in e)
      return false;
    if (typeof Object.keys == "function" && Object.keys(e).length !== 0 || typeof Object.getOwnPropertyNames == "function" && Object.getOwnPropertyNames(e).length !== 0)
      return false;
    var a = Object.getOwnPropertySymbols(e);
    if (a.length !== 1 || a[0] !== t || !Object.prototype.propertyIsEnumerable.call(e, t))
      return false;
    if (typeof Object.getOwnPropertyDescriptor == "function") {
      var i = Object.getOwnPropertyDescriptor(e, t);
      if (i.value !== o2 || i.enumerable !== true)
        return false;
    }
    return true;
  };
});
var D4 = c2((ao, Wr2) => {
  "use strict";
  var gt2 = pr();
  Wr2.exports = function() {
    return gt2() && !!Symbol.toStringTag;
  };
});
var Vr = c2((fo, zr) => {
  "use strict";
  var _r2 = typeof Symbol != "undefined" && Symbol, dt = pr();
  zr.exports = function() {
    return typeof _r2 != "function" || typeof Symbol != "function" || typeof _r2("foo") != "symbol" || typeof Symbol("bar") != "symbol" ? false : dt();
  };
});
var Lr = c2((uo, Jr) => {
  "use strict";
  var bt = "Function.prototype.bind called on incompatible ", cr = Array.prototype.slice, mt = Object.prototype.toString, At2 = "[object Function]";
  Jr.exports = function(e) {
    var t = this;
    if (typeof t != "function" || mt.call(t) !== At2)
      throw new TypeError(bt + t);
    for (var n = cr.call(arguments, 1), o2, a = function() {
      if (this instanceof o2) {
        var g2 = t.apply(this, n.concat(cr.call(arguments)));
        return Object(g2) === g2 ? g2 : this;
      } else
        return t.apply(e, n.concat(cr.call(arguments)));
    }, i = Math.max(0, t.length - n.length), f = [], y4 = 0; y4 < i; y4++)
      f.push("$" + y4);
    if (o2 = Function("binder", "return function (" + f.join(",") + "){ return binder.apply(this,arguments); }")(a), t.prototype) {
      var l = function() {
      };
      l.prototype = t.prototype, o2.prototype = new l(), l.prototype = null;
    }
    return o2;
  };
});
var _ = c2((so, Hr) => {
  "use strict";
  var St = Lr();
  Hr.exports = Function.prototype.bind || St;
});
var Yr = c2((yo, Zr3) => {
  "use strict";
  var ht4 = _();
  Zr3.exports = ht4.call(Function.call, Object.prototype.hasOwnProperty);
});
var J2 = c2((po3, re2) => {
  "use strict";
  var p3, B3 = SyntaxError, Xr2 = Function, T4 = TypeError, lr = function(r) {
    try {
      return Xr2('"use strict"; return (' + r + ").constructor;")();
    } catch {
    }
  }, v2 = Object.getOwnPropertyDescriptor;
  if (v2)
    try {
      v2({}, "");
    } catch {
      v2 = null;
    }
  var gr2 = function() {
    throw new T4();
  }, vt = v2 ? function() {
    try {
      return arguments.callee, gr2;
    } catch {
      try {
        return v2(arguments, "callee").get;
      } catch {
        return gr2;
      }
    }
  }() : gr2, E2 = Vr()(), A4 = Object.getPrototypeOf || function(r) {
    return r.__proto__;
  }, F4 = {}, Ot = typeof Uint8Array == "undefined" ? p3 : A4(Uint8Array), I3 = { "%AggregateError%": typeof AggregateError == "undefined" ? p3 : AggregateError, "%Array%": Array, "%ArrayBuffer%": typeof ArrayBuffer == "undefined" ? p3 : ArrayBuffer, "%ArrayIteratorPrototype%": E2 ? A4([][Symbol.iterator]()) : p3, "%AsyncFromSyncIteratorPrototype%": p3, "%AsyncFunction%": F4, "%AsyncGenerator%": F4, "%AsyncGeneratorFunction%": F4, "%AsyncIteratorPrototype%": F4, "%Atomics%": typeof Atomics == "undefined" ? p3 : Atomics, "%BigInt%": typeof BigInt == "undefined" ? p3 : BigInt, "%Boolean%": Boolean, "%DataView%": typeof DataView == "undefined" ? p3 : DataView, "%Date%": Date, "%decodeURI%": decodeURI, "%decodeURIComponent%": decodeURIComponent, "%encodeURI%": encodeURI, "%encodeURIComponent%": encodeURIComponent, "%Error%": Error, "%eval%": eval, "%EvalError%": EvalError, "%Float32Array%": typeof Float32Array == "undefined" ? p3 : Float32Array, "%Float64Array%": typeof Float64Array == "undefined" ? p3 : Float64Array, "%FinalizationRegistry%": typeof FinalizationRegistry == "undefined" ? p3 : FinalizationRegistry, "%Function%": Xr2, "%GeneratorFunction%": F4, "%Int8Array%": typeof Int8Array == "undefined" ? p3 : Int8Array, "%Int16Array%": typeof Int16Array == "undefined" ? p3 : Int16Array, "%Int32Array%": typeof Int32Array == "undefined" ? p3 : Int32Array, "%isFinite%": isFinite, "%isNaN%": isNaN, "%IteratorPrototype%": E2 ? A4(A4([][Symbol.iterator]())) : p3, "%JSON%": typeof JSON == "object" ? JSON : p3, "%Map%": typeof Map == "undefined" ? p3 : Map, "%MapIteratorPrototype%": typeof Map == "undefined" || !E2 ? p3 : A4((/* @__PURE__ */ new Map())[Symbol.iterator]()), "%Math%": Math, "%Number%": Number, "%Object%": Object, "%parseFloat%": parseFloat, "%parseInt%": parseInt, "%Promise%": typeof Promise == "undefined" ? p3 : Promise, "%Proxy%": typeof Proxy == "undefined" ? p3 : Proxy, "%RangeError%": RangeError, "%ReferenceError%": ReferenceError, "%Reflect%": typeof Reflect == "undefined" ? p3 : Reflect, "%RegExp%": RegExp, "%Set%": typeof Set == "undefined" ? p3 : Set, "%SetIteratorPrototype%": typeof Set == "undefined" || !E2 ? p3 : A4((/* @__PURE__ */ new Set())[Symbol.iterator]()), "%SharedArrayBuffer%": typeof SharedArrayBuffer == "undefined" ? p3 : SharedArrayBuffer, "%String%": String, "%StringIteratorPrototype%": E2 ? A4(""[Symbol.iterator]()) : p3, "%Symbol%": E2 ? Symbol : p3, "%SyntaxError%": B3, "%ThrowTypeError%": vt, "%TypedArray%": Ot, "%TypeError%": T4, "%Uint8Array%": typeof Uint8Array == "undefined" ? p3 : Uint8Array, "%Uint8ClampedArray%": typeof Uint8ClampedArray == "undefined" ? p3 : Uint8ClampedArray, "%Uint16Array%": typeof Uint16Array == "undefined" ? p3 : Uint16Array, "%Uint32Array%": typeof Uint32Array == "undefined" ? p3 : Uint32Array, "%URIError%": URIError, "%WeakMap%": typeof WeakMap == "undefined" ? p3 : WeakMap, "%WeakRef%": typeof WeakRef == "undefined" ? p3 : WeakRef, "%WeakSet%": typeof WeakSet == "undefined" ? p3 : WeakSet }, Pt2 = function r(e) {
    var t;
    if (e === "%AsyncFunction%")
      t = lr("async function () {}");
    else if (e === "%GeneratorFunction%")
      t = lr("function* () {}");
    else if (e === "%AsyncGeneratorFunction%")
      t = lr("async function* () {}");
    else if (e === "%AsyncGenerator%") {
      var n = r("%AsyncGeneratorFunction%");
      n && (t = n.prototype);
    } else if (e === "%AsyncIteratorPrototype%") {
      var o2 = r("%AsyncGenerator%");
      o2 && (t = A4(o2.prototype));
    }
    return I3[e] = t, t;
  }, Kr = { "%ArrayBufferPrototype%": ["ArrayBuffer", "prototype"], "%ArrayPrototype%": ["Array", "prototype"], "%ArrayProto_entries%": ["Array", "prototype", "entries"], "%ArrayProto_forEach%": ["Array", "prototype", "forEach"], "%ArrayProto_keys%": ["Array", "prototype", "keys"], "%ArrayProto_values%": ["Array", "prototype", "values"], "%AsyncFunctionPrototype%": ["AsyncFunction", "prototype"], "%AsyncGenerator%": ["AsyncGeneratorFunction", "prototype"], "%AsyncGeneratorPrototype%": ["AsyncGeneratorFunction", "prototype", "prototype"], "%BooleanPrototype%": ["Boolean", "prototype"], "%DataViewPrototype%": ["DataView", "prototype"], "%DatePrototype%": ["Date", "prototype"], "%ErrorPrototype%": ["Error", "prototype"], "%EvalErrorPrototype%": ["EvalError", "prototype"], "%Float32ArrayPrototype%": ["Float32Array", "prototype"], "%Float64ArrayPrototype%": ["Float64Array", "prototype"], "%FunctionPrototype%": ["Function", "prototype"], "%Generator%": ["GeneratorFunction", "prototype"], "%GeneratorPrototype%": ["GeneratorFunction", "prototype", "prototype"], "%Int8ArrayPrototype%": ["Int8Array", "prototype"], "%Int16ArrayPrototype%": ["Int16Array", "prototype"], "%Int32ArrayPrototype%": ["Int32Array", "prototype"], "%JSONParse%": ["JSON", "parse"], "%JSONStringify%": ["JSON", "stringify"], "%MapPrototype%": ["Map", "prototype"], "%NumberPrototype%": ["Number", "prototype"], "%ObjectPrototype%": ["Object", "prototype"], "%ObjProto_toString%": ["Object", "prototype", "toString"], "%ObjProto_valueOf%": ["Object", "prototype", "valueOf"], "%PromisePrototype%": ["Promise", "prototype"], "%PromiseProto_then%": ["Promise", "prototype", "then"], "%Promise_all%": ["Promise", "all"], "%Promise_reject%": ["Promise", "reject"], "%Promise_resolve%": ["Promise", "resolve"], "%RangeErrorPrototype%": ["RangeError", "prototype"], "%ReferenceErrorPrototype%": ["ReferenceError", "prototype"], "%RegExpPrototype%": ["RegExp", "prototype"], "%SetPrototype%": ["Set", "prototype"], "%SharedArrayBufferPrototype%": ["SharedArrayBuffer", "prototype"], "%StringPrototype%": ["String", "prototype"], "%SymbolPrototype%": ["Symbol", "prototype"], "%SyntaxErrorPrototype%": ["SyntaxError", "prototype"], "%TypedArrayPrototype%": ["TypedArray", "prototype"], "%TypeErrorPrototype%": ["TypeError", "prototype"], "%Uint8ArrayPrototype%": ["Uint8Array", "prototype"], "%Uint8ClampedArrayPrototype%": ["Uint8ClampedArray", "prototype"], "%Uint16ArrayPrototype%": ["Uint16Array", "prototype"], "%Uint32ArrayPrototype%": ["Uint32Array", "prototype"], "%URIErrorPrototype%": ["URIError", "prototype"], "%WeakMapPrototype%": ["WeakMap", "prototype"], "%WeakSetPrototype%": ["WeakSet", "prototype"] }, N4 = _(), z = Yr(), jt2 = N4.call(Function.call, Array.prototype.concat), wt = N4.call(Function.apply, Array.prototype.splice), Qr2 = N4.call(Function.call, String.prototype.replace), V3 = N4.call(Function.call, String.prototype.slice), Et2 = N4.call(Function.call, RegExp.prototype.exec), Ft = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g, Tt2 = /\\(\\)?/g, It2 = function(e) {
    var t = V3(e, 0, 1), n = V3(e, -1);
    if (t === "%" && n !== "%")
      throw new B3("invalid intrinsic syntax, expected closing `%`");
    if (n === "%" && t !== "%")
      throw new B3("invalid intrinsic syntax, expected opening `%`");
    var o2 = [];
    return Qr2(e, Ft, function(a, i, f, y4) {
      o2[o2.length] = f ? Qr2(y4, Tt2, "$1") : i || a;
    }), o2;
  }, Bt = function(e, t) {
    var n = e, o2;
    if (z(Kr, n) && (o2 = Kr[n], n = "%" + o2[0] + "%"), z(I3, n)) {
      var a = I3[n];
      if (a === F4 && (a = Pt2(n)), typeof a == "undefined" && !t)
        throw new T4("intrinsic " + e + " exists, but is not available. Please file an issue!");
      return { alias: o2, name: n, value: a };
    }
    throw new B3("intrinsic " + e + " does not exist!");
  };
  re2.exports = function(e, t) {
    if (typeof e != "string" || e.length === 0)
      throw new T4("intrinsic name must be a non-empty string");
    if (arguments.length > 1 && typeof t != "boolean")
      throw new T4('"allowMissing" argument must be a boolean');
    if (Et2(/^%?[^%]*%?$/g, e) === null)
      throw new B3("`%` may not be present anywhere but at the beginning and end of the intrinsic name");
    var n = It2(e), o2 = n.length > 0 ? n[0] : "", a = Bt("%" + o2 + "%", t), i = a.name, f = a.value, y4 = false, l = a.alias;
    l && (o2 = l[0], wt(n, jt2([0, 1], l)));
    for (var g2 = 1, h = true; g2 < n.length; g2 += 1) {
      var d4 = n[g2], w2 = V3(d4, 0, 1), C = V3(d4, -1);
      if ((w2 === '"' || w2 === "'" || w2 === "`" || C === '"' || C === "'" || C === "`") && w2 !== C)
        throw new B3("property names with quotes must have matching quotes");
      if ((d4 === "constructor" || !h) && (y4 = true), o2 += "." + d4, i = "%" + o2 + "%", z(I3, i))
        f = I3[i];
      else if (f != null) {
        if (!(d4 in f)) {
          if (!t)
            throw new T4("base intrinsic for " + e + " exists, but the property is not available.");
          return;
        }
        if (v2 && g2 + 1 >= n.length) {
          var W4 = v2(f, d4);
          h = !!W4, h && "get" in W4 && !("originalValue" in W4.get) ? f = W4.get : f = f[d4];
        } else
          h = z(f, d4), f = f[d4];
        h && !y4 && (I3[i] = f);
      }
    }
    return f;
  };
});
var ae = c2((co, L4) => {
  "use strict";
  var dr2 = _(), U2 = J2(), ne = U2("%Function.prototype.apply%"), oe = U2("%Function.prototype.call%"), ie = U2("%Reflect.apply%", true) || dr2.call(oe, ne), ee2 = U2("%Object.getOwnPropertyDescriptor%", true), O = U2("%Object.defineProperty%", true), Ut = U2("%Math.max%");
  if (O)
    try {
      O({}, "a", { value: 1 });
    } catch {
      O = null;
    }
  L4.exports = function(e) {
    var t = ie(dr2, oe, arguments);
    if (ee2 && O) {
      var n = ee2(t, "length");
      n.configurable && O(t, "length", { value: 1 + Ut(0, e.length - (arguments.length - 1)) });
    }
    return t;
  };
  var te = function() {
    return ie(dr2, ne, arguments);
  };
  O ? O(L4.exports, "apply", { value: te }) : L4.exports.apply = te;
});
var H2 = c2((lo3, se) => {
  "use strict";
  var fe = J2(), ue2 = ae(), Rt2 = ue2(fe("String.prototype.indexOf"));
  se.exports = function(e, t) {
    var n = fe(e, !!t);
    return typeof n == "function" && Rt2(e, ".prototype.") > -1 ? ue2(n) : n;
  };
});
var ce = c2((go, pe) => {
  "use strict";
  var kt2 = D4()(), xt2 = H2(), br = xt2("Object.prototype.toString"), Z5 = function(e) {
    return kt2 && e && typeof e == "object" && Symbol.toStringTag in e ? false : br(e) === "[object Arguments]";
  }, ye = function(e) {
    return Z5(e) ? true : e !== null && typeof e == "object" && typeof e.length == "number" && e.length >= 0 && br(e) !== "[object Array]" && br(e.callee) === "[object Function]";
  }, Dt = function() {
    return Z5(arguments);
  }();
  Z5.isLegacyArguments = ye;
  pe.exports = Dt ? Z5 : ye;
});
var de = c2((bo, ge2) => {
  "use strict";
  var Nt2 = Object.prototype.toString, Mt = Function.prototype.toString, $t = /^\s*(?:function)?\*/, le2 = D4()(), mr = Object.getPrototypeOf, qt2 = function() {
    if (!le2)
      return false;
    try {
      return Function("return function*() {}")();
    } catch {
    }
  }, Ar;
  ge2.exports = function(e) {
    if (typeof e != "function")
      return false;
    if ($t.test(Mt.call(e)))
      return true;
    if (!le2) {
      var t = Nt2.call(e);
      return t === "[object GeneratorFunction]";
    }
    if (!mr)
      return false;
    if (typeof Ar == "undefined") {
      var n = qt2();
      Ar = n ? mr(n) : false;
    }
    return mr(e) === Ar;
  };
});
var Se = c2((mo, Ae3) => {
  "use strict";
  var me = Function.prototype.toString, R3 = typeof Reflect == "object" && Reflect !== null && Reflect.apply, Sr, Y4;
  if (typeof R3 == "function" && typeof Object.defineProperty == "function")
    try {
      Sr = Object.defineProperty({}, "length", { get: function() {
        throw Y4;
      } }), Y4 = {}, R3(function() {
        throw 42;
      }, null, Sr);
    } catch (r) {
      r !== Y4 && (R3 = null);
    }
  else
    R3 = null;
  var Gt = /^\s*class\b/, hr = function(e) {
    try {
      var t = me.call(e);
      return Gt.test(t);
    } catch {
      return false;
    }
  }, Ct2 = function(e) {
    try {
      return hr(e) ? false : (me.call(e), true);
    } catch {
      return false;
    }
  }, Wt2 = Object.prototype.toString, _t = "[object Function]", zt2 = "[object GeneratorFunction]", Vt3 = typeof Symbol == "function" && !!Symbol.toStringTag, be = typeof document == "object" && typeof document.all == "undefined" && document.all !== void 0 ? document.all : {};
  Ae3.exports = R3 ? function(e) {
    if (e === be)
      return true;
    if (!e || typeof e != "function" && typeof e != "object")
      return false;
    if (typeof e == "function" && !e.prototype)
      return true;
    try {
      R3(e, null, Sr);
    } catch (t) {
      if (t !== Y4)
        return false;
    }
    return !hr(e);
  } : function(e) {
    if (e === be)
      return true;
    if (!e || typeof e != "function" && typeof e != "object")
      return false;
    if (typeof e == "function" && !e.prototype)
      return true;
    if (Vt3)
      return Ct2(e);
    if (hr(e))
      return false;
    var t = Wt2.call(e);
    return t === _t || t === zt2;
  };
});
var vr3 = c2((Ao, ve2) => {
  "use strict";
  var Jt = Se(), Lt2 = Object.prototype.toString, he2 = Object.prototype.hasOwnProperty, Ht = function(e, t, n) {
    for (var o2 = 0, a = e.length; o2 < a; o2++)
      he2.call(e, o2) && (n == null ? t(e[o2], o2, e) : t.call(n, e[o2], o2, e));
  }, Zt2 = function(e, t, n) {
    for (var o2 = 0, a = e.length; o2 < a; o2++)
      n == null ? t(e.charAt(o2), o2, e) : t.call(n, e.charAt(o2), o2, e);
  }, Yt = function(e, t, n) {
    for (var o2 in e)
      he2.call(e, o2) && (n == null ? t(e[o2], o2, e) : t.call(n, e[o2], o2, e));
  }, Kt2 = function(e, t, n) {
    if (!Jt(t))
      throw new TypeError("iterator must be a function");
    var o2;
    arguments.length >= 3 && (o2 = n), Lt2.call(e) === "[object Array]" ? Ht(e, t, o2) : typeof e == "string" ? Zt2(e, t, o2) : Yt(e, t, o2);
  };
  ve2.exports = Kt2;
});
var Pr = c2((So, Oe) => {
  "use strict";
  var Or2 = ["BigInt64Array", "BigUint64Array", "Float32Array", "Float64Array", "Int16Array", "Int32Array", "Int8Array", "Uint16Array", "Uint32Array", "Uint8Array", "Uint8ClampedArray"], Qt = typeof globalThis == "undefined" ? __global$2 : globalThis;
  Oe.exports = function() {
    for (var e = [], t = 0; t < Or2.length; t++)
      typeof Qt[Or2[t]] == "function" && (e[e.length] = Or2[t]);
    return e;
  };
});
var jr = c2((ho, Pe) => {
  "use strict";
  var Xt = J2(), K4 = Xt("%Object.getOwnPropertyDescriptor%", true);
  if (K4)
    try {
      K4([], "length");
    } catch {
      K4 = null;
    }
  Pe.exports = K4;
});
var Fr = c2((vo, Te) => {
  "use strict";
  var je2 = vr3(), rn3 = Pr(), Er3 = H2(), en = Er3("Object.prototype.toString"), we2 = D4()(), tn = typeof globalThis == "undefined" ? __global$2 : globalThis, Ee2 = rn3(), nn = Er3("Array.prototype.indexOf", true) || function(e, t) {
    for (var n = 0; n < e.length; n += 1)
      if (e[n] === t)
        return n;
    return -1;
  }, on2 = Er3("String.prototype.slice"), Fe4 = {}, Q3 = jr(), wr2 = Object.getPrototypeOf;
  we2 && Q3 && wr2 && je2(Ee2, function(r) {
    var e = new tn[r]();
    if (Symbol.toStringTag in e) {
      var t = wr2(e), n = Q3(t, Symbol.toStringTag);
      if (!n) {
        var o2 = wr2(t);
        n = Q3(o2, Symbol.toStringTag);
      }
      Fe4[r] = n.get;
    }
  });
  var an = function(e) {
    var t = false;
    return je2(Fe4, function(n, o2) {
      if (!t)
        try {
          t = n.call(e) === o2;
        } catch {
        }
    }), t;
  };
  Te.exports = function(e) {
    if (!e || typeof e != "object")
      return false;
    if (!we2 || !(Symbol.toStringTag in e)) {
      var t = on2(en(e), 8, -1);
      return nn(Ee2, t) > -1;
    }
    return Q3 ? an(e) : false;
  };
});
var De = c2((Oo, xe3) => {
  "use strict";
  var Be3 = vr3(), fn = Pr(), Ue3 = H2(), un = Ue3("Object.prototype.toString"), Re = D4()(), Ie = typeof globalThis == "undefined" ? __global$2 : globalThis, sn = fn(), yn = Ue3("String.prototype.slice"), ke = {}, Tr2 = jr(), Ir2 = Object.getPrototypeOf;
  Re && Tr2 && Ir2 && Be3(sn, function(r) {
    if (typeof Ie[r] == "function") {
      var e = new Ie[r]();
      if (Symbol.toStringTag in e) {
        var t = Ir2(e), n = Tr2(t, Symbol.toStringTag);
        if (!n) {
          var o2 = Ir2(t);
          n = Tr2(o2, Symbol.toStringTag);
        }
        ke[r] = n.get;
      }
    }
  });
  var pn = function(e) {
    var t = false;
    return Be3(ke, function(n, o2) {
      if (!t)
        try {
          var a = n.call(e);
          a === o2 && (t = a);
        } catch {
        }
    }), t;
  }, cn = Fr();
  xe3.exports = function(e) {
    return cn(e) ? !Re || !(Symbol.toStringTag in e) ? yn(un(e), 8, -1) : pn(e) : false;
  };
});
var Ze = c2((u) => {
  "use strict";
  var ln = ce(), gn = de(), m3 = De(), Ne3 = Fr();
  function k6(r) {
    return r.call.bind(r);
  }
  var Me = typeof BigInt != "undefined", $e2 = typeof Symbol != "undefined", b2 = k6(Object.prototype.toString), dn = k6(Number.prototype.valueOf), bn3 = k6(String.prototype.valueOf), mn = k6(Boolean.prototype.valueOf);
  Me && (qe3 = k6(BigInt.prototype.valueOf));
  var qe3;
  $e2 && (Ge2 = k6(Symbol.prototype.valueOf));
  var Ge2;
  function $4(r, e) {
    if (typeof r != "object")
      return false;
    try {
      return e(r), true;
    } catch {
      return false;
    }
  }
  u.isArgumentsObject = ln;
  u.isGeneratorFunction = gn;
  u.isTypedArray = Ne3;
  function An(r) {
    return typeof Promise != "undefined" && r instanceof Promise || r !== null && typeof r == "object" && typeof r.then == "function" && typeof r.catch == "function";
  }
  u.isPromise = An;
  function Sn(r) {
    return typeof ArrayBuffer != "undefined" && ArrayBuffer.isView ? ArrayBuffer.isView(r) : Ne3(r) || We(r);
  }
  u.isArrayBufferView = Sn;
  function hn(r) {
    return m3(r) === "Uint8Array";
  }
  u.isUint8Array = hn;
  function vn3(r) {
    return m3(r) === "Uint8ClampedArray";
  }
  u.isUint8ClampedArray = vn3;
  function On3(r) {
    return m3(r) === "Uint16Array";
  }
  u.isUint16Array = On3;
  function Pn(r) {
    return m3(r) === "Uint32Array";
  }
  u.isUint32Array = Pn;
  function jn(r) {
    return m3(r) === "Int8Array";
  }
  u.isInt8Array = jn;
  function wn(r) {
    return m3(r) === "Int16Array";
  }
  u.isInt16Array = wn;
  function En(r) {
    return m3(r) === "Int32Array";
  }
  u.isInt32Array = En;
  function Fn(r) {
    return m3(r) === "Float32Array";
  }
  u.isFloat32Array = Fn;
  function Tn(r) {
    return m3(r) === "Float64Array";
  }
  u.isFloat64Array = Tn;
  function In(r) {
    return m3(r) === "BigInt64Array";
  }
  u.isBigInt64Array = In;
  function Bn(r) {
    return m3(r) === "BigUint64Array";
  }
  u.isBigUint64Array = Bn;
  function X5(r) {
    return b2(r) === "[object Map]";
  }
  X5.working = typeof Map != "undefined" && X5(/* @__PURE__ */ new Map());
  function Un(r) {
    return typeof Map == "undefined" ? false : X5.working ? X5(r) : r instanceof Map;
  }
  u.isMap = Un;
  function rr(r) {
    return b2(r) === "[object Set]";
  }
  rr.working = typeof Set != "undefined" && rr(/* @__PURE__ */ new Set());
  function Rn(r) {
    return typeof Set == "undefined" ? false : rr.working ? rr(r) : r instanceof Set;
  }
  u.isSet = Rn;
  function er(r) {
    return b2(r) === "[object WeakMap]";
  }
  er.working = typeof WeakMap != "undefined" && er(/* @__PURE__ */ new WeakMap());
  function kn(r) {
    return typeof WeakMap == "undefined" ? false : er.working ? er(r) : r instanceof WeakMap;
  }
  u.isWeakMap = kn;
  function Ur3(r) {
    return b2(r) === "[object WeakSet]";
  }
  Ur3.working = typeof WeakSet != "undefined" && Ur3(/* @__PURE__ */ new WeakSet());
  function xn(r) {
    return Ur3(r);
  }
  u.isWeakSet = xn;
  function tr(r) {
    return b2(r) === "[object ArrayBuffer]";
  }
  tr.working = typeof ArrayBuffer != "undefined" && tr(new ArrayBuffer());
  function Ce3(r) {
    return typeof ArrayBuffer == "undefined" ? false : tr.working ? tr(r) : r instanceof ArrayBuffer;
  }
  u.isArrayBuffer = Ce3;
  function nr(r) {
    return b2(r) === "[object DataView]";
  }
  nr.working = typeof ArrayBuffer != "undefined" && typeof DataView != "undefined" && nr(new DataView(new ArrayBuffer(1), 0, 1));
  function We(r) {
    return typeof DataView == "undefined" ? false : nr.working ? nr(r) : r instanceof DataView;
  }
  u.isDataView = We;
  var Br2 = typeof SharedArrayBuffer != "undefined" ? SharedArrayBuffer : void 0;
  function M4(r) {
    return b2(r) === "[object SharedArrayBuffer]";
  }
  function _e2(r) {
    return typeof Br2 == "undefined" ? false : (typeof M4.working == "undefined" && (M4.working = M4(new Br2())), M4.working ? M4(r) : r instanceof Br2);
  }
  u.isSharedArrayBuffer = _e2;
  function Dn3(r) {
    return b2(r) === "[object AsyncFunction]";
  }
  u.isAsyncFunction = Dn3;
  function Nn(r) {
    return b2(r) === "[object Map Iterator]";
  }
  u.isMapIterator = Nn;
  function Mn(r) {
    return b2(r) === "[object Set Iterator]";
  }
  u.isSetIterator = Mn;
  function $n3(r) {
    return b2(r) === "[object Generator]";
  }
  u.isGeneratorObject = $n3;
  function qn3(r) {
    return b2(r) === "[object WebAssembly.Module]";
  }
  u.isWebAssemblyCompiledModule = qn3;
  function ze(r) {
    return $4(r, dn);
  }
  u.isNumberObject = ze;
  function Ve2(r) {
    return $4(r, bn3);
  }
  u.isStringObject = Ve2;
  function Je2(r) {
    return $4(r, mn);
  }
  u.isBooleanObject = Je2;
  function Le(r) {
    return Me && $4(r, qe3);
  }
  u.isBigIntObject = Le;
  function He2(r) {
    return $e2 && $4(r, Ge2);
  }
  u.isSymbolObject = He2;
  function Gn(r) {
    return ze(r) || Ve2(r) || Je2(r) || Le(r) || He2(r);
  }
  u.isBoxedPrimitive = Gn;
  function Cn(r) {
    return typeof Uint8Array != "undefined" && (Ce3(r) || _e2(r));
  }
  u.isAnyArrayBuffer = Cn;
  ["isProxy", "isExternal", "isModuleNamespaceObject"].forEach(function(r) {
    Object.defineProperty(u, r, { enumerable: false, value: function() {
      throw new Error(r + " is not supported in userland");
    } });
  });
});
var Ke2 = c2((jo, Ye2) => {
  Ye2.exports = function(e) {
    return e && typeof e == "object" && typeof e.copy == "function" && typeof e.fill == "function" && typeof e.readUInt8 == "function";
  };
});
var Qe = c2((wo, Rr2) => {
  typeof Object.create == "function" ? Rr2.exports = function(e, t) {
    t && (e.super_ = t, e.prototype = Object.create(t.prototype, { constructor: { value: e, enumerable: false, writable: true, configurable: true } }));
  } : Rr2.exports = function(e, t) {
    if (t) {
      e.super_ = t;
      var n = function() {
      };
      n.prototype = t.prototype, e.prototype = new n(), e.prototype.constructor = e;
    }
  };
});
var $r = c2((s) => {
  var Xe2 = Object.getOwnPropertyDescriptors || function(e) {
    for (var t = Object.keys(e), n = {}, o2 = 0; o2 < t.length; o2++)
      n[t[o2]] = Object.getOwnPropertyDescriptor(e, t[o2]);
    return n;
  }, Wn = /%[sdj%]/g;
  s.format = function(r) {
    if (!yr2(r)) {
      for (var e = [], t = 0; t < arguments.length; t++)
        e.push(S3(arguments[t]));
      return e.join(" ");
    }
    for (var t = 1, n = arguments, o2 = n.length, a = String(r).replace(Wn, function(f) {
      if (f === "%%")
        return "%";
      if (t >= o2)
        return f;
      switch (f) {
        case "%s":
          return String(n[t++]);
        case "%d":
          return Number(n[t++]);
        case "%j":
          try {
            return JSON.stringify(n[t++]);
          } catch {
            return "[Circular]";
          }
        default:
          return f;
      }
    }), i = n[t]; t < o2; i = n[++t])
      sr(i) || !x(i) ? a += " " + i : a += " " + S3(i);
    return a;
  };
  s.deprecate = function(r, e) {
    if (typeof node_process_default != "undefined" && node_process_default.noDeprecation === true)
      return r;
    if (typeof node_process_default == "undefined")
      return function() {
        return s.deprecate(r, e).apply(this, arguments);
      };
    var t = false;
    function n() {
      if (!t) {
        if (node_process_default.throwDeprecation)
          throw new Error(e);
        node_process_default.traceDeprecation ? console.trace(e) : console.error(e), t = true;
      }
      return r.apply(this, arguments);
    }
    return n;
  };
  var or2 = {}, rt2 = /^$/;
  node_process_default.env.NODE_DEBUG && (ir2 = node_process_default.env.NODE_DEBUG, ir2 = ir2.replace(/[|\\{}()[\]^$+?.]/g, "\\$&").replace(/\*/g, ".*").replace(/,/g, "$|^").toUpperCase(), rt2 = new RegExp("^" + ir2 + "$", "i"));
  var ir2;
  s.debuglog = function(r) {
    if (r = r.toUpperCase(), !or2[r])
      if (rt2.test(r)) {
        var e = node_process_default.pid;
        or2[r] = function() {
          var t = s.format.apply(s, arguments);
          console.error("%s %d: %s", r, e, t);
        };
      } else
        or2[r] = function() {
        };
    return or2[r];
  };
  function S3(r, e) {
    var t = { seen: [], stylize: zn };
    return arguments.length >= 3 && (t.depth = arguments[2]), arguments.length >= 4 && (t.colors = arguments[3]), Nr2(e) ? t.showHidden = e : e && s._extend(t, e), j2(t.showHidden) && (t.showHidden = false), j2(t.depth) && (t.depth = 2), j2(t.colors) && (t.colors = false), j2(t.customInspect) && (t.customInspect = true), t.colors && (t.stylize = _n3), fr(t, r, t.depth);
  }
  s.inspect = S3;
  S3.colors = { bold: [1, 22], italic: [3, 23], underline: [4, 24], inverse: [7, 27], white: [37, 39], grey: [90, 39], black: [30, 39], blue: [34, 39], cyan: [36, 39], green: [32, 39], magenta: [35, 39], red: [31, 39], yellow: [33, 39] };
  S3.styles = { special: "cyan", number: "yellow", boolean: "yellow", undefined: "grey", null: "bold", string: "green", date: "magenta", regexp: "red" };
  function _n3(r, e) {
    var t = S3.styles[e];
    return t ? "\x1B[" + S3.colors[t][0] + "m" + r + "\x1B[" + S3.colors[t][1] + "m" : r;
  }
  function zn(r, e) {
    return r;
  }
  function Vn(r) {
    var e = {};
    return r.forEach(function(t, n) {
      e[t] = true;
    }), e;
  }
  function fr(r, e, t) {
    if (r.customInspect && e && ar(e.inspect) && e.inspect !== s.inspect && !(e.constructor && e.constructor.prototype === e)) {
      var n = e.inspect(t, r);
      return yr2(n) || (n = fr(r, n, t)), n;
    }
    var o2 = Jn3(r, e);
    if (o2)
      return o2;
    var a = Object.keys(e), i = Vn(a);
    if (r.showHidden && (a = Object.getOwnPropertyNames(e)), G4(e) && (a.indexOf("message") >= 0 || a.indexOf("description") >= 0))
      return kr2(e);
    if (a.length === 0) {
      if (ar(e)) {
        var f = e.name ? ": " + e.name : "";
        return r.stylize("[Function" + f + "]", "special");
      }
      if (q(e))
        return r.stylize(RegExp.prototype.toString.call(e), "regexp");
      if (ur2(e))
        return r.stylize(Date.prototype.toString.call(e), "date");
      if (G4(e))
        return kr2(e);
    }
    var y4 = "", l = false, g2 = ["{", "}"];
    if (et(e) && (l = true, g2 = ["[", "]"]), ar(e)) {
      var h = e.name ? ": " + e.name : "";
      y4 = " [Function" + h + "]";
    }
    if (q(e) && (y4 = " " + RegExp.prototype.toString.call(e)), ur2(e) && (y4 = " " + Date.prototype.toUTCString.call(e)), G4(e) && (y4 = " " + kr2(e)), a.length === 0 && (!l || e.length == 0))
      return g2[0] + y4 + g2[1];
    if (t < 0)
      return q(e) ? r.stylize(RegExp.prototype.toString.call(e), "regexp") : r.stylize("[Object]", "special");
    r.seen.push(e);
    var d4;
    return l ? d4 = Ln3(r, e, t, i, a) : d4 = a.map(function(w2) {
      return Dr(r, e, t, i, w2, l);
    }), r.seen.pop(), Hn3(d4, y4, g2);
  }
  function Jn3(r, e) {
    if (j2(e))
      return r.stylize("undefined", "undefined");
    if (yr2(e)) {
      var t = "'" + JSON.stringify(e).replace(/^"|"$/g, "").replace(/'/g, "\\'").replace(/\\"/g, '"') + "'";
      return r.stylize(t, "string");
    }
    if (tt(e))
      return r.stylize("" + e, "number");
    if (Nr2(e))
      return r.stylize("" + e, "boolean");
    if (sr(e))
      return r.stylize("null", "null");
  }
  function kr2(r) {
    return "[" + Error.prototype.toString.call(r) + "]";
  }
  function Ln3(r, e, t, n, o2) {
    for (var a = [], i = 0, f = e.length; i < f; ++i)
      nt(e, String(i)) ? a.push(Dr(r, e, t, n, String(i), true)) : a.push("");
    return o2.forEach(function(y4) {
      y4.match(/^\d+$/) || a.push(Dr(r, e, t, n, y4, true));
    }), a;
  }
  function Dr(r, e, t, n, o2, a) {
    var i, f, y4;
    if (y4 = Object.getOwnPropertyDescriptor(e, o2) || { value: e[o2] }, y4.get ? y4.set ? f = r.stylize("[Getter/Setter]", "special") : f = r.stylize("[Getter]", "special") : y4.set && (f = r.stylize("[Setter]", "special")), nt(n, o2) || (i = "[" + o2 + "]"), f || (r.seen.indexOf(y4.value) < 0 ? (sr(t) ? f = fr(r, y4.value, null) : f = fr(r, y4.value, t - 1), f.indexOf(`
`) > -1 && (a ? f = f.split(`
`).map(function(l) {
      return "  " + l;
    }).join(`
`).substr(2) : f = `
` + f.split(`
`).map(function(l) {
      return "   " + l;
    }).join(`
`))) : f = r.stylize("[Circular]", "special")), j2(i)) {
      if (a && o2.match(/^\d+$/))
        return f;
      i = JSON.stringify("" + o2), i.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/) ? (i = i.substr(1, i.length - 2), i = r.stylize(i, "name")) : (i = i.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'"), i = r.stylize(i, "string"));
    }
    return i + ": " + f;
  }
  function Hn3(r, e, t) {
    var n = 0, o2 = r.reduce(function(a, i) {
      return n++, i.indexOf(`
`) >= 0 && n++, a + i.replace(/\u001b\[\d\d?m/g, "").length + 1;
    }, 0);
    return o2 > 60 ? t[0] + (e === "" ? "" : e + `
 `) + " " + r.join(`,
  `) + " " + t[1] : t[0] + e + " " + r.join(", ") + " " + t[1];
  }
  s.types = Ze();
  function et(r) {
    return Array.isArray(r);
  }
  s.isArray = et;
  function Nr2(r) {
    return typeof r == "boolean";
  }
  s.isBoolean = Nr2;
  function sr(r) {
    return r === null;
  }
  s.isNull = sr;
  function Zn(r) {
    return r == null;
  }
  s.isNullOrUndefined = Zn;
  function tt(r) {
    return typeof r == "number";
  }
  s.isNumber = tt;
  function yr2(r) {
    return typeof r == "string";
  }
  s.isString = yr2;
  function Yn(r) {
    return typeof r == "symbol";
  }
  s.isSymbol = Yn;
  function j2(r) {
    return r === void 0;
  }
  s.isUndefined = j2;
  function q(r) {
    return x(r) && Mr(r) === "[object RegExp]";
  }
  s.isRegExp = q;
  s.types.isRegExp = q;
  function x(r) {
    return typeof r == "object" && r !== null;
  }
  s.isObject = x;
  function ur2(r) {
    return x(r) && Mr(r) === "[object Date]";
  }
  s.isDate = ur2;
  s.types.isDate = ur2;
  function G4(r) {
    return x(r) && (Mr(r) === "[object Error]" || r instanceof Error);
  }
  s.isError = G4;
  s.types.isNativeError = G4;
  function ar(r) {
    return typeof r == "function";
  }
  s.isFunction = ar;
  function Kn(r) {
    return r === null || typeof r == "boolean" || typeof r == "number" || typeof r == "string" || typeof r == "symbol" || typeof r == "undefined";
  }
  s.isPrimitive = Kn;
  s.isBuffer = Ke2();
  function Mr(r) {
    return Object.prototype.toString.call(r);
  }
  function xr2(r) {
    return r < 10 ? "0" + r.toString(10) : r.toString(10);
  }
  var Qn = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"];
  function Xn() {
    var r = new Date(), e = [xr2(r.getHours()), xr2(r.getMinutes()), xr2(r.getSeconds())].join(":");
    return [r.getDate(), Qn[r.getMonth()], e].join(" ");
  }
  s.log = function() {
    console.log("%s - %s", Xn(), s.format.apply(s, arguments));
  };
  s.inherits = Qe();
  s._extend = function(r, e) {
    if (!e || !x(e))
      return r;
    for (var t = Object.keys(e), n = t.length; n--; )
      r[t[n]] = e[t[n]];
    return r;
  };
  function nt(r, e) {
    return Object.prototype.hasOwnProperty.call(r, e);
  }
  var P2 = typeof Symbol != "undefined" ? Symbol("util.promisify.custom") : void 0;
  s.promisify = function(e) {
    if (typeof e != "function")
      throw new TypeError('The "original" argument must be of type Function');
    if (P2 && e[P2]) {
      var t = e[P2];
      if (typeof t != "function")
        throw new TypeError('The "util.promisify.custom" argument must be of type Function');
      return Object.defineProperty(t, P2, { value: t, enumerable: false, writable: false, configurable: true }), t;
    }
    function t() {
      for (var n, o2, a = new Promise(function(y4, l) {
        n = y4, o2 = l;
      }), i = [], f = 0; f < arguments.length; f++)
        i.push(arguments[f]);
      i.push(function(y4, l) {
        y4 ? o2(y4) : n(l);
      });
      try {
        e.apply(this, i);
      } catch (y4) {
        o2(y4);
      }
      return a;
    }
    return Object.setPrototypeOf(t, Object.getPrototypeOf(e)), P2 && Object.defineProperty(t, P2, { value: t, enumerable: false, writable: false, configurable: true }), Object.defineProperties(t, Xe2(e));
  };
  s.promisify.custom = P2;
  function ro(r, e) {
    if (!r) {
      var t = new Error("Promise was rejected with a falsy value");
      t.reason = r, r = t;
    }
    return e(r);
  }
  function eo(r) {
    if (typeof r != "function")
      throw new TypeError('The "original" argument must be of type Function');
    function e() {
      for (var t = [], n = 0; n < arguments.length; n++)
        t.push(arguments[n]);
      var o2 = t.pop();
      if (typeof o2 != "function")
        throw new TypeError("The last argument must be of type Function");
      var a = this, i = function() {
        return o2.apply(a, arguments);
      };
      r.apply(this, t).then(function(f) {
        node_process_default.nextTick(i.bind(null, null, f));
      }, function(f) {
        node_process_default.nextTick(ro.bind(null, f, i));
      });
    }
    return Object.setPrototypeOf(e, Object.getPrototypeOf(r)), Object.defineProperties(e, Xe2(r)), e;
  }
  s.callbackify = eo;
});
var at = Gr($r());
var ft2 = Gr($r());
var { format: Fo, deprecate: To, debuglog: Io2, inspect: Bo, types: Uo, isArray: Ro, isBoolean: ko, isNull: xo, isNullOrUndefined: Do, isNumber: No, isString: Mo, isSymbol: $o2, isUndefined: qo, isRegExp: Go, isObject: Co2, isDate: Wo, isError: _o, isFunction: zo, isPrimitive: Vo, isBuffer: Jo, log: Lo, inherits: Ho, _extend: Zo, promisify: Yo, callbackify: Ko } = ft2;
var { default: to, ...no } = ft2;
var ot2;
var it;
var Qo = (it = (ot2 = at.default) != null ? ot2 : to) != null ? it : no;

// deno:https://esm.sh/v86/stream-browserify@3.0.0/es2019/stream-browserify.bundle.js
var __global$3 = globalThis || (typeof window !== "undefined" ? window : self);
var xt = Object.create;
var xe = Object.defineProperty;
var Ct = Object.getOwnPropertyDescriptor;
var It = Object.getOwnPropertyNames;
var jt = Object.getPrototypeOf;
var kt = Object.prototype.hasOwnProperty;
var y3 = ((e) => typeof require != "undefined" ? require : typeof Proxy != "undefined" ? new Proxy(e, { get: (t, r) => (typeof require != "undefined" ? require : t)[r] }) : e)(function(e) {
  if (typeof require != "undefined")
    return require.apply(this, arguments);
  throw new Error('Dynamic require of "' + e + '" is not supported');
});
var c3 = (e, t) => () => (t || e((t = { exports: {} }).exports, t), t.exports);
var Wt = (e, t, r, i) => {
  if (t && typeof t == "object" || typeof t == "function")
    for (let n of It(t))
      !kt.call(e, n) && n !== r && xe(e, n, { get: () => t[n], enumerable: !(i = Ct(t, n)) || i.enumerable });
  return e;
};
var Ce = (e, t, r) => (r = e != null ? xt(jt(e)) : {}, Wt(t || !e || !e.__esModule ? xe(r, "default", { value: e, enumerable: true }) : r, e));
var L3 = c3((Di, fe) => {
  typeof Object.create == "function" ? fe.exports = function(t, r) {
    r && (t.super_ = r, t.prototype = Object.create(r.prototype, { constructor: { value: t, enumerable: false, writable: true, configurable: true } }));
  } : fe.exports = function(t, r) {
    if (r) {
      t.super_ = r;
      var i = function() {
      };
      i.prototype = r.prototype, t.prototype = new i(), t.prototype.constructor = t;
    }
  };
});
var le = c3((qi, Ie) => {
  Ie.exports = ee.EventEmitter;
});
var Ue = c3((Pi, We) => {
  "use strict";
  function je2(e, t) {
    var r = Object.keys(e);
    if (Object.getOwnPropertySymbols) {
      var i = Object.getOwnPropertySymbols(e);
      t && (i = i.filter(function(n) {
        return Object.getOwnPropertyDescriptor(e, n).enumerable;
      })), r.push.apply(r, i);
    }
    return r;
  }
  function Ut(e) {
    for (var t = 1; t < arguments.length; t++) {
      var r = arguments[t] != null ? arguments[t] : {};
      t % 2 ? je2(Object(r), true).forEach(function(i) {
        Bt(e, i, r[i]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(r)) : je2(Object(r)).forEach(function(i) {
        Object.defineProperty(e, i, Object.getOwnPropertyDescriptor(r, i));
      });
    }
    return e;
  }
  function Bt(e, t, r) {
    return t in e ? Object.defineProperty(e, t, { value: r, enumerable: true, configurable: true, writable: true }) : e[t] = r, e;
  }
  function Ft(e, t) {
    if (!(e instanceof t))
      throw new TypeError("Cannot call a class as a function");
  }
  function ke(e, t) {
    for (var r = 0; r < t.length; r++) {
      var i = t[r];
      i.enumerable = i.enumerable || false, i.configurable = true, "value" in i && (i.writable = true), Object.defineProperty(e, i.key, i);
    }
  }
  function Ht(e, t, r) {
    return t && ke(e.prototype, t), r && ke(e, r), e;
  }
  var Gt = export_default, $4 = Gt.Buffer, Vt3 = Qo, ue2 = Vt3.inspect, Yt = ue2 && ue2.custom || "inspect";
  function $t(e, t, r) {
    $4.prototype.copy.call(e, t, r);
  }
  We.exports = function() {
    function e() {
      Ft(this, e), this.head = null, this.tail = null, this.length = 0;
    }
    return Ht(e, [{ key: "push", value: function(r) {
      var i = { data: r, next: null };
      this.length > 0 ? this.tail.next = i : this.head = i, this.tail = i, ++this.length;
    } }, { key: "unshift", value: function(r) {
      var i = { data: r, next: this.head };
      this.length === 0 && (this.tail = i), this.head = i, ++this.length;
    } }, { key: "shift", value: function() {
      if (this.length !== 0) {
        var r = this.head.data;
        return this.length === 1 ? this.head = this.tail = null : this.head = this.head.next, --this.length, r;
      }
    } }, { key: "clear", value: function() {
      this.head = this.tail = null, this.length = 0;
    } }, { key: "join", value: function(r) {
      if (this.length === 0)
        return "";
      for (var i = this.head, n = "" + i.data; i = i.next; )
        n += r + i.data;
      return n;
    } }, { key: "concat", value: function(r) {
      if (this.length === 0)
        return $4.alloc(0);
      for (var i = $4.allocUnsafe(r >>> 0), n = this.head, a = 0; n; )
        $t(n.data, i, a), a += n.data.length, n = n.next;
      return i;
    } }, { key: "consume", value: function(r, i) {
      var n;
      return r < this.head.data.length ? (n = this.head.data.slice(0, r), this.head.data = this.head.data.slice(r)) : r === this.head.data.length ? n = this.shift() : n = i ? this._getString(r) : this._getBuffer(r), n;
    } }, { key: "first", value: function() {
      return this.head.data;
    } }, { key: "_getString", value: function(r) {
      var i = this.head, n = 1, a = i.data;
      for (r -= a.length; i = i.next; ) {
        var o2 = i.data, f = r > o2.length ? o2.length : r;
        if (f === o2.length ? a += o2 : a += o2.slice(0, r), r -= f, r === 0) {
          f === o2.length ? (++n, i.next ? this.head = i.next : this.head = this.tail = null) : (this.head = i, i.data = o2.slice(f));
          break;
        }
        ++n;
      }
      return this.length -= n, a;
    } }, { key: "_getBuffer", value: function(r) {
      var i = $4.allocUnsafe(r), n = this.head, a = 1;
      for (n.data.copy(i), r -= n.data.length; n = n.next; ) {
        var o2 = n.data, f = r > o2.length ? o2.length : r;
        if (o2.copy(i, i.length - r, 0, f), r -= f, r === 0) {
          f === o2.length ? (++a, n.next ? this.head = n.next : this.head = this.tail = null) : (this.head = n, n.data = o2.slice(f));
          break;
        }
        ++a;
      }
      return this.length -= a, i;
    } }, { key: Yt, value: function(r, i) {
      return ue2(this, Ut({}, i, { depth: 0, customInspect: false }));
    } }]), e;
  }();
});
var de2 = c3((Ni3, Fe4) => {
  "use strict";
  function Kt2(e, t) {
    var r = this, i = this._readableState && this._readableState.destroyed, n = this._writableState && this._writableState.destroyed;
    return i || n ? (t ? t(e) : e && (this._writableState ? this._writableState.errorEmitted || (this._writableState.errorEmitted = true, node_process_default.nextTick(se, this, e)) : node_process_default.nextTick(se, this, e)), this) : (this._readableState && (this._readableState.destroyed = true), this._writableState && (this._writableState.destroyed = true), this._destroy(e || null, function(a) {
      !t && a ? r._writableState ? r._writableState.errorEmitted ? node_process_default.nextTick(K4, r) : (r._writableState.errorEmitted = true, node_process_default.nextTick(Be3, r, a)) : node_process_default.nextTick(Be3, r, a) : t ? (node_process_default.nextTick(K4, r), t(a)) : node_process_default.nextTick(K4, r);
    }), this);
  }
  function Be3(e, t) {
    se(e, t), K4(e);
  }
  function K4(e) {
    e._writableState && !e._writableState.emitClose || e._readableState && !e._readableState.emitClose || e.emit("close");
  }
  function Xt() {
    this._readableState && (this._readableState.destroyed = false, this._readableState.reading = false, this._readableState.ended = false, this._readableState.endEmitted = false), this._writableState && (this._writableState.destroyed = false, this._writableState.ended = false, this._writableState.ending = false, this._writableState.finalCalled = false, this._writableState.prefinished = false, this._writableState.finished = false, this._writableState.errorEmitted = false);
  }
  function se(e, t) {
    e.emit("error", t);
  }
  function zt2(e, t) {
    var r = e._readableState, i = e._writableState;
    r && r.autoDestroy || i && i.autoDestroy ? e.destroy(t) : e.emit("error", t);
  }
  Fe4.exports = { destroy: Kt2, undestroy: Xt, errorOrDestroy: zt2 };
});
var A3 = c3((xi, Ve2) => {
  "use strict";
  function Jt(e, t) {
    e.prototype = Object.create(t.prototype), e.prototype.constructor = e, e.__proto__ = t;
  }
  var Ge2 = {};
  function b2(e, t, r) {
    r || (r = Error);
    function i(a, o2, f) {
      return typeof t == "string" ? t : t(a, o2, f);
    }
    var n = function(a) {
      Jt(o2, a);
      function o2(f, s, d4) {
        return a.call(this, i(f, s, d4)) || this;
      }
      return o2;
    }(r);
    n.prototype.name = r.name, n.prototype.code = e, Ge2[e] = n;
  }
  function He2(e, t) {
    if (Array.isArray(e)) {
      var r = e.length;
      return e = e.map(function(i) {
        return String(i);
      }), r > 2 ? "one of ".concat(t, " ").concat(e.slice(0, r - 1).join(", "), ", or ") + e[r - 1] : r === 2 ? "one of ".concat(t, " ").concat(e[0], " or ").concat(e[1]) : "of ".concat(t, " ").concat(e[0]);
    } else
      return "of ".concat(t, " ").concat(String(e));
  }
  function Qt(e, t, r) {
    return e.substr(!r || r < 0 ? 0 : +r, t.length) === t;
  }
  function Zt2(e, t, r) {
    return (r === void 0 || r > e.length) && (r = e.length), e.substring(r - t.length, r) === t;
  }
  function er(e, t, r) {
    return typeof r != "number" && (r = 0), r + t.length > e.length ? false : e.indexOf(t, r) !== -1;
  }
  b2("ERR_INVALID_OPT_VALUE", function(e, t) {
    return 'The value "' + t + '" is invalid for option "' + e + '"';
  }, TypeError);
  b2("ERR_INVALID_ARG_TYPE", function(e, t, r) {
    var i;
    typeof t == "string" && Qt(t, "not ") ? (i = "must not be", t = t.replace(/^not /, "")) : i = "must be";
    var n;
    if (Zt2(e, " argument"))
      n = "The ".concat(e, " ").concat(i, " ").concat(He2(t, "type"));
    else {
      var a = er(e, ".") ? "property" : "argument";
      n = 'The "'.concat(e, '" ').concat(a, " ").concat(i, " ").concat(He2(t, "type"));
    }
    return n += ". Received type ".concat(typeof r), n;
  }, TypeError);
  b2("ERR_STREAM_PUSH_AFTER_EOF", "stream.push() after EOF");
  b2("ERR_METHOD_NOT_IMPLEMENTED", function(e) {
    return "The " + e + " method is not implemented";
  });
  b2("ERR_STREAM_PREMATURE_CLOSE", "Premature close");
  b2("ERR_STREAM_DESTROYED", function(e) {
    return "Cannot call " + e + " after a stream was destroyed";
  });
  b2("ERR_MULTIPLE_CALLBACK", "Callback called multiple times");
  b2("ERR_STREAM_CANNOT_PIPE", "Cannot pipe, not readable");
  b2("ERR_STREAM_WRITE_AFTER_END", "write after end");
  b2("ERR_STREAM_NULL_VALUES", "May not write null values to stream", TypeError);
  b2("ERR_UNKNOWN_ENCODING", function(e) {
    return "Unknown encoding: " + e;
  }, TypeError);
  b2("ERR_STREAM_UNSHIFT_AFTER_END_EVENT", "stream.unshift() after end event");
  Ve2.exports.codes = Ge2;
});
var he = c3((Ci, Ye2) => {
  "use strict";
  var tr = A3().codes.ERR_INVALID_OPT_VALUE;
  function rr(e, t, r) {
    return e.highWaterMark != null ? e.highWaterMark : t ? e[r] : null;
  }
  function ir2(e, t, r, i) {
    var n = rr(t, i, r);
    if (n != null) {
      if (!(isFinite(n) && Math.floor(n) === n) || n < 0) {
        var a = i ? r : "highWaterMark";
        throw new tr(a, n);
      }
      return Math.floor(n);
    }
    return e.objectMode ? 16 : 16 * 1024;
  }
  Ye2.exports = { getHighWaterMark: ir2 };
});
var Ke3 = c3((Ii, $e2) => {
  $e2.exports = nr;
  function nr(e, t) {
    if (ce2("noDeprecation"))
      return e;
    var r = false;
    function i() {
      if (!r) {
        if (ce2("throwDeprecation"))
          throw new Error(t);
        ce2("traceDeprecation") ? console.trace(t) : console.warn(t), r = true;
      }
      return e.apply(this, arguments);
    }
    return i;
  }
  function ce2(e) {
    try {
      if (!__global$3.localStorage)
        return false;
    } catch {
      return false;
    }
    var t = __global$3.localStorage[e];
    return t == null ? false : String(t).toLowerCase() === "true";
  }
});
var _e = c3((ji, et) => {
  "use strict";
  et.exports = h;
  function ze(e) {
    var t = this;
    this.next = null, this.entry = null, this.finish = function() {
      qr2(t, e);
    };
  }
  var I3;
  h.WritableState = F4;
  var ar = { deprecate: Ke3() }, Je2 = le(), z = export_default.Buffer, or2 = __global$3.Uint8Array || function() {
  };
  function fr(e) {
    return z.from(e);
  }
  function lr(e) {
    return z.isBuffer(e) || e instanceof or2;
  }
  var be = de2(), ur2 = he(), sr = ur2.getHighWaterMark, S3 = A3().codes, dr2 = S3.ERR_INVALID_ARG_TYPE, hr = S3.ERR_METHOD_NOT_IMPLEMENTED, cr = S3.ERR_MULTIPLE_CALLBACK, pr2 = S3.ERR_STREAM_CANNOT_PIPE, br = S3.ERR_STREAM_DESTROYED, _r2 = S3.ERR_STREAM_NULL_VALUES, gr2 = S3.ERR_STREAM_WRITE_AFTER_END, yr2 = S3.ERR_UNKNOWN_ENCODING, j2 = be.errorOrDestroy;
  L3()(h, Je2);
  function vr5() {
  }
  function F4(e, t, r) {
    I3 = I3 || D5(), e = e || {}, typeof r != "boolean" && (r = t instanceof I3), this.objectMode = !!e.objectMode, r && (this.objectMode = this.objectMode || !!e.writableObjectMode), this.highWaterMark = sr(this, e, "writableHighWaterMark", r), this.finalCalled = false, this.needDrain = false, this.ending = false, this.ended = false, this.finished = false, this.destroyed = false;
    var i = e.decodeStrings === false;
    this.decodeStrings = !i, this.defaultEncoding = e.defaultEncoding || "utf8", this.length = 0, this.writing = false, this.corked = 0, this.sync = true, this.bufferProcessing = false, this.onwrite = function(n) {
      mr(t, n);
    }, this.writecb = null, this.writelen = 0, this.bufferedRequest = null, this.lastBufferedRequest = null, this.pendingcb = 0, this.prefinished = false, this.errorEmitted = false, this.emitClose = e.emitClose !== false, this.autoDestroy = !!e.autoDestroy, this.bufferedRequestCount = 0, this.corkedRequestsFree = new ze(this);
  }
  F4.prototype.getBuffer = function() {
    for (var t = this.bufferedRequest, r = []; t; )
      r.push(t), t = t.next;
    return r;
  };
  (function() {
    try {
      Object.defineProperty(F4.prototype, "buffer", { get: ar.deprecate(function() {
        return this.getBuffer();
      }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003") });
    } catch {
    }
  })();
  var X5;
  typeof Symbol == "function" && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] == "function" ? (X5 = Function.prototype[Symbol.hasInstance], Object.defineProperty(h, Symbol.hasInstance, { value: function(t) {
    return X5.call(this, t) ? true : this !== h ? false : t && t._writableState instanceof F4;
  } })) : X5 = function(t) {
    return t instanceof this;
  };
  function h(e) {
    I3 = I3 || D5();
    var t = this instanceof I3;
    if (!t && !X5.call(h, this))
      return new h(e);
    this._writableState = new F4(e, this, t), this.writable = true, e && (typeof e.write == "function" && (this._write = e.write), typeof e.writev == "function" && (this._writev = e.writev), typeof e.destroy == "function" && (this._destroy = e.destroy), typeof e.final == "function" && (this._final = e.final)), Je2.call(this);
  }
  h.prototype.pipe = function() {
    j2(this, new pr2());
  };
  function wr2(e, t) {
    var r = new gr2();
    j2(e, r), node_process_default.nextTick(t, r);
  }
  function Rr2(e, t, r, i) {
    var n;
    return r === null ? n = new _r2() : typeof r != "string" && !t.objectMode && (n = new dr2("chunk", ["string", "Buffer"], r)), n ? (j2(e, n), node_process_default.nextTick(i, n), false) : true;
  }
  h.prototype.write = function(e, t, r) {
    var i = this._writableState, n = false, a = !i.objectMode && lr(e);
    return a && !z.isBuffer(e) && (e = fr(e)), typeof t == "function" && (r = t, t = null), a ? t = "buffer" : t || (t = i.defaultEncoding), typeof r != "function" && (r = vr5), i.ending ? wr2(this, r) : (a || Rr2(this, i, e, r)) && (i.pendingcb++, n = Sr(this, i, a, e, t, r)), n;
  };
  h.prototype.cork = function() {
    this._writableState.corked++;
  };
  h.prototype.uncork = function() {
    var e = this._writableState;
    e.corked && (e.corked--, !e.writing && !e.corked && !e.bufferProcessing && e.bufferedRequest && Qe2(this, e));
  };
  h.prototype.setDefaultEncoding = function(t) {
    if (typeof t == "string" && (t = t.toLowerCase()), !(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((t + "").toLowerCase()) > -1))
      throw new yr2(t);
    return this._writableState.defaultEncoding = t, this;
  };
  Object.defineProperty(h.prototype, "writableBuffer", { enumerable: false, get: function() {
    return this._writableState && this._writableState.getBuffer();
  } });
  function Er3(e, t, r) {
    return !e.objectMode && e.decodeStrings !== false && typeof t == "string" && (t = z.from(t, r)), t;
  }
  Object.defineProperty(h.prototype, "writableHighWaterMark", { enumerable: false, get: function() {
    return this._writableState.highWaterMark;
  } });
  function Sr(e, t, r, i, n, a) {
    if (!r) {
      var o2 = Er3(t, i, n);
      i !== o2 && (r = true, n = "buffer", i = o2);
    }
    var f = t.objectMode ? 1 : i.length;
    t.length += f;
    var s = t.length < t.highWaterMark;
    if (s || (t.needDrain = true), t.writing || t.corked) {
      var d4 = t.lastBufferedRequest;
      t.lastBufferedRequest = { chunk: i, encoding: n, isBuf: r, callback: a, next: null }, d4 ? d4.next = t.lastBufferedRequest : t.bufferedRequest = t.lastBufferedRequest, t.bufferedRequestCount += 1;
    } else
      pe(e, t, false, f, i, n, a);
    return s;
  }
  function pe(e, t, r, i, n, a, o2) {
    t.writelen = i, t.writecb = o2, t.writing = true, t.sync = true, t.destroyed ? t.onwrite(new br("write")) : r ? e._writev(n, t.onwrite) : e._write(n, a, t.onwrite), t.sync = false;
  }
  function Tr2(e, t, r, i, n) {
    --t.pendingcb, r ? (node_process_default.nextTick(n, i), node_process_default.nextTick(B3, e, t), e._writableState.errorEmitted = true, j2(e, i)) : (n(i), e._writableState.errorEmitted = true, j2(e, i), B3(e, t));
  }
  function Mr(e) {
    e.writing = false, e.writecb = null, e.length -= e.writelen, e.writelen = 0;
  }
  function mr(e, t) {
    var r = e._writableState, i = r.sync, n = r.writecb;
    if (typeof n != "function")
      throw new cr();
    if (Mr(r), t)
      Tr2(e, r, i, t, n);
    else {
      var a = Ze2(r) || e.destroyed;
      !a && !r.corked && !r.bufferProcessing && r.bufferedRequest && Qe2(e, r), i ? node_process_default.nextTick(Xe2, e, r, a, n) : Xe2(e, r, a, n);
    }
  }
  function Xe2(e, t, r, i) {
    r || Or2(e, t), t.pendingcb--, i(), B3(e, t);
  }
  function Or2(e, t) {
    t.length === 0 && t.needDrain && (t.needDrain = false, e.emit("drain"));
  }
  function Qe2(e, t) {
    t.bufferProcessing = true;
    var r = t.bufferedRequest;
    if (e._writev && r && r.next) {
      var i = t.bufferedRequestCount, n = new Array(i), a = t.corkedRequestsFree;
      a.entry = r;
      for (var o2 = 0, f = true; r; )
        n[o2] = r, r.isBuf || (f = false), r = r.next, o2 += 1;
      n.allBuffers = f, pe(e, t, true, t.length, n, "", a.finish), t.pendingcb++, t.lastBufferedRequest = null, a.next ? (t.corkedRequestsFree = a.next, a.next = null) : t.corkedRequestsFree = new ze(t), t.bufferedRequestCount = 0;
    } else {
      for (; r; ) {
        var s = r.chunk, d4 = r.encoding, p3 = r.callback, w2 = t.objectMode ? 1 : s.length;
        if (pe(e, t, false, w2, s, d4, p3), r = r.next, t.bufferedRequestCount--, t.writing)
          break;
      }
      r === null && (t.lastBufferedRequest = null);
    }
    t.bufferedRequest = r, t.bufferProcessing = false;
  }
  h.prototype._write = function(e, t, r) {
    r(new hr("_write()"));
  };
  h.prototype._writev = null;
  h.prototype.end = function(e, t, r) {
    var i = this._writableState;
    return typeof e == "function" ? (r = e, e = null, t = null) : typeof t == "function" && (r = t, t = null), e != null && this.write(e, t), i.corked && (i.corked = 1, this.uncork()), i.ending || Dr(this, i, r), this;
  };
  Object.defineProperty(h.prototype, "writableLength", { enumerable: false, get: function() {
    return this._writableState.length;
  } });
  function Ze2(e) {
    return e.ending && e.length === 0 && e.bufferedRequest === null && !e.finished && !e.writing;
  }
  function Lr4(e, t) {
    e._final(function(r) {
      t.pendingcb--, r && j2(e, r), t.prefinished = true, e.emit("prefinish"), B3(e, t);
    });
  }
  function Ar(e, t) {
    !t.prefinished && !t.finalCalled && (typeof e._final == "function" && !t.destroyed ? (t.pendingcb++, t.finalCalled = true, node_process_default.nextTick(Lr4, e, t)) : (t.prefinished = true, e.emit("prefinish")));
  }
  function B3(e, t) {
    var r = Ze2(t);
    if (r && (Ar(e, t), t.pendingcb === 0 && (t.finished = true, e.emit("finish"), t.autoDestroy))) {
      var i = e._readableState;
      (!i || i.autoDestroy && i.endEmitted) && e.destroy();
    }
    return r;
  }
  function Dr(e, t, r) {
    t.ending = true, B3(e, t), r && (t.finished ? node_process_default.nextTick(r) : e.once("finish", r)), t.ended = true, e.writable = false;
  }
  function qr2(e, t, r) {
    var i = e.entry;
    for (e.entry = null; i; ) {
      var n = i.callback;
      t.pendingcb--, n(r), i = i.next;
    }
    t.corkedRequestsFree.next = e;
  }
  Object.defineProperty(h.prototype, "destroyed", { enumerable: false, get: function() {
    return this._writableState === void 0 ? false : this._writableState.destroyed;
  }, set: function(t) {
    !this._writableState || (this._writableState.destroyed = t);
  } });
  h.prototype.destroy = be.destroy;
  h.prototype._undestroy = be.undestroy;
  h.prototype._destroy = function(e, t) {
    t(e);
  };
});
var D5 = c3((ki2, rt2) => {
  "use strict";
  var Pr2 = Object.keys || function(e) {
    var t = [];
    for (var r in e)
      t.push(r);
    return t;
  };
  rt2.exports = v2;
  var tt = ve(), ye = _e();
  L3()(v2, tt);
  for (ge2 = Pr2(ye.prototype), J3 = 0; J3 < ge2.length; J3++)
    Q3 = ge2[J3], v2.prototype[Q3] || (v2.prototype[Q3] = ye.prototype[Q3]);
  var ge2, Q3, J3;
  function v2(e) {
    if (!(this instanceof v2))
      return new v2(e);
    tt.call(this, e), ye.call(this, e), this.allowHalfOpen = true, e && (e.readable === false && (this.readable = false), e.writable === false && (this.writable = false), e.allowHalfOpen === false && (this.allowHalfOpen = false, this.once("end", Nr2)));
  }
  Object.defineProperty(v2.prototype, "writableHighWaterMark", { enumerable: false, get: function() {
    return this._writableState.highWaterMark;
  } });
  Object.defineProperty(v2.prototype, "writableBuffer", { enumerable: false, get: function() {
    return this._writableState && this._writableState.getBuffer();
  } });
  Object.defineProperty(v2.prototype, "writableLength", { enumerable: false, get: function() {
    return this._writableState.length;
  } });
  function Nr2() {
    this._writableState.ended || node_process_default.nextTick(xr2, this);
  }
  function xr2(e) {
    e.end();
  }
  Object.defineProperty(v2.prototype, "destroyed", { enumerable: false, get: function() {
    return this._readableState === void 0 || this._writableState === void 0 ? false : this._readableState.destroyed && this._writableState.destroyed;
  }, set: function(t) {
    this._readableState === void 0 || this._writableState === void 0 || (this._readableState.destroyed = t, this._writableState.destroyed = t);
  } });
});
var Z3 = c3((Wi, at2) => {
  "use strict";
  var it2 = A3().codes.ERR_STREAM_PREMATURE_CLOSE;
  function Cr2(e) {
    var t = false;
    return function() {
      if (!t) {
        t = true;
        for (var r = arguments.length, i = new Array(r), n = 0; n < r; n++)
          i[n] = arguments[n];
        e.apply(this, i);
      }
    };
  }
  function Ir2() {
  }
  function jr3(e) {
    return e.setHeader && typeof e.abort == "function";
  }
  function nt(e, t, r) {
    if (typeof t == "function")
      return nt(e, null, t);
    t || (t = {}), r = Cr2(r || Ir2);
    var i = t.readable || t.readable !== false && e.readable, n = t.writable || t.writable !== false && e.writable, a = function() {
      e.writable || f();
    }, o2 = e._writableState && e._writableState.finished, f = function() {
      n = false, o2 = true, i || r.call(e);
    }, s = e._readableState && e._readableState.endEmitted, d4 = function() {
      i = false, s = true, n || r.call(e);
    }, p3 = function(g2) {
      r.call(e, g2);
    }, w2 = function() {
      var g2;
      if (i && !s)
        return (!e._readableState || !e._readableState.ended) && (g2 = new it2()), r.call(e, g2);
      if (n && !o2)
        return (!e._writableState || !e._writableState.ended) && (g2 = new it2()), r.call(e, g2);
    }, O = function() {
      e.req.on("finish", f);
    };
    return jr3(e) ? (e.on("complete", f), e.on("abort", w2), e.req ? O() : e.on("request", O)) : n && !e._writableState && (e.on("end", a), e.on("close", a)), e.on("end", d4), e.on("finish", f), t.error !== false && e.on("error", p3), e.on("close", w2), function() {
      e.removeListener("complete", f), e.removeListener("abort", w2), e.removeListener("request", O), e.req && e.req.removeListener("finish", f), e.removeListener("end", a), e.removeListener("close", a), e.removeListener("finish", f), e.removeListener("end", d4), e.removeListener("error", p3), e.removeListener("close", w2);
    };
  }
  at2.exports = nt;
});
var ft3 = c3((Ui, ot4) => {
  "use strict";
  var ee2;
  function T4(e, t, r) {
    return t in e ? Object.defineProperty(e, t, { value: r, enumerable: true, configurable: true, writable: true }) : e[t] = r, e;
  }
  var kr2 = Z3(), M4 = Symbol("lastResolve"), q = Symbol("lastReject"), H3 = Symbol("error"), te = Symbol("ended"), P2 = Symbol("lastPromise"), we2 = Symbol("handlePromise"), N4 = Symbol("stream");
  function m3(e, t) {
    return { value: e, done: t };
  }
  function Wr2(e) {
    var t = e[M4];
    if (t !== null) {
      var r = e[N4].read();
      r !== null && (e[P2] = null, e[M4] = null, e[q] = null, t(m3(r, false)));
    }
  }
  function Ur3(e) {
    node_process_default.nextTick(Wr2, e);
  }
  function Br2(e, t) {
    return function(r, i) {
      e.then(function() {
        if (t[te]) {
          r(m3(void 0, true));
          return;
        }
        t[we2](r, i);
      }, i);
    };
  }
  var Fr3 = Object.getPrototypeOf(function() {
  }), Hr = Object.setPrototypeOf((ee2 = { get stream() {
    return this[N4];
  }, next: function() {
    var t = this, r = this[H3];
    if (r !== null)
      return Promise.reject(r);
    if (this[te])
      return Promise.resolve(m3(void 0, true));
    if (this[N4].destroyed)
      return new Promise(function(o2, f) {
        node_process_default.nextTick(function() {
          t[H3] ? f(t[H3]) : o2(m3(void 0, true));
        });
      });
    var i = this[P2], n;
    if (i)
      n = new Promise(Br2(i, this));
    else {
      var a = this[N4].read();
      if (a !== null)
        return Promise.resolve(m3(a, false));
      n = new Promise(this[we2]);
    }
    return this[P2] = n, n;
  } }, T4(ee2, Symbol.asyncIterator, function() {
    return this;
  }), T4(ee2, "return", function() {
    var t = this;
    return new Promise(function(r, i) {
      t[N4].destroy(null, function(n) {
        if (n) {
          i(n);
          return;
        }
        r(m3(void 0, true));
      });
    });
  }), ee2), Fr3), Gr2 = function(t) {
    var r, i = Object.create(Hr, (r = {}, T4(r, N4, { value: t, writable: true }), T4(r, M4, { value: null, writable: true }), T4(r, q, { value: null, writable: true }), T4(r, H3, { value: null, writable: true }), T4(r, te, { value: t._readableState.endEmitted, writable: true }), T4(r, we2, { value: function(a, o2) {
      var f = i[N4].read();
      f ? (i[P2] = null, i[M4] = null, i[q] = null, a(m3(f, false))) : (i[M4] = a, i[q] = o2);
    }, writable: true }), r));
    return i[P2] = null, kr2(t, function(n) {
      if (n && n.code !== "ERR_STREAM_PREMATURE_CLOSE") {
        var a = i[q];
        a !== null && (i[P2] = null, i[M4] = null, i[q] = null, a(n)), i[H3] = n;
        return;
      }
      var o2 = i[M4];
      o2 !== null && (i[P2] = null, i[M4] = null, i[q] = null, o2(m3(void 0, true))), i[te] = true;
    }), t.on("readable", Ur3.bind(null, i)), i;
  };
  ot4.exports = Gr2;
});
var ut3 = c3((Bi, lt3) => {
  lt3.exports = function() {
    throw new Error("Readable.from is not available in the browser");
  };
});
var ve = c3((Hi, vt) => {
  "use strict";
  vt.exports = u;
  var k6;
  u.ReadableState = ct4;
  var Fi = ee.EventEmitter, ht4 = function(t, r) {
    return t.listeners(r).length;
  }, V3 = le(), re2 = export_default.Buffer, Vr2 = __global$3.Uint8Array || function() {
  };
  function Yr2(e) {
    return re2.from(e);
  }
  function $r3(e) {
    return re2.isBuffer(e) || e instanceof Vr2;
  }
  var Re = Qo, l;
  Re && Re.debuglog ? l = Re.debuglog("stream") : l = function() {
  };
  var Kr = Ue(), Le = de2(), Xr2 = he(), zr = Xr2.getHighWaterMark, ie = A3().codes, Jr = ie.ERR_INVALID_ARG_TYPE, Qr2 = ie.ERR_STREAM_PUSH_AFTER_EOF, Zr3 = ie.ERR_METHOD_NOT_IMPLEMENTED, ei = ie.ERR_STREAM_UNSHIFT_AFTER_END_EVENT, W4, Ee2, Se2;
  L3()(u, V3);
  var G4 = Le.errorOrDestroy, Te = ["error", "close", "destroy", "pause", "resume"];
  function ti(e, t, r) {
    if (typeof e.prependListener == "function")
      return e.prependListener(t, r);
    !e._events || !e._events[t] ? e.on(t, r) : Array.isArray(e._events[t]) ? e._events[t].unshift(r) : e._events[t] = [r, e._events[t]];
  }
  function ct4(e, t, r) {
    k6 = k6 || D5(), e = e || {}, typeof r != "boolean" && (r = t instanceof k6), this.objectMode = !!e.objectMode, r && (this.objectMode = this.objectMode || !!e.readableObjectMode), this.highWaterMark = zr(this, e, "readableHighWaterMark", r), this.buffer = new Kr(), this.length = 0, this.pipes = null, this.pipesCount = 0, this.flowing = null, this.ended = false, this.endEmitted = false, this.reading = false, this.sync = true, this.needReadable = false, this.emittedReadable = false, this.readableListening = false, this.resumeScheduled = false, this.paused = true, this.emitClose = e.emitClose !== false, this.autoDestroy = !!e.autoDestroy, this.destroyed = false, this.defaultEncoding = e.defaultEncoding || "utf8", this.awaitDrain = 0, this.readingMore = false, this.decoder = null, this.encoding = null, e.encoding && (W4 || (W4 = Y2.StringDecoder), this.decoder = new W4(e.encoding), this.encoding = e.encoding);
  }
  function u(e) {
    if (k6 = k6 || D5(), !(this instanceof u))
      return new u(e);
    var t = this instanceof k6;
    this._readableState = new ct4(e, this, t), this.readable = true, e && (typeof e.read == "function" && (this._read = e.read), typeof e.destroy == "function" && (this._destroy = e.destroy)), V3.call(this);
  }
  Object.defineProperty(u.prototype, "destroyed", { enumerable: false, get: function() {
    return this._readableState === void 0 ? false : this._readableState.destroyed;
  }, set: function(t) {
    !this._readableState || (this._readableState.destroyed = t);
  } });
  u.prototype.destroy = Le.destroy;
  u.prototype._undestroy = Le.undestroy;
  u.prototype._destroy = function(e, t) {
    t(e);
  };
  u.prototype.push = function(e, t) {
    var r = this._readableState, i;
    return r.objectMode ? i = true : typeof e == "string" && (t = t || r.defaultEncoding, t !== r.encoding && (e = re2.from(e, t), t = ""), i = true), pt2(this, e, t, false, i);
  };
  u.prototype.unshift = function(e) {
    return pt2(this, e, null, true, false);
  };
  function pt2(e, t, r, i, n) {
    l("readableAddChunk", t);
    var a = e._readableState;
    if (t === null)
      a.reading = false, ni3(e, a);
    else {
      var o2;
      if (n || (o2 = ri(a, t)), o2)
        G4(e, o2);
      else if (a.objectMode || t && t.length > 0)
        if (typeof t != "string" && !a.objectMode && Object.getPrototypeOf(t) !== re2.prototype && (t = Yr2(t)), i)
          a.endEmitted ? G4(e, new ei()) : Me(e, a, t, true);
        else if (a.ended)
          G4(e, new Qr2());
        else {
          if (a.destroyed)
            return false;
          a.reading = false, a.decoder && !r ? (t = a.decoder.write(t), a.objectMode || t.length !== 0 ? Me(e, a, t, false) : Oe(e, a)) : Me(e, a, t, false);
        }
      else
        i || (a.reading = false, Oe(e, a));
    }
    return !a.ended && (a.length < a.highWaterMark || a.length === 0);
  }
  function Me(e, t, r, i) {
    t.flowing && t.length === 0 && !t.sync ? (t.awaitDrain = 0, e.emit("data", r)) : (t.length += t.objectMode ? 1 : r.length, i ? t.buffer.unshift(r) : t.buffer.push(r), t.needReadable && ne(e)), Oe(e, t);
  }
  function ri(e, t) {
    var r;
    return !$r3(t) && typeof t != "string" && t !== void 0 && !e.objectMode && (r = new Jr("chunk", ["string", "Buffer", "Uint8Array"], t)), r;
  }
  u.prototype.isPaused = function() {
    return this._readableState.flowing === false;
  };
  u.prototype.setEncoding = function(e) {
    W4 || (W4 = Y2.StringDecoder);
    var t = new W4(e);
    this._readableState.decoder = t, this._readableState.encoding = this._readableState.decoder.encoding;
    for (var r = this._readableState.buffer.head, i = ""; r !== null; )
      i += t.write(r.data), r = r.next;
    return this._readableState.buffer.clear(), i !== "" && this._readableState.buffer.push(i), this._readableState.length = i.length, this;
  };
  var st2 = 1073741824;
  function ii(e) {
    return e >= st2 ? e = st2 : (e--, e |= e >>> 1, e |= e >>> 2, e |= e >>> 4, e |= e >>> 8, e |= e >>> 16, e++), e;
  }
  function dt(e, t) {
    return e <= 0 || t.length === 0 && t.ended ? 0 : t.objectMode ? 1 : e !== e ? t.flowing && t.length ? t.buffer.head.data.length : t.length : (e > t.highWaterMark && (t.highWaterMark = ii(e)), e <= t.length ? e : t.ended ? t.length : (t.needReadable = true, 0));
  }
  u.prototype.read = function(e) {
    l("read", e), e = parseInt(e, 10);
    var t = this._readableState, r = e;
    if (e !== 0 && (t.emittedReadable = false), e === 0 && t.needReadable && ((t.highWaterMark !== 0 ? t.length >= t.highWaterMark : t.length > 0) || t.ended))
      return l("read: emitReadable", t.length, t.ended), t.length === 0 && t.ended ? me(this) : ne(this), null;
    if (e = dt(e, t), e === 0 && t.ended)
      return t.length === 0 && me(this), null;
    var i = t.needReadable;
    l("need readable", i), (t.length === 0 || t.length - e < t.highWaterMark) && (i = true, l("length less than watermark", i)), t.ended || t.reading ? (i = false, l("reading or ended", i)) : i && (l("do read"), t.reading = true, t.sync = true, t.length === 0 && (t.needReadable = true), this._read(t.highWaterMark), t.sync = false, t.reading || (e = dt(r, t)));
    var n;
    return e > 0 ? n = gt2(e, t) : n = null, n === null ? (t.needReadable = t.length <= t.highWaterMark, e = 0) : (t.length -= e, t.awaitDrain = 0), t.length === 0 && (t.ended || (t.needReadable = true), r !== e && t.ended && me(this)), n !== null && this.emit("data", n), n;
  };
  function ni3(e, t) {
    if (l("onEofChunk"), !t.ended) {
      if (t.decoder) {
        var r = t.decoder.end();
        r && r.length && (t.buffer.push(r), t.length += t.objectMode ? 1 : r.length);
      }
      t.ended = true, t.sync ? ne(e) : (t.needReadable = false, t.emittedReadable || (t.emittedReadable = true, bt(e)));
    }
  }
  function ne(e) {
    var t = e._readableState;
    l("emitReadable", t.needReadable, t.emittedReadable), t.needReadable = false, t.emittedReadable || (l("emitReadable", t.flowing), t.emittedReadable = true, node_process_default.nextTick(bt, e));
  }
  function bt(e) {
    var t = e._readableState;
    l("emitReadable_", t.destroyed, t.length, t.ended), !t.destroyed && (t.length || t.ended) && (e.emit("readable"), t.emittedReadable = false), t.needReadable = !t.flowing && !t.ended && t.length <= t.highWaterMark, Ae3(e);
  }
  function Oe(e, t) {
    t.readingMore || (t.readingMore = true, node_process_default.nextTick(ai3, e, t));
  }
  function ai3(e, t) {
    for (; !t.reading && !t.ended && (t.length < t.highWaterMark || t.flowing && t.length === 0); ) {
      var r = t.length;
      if (l("maybeReadMore read 0"), e.read(0), r === t.length)
        break;
    }
    t.readingMore = false;
  }
  u.prototype._read = function(e) {
    G4(this, new Zr3("_read()"));
  };
  u.prototype.pipe = function(e, t) {
    var r = this, i = this._readableState;
    switch (i.pipesCount) {
      case 0:
        i.pipes = e;
        break;
      case 1:
        i.pipes = [i.pipes, e];
        break;
      default:
        i.pipes.push(e);
        break;
    }
    i.pipesCount += 1, l("pipe count=%d opts=%j", i.pipesCount, t);
    var n = (!t || t.end !== false) && e !== node_process_default.stdout && e !== node_process_default.stderr, a = n ? f : U2;
    i.endEmitted ? node_process_default.nextTick(a) : r.once("end", a), e.on("unpipe", o2);
    function o2(x, C) {
      l("onunpipe"), x === r && C && C.hasUnpiped === false && (C.hasUnpiped = true, p3());
    }
    function f() {
      l("onend"), e.end();
    }
    var s = oi(r);
    e.on("drain", s);
    var d4 = false;
    function p3() {
      l("cleanup"), e.removeListener("close", R3), e.removeListener("finish", g2), e.removeListener("drain", s), e.removeListener("error", O), e.removeListener("unpipe", o2), r.removeListener("end", f), r.removeListener("end", U2), r.removeListener("data", w2), d4 = true, i.awaitDrain && (!e._writableState || e._writableState.needDrain) && s();
    }
    r.on("data", w2);
    function w2(x) {
      l("ondata");
      var C = e.write(x);
      l("dest.write", C), C === false && ((i.pipesCount === 1 && i.pipes === e || i.pipesCount > 1 && yt2(i.pipes, e) !== -1) && !d4 && (l("false write response, pause", i.awaitDrain), i.awaitDrain++), r.pause());
    }
    function O(x) {
      l("onerror", x), U2(), e.removeListener("error", O), ht4(e, "error") === 0 && G4(e, x);
    }
    ti(e, "error", O);
    function R3() {
      e.removeListener("finish", g2), U2();
    }
    e.once("close", R3);
    function g2() {
      l("onfinish"), e.removeListener("close", R3), U2();
    }
    e.once("finish", g2);
    function U2() {
      l("unpipe"), r.unpipe(e);
    }
    return e.emit("pipe", r), i.flowing || (l("pipe resume"), r.resume()), e;
  };
  function oi(e) {
    return function() {
      var r = e._readableState;
      l("pipeOnDrain", r.awaitDrain), r.awaitDrain && r.awaitDrain--, r.awaitDrain === 0 && ht4(e, "data") && (r.flowing = true, Ae3(e));
    };
  }
  u.prototype.unpipe = function(e) {
    var t = this._readableState, r = { hasUnpiped: false };
    if (t.pipesCount === 0)
      return this;
    if (t.pipesCount === 1)
      return e && e !== t.pipes ? this : (e || (e = t.pipes), t.pipes = null, t.pipesCount = 0, t.flowing = false, e && e.emit("unpipe", this, r), this);
    if (!e) {
      var i = t.pipes, n = t.pipesCount;
      t.pipes = null, t.pipesCount = 0, t.flowing = false;
      for (var a = 0; a < n; a++)
        i[a].emit("unpipe", this, { hasUnpiped: false });
      return this;
    }
    var o2 = yt2(t.pipes, e);
    return o2 === -1 ? this : (t.pipes.splice(o2, 1), t.pipesCount -= 1, t.pipesCount === 1 && (t.pipes = t.pipes[0]), e.emit("unpipe", this, r), this);
  };
  u.prototype.on = function(e, t) {
    var r = V3.prototype.on.call(this, e, t), i = this._readableState;
    return e === "data" ? (i.readableListening = this.listenerCount("readable") > 0, i.flowing !== false && this.resume()) : e === "readable" && !i.endEmitted && !i.readableListening && (i.readableListening = i.needReadable = true, i.flowing = false, i.emittedReadable = false, l("on readable", i.length, i.reading), i.length ? ne(this) : i.reading || node_process_default.nextTick(fi4, this)), r;
  };
  u.prototype.addListener = u.prototype.on;
  u.prototype.removeListener = function(e, t) {
    var r = V3.prototype.removeListener.call(this, e, t);
    return e === "readable" && node_process_default.nextTick(_t, this), r;
  };
  u.prototype.removeAllListeners = function(e) {
    var t = V3.prototype.removeAllListeners.apply(this, arguments);
    return (e === "readable" || e === void 0) && node_process_default.nextTick(_t, this), t;
  };
  function _t(e) {
    var t = e._readableState;
    t.readableListening = e.listenerCount("readable") > 0, t.resumeScheduled && !t.paused ? t.flowing = true : e.listenerCount("data") > 0 && e.resume();
  }
  function fi4(e) {
    l("readable nexttick read 0"), e.read(0);
  }
  u.prototype.resume = function() {
    var e = this._readableState;
    return e.flowing || (l("resume"), e.flowing = !e.readableListening, li(this, e)), e.paused = false, this;
  };
  function li(e, t) {
    t.resumeScheduled || (t.resumeScheduled = true, node_process_default.nextTick(ui, e, t));
  }
  function ui(e, t) {
    l("resume", t.reading), t.reading || e.read(0), t.resumeScheduled = false, e.emit("resume"), Ae3(e), t.flowing && !t.reading && e.read(0);
  }
  u.prototype.pause = function() {
    return l("call pause flowing=%j", this._readableState.flowing), this._readableState.flowing !== false && (l("pause"), this._readableState.flowing = false, this.emit("pause")), this._readableState.paused = true, this;
  };
  function Ae3(e) {
    var t = e._readableState;
    for (l("flow", t.flowing); t.flowing && e.read() !== null; )
      ;
  }
  u.prototype.wrap = function(e) {
    var t = this, r = this._readableState, i = false;
    e.on("end", function() {
      if (l("wrapped end"), r.decoder && !r.ended) {
        var o2 = r.decoder.end();
        o2 && o2.length && t.push(o2);
      }
      t.push(null);
    }), e.on("data", function(o2) {
      if (l("wrapped data"), r.decoder && (o2 = r.decoder.write(o2)), !(r.objectMode && o2 == null) && !(!r.objectMode && (!o2 || !o2.length))) {
        var f = t.push(o2);
        f || (i = true, e.pause());
      }
    });
    for (var n in e)
      this[n] === void 0 && typeof e[n] == "function" && (this[n] = function(f) {
        return function() {
          return e[f].apply(e, arguments);
        };
      }(n));
    for (var a = 0; a < Te.length; a++)
      e.on(Te[a], this.emit.bind(this, Te[a]));
    return this._read = function(o2) {
      l("wrapped _read", o2), i && (i = false, e.resume());
    }, this;
  };
  typeof Symbol == "function" && (u.prototype[Symbol.asyncIterator] = function() {
    return Ee2 === void 0 && (Ee2 = ft3()), Ee2(this);
  });
  Object.defineProperty(u.prototype, "readableHighWaterMark", { enumerable: false, get: function() {
    return this._readableState.highWaterMark;
  } });
  Object.defineProperty(u.prototype, "readableBuffer", { enumerable: false, get: function() {
    return this._readableState && this._readableState.buffer;
  } });
  Object.defineProperty(u.prototype, "readableFlowing", { enumerable: false, get: function() {
    return this._readableState.flowing;
  }, set: function(t) {
    this._readableState && (this._readableState.flowing = t);
  } });
  u._fromList = gt2;
  Object.defineProperty(u.prototype, "readableLength", { enumerable: false, get: function() {
    return this._readableState.length;
  } });
  function gt2(e, t) {
    if (t.length === 0)
      return null;
    var r;
    return t.objectMode ? r = t.buffer.shift() : !e || e >= t.length ? (t.decoder ? r = t.buffer.join("") : t.buffer.length === 1 ? r = t.buffer.first() : r = t.buffer.concat(t.length), t.buffer.clear()) : r = t.buffer.consume(e, t.decoder), r;
  }
  function me(e) {
    var t = e._readableState;
    l("endReadable", t.endEmitted), t.endEmitted || (t.ended = true, node_process_default.nextTick(si2, t, e));
  }
  function si2(e, t) {
    if (l("endReadableNT", e.endEmitted, e.length), !e.endEmitted && e.length === 0 && (e.endEmitted = true, t.readable = false, t.emit("end"), e.autoDestroy)) {
      var r = t._writableState;
      (!r || r.autoDestroy && r.finished) && t.destroy();
    }
  }
  typeof Symbol == "function" && (u.from = function(e, t) {
    return Se2 === void 0 && (Se2 = ut3()), Se2(u, e, t);
  });
  function yt2(e, t) {
    for (var r = 0, i = e.length; r < i; r++)
      if (e[r] === t)
        return r;
    return -1;
  }
});
var De2 = c3((Gi, Rt2) => {
  "use strict";
  Rt2.exports = E2;
  var ae2 = A3().codes, di3 = ae2.ERR_METHOD_NOT_IMPLEMENTED, hi2 = ae2.ERR_MULTIPLE_CALLBACK, ci = ae2.ERR_TRANSFORM_ALREADY_TRANSFORMING, pi = ae2.ERR_TRANSFORM_WITH_LENGTH_0, oe = D5();
  L3()(E2, oe);
  function bi(e, t) {
    var r = this._transformState;
    r.transforming = false;
    var i = r.writecb;
    if (i === null)
      return this.emit("error", new hi2());
    r.writechunk = null, r.writecb = null, t != null && this.push(t), i(e);
    var n = this._readableState;
    n.reading = false, (n.needReadable || n.length < n.highWaterMark) && this._read(n.highWaterMark);
  }
  function E2(e) {
    if (!(this instanceof E2))
      return new E2(e);
    oe.call(this, e), this._transformState = { afterTransform: bi.bind(this), needTransform: false, transforming: false, writecb: null, writechunk: null, writeencoding: null }, this._readableState.needReadable = true, this._readableState.sync = false, e && (typeof e.transform == "function" && (this._transform = e.transform), typeof e.flush == "function" && (this._flush = e.flush)), this.on("prefinish", _i);
  }
  function _i() {
    var e = this;
    typeof this._flush == "function" && !this._readableState.destroyed ? this._flush(function(t, r) {
      wt(e, t, r);
    }) : wt(this, null, null);
  }
  E2.prototype.push = function(e, t) {
    return this._transformState.needTransform = false, oe.prototype.push.call(this, e, t);
  };
  E2.prototype._transform = function(e, t, r) {
    r(new di3("_transform()"));
  };
  E2.prototype._write = function(e, t, r) {
    var i = this._transformState;
    if (i.writecb = r, i.writechunk = e, i.writeencoding = t, !i.transforming) {
      var n = this._readableState;
      (i.needTransform || n.needReadable || n.length < n.highWaterMark) && this._read(n.highWaterMark);
    }
  };
  E2.prototype._read = function(e) {
    var t = this._transformState;
    t.writechunk !== null && !t.transforming ? (t.transforming = true, this._transform(t.writechunk, t.writeencoding, t.afterTransform)) : t.needTransform = true;
  };
  E2.prototype._destroy = function(e, t) {
    oe.prototype._destroy.call(this, e, function(r) {
      t(r);
    });
  };
  function wt(e, t, r) {
    if (t)
      return e.emit("error", t);
    if (r != null && e.push(r), e._writableState.length)
      throw new pi();
    if (e._transformState.transforming)
      throw new ci();
    return e.push(null);
  }
});
var Tt = c3((Vi, St) => {
  "use strict";
  St.exports = Y4;
  var Et2 = De2();
  L3()(Y4, Et2);
  function Y4(e) {
    if (!(this instanceof Y4))
      return new Y4(e);
    Et2.call(this, e);
  }
  Y4.prototype._transform = function(e, t, r) {
    r(null, e);
  };
});
var At = c3((Yi, Lt2) => {
  "use strict";
  var qe3;
  function gi(e) {
    var t = false;
    return function() {
      t || (t = true, e.apply(void 0, arguments));
    };
  }
  var Ot = A3().codes, yi = Ot.ERR_MISSING_ARGS, vi = Ot.ERR_STREAM_DESTROYED;
  function Mt(e) {
    if (e)
      throw e;
  }
  function wi(e) {
    return e.setHeader && typeof e.abort == "function";
  }
  function Ri(e, t, r, i) {
    i = gi(i);
    var n = false;
    e.on("close", function() {
      n = true;
    }), qe3 === void 0 && (qe3 = Z3()), qe3(e, { readable: t, writable: r }, function(o2) {
      if (o2)
        return i(o2);
      n = true, i();
    });
    var a = false;
    return function(o2) {
      if (!n && !a) {
        if (a = true, wi(e))
          return e.abort();
        if (typeof e.destroy == "function")
          return e.destroy();
        i(o2 || new vi("pipe"));
      }
    };
  }
  function mt(e) {
    e();
  }
  function Ei(e, t) {
    return e.pipe(t);
  }
  function Si(e) {
    return !e.length || typeof e[e.length - 1] != "function" ? Mt : e.pop();
  }
  function Ti() {
    for (var e = arguments.length, t = new Array(e), r = 0; r < e; r++)
      t[r] = arguments[r];
    var i = Si(t);
    if (Array.isArray(t[0]) && (t = t[0]), t.length < 2)
      throw new yi("streams");
    var n, a = t.map(function(o2, f) {
      var s = f < t.length - 1, d4 = f > 0;
      return Ri(o2, s, d4, function(p3) {
        n || (n = p3), p3 && a.forEach(mt), !s && (a.forEach(mt), i(n));
      });
    });
    return t.reduce(Ei);
  }
  Lt2.exports = Ti;
});
var Ne = c3(($i, Dt) => {
  Dt.exports = _2;
  var Pe = ee.EventEmitter, Mi = L3();
  Mi(_2, Pe);
  _2.Readable = ve();
  _2.Writable = _e();
  _2.Duplex = D5();
  _2.Transform = De2();
  _2.PassThrough = Tt();
  _2.finished = Z3();
  _2.pipeline = At();
  _2.Stream = _2;
  function _2() {
    Pe.call(this);
  }
  _2.prototype.pipe = function(e, t) {
    var r = this;
    function i(p3) {
      e.writable && e.write(p3) === false && r.pause && r.pause();
    }
    r.on("data", i);
    function n() {
      r.readable && r.resume && r.resume();
    }
    e.on("drain", n), !e._isStdio && (!t || t.end !== false) && (r.on("end", o2), r.on("close", f));
    var a = false;
    function o2() {
      a || (a = true, e.end());
    }
    function f() {
      a || (a = true, typeof e.destroy == "function" && e.destroy());
    }
    function s(p3) {
      if (d4(), Pe.listenerCount(this, "error") === 0)
        throw p3;
    }
    r.on("error", s), e.on("error", s);
    function d4() {
      r.removeListener("data", i), e.removeListener("drain", n), r.removeListener("end", o2), r.removeListener("close", f), r.removeListener("error", s), e.removeListener("error", s), r.removeListener("end", d4), r.removeListener("close", d4), e.removeListener("close", d4);
    }
    return r.on("end", d4), r.on("close", d4), e.on("close", d4), e.emit("pipe", r), e;
  };
});
var Nt = Ce(Ne());
var mi = Ce(Ne());
var { default: Oi, ...Li } = mi;
var qt;
var Pt;
var Ki = (Pt = (qt = Nt.default) != null ? qt : Oi) != null ? Pt : Li;

// deno:https://esm.sh/v86/crypto-browserify@3.12.0/es2019/crypto-browserify.bundle.js
var __global$4 = globalThis || (typeof window !== "undefined" ? window : self);
var __setImmediate$2 = (cb, ...args) => setTimeout(cb, 0, ...args);
var m12 = Object.create;
var Ls2 = Object.defineProperty;
var g12 = Object.getOwnPropertyDescriptor;
var y12 = Object.getOwnPropertyNames;
var _12 = Object.getPrototypeOf;
var w1 = Object.prototype.hasOwnProperty;
var Ke4 = ((t) => typeof require != "undefined" ? require : typeof Proxy != "undefined" ? new Proxy(t, { get: (e, r) => (typeof require != "undefined" ? require : e)[r] }) : t)(function(t) {
  if (typeof require != "undefined")
    return require.apply(this, arguments);
  throw new Error('Dynamic require of "' + t + '" is not supported');
});
var k4 = (t, e) => () => (e || t((e = { exports: {} }).exports, e), e.exports);
var x1 = (t, e, r, n) => {
  if (e && typeof e == "object" || typeof e == "function")
    for (let i of y12(e))
      !w1.call(t, i) && i !== r && Ls2(t, i, { get: () => e[i], enumerable: !(n = g12(e, i)) || n.enumerable });
  return t;
};
var Os2 = (t, e, r) => (r = t != null ? m12(_12(t)) : {}, x1(e || !t || !t.__esModule ? Ls2(r, "default", { value: t, enumerable: true }) : r, t));
var Ae2 = k4((ya, Us) => {
  var Gf = export_default, er = Gf.Buffer;
  function zs(t, e) {
    for (var r in t)
      e[r] = t[r];
  }
  er.from && er.alloc && er.allocUnsafe && er.allocUnsafeSlow ? Us.exports = Gf : (zs(Gf, ya), ya.Buffer = ii);
  function ii(t, e, r) {
    return er(t, e, r);
  }
  ii.prototype = Object.create(er.prototype);
  zs(er, ii);
  ii.from = function(t, e, r) {
    if (typeof t == "number")
      throw new TypeError("Argument must not be a number");
    return er(t, e, r);
  };
  ii.alloc = function(t, e, r) {
    if (typeof t != "number")
      throw new TypeError("Argument must be a number");
    var n = er(t);
    return e !== void 0 ? typeof r == "string" ? n.fill(e, r) : n.fill(e) : n.fill(0), n;
  };
  ii.allocUnsafe = function(t) {
    if (typeof t != "number")
      throw new TypeError("Argument must be a number");
    return er(t);
  };
  ii.allocUnsafeSlow = function(t) {
    if (typeof t != "number")
      throw new TypeError("Argument must be a number");
    return Gf.SlowBuffer(t);
  };
});
var fi2 = k4((F8, wa) => {
  "use strict";
  var _a3 = 65536, M1 = 4294967295;
  function S1() {
    throw new Error(`Secure random number generation is not supported by this browser.
Use Chrome, Firefox or Internet Explorer 11`);
  }
  var E1 = Ae2().Buffer, Xf = __global$4.crypto || __global$4.msCrypto;
  Xf && Xf.getRandomValues ? wa.exports = A1 : wa.exports = S1;
  function A1(t, e) {
    if (t > M1)
      throw new RangeError("requested too many random bytes");
    var r = E1.allocUnsafe(t);
    if (t > 0)
      if (t > _a3)
        for (var n = 0; n < t; n += _a3)
          Xf.getRandomValues(r.slice(n, n + _a3));
      else
        Xf.getRandomValues(r);
    return typeof e == "function" ? node_process_default.nextTick(function() {
      e(null, r);
    }) : r;
  }
});
var qe2 = k4((K8, xa) => {
  typeof Object.create == "function" ? xa.exports = function(e, r) {
    r && (e.super_ = r, e.prototype = Object.create(r.prototype, { constructor: { value: e, enumerable: false, writable: true, configurable: true } }));
  } : xa.exports = function(e, r) {
    if (r) {
      e.super_ = r;
      var n = function() {
      };
      n.prototype = r.prototype, e.prototype = new n(), e.prototype.constructor = e;
    }
  };
});
var Ma2 = k4((j8, Hs) => {
  Hs.exports = ee.EventEmitter;
});
var Ws2 = k4((W8, js) => {
  "use strict";
  function Fs(t, e) {
    var r = Object.keys(t);
    if (Object.getOwnPropertySymbols) {
      var n = Object.getOwnPropertySymbols(t);
      e && (n = n.filter(function(i) {
        return Object.getOwnPropertyDescriptor(t, i).enumerable;
      })), r.push.apply(r, n);
    }
    return r;
  }
  function q1(t) {
    for (var e = 1; e < arguments.length; e++) {
      var r = arguments[e] != null ? arguments[e] : {};
      e % 2 ? Fs(Object(r), true).forEach(function(n) {
        B1(t, n, r[n]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(r)) : Fs(Object(r)).forEach(function(n) {
        Object.defineProperty(t, n, Object.getOwnPropertyDescriptor(r, n));
      });
    }
    return t;
  }
  function B1(t, e, r) {
    return e in t ? Object.defineProperty(t, e, { value: r, enumerable: true, configurable: true, writable: true }) : t[e] = r, t;
  }
  function R1(t, e) {
    if (!(t instanceof e))
      throw new TypeError("Cannot call a class as a function");
  }
  function Ks(t, e) {
    for (var r = 0; r < e.length; r++) {
      var n = e[r];
      n.enumerable = n.enumerable || false, n.configurable = true, "value" in n && (n.writable = true), Object.defineProperty(t, n.key, n);
    }
  }
  function I1(t, e, r) {
    return e && Ks(t.prototype, e), r && Ks(t, r), t;
  }
  var k1 = export_default, Yf = k1.Buffer, D1 = Qo, Sa = D1.inspect, P1 = Sa && Sa.custom || "inspect";
  function T1(t, e, r) {
    Yf.prototype.copy.call(t, e, r);
  }
  js.exports = function() {
    function t() {
      R1(this, t), this.head = null, this.tail = null, this.length = 0;
    }
    return I1(t, [{ key: "push", value: function(r) {
      var n = { data: r, next: null };
      this.length > 0 ? this.tail.next = n : this.head = n, this.tail = n, ++this.length;
    } }, { key: "unshift", value: function(r) {
      var n = { data: r, next: this.head };
      this.length === 0 && (this.tail = n), this.head = n, ++this.length;
    } }, { key: "shift", value: function() {
      if (this.length !== 0) {
        var r = this.head.data;
        return this.length === 1 ? this.head = this.tail = null : this.head = this.head.next, --this.length, r;
      }
    } }, { key: "clear", value: function() {
      this.head = this.tail = null, this.length = 0;
    } }, { key: "join", value: function(r) {
      if (this.length === 0)
        return "";
      for (var n = this.head, i = "" + n.data; n = n.next; )
        i += r + n.data;
      return i;
    } }, { key: "concat", value: function(r) {
      if (this.length === 0)
        return Yf.alloc(0);
      for (var n = Yf.allocUnsafe(r >>> 0), i = this.head, o2 = 0; i; )
        T1(i.data, n, o2), o2 += i.data.length, i = i.next;
      return n;
    } }, { key: "consume", value: function(r, n) {
      var i;
      return r < this.head.data.length ? (i = this.head.data.slice(0, r), this.head.data = this.head.data.slice(r)) : r === this.head.data.length ? i = this.shift() : i = n ? this._getString(r) : this._getBuffer(r), i;
    } }, { key: "first", value: function() {
      return this.head.data;
    } }, { key: "_getString", value: function(r) {
      var n = this.head, i = 1, o2 = n.data;
      for (r -= o2.length; n = n.next; ) {
        var p3 = n.data, y4 = r > p3.length ? p3.length : r;
        if (y4 === p3.length ? o2 += p3 : o2 += p3.slice(0, r), r -= y4, r === 0) {
          y4 === p3.length ? (++i, n.next ? this.head = n.next : this.head = this.tail = null) : (this.head = n, n.data = p3.slice(y4));
          break;
        }
        ++i;
      }
      return this.length -= i, o2;
    } }, { key: "_getBuffer", value: function(r) {
      var n = Yf.allocUnsafe(r), i = this.head, o2 = 1;
      for (i.data.copy(n), r -= i.data.length; i = i.next; ) {
        var p3 = i.data, y4 = r > p3.length ? p3.length : r;
        if (p3.copy(n, n.length - r, 0, y4), r -= y4, r === 0) {
          y4 === p3.length ? (++o2, i.next ? this.head = i.next : this.head = this.tail = null) : (this.head = i, i.data = p3.slice(y4));
          break;
        }
        ++o2;
      }
      return this.length -= o2, n;
    } }, { key: P1, value: function(r, n) {
      return Sa(this, q1({}, n, { depth: 0, customInspect: false }));
    } }]), t;
  }();
});
var Aa2 = k4((V8, Zs) => {
  "use strict";
  function C1(t, e) {
    var r = this, n = this._readableState && this._readableState.destroyed, i = this._writableState && this._writableState.destroyed;
    return n || i ? (e ? e(t) : t && (this._writableState ? this._writableState.errorEmitted || (this._writableState.errorEmitted = true, node_process_default.nextTick(Ea, this, t)) : node_process_default.nextTick(Ea, this, t)), this) : (this._readableState && (this._readableState.destroyed = true), this._writableState && (this._writableState.destroyed = true), this._destroy(t || null, function(o2) {
      !e && o2 ? r._writableState ? r._writableState.errorEmitted ? node_process_default.nextTick(Jf, r) : (r._writableState.errorEmitted = true, node_process_default.nextTick(Vs, r, o2)) : node_process_default.nextTick(Vs, r, o2) : e ? (node_process_default.nextTick(Jf, r), e(o2)) : node_process_default.nextTick(Jf, r);
    }), this);
  }
  function Vs(t, e) {
    Ea(t, e), Jf(t);
  }
  function Jf(t) {
    t._writableState && !t._writableState.emitClose || t._readableState && !t._readableState.emitClose || t.emit("close");
  }
  function N1() {
    this._readableState && (this._readableState.destroyed = false, this._readableState.reading = false, this._readableState.ended = false, this._readableState.endEmitted = false), this._writableState && (this._writableState.destroyed = false, this._writableState.ended = false, this._writableState.ending = false, this._writableState.finalCalled = false, this._writableState.prefinished = false, this._writableState.finished = false, this._writableState.errorEmitted = false);
  }
  function Ea(t, e) {
    t.emit("error", e);
  }
  function L1(t, e) {
    var r = t._readableState, n = t._writableState;
    r && r.autoDestroy || n && n.autoDestroy ? t.destroy(e) : t.emit("error", e);
  }
  Zs.exports = { destroy: C1, undestroy: N1, errorOrDestroy: L1 };
});
var ni2 = k4((Z8, Ys) => {
  "use strict";
  function O1(t, e) {
    t.prototype = Object.create(e.prototype), t.prototype.constructor = t, t.__proto__ = e;
  }
  var Xs = {};
  function ct4(t, e, r) {
    r || (r = Error);
    function n(o2, p3, y4) {
      return typeof e == "string" ? e : e(o2, p3, y4);
    }
    var i = function(o2) {
      O1(p3, o2);
      function p3(y4, w2, x) {
        return o2.call(this, n(y4, w2, x)) || this;
      }
      return p3;
    }(r);
    i.prototype.name = r.name, i.prototype.code = t, Xs[t] = i;
  }
  function Gs(t, e) {
    if (Array.isArray(t)) {
      var r = t.length;
      return t = t.map(function(n) {
        return String(n);
      }), r > 2 ? "one of ".concat(e, " ").concat(t.slice(0, r - 1).join(", "), ", or ") + t[r - 1] : r === 2 ? "one of ".concat(e, " ").concat(t[0], " or ").concat(t[1]) : "of ".concat(e, " ").concat(t[0]);
    } else
      return "of ".concat(e, " ").concat(String(t));
  }
  function z1(t, e, r) {
    return t.substr(!r || r < 0 ? 0 : +r, e.length) === e;
  }
  function U1(t, e, r) {
    return (r === void 0 || r > t.length) && (r = t.length), t.substring(r - e.length, r) === e;
  }
  function H1(t, e, r) {
    return typeof r != "number" && (r = 0), r + e.length > t.length ? false : t.indexOf(e, r) !== -1;
  }
  ct4("ERR_INVALID_OPT_VALUE", function(t, e) {
    return 'The value "' + e + '" is invalid for option "' + t + '"';
  }, TypeError);
  ct4("ERR_INVALID_ARG_TYPE", function(t, e, r) {
    var n;
    typeof e == "string" && z1(e, "not ") ? (n = "must not be", e = e.replace(/^not /, "")) : n = "must be";
    var i;
    if (U1(t, " argument"))
      i = "The ".concat(t, " ").concat(n, " ").concat(Gs(e, "type"));
    else {
      var o2 = H1(t, ".") ? "property" : "argument";
      i = 'The "'.concat(t, '" ').concat(o2, " ").concat(n, " ").concat(Gs(e, "type"));
    }
    return i += ". Received type ".concat(typeof r), i;
  }, TypeError);
  ct4("ERR_STREAM_PUSH_AFTER_EOF", "stream.push() after EOF");
  ct4("ERR_METHOD_NOT_IMPLEMENTED", function(t) {
    return "The " + t + " method is not implemented";
  });
  ct4("ERR_STREAM_PREMATURE_CLOSE", "Premature close");
  ct4("ERR_STREAM_DESTROYED", function(t) {
    return "Cannot call " + t + " after a stream was destroyed";
  });
  ct4("ERR_MULTIPLE_CALLBACK", "Callback called multiple times");
  ct4("ERR_STREAM_CANNOT_PIPE", "Cannot pipe, not readable");
  ct4("ERR_STREAM_WRITE_AFTER_END", "write after end");
  ct4("ERR_STREAM_NULL_VALUES", "May not write null values to stream", TypeError);
  ct4("ERR_UNKNOWN_ENCODING", function(t) {
    return "Unknown encoding: " + t;
  }, TypeError);
  ct4("ERR_STREAM_UNSHIFT_AFTER_END_EVENT", "stream.unshift() after end event");
  Ys.exports.codes = Xs;
});
var qa2 = k4((G8, Js) => {
  "use strict";
  var F1 = ni2().codes.ERR_INVALID_OPT_VALUE;
  function K1(t, e, r) {
    return t.highWaterMark != null ? t.highWaterMark : e ? t[r] : null;
  }
  function j1(t, e, r, n) {
    var i = K1(e, n, r);
    if (i != null) {
      if (!(isFinite(i) && Math.floor(i) === i) || i < 0) {
        var o2 = n ? r : "highWaterMark";
        throw new F1(o2, i);
      }
      return Math.floor(i);
    }
    return t.objectMode ? 16 : 16 * 1024;
  }
  Js.exports = { getHighWaterMark: j1 };
});
var Qs2 = k4((X8, $s) => {
  $s.exports = W1;
  function W1(t, e) {
    if (Ba("noDeprecation"))
      return t;
    var r = false;
    function n() {
      if (!r) {
        if (Ba("throwDeprecation"))
          throw new Error(e);
        Ba("traceDeprecation") ? console.trace(e) : console.warn(e), r = true;
      }
      return t.apply(this, arguments);
    }
    return n;
  }
  function Ba(t) {
    try {
      if (!__global$4.localStorage)
        return false;
    } catch {
      return false;
    }
    var e = __global$4.localStorage[t];
    return e == null ? false : String(e).toLowerCase() === "true";
  }
});
var ka2 = k4((Y8, no2) => {
  "use strict";
  no2.exports = Le;
  function to2(t) {
    var e = this;
    this.next = null, this.entry = null, this.finish = function() {
      gv(e, t);
    };
  }
  var Di;
  Le.WritableState = df;
  var V1 = { deprecate: Qs2() }, ro = Ma2(), Qf = export_default.Buffer, Z1 = __global$4.Uint8Array || function() {
  };
  function G1(t) {
    return Qf.from(t);
  }
  function X1(t) {
    return Qf.isBuffer(t) || t instanceof Z1;
  }
  var Ia = Aa2(), Y1 = qa2(), J1 = Y1.getHighWaterMark, Hr = ni2().codes, $1 = Hr.ERR_INVALID_ARG_TYPE, Q1 = Hr.ERR_METHOD_NOT_IMPLEMENTED, ev = Hr.ERR_MULTIPLE_CALLBACK, tv = Hr.ERR_STREAM_CANNOT_PIPE, rv = Hr.ERR_STREAM_DESTROYED, iv = Hr.ERR_STREAM_NULL_VALUES, fv = Hr.ERR_STREAM_WRITE_AFTER_END, nv = Hr.ERR_UNKNOWN_ENCODING, Pi = Ia.errorOrDestroy;
  qe2()(Le, ro);
  function av() {
  }
  function df(t, e, r) {
    Di = Di || ai2(), t = t || {}, typeof r != "boolean" && (r = e instanceof Di), this.objectMode = !!t.objectMode, r && (this.objectMode = this.objectMode || !!t.writableObjectMode), this.highWaterMark = J1(this, t, "writableHighWaterMark", r), this.finalCalled = false, this.needDrain = false, this.ending = false, this.ended = false, this.finished = false, this.destroyed = false;
    var n = t.decodeStrings === false;
    this.decodeStrings = !n, this.defaultEncoding = t.defaultEncoding || "utf8", this.length = 0, this.writing = false, this.corked = 0, this.sync = true, this.bufferProcessing = false, this.onwrite = function(i) {
      lv(e, i);
    }, this.writecb = null, this.writelen = 0, this.bufferedRequest = null, this.lastBufferedRequest = null, this.pendingcb = 0, this.prefinished = false, this.errorEmitted = false, this.emitClose = t.emitClose !== false, this.autoDestroy = !!t.autoDestroy, this.bufferedRequestCount = 0, this.corkedRequestsFree = new to2(this);
  }
  df.prototype.getBuffer = function() {
    for (var e = this.bufferedRequest, r = []; e; )
      r.push(e), e = e.next;
    return r;
  };
  (function() {
    try {
      Object.defineProperty(df.prototype, "buffer", { get: V1.deprecate(function() {
        return this.getBuffer();
      }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003") });
    } catch {
    }
  })();
  var $f;
  typeof Symbol == "function" && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] == "function" ? ($f = Function.prototype[Symbol.hasInstance], Object.defineProperty(Le, Symbol.hasInstance, { value: function(e) {
    return $f.call(this, e) ? true : this !== Le ? false : e && e._writableState instanceof df;
  } })) : $f = function(e) {
    return e instanceof this;
  };
  function Le(t) {
    Di = Di || ai2();
    var e = this instanceof Di;
    if (!e && !$f.call(Le, this))
      return new Le(t);
    this._writableState = new df(t, this, e), this.writable = true, t && (typeof t.write == "function" && (this._write = t.write), typeof t.writev == "function" && (this._writev = t.writev), typeof t.destroy == "function" && (this._destroy = t.destroy), typeof t.final == "function" && (this._final = t.final)), ro.call(this);
  }
  Le.prototype.pipe = function() {
    Pi(this, new tv());
  };
  function sv(t, e) {
    var r = new fv();
    Pi(t, r), node_process_default.nextTick(e, r);
  }
  function ov(t, e, r, n) {
    var i;
    return r === null ? i = new iv() : typeof r != "string" && !e.objectMode && (i = new $1("chunk", ["string", "Buffer"], r)), i ? (Pi(t, i), node_process_default.nextTick(n, i), false) : true;
  }
  Le.prototype.write = function(t, e, r) {
    var n = this._writableState, i = false, o2 = !n.objectMode && X1(t);
    return o2 && !Qf.isBuffer(t) && (t = G1(t)), typeof e == "function" && (r = e, e = null), o2 ? e = "buffer" : e || (e = n.defaultEncoding), typeof r != "function" && (r = av), n.ending ? sv(this, r) : (o2 || ov(this, n, t, r)) && (n.pendingcb++, i = uv(this, n, o2, t, e, r)), i;
  };
  Le.prototype.cork = function() {
    this._writableState.corked++;
  };
  Le.prototype.uncork = function() {
    var t = this._writableState;
    t.corked && (t.corked--, !t.writing && !t.corked && !t.bufferProcessing && t.bufferedRequest && io(this, t));
  };
  Le.prototype.setDefaultEncoding = function(e) {
    if (typeof e == "string" && (e = e.toLowerCase()), !(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((e + "").toLowerCase()) > -1))
      throw new nv(e);
    return this._writableState.defaultEncoding = e, this;
  };
  Object.defineProperty(Le.prototype, "writableBuffer", { enumerable: false, get: function() {
    return this._writableState && this._writableState.getBuffer();
  } });
  function hv(t, e, r) {
    return !t.objectMode && t.decodeStrings !== false && typeof e == "string" && (e = Qf.from(e, r)), e;
  }
  Object.defineProperty(Le.prototype, "writableHighWaterMark", { enumerable: false, get: function() {
    return this._writableState.highWaterMark;
  } });
  function uv(t, e, r, n, i, o2) {
    if (!r) {
      var p3 = hv(e, n, i);
      n !== p3 && (r = true, i = "buffer", n = p3);
    }
    var y4 = e.objectMode ? 1 : n.length;
    e.length += y4;
    var w2 = e.length < e.highWaterMark;
    if (w2 || (e.needDrain = true), e.writing || e.corked) {
      var x = e.lastBufferedRequest;
      e.lastBufferedRequest = { chunk: n, encoding: i, isBuf: r, callback: o2, next: null }, x ? x.next = e.lastBufferedRequest : e.bufferedRequest = e.lastBufferedRequest, e.bufferedRequestCount += 1;
    } else
      Ra(t, e, false, y4, n, i, o2);
    return w2;
  }
  function Ra(t, e, r, n, i, o2, p3) {
    e.writelen = n, e.writecb = p3, e.writing = true, e.sync = true, e.destroyed ? e.onwrite(new rv("write")) : r ? t._writev(i, e.onwrite) : t._write(i, o2, e.onwrite), e.sync = false;
  }
  function dv(t, e, r, n, i) {
    --e.pendingcb, r ? (node_process_default.nextTick(i, n), node_process_default.nextTick(uf, t, e), t._writableState.errorEmitted = true, Pi(t, n)) : (i(n), t._writableState.errorEmitted = true, Pi(t, n), uf(t, e));
  }
  function cv(t) {
    t.writing = false, t.writecb = null, t.length -= t.writelen, t.writelen = 0;
  }
  function lv(t, e) {
    var r = t._writableState, n = r.sync, i = r.writecb;
    if (typeof i != "function")
      throw new ev();
    if (cv(r), e)
      dv(t, r, n, e, i);
    else {
      var o2 = fo(r) || t.destroyed;
      !o2 && !r.corked && !r.bufferProcessing && r.bufferedRequest && io(t, r), n ? node_process_default.nextTick(eo, t, r, o2, i) : eo(t, r, o2, i);
    }
  }
  function eo(t, e, r, n) {
    r || vv(t, e), e.pendingcb--, n(), uf(t, e);
  }
  function vv(t, e) {
    e.length === 0 && e.needDrain && (e.needDrain = false, t.emit("drain"));
  }
  function io(t, e) {
    e.bufferProcessing = true;
    var r = e.bufferedRequest;
    if (t._writev && r && r.next) {
      var n = e.bufferedRequestCount, i = new Array(n), o2 = e.corkedRequestsFree;
      o2.entry = r;
      for (var p3 = 0, y4 = true; r; )
        i[p3] = r, r.isBuf || (y4 = false), r = r.next, p3 += 1;
      i.allBuffers = y4, Ra(t, e, true, e.length, i, "", o2.finish), e.pendingcb++, e.lastBufferedRequest = null, o2.next ? (e.corkedRequestsFree = o2.next, o2.next = null) : e.corkedRequestsFree = new to2(e), e.bufferedRequestCount = 0;
    } else {
      for (; r; ) {
        var w2 = r.chunk, x = r.encoding, M4 = r.callback, E2 = e.objectMode ? 1 : w2.length;
        if (Ra(t, e, false, E2, w2, x, M4), r = r.next, e.bufferedRequestCount--, e.writing)
          break;
      }
      r === null && (e.lastBufferedRequest = null);
    }
    e.bufferedRequest = r, e.bufferProcessing = false;
  }
  Le.prototype._write = function(t, e, r) {
    r(new Q1("_write()"));
  };
  Le.prototype._writev = null;
  Le.prototype.end = function(t, e, r) {
    var n = this._writableState;
    return typeof t == "function" ? (r = t, t = null, e = null) : typeof e == "function" && (r = e, e = null), t != null && this.write(t, e), n.corked && (n.corked = 1, this.uncork()), n.ending || mv(this, n, r), this;
  };
  Object.defineProperty(Le.prototype, "writableLength", { enumerable: false, get: function() {
    return this._writableState.length;
  } });
  function fo(t) {
    return t.ending && t.length === 0 && t.bufferedRequest === null && !t.finished && !t.writing;
  }
  function pv(t, e) {
    t._final(function(r) {
      e.pendingcb--, r && Pi(t, r), e.prefinished = true, t.emit("prefinish"), uf(t, e);
    });
  }
  function bv(t, e) {
    !e.prefinished && !e.finalCalled && (typeof t._final == "function" && !e.destroyed ? (e.pendingcb++, e.finalCalled = true, node_process_default.nextTick(pv, t, e)) : (e.prefinished = true, t.emit("prefinish")));
  }
  function uf(t, e) {
    var r = fo(e);
    if (r && (bv(t, e), e.pendingcb === 0 && (e.finished = true, t.emit("finish"), e.autoDestroy))) {
      var n = t._readableState;
      (!n || n.autoDestroy && n.endEmitted) && t.destroy();
    }
    return r;
  }
  function mv(t, e, r) {
    e.ending = true, uf(t, e), r && (e.finished ? node_process_default.nextTick(r) : t.once("finish", r)), e.ended = true, t.writable = false;
  }
  function gv(t, e, r) {
    var n = t.entry;
    for (t.entry = null; n; ) {
      var i = n.callback;
      e.pendingcb--, i(r), n = n.next;
    }
    e.corkedRequestsFree.next = t;
  }
  Object.defineProperty(Le.prototype, "destroyed", { enumerable: false, get: function() {
    return this._writableState === void 0 ? false : this._writableState.destroyed;
  }, set: function(e) {
    !this._writableState || (this._writableState.destroyed = e);
  } });
  Le.prototype.destroy = Ia.destroy;
  Le.prototype._undestroy = Ia.undestroy;
  Le.prototype._destroy = function(t, e) {
    e(t);
  };
});
var ai2 = k4((J8, so) => {
  "use strict";
  var yv = Object.keys || function(t) {
    var e = [];
    for (var r in t)
      e.push(r);
    return e;
  };
  so.exports = tr;
  var ao = Ta2(), Pa = ka2();
  qe2()(tr, ao);
  for (Da = yv(Pa.prototype), en = 0; en < Da.length; en++)
    tn = Da[en], tr.prototype[tn] || (tr.prototype[tn] = Pa.prototype[tn]);
  var Da, tn, en;
  function tr(t) {
    if (!(this instanceof tr))
      return new tr(t);
    ao.call(this, t), Pa.call(this, t), this.allowHalfOpen = true, t && (t.readable === false && (this.readable = false), t.writable === false && (this.writable = false), t.allowHalfOpen === false && (this.allowHalfOpen = false, this.once("end", _v)));
  }
  Object.defineProperty(tr.prototype, "writableHighWaterMark", { enumerable: false, get: function() {
    return this._writableState.highWaterMark;
  } });
  Object.defineProperty(tr.prototype, "writableBuffer", { enumerable: false, get: function() {
    return this._writableState && this._writableState.getBuffer();
  } });
  Object.defineProperty(tr.prototype, "writableLength", { enumerable: false, get: function() {
    return this._writableState.length;
  } });
  function _v() {
    this._writableState.ended || node_process_default.nextTick(wv, this);
  }
  function wv(t) {
    t.end();
  }
  Object.defineProperty(tr.prototype, "destroyed", { enumerable: false, get: function() {
    return this._readableState === void 0 || this._writableState === void 0 ? false : this._readableState.destroyed && this._writableState.destroyed;
  }, set: function(e) {
    this._readableState === void 0 || this._writableState === void 0 || (this._readableState.destroyed = e, this._writableState.destroyed = e);
  } });
});
var rn2 = k4(($8, uo) => {
  "use strict";
  var oo = ni2().codes.ERR_STREAM_PREMATURE_CLOSE;
  function xv(t) {
    var e = false;
    return function() {
      if (!e) {
        e = true;
        for (var r = arguments.length, n = new Array(r), i = 0; i < r; i++)
          n[i] = arguments[i];
        t.apply(this, n);
      }
    };
  }
  function Mv() {
  }
  function Sv(t) {
    return t.setHeader && typeof t.abort == "function";
  }
  function ho(t, e, r) {
    if (typeof e == "function")
      return ho(t, null, e);
    e || (e = {}), r = xv(r || Mv);
    var n = e.readable || e.readable !== false && t.readable, i = e.writable || e.writable !== false && t.writable, o2 = function() {
      t.writable || y4();
    }, p3 = t._writableState && t._writableState.finished, y4 = function() {
      i = false, p3 = true, n || r.call(t);
    }, w2 = t._readableState && t._readableState.endEmitted, x = function() {
      n = false, w2 = true, i || r.call(t);
    }, M4 = function(D6) {
      r.call(t, D6);
    }, E2 = function() {
      var D6;
      if (n && !w2)
        return (!t._readableState || !t._readableState.ended) && (D6 = new oo()), r.call(t, D6);
      if (i && !p3)
        return (!t._writableState || !t._writableState.ended) && (D6 = new oo()), r.call(t, D6);
    }, A4 = function() {
      t.req.on("finish", y4);
    };
    return Sv(t) ? (t.on("complete", y4), t.on("abort", E2), t.req ? A4() : t.on("request", A4)) : i && !t._writableState && (t.on("end", o2), t.on("close", o2)), t.on("end", x), t.on("finish", y4), e.error !== false && t.on("error", M4), t.on("close", E2), function() {
      t.removeListener("complete", y4), t.removeListener("abort", E2), t.removeListener("request", A4), t.req && t.req.removeListener("finish", y4), t.removeListener("end", o2), t.removeListener("close", o2), t.removeListener("finish", y4), t.removeListener("end", x), t.removeListener("error", M4), t.removeListener("close", E2);
    };
  }
  uo.exports = ho;
});
var lo2 = k4((Q8, co) => {
  "use strict";
  var fn;
  function Fr3(t, e, r) {
    return e in t ? Object.defineProperty(t, e, { value: r, enumerable: true, configurable: true, writable: true }) : t[e] = r, t;
  }
  var Ev = rn2(), Kr = Symbol("lastResolve"), si2 = Symbol("lastReject"), cf = Symbol("error"), nn = Symbol("ended"), oi = Symbol("lastPromise"), Ca = Symbol("handlePromise"), hi2 = Symbol("stream");
  function jr3(t, e) {
    return { value: t, done: e };
  }
  function Av(t) {
    var e = t[Kr];
    if (e !== null) {
      var r = t[hi2].read();
      r !== null && (t[oi] = null, t[Kr] = null, t[si2] = null, e(jr3(r, false)));
    }
  }
  function qv(t) {
    node_process_default.nextTick(Av, t);
  }
  function Bv(t, e) {
    return function(r, n) {
      t.then(function() {
        if (e[nn]) {
          r(jr3(void 0, true));
          return;
        }
        e[Ca](r, n);
      }, n);
    };
  }
  var Rv = Object.getPrototypeOf(function() {
  }), Iv = Object.setPrototypeOf((fn = { get stream() {
    return this[hi2];
  }, next: function() {
    var e = this, r = this[cf];
    if (r !== null)
      return Promise.reject(r);
    if (this[nn])
      return Promise.resolve(jr3(void 0, true));
    if (this[hi2].destroyed)
      return new Promise(function(p3, y4) {
        node_process_default.nextTick(function() {
          e[cf] ? y4(e[cf]) : p3(jr3(void 0, true));
        });
      });
    var n = this[oi], i;
    if (n)
      i = new Promise(Bv(n, this));
    else {
      var o2 = this[hi2].read();
      if (o2 !== null)
        return Promise.resolve(jr3(o2, false));
      i = new Promise(this[Ca]);
    }
    return this[oi] = i, i;
  } }, Fr3(fn, Symbol.asyncIterator, function() {
    return this;
  }), Fr3(fn, "return", function() {
    var e = this;
    return new Promise(function(r, n) {
      e[hi2].destroy(null, function(i) {
        if (i) {
          n(i);
          return;
        }
        r(jr3(void 0, true));
      });
    });
  }), fn), Rv), kv = function(e) {
    var r, n = Object.create(Iv, (r = {}, Fr3(r, hi2, { value: e, writable: true }), Fr3(r, Kr, { value: null, writable: true }), Fr3(r, si2, { value: null, writable: true }), Fr3(r, cf, { value: null, writable: true }), Fr3(r, nn, { value: e._readableState.endEmitted, writable: true }), Fr3(r, Ca, { value: function(o2, p3) {
      var y4 = n[hi2].read();
      y4 ? (n[oi] = null, n[Kr] = null, n[si2] = null, o2(jr3(y4, false))) : (n[Kr] = o2, n[si2] = p3);
    }, writable: true }), r));
    return n[oi] = null, Ev(e, function(i) {
      if (i && i.code !== "ERR_STREAM_PREMATURE_CLOSE") {
        var o2 = n[si2];
        o2 !== null && (n[oi] = null, n[Kr] = null, n[si2] = null, o2(i)), n[cf] = i;
        return;
      }
      var p3 = n[Kr];
      p3 !== null && (n[oi] = null, n[Kr] = null, n[si2] = null, p3(jr3(void 0, true))), n[nn] = true;
    }), e.on("readable", qv.bind(null, n)), n;
  };
  co.exports = kv;
});
var po2 = k4((e5, vo) => {
  vo.exports = function() {
    throw new Error("Readable.from is not available in the browser");
  };
});
var Ta2 = k4((r5, Eo) => {
  "use strict";
  Eo.exports = Ie;
  var Ti;
  Ie.ReadableState = yo;
  var t5 = ee.EventEmitter, go = function(e, r) {
    return e.listeners(r).length;
  }, vf = Ma2(), an = export_default.Buffer, Dv = __global$4.Uint8Array || function() {
  };
  function Pv(t) {
    return an.from(t);
  }
  function Tv(t) {
    return an.isBuffer(t) || t instanceof Dv;
  }
  var Na = Qo, Be3;
  Na && Na.debuglog ? Be3 = Na.debuglog("stream") : Be3 = function() {
  };
  var Cv = Ws2(), Ka = Aa2(), Nv = qa2(), Lv = Nv.getHighWaterMark, sn = ni2().codes, Ov = sn.ERR_INVALID_ARG_TYPE, zv = sn.ERR_STREAM_PUSH_AFTER_EOF, Uv = sn.ERR_METHOD_NOT_IMPLEMENTED, Hv = sn.ERR_STREAM_UNSHIFT_AFTER_END_EVENT, Ci, La, Oa;
  qe2()(Ie, vf);
  var lf = Ka.errorOrDestroy, za = ["error", "close", "destroy", "pause", "resume"];
  function Fv(t, e, r) {
    if (typeof t.prependListener == "function")
      return t.prependListener(e, r);
    !t._events || !t._events[e] ? t.on(e, r) : Array.isArray(t._events[e]) ? t._events[e].unshift(r) : t._events[e] = [r, t._events[e]];
  }
  function yo(t, e, r) {
    Ti = Ti || ai2(), t = t || {}, typeof r != "boolean" && (r = e instanceof Ti), this.objectMode = !!t.objectMode, r && (this.objectMode = this.objectMode || !!t.readableObjectMode), this.highWaterMark = Lv(this, t, "readableHighWaterMark", r), this.buffer = new Cv(), this.length = 0, this.pipes = null, this.pipesCount = 0, this.flowing = null, this.ended = false, this.endEmitted = false, this.reading = false, this.sync = true, this.needReadable = false, this.emittedReadable = false, this.readableListening = false, this.resumeScheduled = false, this.paused = true, this.emitClose = t.emitClose !== false, this.autoDestroy = !!t.autoDestroy, this.destroyed = false, this.defaultEncoding = t.defaultEncoding || "utf8", this.awaitDrain = 0, this.readingMore = false, this.decoder = null, this.encoding = null, t.encoding && (Ci || (Ci = Y2.StringDecoder), this.decoder = new Ci(t.encoding), this.encoding = t.encoding);
  }
  function Ie(t) {
    if (Ti = Ti || ai2(), !(this instanceof Ie))
      return new Ie(t);
    var e = this instanceof Ti;
    this._readableState = new yo(t, this, e), this.readable = true, t && (typeof t.read == "function" && (this._read = t.read), typeof t.destroy == "function" && (this._destroy = t.destroy)), vf.call(this);
  }
  Object.defineProperty(Ie.prototype, "destroyed", { enumerable: false, get: function() {
    return this._readableState === void 0 ? false : this._readableState.destroyed;
  }, set: function(e) {
    !this._readableState || (this._readableState.destroyed = e);
  } });
  Ie.prototype.destroy = Ka.destroy;
  Ie.prototype._undestroy = Ka.undestroy;
  Ie.prototype._destroy = function(t, e) {
    e(t);
  };
  Ie.prototype.push = function(t, e) {
    var r = this._readableState, n;
    return r.objectMode ? n = true : typeof t == "string" && (e = e || r.defaultEncoding, e !== r.encoding && (t = an.from(t, e), e = ""), n = true), _o2(this, t, e, false, n);
  };
  Ie.prototype.unshift = function(t) {
    return _o2(this, t, null, true, false);
  };
  function _o2(t, e, r, n, i) {
    Be3("readableAddChunk", e);
    var o2 = t._readableState;
    if (e === null)
      o2.reading = false, Wv(t, o2);
    else {
      var p3;
      if (i || (p3 = Kv(o2, e)), p3)
        lf(t, p3);
      else if (o2.objectMode || e && e.length > 0)
        if (typeof e != "string" && !o2.objectMode && Object.getPrototypeOf(e) !== an.prototype && (e = Pv(e)), n)
          o2.endEmitted ? lf(t, new Hv()) : Ua(t, o2, e, true);
        else if (o2.ended)
          lf(t, new zv());
        else {
          if (o2.destroyed)
            return false;
          o2.reading = false, o2.decoder && !r ? (e = o2.decoder.write(e), o2.objectMode || e.length !== 0 ? Ua(t, o2, e, false) : Fa(t, o2)) : Ua(t, o2, e, false);
        }
      else
        n || (o2.reading = false, Fa(t, o2));
    }
    return !o2.ended && (o2.length < o2.highWaterMark || o2.length === 0);
  }
  function Ua(t, e, r, n) {
    e.flowing && e.length === 0 && !e.sync ? (e.awaitDrain = 0, t.emit("data", r)) : (e.length += e.objectMode ? 1 : r.length, n ? e.buffer.unshift(r) : e.buffer.push(r), e.needReadable && on2(t)), Fa(t, e);
  }
  function Kv(t, e) {
    var r;
    return !Tv(e) && typeof e != "string" && e !== void 0 && !t.objectMode && (r = new Ov("chunk", ["string", "Buffer", "Uint8Array"], e)), r;
  }
  Ie.prototype.isPaused = function() {
    return this._readableState.flowing === false;
  };
  Ie.prototype.setEncoding = function(t) {
    Ci || (Ci = Y2.StringDecoder);
    var e = new Ci(t);
    this._readableState.decoder = e, this._readableState.encoding = this._readableState.decoder.encoding;
    for (var r = this._readableState.buffer.head, n = ""; r !== null; )
      n += e.write(r.data), r = r.next;
    return this._readableState.buffer.clear(), n !== "" && this._readableState.buffer.push(n), this._readableState.length = n.length, this;
  };
  var bo = 1073741824;
  function jv(t) {
    return t >= bo ? t = bo : (t--, t |= t >>> 1, t |= t >>> 2, t |= t >>> 4, t |= t >>> 8, t |= t >>> 16, t++), t;
  }
  function mo(t, e) {
    return t <= 0 || e.length === 0 && e.ended ? 0 : e.objectMode ? 1 : t !== t ? e.flowing && e.length ? e.buffer.head.data.length : e.length : (t > e.highWaterMark && (e.highWaterMark = jv(t)), t <= e.length ? t : e.ended ? e.length : (e.needReadable = true, 0));
  }
  Ie.prototype.read = function(t) {
    Be3("read", t), t = parseInt(t, 10);
    var e = this._readableState, r = t;
    if (t !== 0 && (e.emittedReadable = false), t === 0 && e.needReadable && ((e.highWaterMark !== 0 ? e.length >= e.highWaterMark : e.length > 0) || e.ended))
      return Be3("read: emitReadable", e.length, e.ended), e.length === 0 && e.ended ? Ha(this) : on2(this), null;
    if (t = mo(t, e), t === 0 && e.ended)
      return e.length === 0 && Ha(this), null;
    var n = e.needReadable;
    Be3("need readable", n), (e.length === 0 || e.length - t < e.highWaterMark) && (n = true, Be3("length less than watermark", n)), e.ended || e.reading ? (n = false, Be3("reading or ended", n)) : n && (Be3("do read"), e.reading = true, e.sync = true, e.length === 0 && (e.needReadable = true), this._read(e.highWaterMark), e.sync = false, e.reading || (t = mo(r, e)));
    var i;
    return t > 0 ? i = Mo2(t, e) : i = null, i === null ? (e.needReadable = e.length <= e.highWaterMark, t = 0) : (e.length -= t, e.awaitDrain = 0), e.length === 0 && (e.ended || (e.needReadable = true), r !== t && e.ended && Ha(this)), i !== null && this.emit("data", i), i;
  };
  function Wv(t, e) {
    if (Be3("onEofChunk"), !e.ended) {
      if (e.decoder) {
        var r = e.decoder.end();
        r && r.length && (e.buffer.push(r), e.length += e.objectMode ? 1 : r.length);
      }
      e.ended = true, e.sync ? on2(t) : (e.needReadable = false, e.emittedReadable || (e.emittedReadable = true, wo(t)));
    }
  }
  function on2(t) {
    var e = t._readableState;
    Be3("emitReadable", e.needReadable, e.emittedReadable), e.needReadable = false, e.emittedReadable || (Be3("emitReadable", e.flowing), e.emittedReadable = true, node_process_default.nextTick(wo, t));
  }
  function wo(t) {
    var e = t._readableState;
    Be3("emitReadable_", e.destroyed, e.length, e.ended), !e.destroyed && (e.length || e.ended) && (t.emit("readable"), e.emittedReadable = false), e.needReadable = !e.flowing && !e.ended && e.length <= e.highWaterMark, ja(t);
  }
  function Fa(t, e) {
    e.readingMore || (e.readingMore = true, node_process_default.nextTick(Vv, t, e));
  }
  function Vv(t, e) {
    for (; !e.reading && !e.ended && (e.length < e.highWaterMark || e.flowing && e.length === 0); ) {
      var r = e.length;
      if (Be3("maybeReadMore read 0"), t.read(0), r === e.length)
        break;
    }
    e.readingMore = false;
  }
  Ie.prototype._read = function(t) {
    lf(this, new Uv("_read()"));
  };
  Ie.prototype.pipe = function(t, e) {
    var r = this, n = this._readableState;
    switch (n.pipesCount) {
      case 0:
        n.pipes = t;
        break;
      case 1:
        n.pipes = [n.pipes, t];
        break;
      default:
        n.pipes.push(t);
        break;
    }
    n.pipesCount += 1, Be3("pipe count=%d opts=%j", n.pipesCount, e);
    var i = (!e || e.end !== false) && t !== node_process_default.stdout && t !== node_process_default.stderr, o2 = i ? y4 : C;
    n.endEmitted ? node_process_default.nextTick(o2) : r.once("end", o2), t.on("unpipe", p3);
    function p3(ge2, L4) {
      Be3("onunpipe"), ge2 === r && L4 && L4.hasUnpiped === false && (L4.hasUnpiped = true, M4());
    }
    function y4() {
      Be3("onend"), t.end();
    }
    var w2 = Zv(r);
    t.on("drain", w2);
    var x = false;
    function M4() {
      Be3("cleanup"), t.removeListener("close", I3), t.removeListener("finish", D6), t.removeListener("drain", w2), t.removeListener("error", A4), t.removeListener("unpipe", p3), r.removeListener("end", y4), r.removeListener("end", C), r.removeListener("data", E2), x = true, n.awaitDrain && (!t._writableState || t._writableState.needDrain) && w2();
    }
    r.on("data", E2);
    function E2(ge2) {
      Be3("ondata");
      var L4 = t.write(ge2);
      Be3("dest.write", L4), L4 === false && ((n.pipesCount === 1 && n.pipes === t || n.pipesCount > 1 && So(n.pipes, t) !== -1) && !x && (Be3("false write response, pause", n.awaitDrain), n.awaitDrain++), r.pause());
    }
    function A4(ge2) {
      Be3("onerror", ge2), C(), t.removeListener("error", A4), go(t, "error") === 0 && lf(t, ge2);
    }
    Fv(t, "error", A4);
    function I3() {
      t.removeListener("finish", D6), C();
    }
    t.once("close", I3);
    function D6() {
      Be3("onfinish"), t.removeListener("close", I3), C();
    }
    t.once("finish", D6);
    function C() {
      Be3("unpipe"), r.unpipe(t);
    }
    return t.emit("pipe", r), n.flowing || (Be3("pipe resume"), r.resume()), t;
  };
  function Zv(t) {
    return function() {
      var r = t._readableState;
      Be3("pipeOnDrain", r.awaitDrain), r.awaitDrain && r.awaitDrain--, r.awaitDrain === 0 && go(t, "data") && (r.flowing = true, ja(t));
    };
  }
  Ie.prototype.unpipe = function(t) {
    var e = this._readableState, r = { hasUnpiped: false };
    if (e.pipesCount === 0)
      return this;
    if (e.pipesCount === 1)
      return t && t !== e.pipes ? this : (t || (t = e.pipes), e.pipes = null, e.pipesCount = 0, e.flowing = false, t && t.emit("unpipe", this, r), this);
    if (!t) {
      var n = e.pipes, i = e.pipesCount;
      e.pipes = null, e.pipesCount = 0, e.flowing = false;
      for (var o2 = 0; o2 < i; o2++)
        n[o2].emit("unpipe", this, { hasUnpiped: false });
      return this;
    }
    var p3 = So(e.pipes, t);
    return p3 === -1 ? this : (e.pipes.splice(p3, 1), e.pipesCount -= 1, e.pipesCount === 1 && (e.pipes = e.pipes[0]), t.emit("unpipe", this, r), this);
  };
  Ie.prototype.on = function(t, e) {
    var r = vf.prototype.on.call(this, t, e), n = this._readableState;
    return t === "data" ? (n.readableListening = this.listenerCount("readable") > 0, n.flowing !== false && this.resume()) : t === "readable" && !n.endEmitted && !n.readableListening && (n.readableListening = n.needReadable = true, n.flowing = false, n.emittedReadable = false, Be3("on readable", n.length, n.reading), n.length ? on2(this) : n.reading || node_process_default.nextTick(Gv, this)), r;
  };
  Ie.prototype.addListener = Ie.prototype.on;
  Ie.prototype.removeListener = function(t, e) {
    var r = vf.prototype.removeListener.call(this, t, e);
    return t === "readable" && node_process_default.nextTick(xo2, this), r;
  };
  Ie.prototype.removeAllListeners = function(t) {
    var e = vf.prototype.removeAllListeners.apply(this, arguments);
    return (t === "readable" || t === void 0) && node_process_default.nextTick(xo2, this), e;
  };
  function xo2(t) {
    var e = t._readableState;
    e.readableListening = t.listenerCount("readable") > 0, e.resumeScheduled && !e.paused ? e.flowing = true : t.listenerCount("data") > 0 && t.resume();
  }
  function Gv(t) {
    Be3("readable nexttick read 0"), t.read(0);
  }
  Ie.prototype.resume = function() {
    var t = this._readableState;
    return t.flowing || (Be3("resume"), t.flowing = !t.readableListening, Xv(this, t)), t.paused = false, this;
  };
  function Xv(t, e) {
    e.resumeScheduled || (e.resumeScheduled = true, node_process_default.nextTick(Yv, t, e));
  }
  function Yv(t, e) {
    Be3("resume", e.reading), e.reading || t.read(0), e.resumeScheduled = false, t.emit("resume"), ja(t), e.flowing && !e.reading && t.read(0);
  }
  Ie.prototype.pause = function() {
    return Be3("call pause flowing=%j", this._readableState.flowing), this._readableState.flowing !== false && (Be3("pause"), this._readableState.flowing = false, this.emit("pause")), this._readableState.paused = true, this;
  };
  function ja(t) {
    var e = t._readableState;
    for (Be3("flow", e.flowing); e.flowing && t.read() !== null; )
      ;
  }
  Ie.prototype.wrap = function(t) {
    var e = this, r = this._readableState, n = false;
    t.on("end", function() {
      if (Be3("wrapped end"), r.decoder && !r.ended) {
        var p3 = r.decoder.end();
        p3 && p3.length && e.push(p3);
      }
      e.push(null);
    }), t.on("data", function(p3) {
      if (Be3("wrapped data"), r.decoder && (p3 = r.decoder.write(p3)), !(r.objectMode && p3 == null) && !(!r.objectMode && (!p3 || !p3.length))) {
        var y4 = e.push(p3);
        y4 || (n = true, t.pause());
      }
    });
    for (var i in t)
      this[i] === void 0 && typeof t[i] == "function" && (this[i] = function(y4) {
        return function() {
          return t[y4].apply(t, arguments);
        };
      }(i));
    for (var o2 = 0; o2 < za.length; o2++)
      t.on(za[o2], this.emit.bind(this, za[o2]));
    return this._read = function(p3) {
      Be3("wrapped _read", p3), n && (n = false, t.resume());
    }, this;
  };
  typeof Symbol == "function" && (Ie.prototype[Symbol.asyncIterator] = function() {
    return La === void 0 && (La = lo2()), La(this);
  });
  Object.defineProperty(Ie.prototype, "readableHighWaterMark", { enumerable: false, get: function() {
    return this._readableState.highWaterMark;
  } });
  Object.defineProperty(Ie.prototype, "readableBuffer", { enumerable: false, get: function() {
    return this._readableState && this._readableState.buffer;
  } });
  Object.defineProperty(Ie.prototype, "readableFlowing", { enumerable: false, get: function() {
    return this._readableState.flowing;
  }, set: function(e) {
    this._readableState && (this._readableState.flowing = e);
  } });
  Ie._fromList = Mo2;
  Object.defineProperty(Ie.prototype, "readableLength", { enumerable: false, get: function() {
    return this._readableState.length;
  } });
  function Mo2(t, e) {
    if (e.length === 0)
      return null;
    var r;
    return e.objectMode ? r = e.buffer.shift() : !t || t >= e.length ? (e.decoder ? r = e.buffer.join("") : e.buffer.length === 1 ? r = e.buffer.first() : r = e.buffer.concat(e.length), e.buffer.clear()) : r = e.buffer.consume(t, e.decoder), r;
  }
  function Ha(t) {
    var e = t._readableState;
    Be3("endReadable", e.endEmitted), e.endEmitted || (e.ended = true, node_process_default.nextTick(Jv, e, t));
  }
  function Jv(t, e) {
    if (Be3("endReadableNT", t.endEmitted, t.length), !t.endEmitted && t.length === 0 && (t.endEmitted = true, e.readable = false, e.emit("end"), t.autoDestroy)) {
      var r = e._writableState;
      (!r || r.autoDestroy && r.finished) && e.destroy();
    }
  }
  typeof Symbol == "function" && (Ie.from = function(t, e) {
    return Oa === void 0 && (Oa = po2()), Oa(Ie, t, e);
  });
  function So(t, e) {
    for (var r = 0, n = t.length; r < n; r++)
      if (t[r] === e)
        return r;
    return -1;
  }
});
var Wa2 = k4((i5, qo2) => {
  "use strict";
  qo2.exports = cr;
  var hn = ni2().codes, $v = hn.ERR_METHOD_NOT_IMPLEMENTED, Qv = hn.ERR_MULTIPLE_CALLBACK, ep = hn.ERR_TRANSFORM_ALREADY_TRANSFORMING, tp = hn.ERR_TRANSFORM_WITH_LENGTH_0, un = ai2();
  qe2()(cr, un);
  function rp(t, e) {
    var r = this._transformState;
    r.transforming = false;
    var n = r.writecb;
    if (n === null)
      return this.emit("error", new Qv());
    r.writechunk = null, r.writecb = null, e != null && this.push(e), n(t);
    var i = this._readableState;
    i.reading = false, (i.needReadable || i.length < i.highWaterMark) && this._read(i.highWaterMark);
  }
  function cr(t) {
    if (!(this instanceof cr))
      return new cr(t);
    un.call(this, t), this._transformState = { afterTransform: rp.bind(this), needTransform: false, transforming: false, writecb: null, writechunk: null, writeencoding: null }, this._readableState.needReadable = true, this._readableState.sync = false, t && (typeof t.transform == "function" && (this._transform = t.transform), typeof t.flush == "function" && (this._flush = t.flush)), this.on("prefinish", ip);
  }
  function ip() {
    var t = this;
    typeof this._flush == "function" && !this._readableState.destroyed ? this._flush(function(e, r) {
      Ao(t, e, r);
    }) : Ao(this, null, null);
  }
  cr.prototype.push = function(t, e) {
    return this._transformState.needTransform = false, un.prototype.push.call(this, t, e);
  };
  cr.prototype._transform = function(t, e, r) {
    r(new $v("_transform()"));
  };
  cr.prototype._write = function(t, e, r) {
    var n = this._transformState;
    if (n.writecb = r, n.writechunk = t, n.writeencoding = e, !n.transforming) {
      var i = this._readableState;
      (n.needTransform || i.needReadable || i.length < i.highWaterMark) && this._read(i.highWaterMark);
    }
  };
  cr.prototype._read = function(t) {
    var e = this._transformState;
    e.writechunk !== null && !e.transforming ? (e.transforming = true, this._transform(e.writechunk, e.writeencoding, e.afterTransform)) : e.needTransform = true;
  };
  cr.prototype._destroy = function(t, e) {
    un.prototype._destroy.call(this, t, function(r) {
      e(r);
    });
  };
  function Ao(t, e, r) {
    if (e)
      return t.emit("error", e);
    if (r != null && t.push(r), t._writableState.length)
      throw new tp();
    if (t._transformState.transforming)
      throw new ep();
    return t.push(null);
  }
});
var Io3 = k4((f5, Ro2) => {
  "use strict";
  Ro2.exports = pf;
  var Bo2 = Wa2();
  qe2()(pf, Bo2);
  function pf(t) {
    if (!(this instanceof pf))
      return new pf(t);
    Bo2.call(this, t);
  }
  pf.prototype._transform = function(t, e, r) {
    r(null, t);
  };
});
var Co3 = k4((n5, To2) => {
  "use strict";
  var Va;
  function fp(t) {
    var e = false;
    return function() {
      e || (e = true, t.apply(void 0, arguments));
    };
  }
  var Po = ni2().codes, np = Po.ERR_MISSING_ARGS, ap = Po.ERR_STREAM_DESTROYED;
  function ko2(t) {
    if (t)
      throw t;
  }
  function sp(t) {
    return t.setHeader && typeof t.abort == "function";
  }
  function op(t, e, r, n) {
    n = fp(n);
    var i = false;
    t.on("close", function() {
      i = true;
    }), Va === void 0 && (Va = rn2()), Va(t, { readable: e, writable: r }, function(p3) {
      if (p3)
        return n(p3);
      i = true, n();
    });
    var o2 = false;
    return function(p3) {
      if (!i && !o2) {
        if (o2 = true, sp(t))
          return t.abort();
        if (typeof t.destroy == "function")
          return t.destroy();
        n(p3 || new ap("pipe"));
      }
    };
  }
  function Do2(t) {
    t();
  }
  function hp(t, e) {
    return t.pipe(e);
  }
  function up(t) {
    return !t.length || typeof t[t.length - 1] != "function" ? ko2 : t.pop();
  }
  function dp() {
    for (var t = arguments.length, e = new Array(t), r = 0; r < t; r++)
      e[r] = arguments[r];
    var n = up(e);
    if (Array.isArray(e[0]) && (e = e[0]), e.length < 2)
      throw new np("streams");
    var i, o2 = e.map(function(p3, y4) {
      var w2 = y4 < e.length - 1, x = y4 > 0;
      return op(p3, w2, x, function(M4) {
        i || (i = M4), M4 && o2.forEach(Do2), !w2 && (o2.forEach(Do2), n(i));
      });
    });
    return e.reduce(hp);
  }
  To2.exports = dp;
});
var Za2 = k4((lt3, No2) => {
  lt3 = No2.exports = Ta2();
  lt3.Stream = lt3;
  lt3.Readable = lt3;
  lt3.Writable = ka2();
  lt3.Duplex = ai2();
  lt3.Transform = Wa2();
  lt3.PassThrough = Io3();
  lt3.finished = rn2();
  lt3.pipeline = Co3();
});
var Ga2 = k4((a5, Oo) => {
  "use strict";
  var dn = Ae2().Buffer, Lo2 = Za2().Transform, cp = qe2();
  function lp(t, e) {
    if (!dn.isBuffer(t) && typeof t != "string")
      throw new TypeError(e + " must be a string or a buffer");
  }
  function Wr2(t) {
    Lo2.call(this), this._block = dn.allocUnsafe(t), this._blockSize = t, this._blockOffset = 0, this._length = [0, 0, 0, 0], this._finalized = false;
  }
  cp(Wr2, Lo2);
  Wr2.prototype._transform = function(t, e, r) {
    var n = null;
    try {
      this.update(t, e);
    } catch (i) {
      n = i;
    }
    r(n);
  };
  Wr2.prototype._flush = function(t) {
    var e = null;
    try {
      this.push(this.digest());
    } catch (r) {
      e = r;
    }
    t(e);
  };
  Wr2.prototype.update = function(t, e) {
    if (lp(t, "Data"), this._finalized)
      throw new Error("Digest already called");
    dn.isBuffer(t) || (t = dn.from(t, e));
    for (var r = this._block, n = 0; this._blockOffset + t.length - n >= this._blockSize; ) {
      for (var i = this._blockOffset; i < this._blockSize; )
        r[i++] = t[n++];
      this._update(), this._blockOffset = 0;
    }
    for (; n < t.length; )
      r[this._blockOffset++] = t[n++];
    for (var o2 = 0, p3 = t.length * 8; p3 > 0; ++o2)
      this._length[o2] += p3, p3 = this._length[o2] / 4294967296 | 0, p3 > 0 && (this._length[o2] -= 4294967296 * p3);
    return this;
  };
  Wr2.prototype._update = function() {
    throw new Error("_update is not implemented");
  };
  Wr2.prototype.digest = function(t) {
    if (this._finalized)
      throw new Error("Digest already called");
    this._finalized = true;
    var e = this._digest();
    t !== void 0 && (e = e.toString(t)), this._block.fill(0), this._blockOffset = 0;
    for (var r = 0; r < 4; ++r)
      this._length[r] = 0;
    return e;
  };
  Wr2.prototype._digest = function() {
    throw new Error("_digest is not implemented");
  };
  Oo.exports = Wr2;
});
var vn2 = k4((s5, Uo2) => {
  "use strict";
  var vp = qe2(), zo2 = Ga2(), pp = Ae2().Buffer, bp = new Array(16);
  function cn() {
    zo2.call(this, 64), this._a = 1732584193, this._b = 4023233417, this._c = 2562383102, this._d = 271733878;
  }
  vp(cn, zo2);
  cn.prototype._update = function() {
    for (var t = bp, e = 0; e < 16; ++e)
      t[e] = this._block.readInt32LE(e * 4);
    var r = this._a, n = this._b, i = this._c, o2 = this._d;
    r = Je2(r, n, i, o2, t[0], 3614090360, 7), o2 = Je2(o2, r, n, i, t[1], 3905402710, 12), i = Je2(i, o2, r, n, t[2], 606105819, 17), n = Je2(n, i, o2, r, t[3], 3250441966, 22), r = Je2(r, n, i, o2, t[4], 4118548399, 7), o2 = Je2(o2, r, n, i, t[5], 1200080426, 12), i = Je2(i, o2, r, n, t[6], 2821735955, 17), n = Je2(n, i, o2, r, t[7], 4249261313, 22), r = Je2(r, n, i, o2, t[8], 1770035416, 7), o2 = Je2(o2, r, n, i, t[9], 2336552879, 12), i = Je2(i, o2, r, n, t[10], 4294925233, 17), n = Je2(n, i, o2, r, t[11], 2304563134, 22), r = Je2(r, n, i, o2, t[12], 1804603682, 7), o2 = Je2(o2, r, n, i, t[13], 4254626195, 12), i = Je2(i, o2, r, n, t[14], 2792965006, 17), n = Je2(n, i, o2, r, t[15], 1236535329, 22), r = $e2(r, n, i, o2, t[1], 4129170786, 5), o2 = $e2(o2, r, n, i, t[6], 3225465664, 9), i = $e2(i, o2, r, n, t[11], 643717713, 14), n = $e2(n, i, o2, r, t[0], 3921069994, 20), r = $e2(r, n, i, o2, t[5], 3593408605, 5), o2 = $e2(o2, r, n, i, t[10], 38016083, 9), i = $e2(i, o2, r, n, t[15], 3634488961, 14), n = $e2(n, i, o2, r, t[4], 3889429448, 20), r = $e2(r, n, i, o2, t[9], 568446438, 5), o2 = $e2(o2, r, n, i, t[14], 3275163606, 9), i = $e2(i, o2, r, n, t[3], 4107603335, 14), n = $e2(n, i, o2, r, t[8], 1163531501, 20), r = $e2(r, n, i, o2, t[13], 2850285829, 5), o2 = $e2(o2, r, n, i, t[2], 4243563512, 9), i = $e2(i, o2, r, n, t[7], 1735328473, 14), n = $e2(n, i, o2, r, t[12], 2368359562, 20), r = Qe2(r, n, i, o2, t[5], 4294588738, 4), o2 = Qe2(o2, r, n, i, t[8], 2272392833, 11), i = Qe2(i, o2, r, n, t[11], 1839030562, 16), n = Qe2(n, i, o2, r, t[14], 4259657740, 23), r = Qe2(r, n, i, o2, t[1], 2763975236, 4), o2 = Qe2(o2, r, n, i, t[4], 1272893353, 11), i = Qe2(i, o2, r, n, t[7], 4139469664, 16), n = Qe2(n, i, o2, r, t[10], 3200236656, 23), r = Qe2(r, n, i, o2, t[13], 681279174, 4), o2 = Qe2(o2, r, n, i, t[0], 3936430074, 11), i = Qe2(i, o2, r, n, t[3], 3572445317, 16), n = Qe2(n, i, o2, r, t[6], 76029189, 23), r = Qe2(r, n, i, o2, t[9], 3654602809, 4), o2 = Qe2(o2, r, n, i, t[12], 3873151461, 11), i = Qe2(i, o2, r, n, t[15], 530742520, 16), n = Qe2(n, i, o2, r, t[2], 3299628645, 23), r = et(r, n, i, o2, t[0], 4096336452, 6), o2 = et(o2, r, n, i, t[7], 1126891415, 10), i = et(i, o2, r, n, t[14], 2878612391, 15), n = et(n, i, o2, r, t[5], 4237533241, 21), r = et(r, n, i, o2, t[12], 1700485571, 6), o2 = et(o2, r, n, i, t[3], 2399980690, 10), i = et(i, o2, r, n, t[10], 4293915773, 15), n = et(n, i, o2, r, t[1], 2240044497, 21), r = et(r, n, i, o2, t[8], 1873313359, 6), o2 = et(o2, r, n, i, t[15], 4264355552, 10), i = et(i, o2, r, n, t[6], 2734768916, 15), n = et(n, i, o2, r, t[13], 1309151649, 21), r = et(r, n, i, o2, t[4], 4149444226, 6), o2 = et(o2, r, n, i, t[11], 3174756917, 10), i = et(i, o2, r, n, t[2], 718787259, 15), n = et(n, i, o2, r, t[9], 3951481745, 21), this._a = this._a + r | 0, this._b = this._b + n | 0, this._c = this._c + i | 0, this._d = this._d + o2 | 0;
  };
  cn.prototype._digest = function() {
    this._block[this._blockOffset++] = 128, this._blockOffset > 56 && (this._block.fill(0, this._blockOffset, 64), this._update(), this._blockOffset = 0), this._block.fill(0, this._blockOffset, 56), this._block.writeUInt32LE(this._length[0], 56), this._block.writeUInt32LE(this._length[1], 60), this._update();
    var t = pp.allocUnsafe(16);
    return t.writeInt32LE(this._a, 0), t.writeInt32LE(this._b, 4), t.writeInt32LE(this._c, 8), t.writeInt32LE(this._d, 12), t;
  };
  function ln(t, e) {
    return t << e | t >>> 32 - e;
  }
  function Je2(t, e, r, n, i, o2, p3) {
    return ln(t + (e & r | ~e & n) + i + o2 | 0, p3) + e | 0;
  }
  function $e2(t, e, r, n, i, o2, p3) {
    return ln(t + (e & n | r & ~n) + i + o2 | 0, p3) + e | 0;
  }
  function Qe2(t, e, r, n, i, o2, p3) {
    return ln(t + (e ^ r ^ n) + i + o2 | 0, p3) + e | 0;
  }
  function et(t, e, r, n, i, o2, p3) {
    return ln(t + (r ^ (e | ~n)) + i + o2 | 0, p3) + e | 0;
  }
  Uo2.exports = cn;
});
var bn2 = k4((o5, Zo2) => {
  "use strict";
  var Xa = export_default.Buffer, mp = qe2(), Vo2 = Ga2(), gp = new Array(16), bf = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8, 3, 10, 14, 4, 9, 15, 8, 1, 2, 7, 0, 6, 13, 11, 5, 12, 1, 9, 11, 10, 0, 8, 12, 4, 13, 3, 7, 15, 14, 5, 6, 2, 4, 0, 5, 9, 7, 12, 2, 10, 14, 1, 3, 8, 11, 6, 15, 13], mf = [5, 14, 7, 0, 9, 2, 11, 4, 13, 6, 15, 8, 1, 10, 3, 12, 6, 11, 3, 7, 0, 13, 5, 10, 14, 15, 8, 12, 4, 9, 1, 2, 15, 5, 1, 3, 7, 14, 6, 9, 11, 8, 12, 2, 10, 0, 4, 13, 8, 6, 4, 1, 3, 11, 15, 0, 5, 12, 2, 13, 9, 7, 10, 14, 12, 15, 10, 4, 1, 5, 8, 7, 6, 2, 13, 14, 0, 3, 9, 11], gf = [11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8, 7, 6, 8, 13, 11, 9, 7, 15, 7, 12, 15, 9, 11, 7, 13, 12, 11, 13, 6, 7, 14, 9, 13, 15, 14, 8, 13, 6, 5, 12, 7, 5, 11, 12, 14, 15, 14, 15, 9, 8, 9, 14, 5, 6, 8, 6, 5, 12, 9, 15, 5, 11, 6, 8, 13, 12, 5, 12, 13, 14, 11, 8, 5, 6], yf = [8, 9, 9, 11, 13, 15, 15, 5, 7, 7, 8, 11, 14, 14, 12, 6, 9, 13, 15, 7, 12, 8, 9, 11, 7, 7, 12, 7, 6, 15, 13, 11, 9, 7, 15, 11, 8, 6, 6, 14, 12, 13, 5, 14, 13, 13, 7, 5, 15, 5, 8, 11, 14, 14, 6, 14, 6, 9, 12, 9, 12, 5, 15, 8, 8, 5, 12, 9, 12, 5, 14, 6, 8, 13, 6, 5, 15, 13, 11, 11], _f = [0, 1518500249, 1859775393, 2400959708, 2840853838], wf = [1352829926, 1548603684, 1836072691, 2053994217, 0];
  function pn() {
    Vo2.call(this, 64), this._a = 1732584193, this._b = 4023233417, this._c = 2562383102, this._d = 271733878, this._e = 3285377520;
  }
  mp(pn, Vo2);
  pn.prototype._update = function() {
    for (var t = gp, e = 0; e < 16; ++e)
      t[e] = this._block.readInt32LE(e * 4);
    for (var r = this._a | 0, n = this._b | 0, i = this._c | 0, o2 = this._d | 0, p3 = this._e | 0, y4 = this._a | 0, w2 = this._b | 0, x = this._c | 0, M4 = this._d | 0, E2 = this._e | 0, A4 = 0; A4 < 80; A4 += 1) {
      var I3, D6;
      A4 < 16 ? (I3 = Ho2(r, n, i, o2, p3, t[bf[A4]], _f[0], gf[A4]), D6 = Wo2(y4, w2, x, M4, E2, t[mf[A4]], wf[0], yf[A4])) : A4 < 32 ? (I3 = Fo2(r, n, i, o2, p3, t[bf[A4]], _f[1], gf[A4]), D6 = jo(y4, w2, x, M4, E2, t[mf[A4]], wf[1], yf[A4])) : A4 < 48 ? (I3 = Ko2(r, n, i, o2, p3, t[bf[A4]], _f[2], gf[A4]), D6 = Ko2(y4, w2, x, M4, E2, t[mf[A4]], wf[2], yf[A4])) : A4 < 64 ? (I3 = jo(r, n, i, o2, p3, t[bf[A4]], _f[3], gf[A4]), D6 = Fo2(y4, w2, x, M4, E2, t[mf[A4]], wf[3], yf[A4])) : (I3 = Wo2(r, n, i, o2, p3, t[bf[A4]], _f[4], gf[A4]), D6 = Ho2(y4, w2, x, M4, E2, t[mf[A4]], wf[4], yf[A4])), r = p3, p3 = o2, o2 = ui(i, 10), i = n, n = I3, y4 = E2, E2 = M4, M4 = ui(x, 10), x = w2, w2 = D6;
    }
    var C = this._b + i + M4 | 0;
    this._b = this._c + o2 + E2 | 0, this._c = this._d + p3 + y4 | 0, this._d = this._e + r + w2 | 0, this._e = this._a + n + x | 0, this._a = C;
  };
  pn.prototype._digest = function() {
    this._block[this._blockOffset++] = 128, this._blockOffset > 56 && (this._block.fill(0, this._blockOffset, 64), this._update(), this._blockOffset = 0), this._block.fill(0, this._blockOffset, 56), this._block.writeUInt32LE(this._length[0], 56), this._block.writeUInt32LE(this._length[1], 60), this._update();
    var t = Xa.alloc ? Xa.alloc(20) : new Xa(20);
    return t.writeInt32LE(this._a, 0), t.writeInt32LE(this._b, 4), t.writeInt32LE(this._c, 8), t.writeInt32LE(this._d, 12), t.writeInt32LE(this._e, 16), t;
  };
  function ui(t, e) {
    return t << e | t >>> 32 - e;
  }
  function Ho2(t, e, r, n, i, o2, p3, y4) {
    return ui(t + (e ^ r ^ n) + o2 + p3 | 0, y4) + i | 0;
  }
  function Fo2(t, e, r, n, i, o2, p3, y4) {
    return ui(t + (e & r | ~e & n) + o2 + p3 | 0, y4) + i | 0;
  }
  function Ko2(t, e, r, n, i, o2, p3, y4) {
    return ui(t + ((e | ~r) ^ n) + o2 + p3 | 0, y4) + i | 0;
  }
  function jo(t, e, r, n, i, o2, p3, y4) {
    return ui(t + (e & n | r & ~n) + o2 + p3 | 0, y4) + i | 0;
  }
  function Wo2(t, e, r, n, i, o2, p3, y4) {
    return ui(t + (e ^ (r | ~n)) + o2 + p3 | 0, y4) + i | 0;
  }
  Zo2.exports = pn;
});
var di2 = k4((h5, Xo) => {
  var Go2 = Ae2().Buffer;
  function mn(t, e) {
    this._block = Go2.alloc(t), this._finalSize = e, this._blockSize = t, this._len = 0;
  }
  mn.prototype.update = function(t, e) {
    typeof t == "string" && (e = e || "utf8", t = Go2.from(t, e));
    for (var r = this._block, n = this._blockSize, i = t.length, o2 = this._len, p3 = 0; p3 < i; ) {
      for (var y4 = o2 % n, w2 = Math.min(i - p3, n - y4), x = 0; x < w2; x++)
        r[y4 + x] = t[p3 + x];
      o2 += w2, p3 += w2, o2 % n === 0 && this._update(r);
    }
    return this._len += i, this;
  };
  mn.prototype.digest = function(t) {
    var e = this._len % this._blockSize;
    this._block[e] = 128, this._block.fill(0, e + 1), e >= this._finalSize && (this._update(this._block), this._block.fill(0));
    var r = this._len * 8;
    if (r <= 4294967295)
      this._block.writeUInt32BE(r, this._blockSize - 4);
    else {
      var n = (r & 4294967295) >>> 0, i = (r - n) / 4294967296;
      this._block.writeUInt32BE(i, this._blockSize - 8), this._block.writeUInt32BE(n, this._blockSize - 4);
    }
    this._update(this._block);
    var o2 = this._hash();
    return t ? o2.toString(t) : o2;
  };
  mn.prototype._update = function() {
    throw new Error("_update must be implemented by subclass");
  };
  Xo.exports = mn;
});
var $o3 = k4((u5, Jo2) => {
  var yp = qe2(), Yo2 = di2(), _p = Ae2().Buffer, wp = [1518500249, 1859775393, -1894007588, -899497514], xp = new Array(80);
  function xf() {
    this.init(), this._w = xp, Yo2.call(this, 64, 56);
  }
  yp(xf, Yo2);
  xf.prototype.init = function() {
    return this._a = 1732584193, this._b = 4023233417, this._c = 2562383102, this._d = 271733878, this._e = 3285377520, this;
  };
  function Mp(t) {
    return t << 5 | t >>> 27;
  }
  function Sp(t) {
    return t << 30 | t >>> 2;
  }
  function Ep(t, e, r, n) {
    return t === 0 ? e & r | ~e & n : t === 2 ? e & r | e & n | r & n : e ^ r ^ n;
  }
  xf.prototype._update = function(t) {
    for (var e = this._w, r = this._a | 0, n = this._b | 0, i = this._c | 0, o2 = this._d | 0, p3 = this._e | 0, y4 = 0; y4 < 16; ++y4)
      e[y4] = t.readInt32BE(y4 * 4);
    for (; y4 < 80; ++y4)
      e[y4] = e[y4 - 3] ^ e[y4 - 8] ^ e[y4 - 14] ^ e[y4 - 16];
    for (var w2 = 0; w2 < 80; ++w2) {
      var x = ~~(w2 / 20), M4 = Mp(r) + Ep(x, n, i, o2) + p3 + e[w2] + wp[x] | 0;
      p3 = o2, o2 = i, i = Sp(n), n = r, r = M4;
    }
    this._a = r + this._a | 0, this._b = n + this._b | 0, this._c = i + this._c | 0, this._d = o2 + this._d | 0, this._e = p3 + this._e | 0;
  };
  xf.prototype._hash = function() {
    var t = _p.allocUnsafe(20);
    return t.writeInt32BE(this._a | 0, 0), t.writeInt32BE(this._b | 0, 4), t.writeInt32BE(this._c | 0, 8), t.writeInt32BE(this._d | 0, 12), t.writeInt32BE(this._e | 0, 16), t;
  };
  Jo2.exports = xf;
});
var th2 = k4((d5, eh) => {
  var Ap = qe2(), Qo2 = di2(), qp = Ae2().Buffer, Bp = [1518500249, 1859775393, -1894007588, -899497514], Rp = new Array(80);
  function Mf() {
    this.init(), this._w = Rp, Qo2.call(this, 64, 56);
  }
  Ap(Mf, Qo2);
  Mf.prototype.init = function() {
    return this._a = 1732584193, this._b = 4023233417, this._c = 2562383102, this._d = 271733878, this._e = 3285377520, this;
  };
  function Ip(t) {
    return t << 1 | t >>> 31;
  }
  function kp(t) {
    return t << 5 | t >>> 27;
  }
  function Dp(t) {
    return t << 30 | t >>> 2;
  }
  function Pp(t, e, r, n) {
    return t === 0 ? e & r | ~e & n : t === 2 ? e & r | e & n | r & n : e ^ r ^ n;
  }
  Mf.prototype._update = function(t) {
    for (var e = this._w, r = this._a | 0, n = this._b | 0, i = this._c | 0, o2 = this._d | 0, p3 = this._e | 0, y4 = 0; y4 < 16; ++y4)
      e[y4] = t.readInt32BE(y4 * 4);
    for (; y4 < 80; ++y4)
      e[y4] = Ip(e[y4 - 3] ^ e[y4 - 8] ^ e[y4 - 14] ^ e[y4 - 16]);
    for (var w2 = 0; w2 < 80; ++w2) {
      var x = ~~(w2 / 20), M4 = kp(r) + Pp(x, n, i, o2) + p3 + e[w2] + Bp[x] | 0;
      p3 = o2, o2 = i, i = Dp(n), n = r, r = M4;
    }
    this._a = r + this._a | 0, this._b = n + this._b | 0, this._c = i + this._c | 0, this._d = o2 + this._d | 0, this._e = p3 + this._e | 0;
  };
  Mf.prototype._hash = function() {
    var t = qp.allocUnsafe(20);
    return t.writeInt32BE(this._a | 0, 0), t.writeInt32BE(this._b | 0, 4), t.writeInt32BE(this._c | 0, 8), t.writeInt32BE(this._d | 0, 12), t.writeInt32BE(this._e | 0, 16), t;
  };
  eh.exports = Mf;
});
var Ya2 = k4((c5, ih) => {
  var Tp = qe2(), rh = di2(), Cp = Ae2().Buffer, Np = [1116352408, 1899447441, 3049323471, 3921009573, 961987163, 1508970993, 2453635748, 2870763221, 3624381080, 310598401, 607225278, 1426881987, 1925078388, 2162078206, 2614888103, 3248222580, 3835390401, 4022224774, 264347078, 604807628, 770255983, 1249150122, 1555081692, 1996064986, 2554220882, 2821834349, 2952996808, 3210313671, 3336571891, 3584528711, 113926993, 338241895, 666307205, 773529912, 1294757372, 1396182291, 1695183700, 1986661051, 2177026350, 2456956037, 2730485921, 2820302411, 3259730800, 3345764771, 3516065817, 3600352804, 4094571909, 275423344, 430227734, 506948616, 659060556, 883997877, 958139571, 1322822218, 1537002063, 1747873779, 1955562222, 2024104815, 2227730452, 2361852424, 2428436474, 2756734187, 3204031479, 3329325298], Lp = new Array(64);
  function Sf() {
    this.init(), this._w = Lp, rh.call(this, 64, 56);
  }
  Tp(Sf, rh);
  Sf.prototype.init = function() {
    return this._a = 1779033703, this._b = 3144134277, this._c = 1013904242, this._d = 2773480762, this._e = 1359893119, this._f = 2600822924, this._g = 528734635, this._h = 1541459225, this;
  };
  function Op(t, e, r) {
    return r ^ t & (e ^ r);
  }
  function zp(t, e, r) {
    return t & e | r & (t | e);
  }
  function Up(t) {
    return (t >>> 2 | t << 30) ^ (t >>> 13 | t << 19) ^ (t >>> 22 | t << 10);
  }
  function Hp(t) {
    return (t >>> 6 | t << 26) ^ (t >>> 11 | t << 21) ^ (t >>> 25 | t << 7);
  }
  function Fp(t) {
    return (t >>> 7 | t << 25) ^ (t >>> 18 | t << 14) ^ t >>> 3;
  }
  function Kp(t) {
    return (t >>> 17 | t << 15) ^ (t >>> 19 | t << 13) ^ t >>> 10;
  }
  Sf.prototype._update = function(t) {
    for (var e = this._w, r = this._a | 0, n = this._b | 0, i = this._c | 0, o2 = this._d | 0, p3 = this._e | 0, y4 = this._f | 0, w2 = this._g | 0, x = this._h | 0, M4 = 0; M4 < 16; ++M4)
      e[M4] = t.readInt32BE(M4 * 4);
    for (; M4 < 64; ++M4)
      e[M4] = Kp(e[M4 - 2]) + e[M4 - 7] + Fp(e[M4 - 15]) + e[M4 - 16] | 0;
    for (var E2 = 0; E2 < 64; ++E2) {
      var A4 = x + Hp(p3) + Op(p3, y4, w2) + Np[E2] + e[E2] | 0, I3 = Up(r) + zp(r, n, i) | 0;
      x = w2, w2 = y4, y4 = p3, p3 = o2 + A4 | 0, o2 = i, i = n, n = r, r = A4 + I3 | 0;
    }
    this._a = r + this._a | 0, this._b = n + this._b | 0, this._c = i + this._c | 0, this._d = o2 + this._d | 0, this._e = p3 + this._e | 0, this._f = y4 + this._f | 0, this._g = w2 + this._g | 0, this._h = x + this._h | 0;
  };
  Sf.prototype._hash = function() {
    var t = Cp.allocUnsafe(32);
    return t.writeInt32BE(this._a, 0), t.writeInt32BE(this._b, 4), t.writeInt32BE(this._c, 8), t.writeInt32BE(this._d, 12), t.writeInt32BE(this._e, 16), t.writeInt32BE(this._f, 20), t.writeInt32BE(this._g, 24), t.writeInt32BE(this._h, 28), t;
  };
  ih.exports = Sf;
});
var nh2 = k4((l5, fh) => {
  var jp = qe2(), Wp = Ya2(), Vp = di2(), Zp = Ae2().Buffer, Gp = new Array(64);
  function gn() {
    this.init(), this._w = Gp, Vp.call(this, 64, 56);
  }
  jp(gn, Wp);
  gn.prototype.init = function() {
    return this._a = 3238371032, this._b = 914150663, this._c = 812702999, this._d = 4144912697, this._e = 4290775857, this._f = 1750603025, this._g = 1694076839, this._h = 3204075428, this;
  };
  gn.prototype._hash = function() {
    var t = Zp.allocUnsafe(28);
    return t.writeInt32BE(this._a, 0), t.writeInt32BE(this._b, 4), t.writeInt32BE(this._c, 8), t.writeInt32BE(this._d, 12), t.writeInt32BE(this._e, 16), t.writeInt32BE(this._f, 20), t.writeInt32BE(this._g, 24), t;
  };
  fh.exports = gn;
});
var Ja2 = k4((v5, ch) => {
  var Xp = qe2(), dh = di2(), Yp = Ae2().Buffer, ah = [1116352408, 3609767458, 1899447441, 602891725, 3049323471, 3964484399, 3921009573, 2173295548, 961987163, 4081628472, 1508970993, 3053834265, 2453635748, 2937671579, 2870763221, 3664609560, 3624381080, 2734883394, 310598401, 1164996542, 607225278, 1323610764, 1426881987, 3590304994, 1925078388, 4068182383, 2162078206, 991336113, 2614888103, 633803317, 3248222580, 3479774868, 3835390401, 2666613458, 4022224774, 944711139, 264347078, 2341262773, 604807628, 2007800933, 770255983, 1495990901, 1249150122, 1856431235, 1555081692, 3175218132, 1996064986, 2198950837, 2554220882, 3999719339, 2821834349, 766784016, 2952996808, 2566594879, 3210313671, 3203337956, 3336571891, 1034457026, 3584528711, 2466948901, 113926993, 3758326383, 338241895, 168717936, 666307205, 1188179964, 773529912, 1546045734, 1294757372, 1522805485, 1396182291, 2643833823, 1695183700, 2343527390, 1986661051, 1014477480, 2177026350, 1206759142, 2456956037, 344077627, 2730485921, 1290863460, 2820302411, 3158454273, 3259730800, 3505952657, 3345764771, 106217008, 3516065817, 3606008344, 3600352804, 1432725776, 4094571909, 1467031594, 275423344, 851169720, 430227734, 3100823752, 506948616, 1363258195, 659060556, 3750685593, 883997877, 3785050280, 958139571, 3318307427, 1322822218, 3812723403, 1537002063, 2003034995, 1747873779, 3602036899, 1955562222, 1575990012, 2024104815, 1125592928, 2227730452, 2716904306, 2361852424, 442776044, 2428436474, 593698344, 2756734187, 3733110249, 3204031479, 2999351573, 3329325298, 3815920427, 3391569614, 3928383900, 3515267271, 566280711, 3940187606, 3454069534, 4118630271, 4000239992, 116418474, 1914138554, 174292421, 2731055270, 289380356, 3203993006, 460393269, 320620315, 685471733, 587496836, 852142971, 1086792851, 1017036298, 365543100, 1126000580, 2618297676, 1288033470, 3409855158, 1501505948, 4234509866, 1607167915, 987167468, 1816402316, 1246189591], Jp = new Array(160);
  function Ef() {
    this.init(), this._w = Jp, dh.call(this, 128, 112);
  }
  Xp(Ef, dh);
  Ef.prototype.init = function() {
    return this._ah = 1779033703, this._bh = 3144134277, this._ch = 1013904242, this._dh = 2773480762, this._eh = 1359893119, this._fh = 2600822924, this._gh = 528734635, this._hh = 1541459225, this._al = 4089235720, this._bl = 2227873595, this._cl = 4271175723, this._dl = 1595750129, this._el = 2917565137, this._fl = 725511199, this._gl = 4215389547, this._hl = 327033209, this;
  };
  function sh(t, e, r) {
    return r ^ t & (e ^ r);
  }
  function oh(t, e, r) {
    return t & e | r & (t | e);
  }
  function hh(t, e) {
    return (t >>> 28 | e << 4) ^ (e >>> 2 | t << 30) ^ (e >>> 7 | t << 25);
  }
  function uh(t, e) {
    return (t >>> 14 | e << 18) ^ (t >>> 18 | e << 14) ^ (e >>> 9 | t << 23);
  }
  function $p(t, e) {
    return (t >>> 1 | e << 31) ^ (t >>> 8 | e << 24) ^ t >>> 7;
  }
  function Qp(t, e) {
    return (t >>> 1 | e << 31) ^ (t >>> 8 | e << 24) ^ (t >>> 7 | e << 25);
  }
  function e2(t, e) {
    return (t >>> 19 | e << 13) ^ (e >>> 29 | t << 3) ^ t >>> 6;
  }
  function t2(t, e) {
    return (t >>> 19 | e << 13) ^ (e >>> 29 | t << 3) ^ (t >>> 6 | e << 26);
  }
  function je2(t, e) {
    return t >>> 0 < e >>> 0 ? 1 : 0;
  }
  Ef.prototype._update = function(t) {
    for (var e = this._w, r = this._ah | 0, n = this._bh | 0, i = this._ch | 0, o2 = this._dh | 0, p3 = this._eh | 0, y4 = this._fh | 0, w2 = this._gh | 0, x = this._hh | 0, M4 = this._al | 0, E2 = this._bl | 0, A4 = this._cl | 0, I3 = this._dl | 0, D6 = this._el | 0, C = this._fl | 0, ge2 = this._gl | 0, L4 = this._hl | 0, ye = 0; ye < 32; ye += 2)
      e[ye] = t.readInt32BE(ye * 4), e[ye + 1] = t.readInt32BE(ye * 4 + 4);
    for (; ye < 160; ye += 2) {
      var Re = e[ye - 30], xe3 = e[ye - 15 * 2 + 1], ke = $p(Re, xe3), Me = Qp(xe3, Re);
      Re = e[ye - 2 * 2], xe3 = e[ye - 2 * 2 + 1];
      var Ce3 = e2(Re, xe3), Ee2 = t2(xe3, Re), Ne3 = e[ye - 7 * 2], S3 = e[ye - 7 * 2 + 1], v2 = e[ye - 16 * 2], _2 = e[ye - 16 * 2 + 1], c5 = Me + S3 | 0, f = ke + Ne3 + je2(c5, Me) | 0;
      c5 = c5 + Ee2 | 0, f = f + Ce3 + je2(c5, Ee2) | 0, c5 = c5 + _2 | 0, f = f + v2 + je2(c5, _2) | 0, e[ye] = f, e[ye + 1] = c5;
    }
    for (var a = 0; a < 160; a += 2) {
      f = e[a], c5 = e[a + 1];
      var u = oh(r, n, i), l = oh(M4, E2, A4), d4 = hh(r, M4), h = hh(M4, r), b2 = uh(p3, D6), m3 = uh(D6, p3), s = ah[a], g2 = ah[a + 1], q = sh(p3, y4, w2), R3 = sh(D6, C, ge2), B3 = L4 + m3 | 0, P2 = x + b2 + je2(B3, L4) | 0;
      B3 = B3 + R3 | 0, P2 = P2 + q + je2(B3, R3) | 0, B3 = B3 + g2 | 0, P2 = P2 + s + je2(B3, g2) | 0, B3 = B3 + c5 | 0, P2 = P2 + f + je2(B3, c5) | 0;
      var T4 = h + l | 0, N4 = d4 + u + je2(T4, h) | 0;
      x = w2, L4 = ge2, w2 = y4, ge2 = C, y4 = p3, C = D6, D6 = I3 + B3 | 0, p3 = o2 + P2 + je2(D6, I3) | 0, o2 = i, I3 = A4, i = n, A4 = E2, n = r, E2 = M4, M4 = B3 + T4 | 0, r = P2 + N4 + je2(M4, B3) | 0;
    }
    this._al = this._al + M4 | 0, this._bl = this._bl + E2 | 0, this._cl = this._cl + A4 | 0, this._dl = this._dl + I3 | 0, this._el = this._el + D6 | 0, this._fl = this._fl + C | 0, this._gl = this._gl + ge2 | 0, this._hl = this._hl + L4 | 0, this._ah = this._ah + r + je2(this._al, M4) | 0, this._bh = this._bh + n + je2(this._bl, E2) | 0, this._ch = this._ch + i + je2(this._cl, A4) | 0, this._dh = this._dh + o2 + je2(this._dl, I3) | 0, this._eh = this._eh + p3 + je2(this._el, D6) | 0, this._fh = this._fh + y4 + je2(this._fl, C) | 0, this._gh = this._gh + w2 + je2(this._gl, ge2) | 0, this._hh = this._hh + x + je2(this._hl, L4) | 0;
  };
  Ef.prototype._hash = function() {
    var t = Yp.allocUnsafe(64);
    function e(r, n, i) {
      t.writeInt32BE(r, i), t.writeInt32BE(n, i + 4);
    }
    return e(this._ah, this._al, 0), e(this._bh, this._bl, 8), e(this._ch, this._cl, 16), e(this._dh, this._dl, 24), e(this._eh, this._el, 32), e(this._fh, this._fl, 40), e(this._gh, this._gl, 48), e(this._hh, this._hl, 56), t;
  };
  ch.exports = Ef;
});
var vh2 = k4((p5, lh) => {
  var r2 = qe2(), i2 = Ja2(), f2 = di2(), n2 = Ae2().Buffer, a2 = new Array(160);
  function yn() {
    this.init(), this._w = a2, f2.call(this, 128, 112);
  }
  r2(yn, i2);
  yn.prototype.init = function() {
    return this._ah = 3418070365, this._bh = 1654270250, this._ch = 2438529370, this._dh = 355462360, this._eh = 1731405415, this._fh = 2394180231, this._gh = 3675008525, this._hh = 1203062813, this._al = 3238371032, this._bl = 914150663, this._cl = 812702999, this._dl = 4144912697, this._el = 4290775857, this._fl = 1750603025, this._gl = 1694076839, this._hl = 3204075428, this;
  };
  yn.prototype._hash = function() {
    var t = n2.allocUnsafe(48);
    function e(r, n, i) {
      t.writeInt32BE(r, i), t.writeInt32BE(n, i + 4);
    }
    return e(this._ah, this._al, 0), e(this._bh, this._bl, 8), e(this._ch, this._cl, 16), e(this._dh, this._dl, 24), e(this._eh, this._el, 32), e(this._fh, this._fl, 40), t;
  };
  lh.exports = yn;
});
var _n2 = k4((lr, ph) => {
  var lr = ph.exports = function(e) {
    e = e.toLowerCase();
    var r = lr[e];
    if (!r)
      throw new Error(e + " is not supported (we accept pull requests)");
    return new r();
  };
  lr.sha = $o3();
  lr.sha1 = th2();
  lr.sha224 = nh2();
  lr.sha256 = Ya2();
  lr.sha384 = vh2();
  lr.sha512 = Ja2();
});
var vr4 = k4((b5, gh) => {
  var bh = Ae2().Buffer, mh = Ki.Transform, s2 = Y2.StringDecoder, o2 = qe2();
  function Ft(t) {
    mh.call(this), this.hashMode = typeof t == "string", this.hashMode ? this[t] = this._finalOrDigest : this.final = this._finalOrDigest, this._final && (this.__final = this._final, this._final = null), this._decoder = null, this._encoding = null;
  }
  o2(Ft, mh);
  Ft.prototype.update = function(t, e, r) {
    typeof t == "string" && (t = bh.from(t, e));
    var n = this._update(t);
    return this.hashMode ? this : (r && (n = this._toString(n, r)), n);
  };
  Ft.prototype.setAutoPadding = function() {
  };
  Ft.prototype.getAuthTag = function() {
    throw new Error("trying to get auth tag in unsupported state");
  };
  Ft.prototype.setAuthTag = function() {
    throw new Error("trying to set auth tag in unsupported state");
  };
  Ft.prototype.setAAD = function() {
    throw new Error("trying to set aad in unsupported state");
  };
  Ft.prototype._transform = function(t, e, r) {
    var n;
    try {
      this.hashMode ? this._update(t) : this.push(this._update(t));
    } catch (i) {
      n = i;
    } finally {
      r(n);
    }
  };
  Ft.prototype._flush = function(t) {
    var e;
    try {
      this.push(this.__final());
    } catch (r) {
      e = r;
    }
    t(e);
  };
  Ft.prototype._finalOrDigest = function(t) {
    var e = this.__final() || bh.alloc(0);
    return t && (e = this._toString(e, t, true)), e;
  };
  Ft.prototype._toString = function(t, e, r) {
    if (this._decoder || (this._decoder = new s2(e), this._encoding = e), this._encoding !== e)
      throw new Error("can't switch encodings");
    var n = this._decoder.write(t);
    return r && (n += this._decoder.end()), n;
  };
  gh.exports = Ft;
});
var Ni2 = k4((m5, _h) => {
  "use strict";
  var h2 = qe2(), u2 = vn2(), d22 = bn2(), c22 = _n2(), yh = vr4();
  function wn(t) {
    yh.call(this, "digest"), this._hash = t;
  }
  h2(wn, yh);
  wn.prototype._update = function(t) {
    this._hash.update(t);
  };
  wn.prototype._final = function() {
    return this._hash.digest();
  };
  _h.exports = function(e) {
    return e = e.toLowerCase(), e === "md5" ? new u2() : e === "rmd160" || e === "ripemd160" ? new d22() : new wn(c22(e));
  };
});
var Mh2 = k4((g5, xh) => {
  "use strict";
  var l2 = qe2(), ci = Ae2().Buffer, wh = vr4(), v2 = ci.alloc(128), Li2 = 64;
  function xn(t, e) {
    wh.call(this, "digest"), typeof e == "string" && (e = ci.from(e)), this._alg = t, this._key = e, e.length > Li2 ? e = t(e) : e.length < Li2 && (e = ci.concat([e, v2], Li2));
    for (var r = this._ipad = ci.allocUnsafe(Li2), n = this._opad = ci.allocUnsafe(Li2), i = 0; i < Li2; i++)
      r[i] = e[i] ^ 54, n[i] = e[i] ^ 92;
    this._hash = [r];
  }
  l2(xn, wh);
  xn.prototype._update = function(t) {
    this._hash.push(t);
  };
  xn.prototype._final = function() {
    var t = this._alg(ci.concat(this._hash));
    return this._alg(ci.concat([this._opad, t]));
  };
  xh.exports = xn;
});
var $a2 = k4((y5, Sh) => {
  var p22 = vn2();
  Sh.exports = function(t) {
    return new p22().update(t).digest();
  };
});
var t02 = k4((_5, Ah) => {
  "use strict";
  var b2 = qe2(), m22 = Mh2(), Eh = vr4(), Af = Ae2().Buffer, g2 = $a2(), Qa = bn2(), e0 = _n2(), y22 = Af.alloc(128);
  function qf(t, e) {
    Eh.call(this, "digest"), typeof e == "string" && (e = Af.from(e));
    var r = t === "sha512" || t === "sha384" ? 128 : 64;
    if (this._alg = t, this._key = e, e.length > r) {
      var n = t === "rmd160" ? new Qa() : e0(t);
      e = n.update(e).digest();
    } else
      e.length < r && (e = Af.concat([e, y22], r));
    for (var i = this._ipad = Af.allocUnsafe(r), o2 = this._opad = Af.allocUnsafe(r), p3 = 0; p3 < r; p3++)
      i[p3] = e[p3] ^ 54, o2[p3] = e[p3] ^ 92;
    this._hash = t === "rmd160" ? new Qa() : e0(t), this._hash.update(i);
  }
  b2(qf, Eh);
  qf.prototype._update = function(t) {
    this._hash.update(t);
  };
  qf.prototype._final = function() {
    var t = this._hash.digest(), e = this._alg === "rmd160" ? new Qa() : e0(this._alg);
    return e.update(this._opad).update(t).digest();
  };
  Ah.exports = function(e, r) {
    return e = e.toLowerCase(), e === "rmd160" || e === "ripemd160" ? new qf("rmd160", r) : e === "md5" ? new m22(g2, r) : new qf(e, r);
  };
});
var r02 = k4((w5, _2) => {
  _2.exports = { sha224WithRSAEncryption: { sign: "rsa", hash: "sha224", id: "302d300d06096086480165030402040500041c" }, "RSA-SHA224": { sign: "ecdsa/rsa", hash: "sha224", id: "302d300d06096086480165030402040500041c" }, sha256WithRSAEncryption: { sign: "rsa", hash: "sha256", id: "3031300d060960864801650304020105000420" }, "RSA-SHA256": { sign: "ecdsa/rsa", hash: "sha256", id: "3031300d060960864801650304020105000420" }, sha384WithRSAEncryption: { sign: "rsa", hash: "sha384", id: "3041300d060960864801650304020205000430" }, "RSA-SHA384": { sign: "ecdsa/rsa", hash: "sha384", id: "3041300d060960864801650304020205000430" }, sha512WithRSAEncryption: { sign: "rsa", hash: "sha512", id: "3051300d060960864801650304020305000440" }, "RSA-SHA512": { sign: "ecdsa/rsa", hash: "sha512", id: "3051300d060960864801650304020305000440" }, "RSA-SHA1": { sign: "rsa", hash: "sha1", id: "3021300906052b0e03021a05000414" }, "ecdsa-with-SHA1": { sign: "ecdsa", hash: "sha1", id: "" }, sha256: { sign: "ecdsa", hash: "sha256", id: "" }, sha224: { sign: "ecdsa", hash: "sha224", id: "" }, sha384: { sign: "ecdsa", hash: "sha384", id: "" }, sha512: { sign: "ecdsa", hash: "sha512", id: "" }, "DSA-SHA": { sign: "dsa", hash: "sha1", id: "" }, "DSA-SHA1": { sign: "dsa", hash: "sha1", id: "" }, DSA: { sign: "dsa", hash: "sha1", id: "" }, "DSA-WITH-SHA224": { sign: "dsa", hash: "sha224", id: "" }, "DSA-SHA224": { sign: "dsa", hash: "sha224", id: "" }, "DSA-WITH-SHA256": { sign: "dsa", hash: "sha256", id: "" }, "DSA-SHA256": { sign: "dsa", hash: "sha256", id: "" }, "DSA-WITH-SHA384": { sign: "dsa", hash: "sha384", id: "" }, "DSA-SHA384": { sign: "dsa", hash: "sha384", id: "" }, "DSA-WITH-SHA512": { sign: "dsa", hash: "sha512", id: "" }, "DSA-SHA512": { sign: "dsa", hash: "sha512", id: "" }, "DSA-RIPEMD160": { sign: "dsa", hash: "rmd160", id: "" }, ripemd160WithRSA: { sign: "rsa", hash: "rmd160", id: "3021300906052b2403020105000414" }, "RSA-RIPEMD160": { sign: "rsa", hash: "rmd160", id: "3021300906052b2403020105000414" }, md5WithRSAEncryption: { sign: "rsa", hash: "md5", id: "3020300c06082a864886f70d020505000410" }, "RSA-MD5": { sign: "rsa", hash: "md5", id: "3020300c06082a864886f70d020505000410" } };
});
var Bh2 = k4((x5, qh) => {
  qh.exports = r02();
});
var i02 = k4((M5, Rh) => {
  var w2 = Math.pow(2, 30) - 1;
  Rh.exports = function(t, e) {
    if (typeof t != "number")
      throw new TypeError("Iterations not a number");
    if (t < 0)
      throw new TypeError("Bad iterations");
    if (typeof e != "number")
      throw new TypeError("Key length not a number");
    if (e < 0 || e > w2 || e !== e)
      throw new TypeError("Bad key length");
  };
});
var f02 = k4((S5, kh) => {
  var Mn;
  node_process_default && node_process_default.browser ? Mn = "utf-8" : node_process_default && node_process_default.version ? (Ih = parseInt(node_process_default.version.split(".")[0].slice(1), 10), Mn = Ih >= 6 ? "utf-8" : "binary") : Mn = "utf-8";
  var Ih;
  kh.exports = Mn;
});
var a02 = k4((E5, Dh) => {
  var n0 = Ae2().Buffer;
  Dh.exports = function(t, e, r) {
    if (n0.isBuffer(t))
      return t;
    if (typeof t == "string")
      return n0.from(t, e);
    if (ArrayBuffer.isView(t))
      return n0.from(t.buffer);
    throw new TypeError(r + " must be a string, a Buffer, a typed array or a DataView");
  };
});
var s02 = k4((A5, Nh) => {
  var x2 = $a2(), M22 = bn2(), S22 = _n2(), li = Ae2().Buffer, E2 = i02(), Ph = f02(), Th = a02(), A22 = li.alloc(128), Sn = { md5: 16, sha1: 20, sha224: 28, sha256: 32, sha384: 48, sha512: 64, rmd160: 20, ripemd160: 20 };
  function Ch(t, e, r) {
    var n = q2(t), i = t === "sha512" || t === "sha384" ? 128 : 64;
    e.length > i ? e = n(e) : e.length < i && (e = li.concat([e, A22], i));
    for (var o2 = li.allocUnsafe(i + Sn[t]), p3 = li.allocUnsafe(i + Sn[t]), y4 = 0; y4 < i; y4++)
      o2[y4] = e[y4] ^ 54, p3[y4] = e[y4] ^ 92;
    var w2 = li.allocUnsafe(i + r + 4);
    o2.copy(w2, 0, 0, i), this.ipad1 = w2, this.ipad2 = o2, this.opad = p3, this.alg = t, this.blocksize = i, this.hash = n, this.size = Sn[t];
  }
  Ch.prototype.run = function(t, e) {
    t.copy(e, this.blocksize);
    var r = this.hash(e);
    return r.copy(this.opad, this.blocksize), this.hash(this.opad);
  };
  function q2(t) {
    function e(n) {
      return S22(t).update(n).digest();
    }
    function r(n) {
      return new M22().update(n).digest();
    }
    return t === "rmd160" || t === "ripemd160" ? r : t === "md5" ? x2 : e;
  }
  function B22(t, e, r, n, i) {
    E2(r, n), t = Th(t, Ph, "Password"), e = Th(e, Ph, "Salt"), i = i || "sha1";
    var o2 = new Ch(i, t, e.length), p3 = li.allocUnsafe(n), y4 = li.allocUnsafe(e.length + 4);
    e.copy(y4, 0, 0, e.length);
    for (var w2 = 0, x = Sn[i], M4 = Math.ceil(n / x), E3 = 1; E3 <= M4; E3++) {
      y4.writeUInt32BE(E3, e.length);
      for (var A4 = o2.run(y4, o2.ipad1), I3 = A4, D6 = 1; D6 < r; D6++) {
        I3 = o2.run(I3, o2.ipad2);
        for (var C = 0; C < x; C++)
          A4[C] ^= I3[C];
      }
      A4.copy(p3, w2), w2 += x;
    }
    return p3;
  }
  Nh.exports = B22;
});
var Kh2 = k4((q5, Fh) => {
  var Uh = Ae2().Buffer, R22 = i02(), Lh = f02(), Oh = s02(), zh = a02(), En, Bf = __global$4.crypto && __global$4.crypto.subtle, I22 = { sha: "SHA-1", "sha-1": "SHA-1", sha1: "SHA-1", sha256: "SHA-256", "sha-256": "SHA-256", sha384: "SHA-384", "sha-384": "SHA-384", "sha-512": "SHA-512", sha512: "SHA-512" }, o0 = [];
  function k22(t) {
    if (node_process_default && !node_process_default.browser || !Bf || !Bf.importKey || !Bf.deriveBits)
      return Promise.resolve(false);
    if (o0[t] !== void 0)
      return o0[t];
    En = En || Uh.alloc(8);
    var e = Hh(En, En, 10, 128, t).then(function() {
      return true;
    }).catch(function() {
      return false;
    });
    return o0[t] = e, e;
  }
  var vi;
  function h0() {
    return vi || (node_process_default && node_process_default.nextTick ? vi = node_process_default.nextTick : __global$4.queueMicrotask ? vi = __global$4.queueMicrotask : __setImmediate$2 ? vi = __setImmediate$2 : vi = __global$4.setTimeout, vi);
  }
  function Hh(t, e, r, n, i) {
    return Bf.importKey("raw", t, { name: "PBKDF2" }, false, ["deriveBits"]).then(function(o2) {
      return Bf.deriveBits({ name: "PBKDF2", salt: e, iterations: r, hash: { name: i } }, o2, n << 3);
    }).then(function(o2) {
      return Uh.from(o2);
    });
  }
  function D22(t, e) {
    t.then(function(r) {
      h0()(function() {
        e(null, r);
      });
    }, function(r) {
      h0()(function() {
        e(r);
      });
    });
  }
  Fh.exports = function(t, e, r, n, i, o2) {
    typeof i == "function" && (o2 = i, i = void 0), i = i || "sha1";
    var p3 = I22[i.toLowerCase()];
    if (!p3 || typeof __global$4.Promise != "function") {
      h0()(function() {
        var y4;
        try {
          y4 = Oh(t, e, r, n, i);
        } catch (w2) {
          return o2(w2);
        }
        o2(null, y4);
      });
      return;
    }
    if (R22(r, n), t = zh(t, Lh, "Password"), e = zh(e, Lh, "Salt"), typeof o2 != "function")
      throw new Error("No callback provided to pbkdf2");
    D22(k22(p3).then(function(y4) {
      return y4 ? Hh(t, e, r, n, p3) : Oh(t, e, r, n, i);
    }), o2);
  };
});
var d02 = k4((u0) => {
  u0.pbkdf2 = Kh2();
  u0.pbkdf2Sync = s02();
});
var c02 = k4((vt) => {
  "use strict";
  vt.readUInt32BE = function(e, r) {
    var n = e[0 + r] << 24 | e[1 + r] << 16 | e[2 + r] << 8 | e[3 + r];
    return n >>> 0;
  };
  vt.writeUInt32BE = function(e, r, n) {
    e[0 + n] = r >>> 24, e[1 + n] = r >>> 16 & 255, e[2 + n] = r >>> 8 & 255, e[3 + n] = r & 255;
  };
  vt.ip = function(e, r, n, i) {
    for (var o2 = 0, p3 = 0, y4 = 6; y4 >= 0; y4 -= 2) {
      for (var w2 = 0; w2 <= 24; w2 += 8)
        o2 <<= 1, o2 |= r >>> w2 + y4 & 1;
      for (var w2 = 0; w2 <= 24; w2 += 8)
        o2 <<= 1, o2 |= e >>> w2 + y4 & 1;
    }
    for (var y4 = 6; y4 >= 0; y4 -= 2) {
      for (var w2 = 1; w2 <= 25; w2 += 8)
        p3 <<= 1, p3 |= r >>> w2 + y4 & 1;
      for (var w2 = 1; w2 <= 25; w2 += 8)
        p3 <<= 1, p3 |= e >>> w2 + y4 & 1;
    }
    n[i + 0] = o2 >>> 0, n[i + 1] = p3 >>> 0;
  };
  vt.rip = function(e, r, n, i) {
    for (var o2 = 0, p3 = 0, y4 = 0; y4 < 4; y4++)
      for (var w2 = 24; w2 >= 0; w2 -= 8)
        o2 <<= 1, o2 |= r >>> w2 + y4 & 1, o2 <<= 1, o2 |= e >>> w2 + y4 & 1;
    for (var y4 = 4; y4 < 8; y4++)
      for (var w2 = 24; w2 >= 0; w2 -= 8)
        p3 <<= 1, p3 |= r >>> w2 + y4 & 1, p3 <<= 1, p3 |= e >>> w2 + y4 & 1;
    n[i + 0] = o2 >>> 0, n[i + 1] = p3 >>> 0;
  };
  vt.pc1 = function(e, r, n, i) {
    for (var o2 = 0, p3 = 0, y4 = 7; y4 >= 5; y4--) {
      for (var w2 = 0; w2 <= 24; w2 += 8)
        o2 <<= 1, o2 |= r >> w2 + y4 & 1;
      for (var w2 = 0; w2 <= 24; w2 += 8)
        o2 <<= 1, o2 |= e >> w2 + y4 & 1;
    }
    for (var w2 = 0; w2 <= 24; w2 += 8)
      o2 <<= 1, o2 |= r >> w2 + y4 & 1;
    for (var y4 = 1; y4 <= 3; y4++) {
      for (var w2 = 0; w2 <= 24; w2 += 8)
        p3 <<= 1, p3 |= r >> w2 + y4 & 1;
      for (var w2 = 0; w2 <= 24; w2 += 8)
        p3 <<= 1, p3 |= e >> w2 + y4 & 1;
    }
    for (var w2 = 0; w2 <= 24; w2 += 8)
      p3 <<= 1, p3 |= e >> w2 + y4 & 1;
    n[i + 0] = o2 >>> 0, n[i + 1] = p3 >>> 0;
  };
  vt.r28shl = function(e, r) {
    return e << r & 268435455 | e >>> 28 - r;
  };
  var An = [14, 11, 17, 4, 27, 23, 25, 0, 13, 22, 7, 18, 5, 9, 16, 24, 2, 20, 12, 21, 1, 8, 15, 26, 15, 4, 25, 19, 9, 1, 26, 16, 5, 11, 23, 8, 12, 7, 17, 0, 22, 3, 10, 14, 6, 20, 27, 24];
  vt.pc2 = function(e, r, n, i) {
    for (var o2 = 0, p3 = 0, y4 = An.length >>> 1, w2 = 0; w2 < y4; w2++)
      o2 <<= 1, o2 |= e >>> An[w2] & 1;
    for (var w2 = y4; w2 < An.length; w2++)
      p3 <<= 1, p3 |= r >>> An[w2] & 1;
    n[i + 0] = o2 >>> 0, n[i + 1] = p3 >>> 0;
  };
  vt.expand = function(e, r, n) {
    var i = 0, o2 = 0;
    i = (e & 1) << 5 | e >>> 27;
    for (var p3 = 23; p3 >= 15; p3 -= 4)
      i <<= 6, i |= e >>> p3 & 63;
    for (var p3 = 11; p3 >= 3; p3 -= 4)
      o2 |= e >>> p3 & 63, o2 <<= 6;
    o2 |= (e & 31) << 1 | e >>> 31, r[n + 0] = i >>> 0, r[n + 1] = o2 >>> 0;
  };
  var jh = [14, 0, 4, 15, 13, 7, 1, 4, 2, 14, 15, 2, 11, 13, 8, 1, 3, 10, 10, 6, 6, 12, 12, 11, 5, 9, 9, 5, 0, 3, 7, 8, 4, 15, 1, 12, 14, 8, 8, 2, 13, 4, 6, 9, 2, 1, 11, 7, 15, 5, 12, 11, 9, 3, 7, 14, 3, 10, 10, 0, 5, 6, 0, 13, 15, 3, 1, 13, 8, 4, 14, 7, 6, 15, 11, 2, 3, 8, 4, 14, 9, 12, 7, 0, 2, 1, 13, 10, 12, 6, 0, 9, 5, 11, 10, 5, 0, 13, 14, 8, 7, 10, 11, 1, 10, 3, 4, 15, 13, 4, 1, 2, 5, 11, 8, 6, 12, 7, 6, 12, 9, 0, 3, 5, 2, 14, 15, 9, 10, 13, 0, 7, 9, 0, 14, 9, 6, 3, 3, 4, 15, 6, 5, 10, 1, 2, 13, 8, 12, 5, 7, 14, 11, 12, 4, 11, 2, 15, 8, 1, 13, 1, 6, 10, 4, 13, 9, 0, 8, 6, 15, 9, 3, 8, 0, 7, 11, 4, 1, 15, 2, 14, 12, 3, 5, 11, 10, 5, 14, 2, 7, 12, 7, 13, 13, 8, 14, 11, 3, 5, 0, 6, 6, 15, 9, 0, 10, 3, 1, 4, 2, 7, 8, 2, 5, 12, 11, 1, 12, 10, 4, 14, 15, 9, 10, 3, 6, 15, 9, 0, 0, 6, 12, 10, 11, 1, 7, 13, 13, 8, 15, 9, 1, 4, 3, 5, 14, 11, 5, 12, 2, 7, 8, 2, 4, 14, 2, 14, 12, 11, 4, 2, 1, 12, 7, 4, 10, 7, 11, 13, 6, 1, 8, 5, 5, 0, 3, 15, 15, 10, 13, 3, 0, 9, 14, 8, 9, 6, 4, 11, 2, 8, 1, 12, 11, 7, 10, 1, 13, 14, 7, 2, 8, 13, 15, 6, 9, 15, 12, 0, 5, 9, 6, 10, 3, 4, 0, 5, 14, 3, 12, 10, 1, 15, 10, 4, 15, 2, 9, 7, 2, 12, 6, 9, 8, 5, 0, 6, 13, 1, 3, 13, 4, 14, 14, 0, 7, 11, 5, 3, 11, 8, 9, 4, 14, 3, 15, 2, 5, 12, 2, 9, 8, 5, 12, 15, 3, 10, 7, 11, 0, 14, 4, 1, 10, 7, 1, 6, 13, 0, 11, 8, 6, 13, 4, 13, 11, 0, 2, 11, 14, 7, 15, 4, 0, 9, 8, 1, 13, 10, 3, 14, 12, 3, 9, 5, 7, 12, 5, 2, 10, 15, 6, 8, 1, 6, 1, 6, 4, 11, 11, 13, 13, 8, 12, 1, 3, 4, 7, 10, 14, 7, 10, 9, 15, 5, 6, 0, 8, 15, 0, 14, 5, 2, 9, 3, 2, 12, 13, 1, 2, 15, 8, 13, 4, 8, 6, 10, 15, 3, 11, 7, 1, 4, 10, 12, 9, 5, 3, 6, 14, 11, 5, 0, 0, 14, 12, 9, 7, 2, 7, 2, 11, 1, 4, 14, 1, 7, 9, 4, 12, 10, 14, 8, 2, 13, 0, 15, 6, 12, 10, 9, 13, 0, 15, 3, 3, 5, 5, 6, 8, 11];
  vt.substitute = function(e, r) {
    for (var n = 0, i = 0; i < 4; i++) {
      var o2 = e >>> 18 - i * 6 & 63, p3 = jh[i * 64 + o2];
      n <<= 4, n |= p3;
    }
    for (var i = 0; i < 4; i++) {
      var o2 = r >>> 18 - i * 6 & 63, p3 = jh[4 * 64 + i * 64 + o2];
      n <<= 4, n |= p3;
    }
    return n >>> 0;
  };
  var Wh = [16, 25, 12, 11, 3, 20, 4, 15, 31, 17, 9, 6, 27, 14, 1, 22, 30, 24, 8, 18, 0, 5, 29, 23, 13, 19, 2, 26, 10, 21, 28, 7];
  vt.permute = function(e) {
    for (var r = 0, n = 0; n < Wh.length; n++)
      r <<= 1, r |= e >>> Wh[n] & 1;
    return r >>> 0;
  };
  vt.padSplit = function(e, r, n) {
    for (var i = e.toString(2); i.length < r; )
      i = "0" + i;
    for (var o2 = [], p3 = 0; p3 < r; p3 += n)
      o2.push(i.slice(p3, p3 + n));
    return o2.join(" ");
  };
});
var ot3 = k4((I5, Zh) => {
  Zh.exports = Vh;
  function Vh(t, e) {
    if (!t)
      throw new Error(e || "Assertion failed");
  }
  Vh.equal = function(e, r, n) {
    if (e != r)
      throw new Error(n || "Assertion failed: " + e + " != " + r);
  };
});
var qn2 = k4((k52, Gh) => {
  "use strict";
  var P2 = ot3();
  function pt2(t) {
    this.options = t, this.type = this.options.type, this.blockSize = 8, this._init(), this.buffer = new Array(this.blockSize), this.bufferOff = 0;
  }
  Gh.exports = pt2;
  pt2.prototype._init = function() {
  };
  pt2.prototype.update = function(e) {
    return e.length === 0 ? [] : this.type === "decrypt" ? this._updateDecrypt(e) : this._updateEncrypt(e);
  };
  pt2.prototype._buffer = function(e, r) {
    for (var n = Math.min(this.buffer.length - this.bufferOff, e.length - r), i = 0; i < n; i++)
      this.buffer[this.bufferOff + i] = e[r + i];
    return this.bufferOff += n, n;
  };
  pt2.prototype._flushBuffer = function(e, r) {
    return this._update(this.buffer, 0, e, r), this.bufferOff = 0, this.blockSize;
  };
  pt2.prototype._updateEncrypt = function(e) {
    var r = 0, n = 0, i = (this.bufferOff + e.length) / this.blockSize | 0, o2 = new Array(i * this.blockSize);
    this.bufferOff !== 0 && (r += this._buffer(e, r), this.bufferOff === this.buffer.length && (n += this._flushBuffer(o2, n)));
    for (var p3 = e.length - (e.length - r) % this.blockSize; r < p3; r += this.blockSize)
      this._update(e, r, o2, n), n += this.blockSize;
    for (; r < e.length; r++, this.bufferOff++)
      this.buffer[this.bufferOff] = e[r];
    return o2;
  };
  pt2.prototype._updateDecrypt = function(e) {
    for (var r = 0, n = 0, i = Math.ceil((this.bufferOff + e.length) / this.blockSize) - 1, o2 = new Array(i * this.blockSize); i > 0; i--)
      r += this._buffer(e, r), n += this._flushBuffer(o2, n);
    return r += this._buffer(e, r), o2;
  };
  pt2.prototype.final = function(e) {
    var r;
    e && (r = this.update(e));
    var n;
    return this.type === "encrypt" ? n = this._finalEncrypt() : n = this._finalDecrypt(), r ? r.concat(n) : n;
  };
  pt2.prototype._pad = function(e, r) {
    if (r === 0)
      return false;
    for (; r < e.length; )
      e[r++] = 0;
    return true;
  };
  pt2.prototype._finalEncrypt = function() {
    if (!this._pad(this.buffer, this.bufferOff))
      return [];
    var e = new Array(this.blockSize);
    return this._update(this.buffer, 0, e, 0), e;
  };
  pt2.prototype._unpad = function(e) {
    return e;
  };
  pt2.prototype._finalDecrypt = function() {
    P2.equal(this.bufferOff, this.blockSize, "Not enough data to decrypt");
    var e = new Array(this.blockSize);
    return this._flushBuffer(e, 0), this._unpad(e);
  };
});
var l02 = k4((D52, Jh) => {
  "use strict";
  var Xh = ot3(), T22 = qe2(), He2 = c02(), Yh = qn2();
  function C2() {
    this.tmp = new Array(2), this.keys = null;
  }
  function rr(t) {
    Yh.call(this, t);
    var e = new C2();
    this._desState = e, this.deriveKeys(e, t.key);
  }
  T22(rr, Yh);
  Jh.exports = rr;
  rr.create = function(e) {
    return new rr(e);
  };
  var N22 = [1, 1, 2, 2, 2, 2, 2, 2, 1, 2, 2, 2, 2, 2, 2, 1];
  rr.prototype.deriveKeys = function(e, r) {
    e.keys = new Array(16 * 2), Xh.equal(r.length, this.blockSize, "Invalid key length");
    var n = He2.readUInt32BE(r, 0), i = He2.readUInt32BE(r, 4);
    He2.pc1(n, i, e.tmp, 0), n = e.tmp[0], i = e.tmp[1];
    for (var o2 = 0; o2 < e.keys.length; o2 += 2) {
      var p3 = N22[o2 >>> 1];
      n = He2.r28shl(n, p3), i = He2.r28shl(i, p3), He2.pc2(n, i, e.keys, o2);
    }
  };
  rr.prototype._update = function(e, r, n, i) {
    var o2 = this._desState, p3 = He2.readUInt32BE(e, r), y4 = He2.readUInt32BE(e, r + 4);
    He2.ip(p3, y4, o2.tmp, 0), p3 = o2.tmp[0], y4 = o2.tmp[1], this.type === "encrypt" ? this._encrypt(o2, p3, y4, o2.tmp, 0) : this._decrypt(o2, p3, y4, o2.tmp, 0), p3 = o2.tmp[0], y4 = o2.tmp[1], He2.writeUInt32BE(n, p3, i), He2.writeUInt32BE(n, y4, i + 4);
  };
  rr.prototype._pad = function(e, r) {
    for (var n = e.length - r, i = r; i < e.length; i++)
      e[i] = n;
    return true;
  };
  rr.prototype._unpad = function(e) {
    for (var r = e[e.length - 1], n = e.length - r; n < e.length; n++)
      Xh.equal(e[n], r);
    return e.slice(0, e.length - r);
  };
  rr.prototype._encrypt = function(e, r, n, i, o2) {
    for (var p3 = r, y4 = n, w2 = 0; w2 < e.keys.length; w2 += 2) {
      var x = e.keys[w2], M4 = e.keys[w2 + 1];
      He2.expand(y4, e.tmp, 0), x ^= e.tmp[0], M4 ^= e.tmp[1];
      var E2 = He2.substitute(x, M4), A4 = He2.permute(E2), I3 = y4;
      y4 = (p3 ^ A4) >>> 0, p3 = I3;
    }
    He2.rip(y4, p3, i, o2);
  };
  rr.prototype._decrypt = function(e, r, n, i, o2) {
    for (var p3 = n, y4 = r, w2 = e.keys.length - 2; w2 >= 0; w2 -= 2) {
      var x = e.keys[w2], M4 = e.keys[w2 + 1];
      He2.expand(p3, e.tmp, 0), x ^= e.tmp[0], M4 ^= e.tmp[1];
      var E2 = He2.substitute(x, M4), A4 = He2.permute(E2), I3 = p3;
      p3 = (y4 ^ A4) >>> 0, y4 = I3;
    }
    He2.rip(p3, y4, i, o2);
  };
});
var Qh2 = k4(($h) => {
  "use strict";
  var L22 = ot3(), O2 = qe2(), Bn = {};
  function z2(t) {
    L22.equal(t.length, 8, "Invalid IV length"), this.iv = new Array(8);
    for (var e = 0; e < this.iv.length; e++)
      this.iv[e] = t[e];
  }
  function U2(t) {
    function e(o2) {
      t.call(this, o2), this._cbcInit();
    }
    O2(e, t);
    for (var r = Object.keys(Bn), n = 0; n < r.length; n++) {
      var i = r[n];
      e.prototype[i] = Bn[i];
    }
    return e.create = function(p3) {
      return new e(p3);
    }, e;
  }
  $h.instantiate = U2;
  Bn._cbcInit = function() {
    var e = new z2(this.options.iv);
    this._cbcState = e;
  };
  Bn._update = function(e, r, n, i) {
    var o2 = this._cbcState, p3 = this.constructor.super_.prototype, y4 = o2.iv;
    if (this.type === "encrypt") {
      for (var w2 = 0; w2 < this.blockSize; w2++)
        y4[w2] ^= e[r + w2];
      p3._update.call(this, y4, 0, n, i);
      for (var w2 = 0; w2 < this.blockSize; w2++)
        y4[w2] = n[i + w2];
    } else {
      p3._update.call(this, e, r, n, i);
      for (var w2 = 0; w2 < this.blockSize; w2++)
        n[i + w2] ^= y4[w2];
      for (var w2 = 0; w2 < this.blockSize; w2++)
        y4[w2] = e[r + w2];
    }
  };
});
var ru2 = k4((T5, tu) => {
  "use strict";
  var H22 = ot3(), F22 = qe2(), eu = qn2(), Vr2 = l02();
  function K22(t, e) {
    H22.equal(e.length, 24, "Invalid key length");
    var r = e.slice(0, 8), n = e.slice(8, 16), i = e.slice(16, 24);
    t === "encrypt" ? this.ciphers = [Vr2.create({ type: "encrypt", key: r }), Vr2.create({ type: "decrypt", key: n }), Vr2.create({ type: "encrypt", key: i })] : this.ciphers = [Vr2.create({ type: "decrypt", key: i }), Vr2.create({ type: "encrypt", key: n }), Vr2.create({ type: "decrypt", key: r })];
  }
  function pi(t) {
    eu.call(this, t);
    var e = new K22(this.type, this.options.key);
    this._edeState = e;
  }
  F22(pi, eu);
  tu.exports = pi;
  pi.create = function(e) {
    return new pi(e);
  };
  pi.prototype._update = function(e, r, n, i) {
    var o2 = this._edeState;
    o2.ciphers[0]._update(e, r, n, i), o2.ciphers[1]._update(n, i, n, i), o2.ciphers[2]._update(n, i, n, i);
  };
  pi.prototype._pad = Vr2.prototype._pad;
  pi.prototype._unpad = Vr2.prototype._unpad;
});
var iu2 = k4((Oi2) => {
  "use strict";
  Oi2.utils = c02();
  Oi2.Cipher = qn2();
  Oi2.DES = l02();
  Oi2.CBC = Qh2();
  Oi2.EDE = ru2();
});
var au2 = k4((N5, nu) => {
  var fu = vr4(), pr2 = iu2(), j2 = qe2(), bi = Ae2().Buffer, Rf = { "des-ede3-cbc": pr2.CBC.instantiate(pr2.EDE), "des-ede3": pr2.EDE, "des-ede-cbc": pr2.CBC.instantiate(pr2.EDE), "des-ede": pr2.EDE, "des-cbc": pr2.CBC.instantiate(pr2.DES), "des-ecb": pr2.DES };
  Rf.des = Rf["des-cbc"];
  Rf.des3 = Rf["des-ede3-cbc"];
  nu.exports = Rn;
  j2(Rn, fu);
  function Rn(t) {
    fu.call(this);
    var e = t.mode.toLowerCase(), r = Rf[e], n;
    t.decrypt ? n = "decrypt" : n = "encrypt";
    var i = t.key;
    bi.isBuffer(i) || (i = bi.from(i)), (e === "des-ede" || e === "des-ede-cbc") && (i = bi.concat([i, i.slice(0, 8)]));
    var o2 = t.iv;
    bi.isBuffer(o2) || (o2 = bi.from(o2)), this._des = r.create({ key: i, iv: o2, type: n });
  }
  Rn.prototype._update = function(t) {
    return bi.from(this._des.update(t));
  };
  Rn.prototype._final = function() {
    return bi.from(this._des.final());
  };
});
var su2 = k4((v0) => {
  v0.encrypt = function(t, e) {
    return t._cipher.encryptBlock(e);
  };
  v0.decrypt = function(t, e) {
    return t._cipher.decryptBlock(e);
  };
});
var zi2 = k4((O5, ou) => {
  ou.exports = function(e, r) {
    for (var n = Math.min(e.length, r.length), i = new ut(n), o2 = 0; o2 < n; ++o2)
      i[o2] = e[o2] ^ r[o2];
    return i;
  };
});
var uu2 = k4((p0) => {
  var hu = zi2();
  p0.encrypt = function(t, e) {
    var r = hu(e, t._prev);
    return t._prev = t._cipher.encryptBlock(r), t._prev;
  };
  p0.decrypt = function(t, e) {
    var r = t._prev;
    t._prev = e;
    var n = t._cipher.decryptBlock(e);
    return hu(n, r);
  };
});
var lu2 = k4((cu) => {
  var If = Ae2().Buffer, W22 = zi2();
  function du(t, e, r) {
    var n = e.length, i = W22(e, t._cache);
    return t._cache = t._cache.slice(n), t._prev = If.concat([t._prev, r ? e : i]), i;
  }
  cu.encrypt = function(t, e, r) {
    for (var n = If.allocUnsafe(0), i; e.length; )
      if (t._cache.length === 0 && (t._cache = t._cipher.encryptBlock(t._prev), t._prev = If.allocUnsafe(0)), t._cache.length <= e.length)
        i = t._cache.length, n = If.concat([n, du(t, e.slice(0, i), r)]), e = e.slice(i);
      else {
        n = If.concat([n, du(t, e, r)]);
        break;
      }
    return n;
  };
});
var pu2 = k4((vu) => {
  var b0 = Ae2().Buffer;
  function V22(t, e, r) {
    var n = t._cipher.encryptBlock(t._prev), i = n[0] ^ e;
    return t._prev = b0.concat([t._prev.slice(1), b0.from([r ? e : i])]), i;
  }
  vu.encrypt = function(t, e, r) {
    for (var n = e.length, i = b0.allocUnsafe(n), o2 = -1; ++o2 < n; )
      i[o2] = V22(t, e[o2], r);
    return i;
  };
});
var mu2 = k4((bu) => {
  var In = Ae2().Buffer;
  function Z22(t, e, r) {
    for (var n, i = -1, o2 = 8, p3 = 0, y4, w2; ++i < o2; )
      n = t._cipher.encryptBlock(t._prev), y4 = e & 1 << 7 - i ? 128 : 0, w2 = n[0] ^ y4, p3 += (w2 & 128) >> i % 8, t._prev = G22(t._prev, r ? y4 : w2);
    return p3;
  }
  function G22(t, e) {
    var r = t.length, n = -1, i = In.allocUnsafe(t.length);
    for (t = In.concat([t, In.from([e])]); ++n < r; )
      i[n] = t[n] << 1 | t[n + 1] >> 7;
    return i;
  }
  bu.encrypt = function(t, e, r) {
    for (var n = e.length, i = In.allocUnsafe(n), o2 = -1; ++o2 < n; )
      i[o2] = Z22(t, e[o2], r);
    return i;
  };
});
var yu2 = k4((gu) => {
  var X22 = zi2();
  function Y22(t) {
    return t._prev = t._cipher.encryptBlock(t._prev), t._prev;
  }
  gu.encrypt = function(t, e) {
    for (; t._cache.length < e.length; )
      t._cache = ut.concat([t._cache, Y22(t)]);
    var r = t._cache.slice(0, e.length);
    return t._cache = t._cache.slice(e.length), X22(e, r);
  };
});
var m02 = k4((j5, _u) => {
  function J22(t) {
    for (var e = t.length, r; e--; )
      if (r = t.readUInt8(e), r === 255)
        t.writeUInt8(0, e);
      else {
        r++, t.writeUInt8(r, e);
        break;
      }
  }
  _u.exports = J22;
});
var y02 = k4((xu) => {
  var $22 = zi2(), wu = Ae2().Buffer, Q22 = m02();
  function eb(t) {
    var e = t._cipher.encryptBlockRaw(t._prev);
    return Q22(t._prev), e;
  }
  var g0 = 16;
  xu.encrypt = function(t, e) {
    var r = Math.ceil(e.length / g0), n = t._cache.length;
    t._cache = wu.concat([t._cache, wu.allocUnsafe(r * g0)]);
    for (var i = 0; i < r; i++) {
      var o2 = eb(t), p3 = n + i * g0;
      t._cache.writeUInt32BE(o2[0], p3 + 0), t._cache.writeUInt32BE(o2[1], p3 + 4), t._cache.writeUInt32BE(o2[2], p3 + 8), t._cache.writeUInt32BE(o2[3], p3 + 12);
    }
    var y4 = t._cache.slice(0, e.length);
    return t._cache = t._cache.slice(e.length), $22(e, y4);
  };
});
var _02 = k4((V5, tb) => {
  tb.exports = { "aes-128-ecb": { cipher: "AES", key: 128, iv: 0, mode: "ECB", type: "block" }, "aes-192-ecb": { cipher: "AES", key: 192, iv: 0, mode: "ECB", type: "block" }, "aes-256-ecb": { cipher: "AES", key: 256, iv: 0, mode: "ECB", type: "block" }, "aes-128-cbc": { cipher: "AES", key: 128, iv: 16, mode: "CBC", type: "block" }, "aes-192-cbc": { cipher: "AES", key: 192, iv: 16, mode: "CBC", type: "block" }, "aes-256-cbc": { cipher: "AES", key: 256, iv: 16, mode: "CBC", type: "block" }, aes128: { cipher: "AES", key: 128, iv: 16, mode: "CBC", type: "block" }, aes192: { cipher: "AES", key: 192, iv: 16, mode: "CBC", type: "block" }, aes256: { cipher: "AES", key: 256, iv: 16, mode: "CBC", type: "block" }, "aes-128-cfb": { cipher: "AES", key: 128, iv: 16, mode: "CFB", type: "stream" }, "aes-192-cfb": { cipher: "AES", key: 192, iv: 16, mode: "CFB", type: "stream" }, "aes-256-cfb": { cipher: "AES", key: 256, iv: 16, mode: "CFB", type: "stream" }, "aes-128-cfb8": { cipher: "AES", key: 128, iv: 16, mode: "CFB8", type: "stream" }, "aes-192-cfb8": { cipher: "AES", key: 192, iv: 16, mode: "CFB8", type: "stream" }, "aes-256-cfb8": { cipher: "AES", key: 256, iv: 16, mode: "CFB8", type: "stream" }, "aes-128-cfb1": { cipher: "AES", key: 128, iv: 16, mode: "CFB1", type: "stream" }, "aes-192-cfb1": { cipher: "AES", key: 192, iv: 16, mode: "CFB1", type: "stream" }, "aes-256-cfb1": { cipher: "AES", key: 256, iv: 16, mode: "CFB1", type: "stream" }, "aes-128-ofb": { cipher: "AES", key: 128, iv: 16, mode: "OFB", type: "stream" }, "aes-192-ofb": { cipher: "AES", key: 192, iv: 16, mode: "OFB", type: "stream" }, "aes-256-ofb": { cipher: "AES", key: 256, iv: 16, mode: "OFB", type: "stream" }, "aes-128-ctr": { cipher: "AES", key: 128, iv: 16, mode: "CTR", type: "stream" }, "aes-192-ctr": { cipher: "AES", key: 192, iv: 16, mode: "CTR", type: "stream" }, "aes-256-ctr": { cipher: "AES", key: 256, iv: 16, mode: "CTR", type: "stream" }, "aes-128-gcm": { cipher: "AES", key: 128, iv: 12, mode: "GCM", type: "auth" }, "aes-192-gcm": { cipher: "AES", key: 192, iv: 12, mode: "GCM", type: "auth" }, "aes-256-gcm": { cipher: "AES", key: 256, iv: 12, mode: "GCM", type: "auth" } };
});
var Dn2 = k4((Z5, Mu) => {
  var rb = { ECB: su2(), CBC: uu2(), CFB: lu2(), CFB8: pu2(), CFB1: mu2(), OFB: yu2(), CTR: y02(), GCM: y02() }, kn = _02();
  for (w0 in kn)
    kn[w0].module = rb[kn[w0].mode];
  var w0;
  Mu.exports = kn;
});
var kf2 = k4((G5, Eu) => {
  var Pn = Ae2().Buffer;
  function M0(t) {
    Pn.isBuffer(t) || (t = Pn.from(t));
    for (var e = t.length / 4 | 0, r = new Array(e), n = 0; n < e; n++)
      r[n] = t.readUInt32BE(n * 4);
    return r;
  }
  function x0(t) {
    for (var e = 0; e < t.length; t++)
      t[e] = 0;
  }
  function Su(t, e, r, n, i) {
    for (var o2 = r[0], p3 = r[1], y4 = r[2], w2 = r[3], x = t[0] ^ e[0], M4 = t[1] ^ e[1], E2 = t[2] ^ e[2], A4 = t[3] ^ e[3], I3, D6, C, ge2, L4 = 4, ye = 1; ye < i; ye++)
      I3 = o2[x >>> 24] ^ p3[M4 >>> 16 & 255] ^ y4[E2 >>> 8 & 255] ^ w2[A4 & 255] ^ e[L4++], D6 = o2[M4 >>> 24] ^ p3[E2 >>> 16 & 255] ^ y4[A4 >>> 8 & 255] ^ w2[x & 255] ^ e[L4++], C = o2[E2 >>> 24] ^ p3[A4 >>> 16 & 255] ^ y4[x >>> 8 & 255] ^ w2[M4 & 255] ^ e[L4++], ge2 = o2[A4 >>> 24] ^ p3[x >>> 16 & 255] ^ y4[M4 >>> 8 & 255] ^ w2[E2 & 255] ^ e[L4++], x = I3, M4 = D6, E2 = C, A4 = ge2;
    return I3 = (n[x >>> 24] << 24 | n[M4 >>> 16 & 255] << 16 | n[E2 >>> 8 & 255] << 8 | n[A4 & 255]) ^ e[L4++], D6 = (n[M4 >>> 24] << 24 | n[E2 >>> 16 & 255] << 16 | n[A4 >>> 8 & 255] << 8 | n[x & 255]) ^ e[L4++], C = (n[E2 >>> 24] << 24 | n[A4 >>> 16 & 255] << 16 | n[x >>> 8 & 255] << 8 | n[M4 & 255]) ^ e[L4++], ge2 = (n[A4 >>> 24] << 24 | n[x >>> 16 & 255] << 16 | n[M4 >>> 8 & 255] << 8 | n[E2 & 255]) ^ e[L4++], I3 = I3 >>> 0, D6 = D6 >>> 0, C = C >>> 0, ge2 = ge2 >>> 0, [I3, D6, C, ge2];
  }
  var ib = [0, 1, 2, 4, 8, 16, 32, 64, 128, 27, 54], Ue3 = function() {
    for (var t = new Array(256), e = 0; e < 256; e++)
      e < 128 ? t[e] = e << 1 : t[e] = e << 1 ^ 283;
    for (var r = [], n = [], i = [[], [], [], []], o2 = [[], [], [], []], p3 = 0, y4 = 0, w2 = 0; w2 < 256; ++w2) {
      var x = y4 ^ y4 << 1 ^ y4 << 2 ^ y4 << 3 ^ y4 << 4;
      x = x >>> 8 ^ x & 255 ^ 99, r[p3] = x, n[x] = p3;
      var M4 = t[p3], E2 = t[M4], A4 = t[E2], I3 = t[x] * 257 ^ x * 16843008;
      i[0][p3] = I3 << 24 | I3 >>> 8, i[1][p3] = I3 << 16 | I3 >>> 16, i[2][p3] = I3 << 8 | I3 >>> 24, i[3][p3] = I3, I3 = A4 * 16843009 ^ E2 * 65537 ^ M4 * 257 ^ p3 * 16843008, o2[0][x] = I3 << 24 | I3 >>> 8, o2[1][x] = I3 << 16 | I3 >>> 16, o2[2][x] = I3 << 8 | I3 >>> 24, o2[3][x] = I3, p3 === 0 ? p3 = y4 = 1 : (p3 = M4 ^ t[t[t[A4 ^ M4]]], y4 ^= t[t[y4]]);
    }
    return { SBOX: r, INV_SBOX: n, SUB_MIX: i, INV_SUB_MIX: o2 };
  }();
  function bt(t) {
    this._key = M0(t), this._reset();
  }
  bt.blockSize = 4 * 4;
  bt.keySize = 256 / 8;
  bt.prototype.blockSize = bt.blockSize;
  bt.prototype.keySize = bt.keySize;
  bt.prototype._reset = function() {
    for (var t = this._key, e = t.length, r = e + 6, n = (r + 1) * 4, i = [], o2 = 0; o2 < e; o2++)
      i[o2] = t[o2];
    for (o2 = e; o2 < n; o2++) {
      var p3 = i[o2 - 1];
      o2 % e === 0 ? (p3 = p3 << 8 | p3 >>> 24, p3 = Ue3.SBOX[p3 >>> 24] << 24 | Ue3.SBOX[p3 >>> 16 & 255] << 16 | Ue3.SBOX[p3 >>> 8 & 255] << 8 | Ue3.SBOX[p3 & 255], p3 ^= ib[o2 / e | 0] << 24) : e > 6 && o2 % e === 4 && (p3 = Ue3.SBOX[p3 >>> 24] << 24 | Ue3.SBOX[p3 >>> 16 & 255] << 16 | Ue3.SBOX[p3 >>> 8 & 255] << 8 | Ue3.SBOX[p3 & 255]), i[o2] = i[o2 - e] ^ p3;
    }
    for (var y4 = [], w2 = 0; w2 < n; w2++) {
      var x = n - w2, M4 = i[x - (w2 % 4 ? 0 : 4)];
      w2 < 4 || x <= 4 ? y4[w2] = M4 : y4[w2] = Ue3.INV_SUB_MIX[0][Ue3.SBOX[M4 >>> 24]] ^ Ue3.INV_SUB_MIX[1][Ue3.SBOX[M4 >>> 16 & 255]] ^ Ue3.INV_SUB_MIX[2][Ue3.SBOX[M4 >>> 8 & 255]] ^ Ue3.INV_SUB_MIX[3][Ue3.SBOX[M4 & 255]];
    }
    this._nRounds = r, this._keySchedule = i, this._invKeySchedule = y4;
  };
  bt.prototype.encryptBlockRaw = function(t) {
    return t = M0(t), Su(t, this._keySchedule, Ue3.SUB_MIX, Ue3.SBOX, this._nRounds);
  };
  bt.prototype.encryptBlock = function(t) {
    var e = this.encryptBlockRaw(t), r = Pn.allocUnsafe(16);
    return r.writeUInt32BE(e[0], 0), r.writeUInt32BE(e[1], 4), r.writeUInt32BE(e[2], 8), r.writeUInt32BE(e[3], 12), r;
  };
  bt.prototype.decryptBlock = function(t) {
    t = M0(t);
    var e = t[1];
    t[1] = t[3], t[3] = e;
    var r = Su(t, this._invKeySchedule, Ue3.INV_SUB_MIX, Ue3.INV_SBOX, this._nRounds), n = Pn.allocUnsafe(16);
    return n.writeUInt32BE(r[0], 0), n.writeUInt32BE(r[3], 4), n.writeUInt32BE(r[2], 8), n.writeUInt32BE(r[1], 12), n;
  };
  bt.prototype.scrub = function() {
    x0(this._keySchedule), x0(this._invKeySchedule), x0(this._key);
  };
  Eu.exports.AES = bt;
});
var Bu2 = k4((X5, qu) => {
  var Ui = Ae2().Buffer, fb = Ui.alloc(16, 0);
  function nb(t) {
    return [t.readUInt32BE(0), t.readUInt32BE(4), t.readUInt32BE(8), t.readUInt32BE(12)];
  }
  function Au(t) {
    var e = Ui.allocUnsafe(16);
    return e.writeUInt32BE(t[0] >>> 0, 0), e.writeUInt32BE(t[1] >>> 0, 4), e.writeUInt32BE(t[2] >>> 0, 8), e.writeUInt32BE(t[3] >>> 0, 12), e;
  }
  function Df(t) {
    this.h = t, this.state = Ui.alloc(16, 0), this.cache = Ui.allocUnsafe(0);
  }
  Df.prototype.ghash = function(t) {
    for (var e = -1; ++e < t.length; )
      this.state[e] ^= t[e];
    this._multiply();
  };
  Df.prototype._multiply = function() {
    for (var t = nb(this.h), e = [0, 0, 0, 0], r, n, i, o2 = -1; ++o2 < 128; ) {
      for (n = (this.state[~~(o2 / 8)] & 1 << 7 - o2 % 8) !== 0, n && (e[0] ^= t[0], e[1] ^= t[1], e[2] ^= t[2], e[3] ^= t[3]), i = (t[3] & 1) !== 0, r = 3; r > 0; r--)
        t[r] = t[r] >>> 1 | (t[r - 1] & 1) << 31;
      t[0] = t[0] >>> 1, i && (t[0] = t[0] ^ 225 << 24);
    }
    this.state = Au(e);
  };
  Df.prototype.update = function(t) {
    this.cache = Ui.concat([this.cache, t]);
    for (var e; this.cache.length >= 16; )
      e = this.cache.slice(0, 16), this.cache = this.cache.slice(16), this.ghash(e);
  };
  Df.prototype.final = function(t, e) {
    return this.cache.length && this.ghash(Ui.concat([this.cache, fb], 16)), this.ghash(Au([0, t, 0, e])), this.state;
  };
  qu.exports = Df;
});
var S02 = k4((Y5, ku) => {
  var ab = kf2(), ft4 = Ae2().Buffer, Ru = vr4(), sb = qe2(), Iu = Bu2(), ob = zi2(), hb = m02();
  function ub(t, e) {
    var r = 0;
    t.length !== e.length && r++;
    for (var n = Math.min(t.length, e.length), i = 0; i < n; ++i)
      r += t[i] ^ e[i];
    return r;
  }
  function db(t, e, r) {
    if (e.length === 12)
      return t._finID = ft4.concat([e, ft4.from([0, 0, 0, 1])]), ft4.concat([e, ft4.from([0, 0, 0, 2])]);
    var n = new Iu(r), i = e.length, o2 = i % 16;
    n.update(e), o2 && (o2 = 16 - o2, n.update(ft4.alloc(o2, 0))), n.update(ft4.alloc(8, 0));
    var p3 = i * 8, y4 = ft4.alloc(8);
    y4.writeUIntBE(p3, 0, 8), n.update(y4), t._finID = n.state;
    var w2 = ft4.from(t._finID);
    return hb(w2), w2;
  }
  function mi2(t, e, r, n) {
    Ru.call(this);
    var i = ft4.alloc(4, 0);
    this._cipher = new ab.AES(e);
    var o2 = this._cipher.encryptBlock(i);
    this._ghash = new Iu(o2), r = db(this, r, o2), this._prev = ft4.from(r), this._cache = ft4.allocUnsafe(0), this._secCache = ft4.allocUnsafe(0), this._decrypt = n, this._alen = 0, this._len = 0, this._mode = t, this._authTag = null, this._called = false;
  }
  sb(mi2, Ru);
  mi2.prototype._update = function(t) {
    if (!this._called && this._alen) {
      var e = 16 - this._alen % 16;
      e < 16 && (e = ft4.alloc(e, 0), this._ghash.update(e));
    }
    this._called = true;
    var r = this._mode.encrypt(this, t);
    return this._decrypt ? this._ghash.update(t) : this._ghash.update(r), this._len += t.length, r;
  };
  mi2.prototype._final = function() {
    if (this._decrypt && !this._authTag)
      throw new Error("Unsupported state or unable to authenticate data");
    var t = ob(this._ghash.final(this._alen * 8, this._len * 8), this._cipher.encryptBlock(this._finID));
    if (this._decrypt && ub(t, this._authTag))
      throw new Error("Unsupported state or unable to authenticate data");
    this._authTag = t, this._cipher.scrub();
  };
  mi2.prototype.getAuthTag = function() {
    if (this._decrypt || !ft4.isBuffer(this._authTag))
      throw new Error("Attempting to get auth tag in unsupported state");
    return this._authTag;
  };
  mi2.prototype.setAuthTag = function(e) {
    if (!this._decrypt)
      throw new Error("Attempting to set auth tag in unsupported state");
    this._authTag = e;
  };
  mi2.prototype.setAAD = function(e) {
    if (this._called)
      throw new Error("Attempting to set AAD in unsupported state");
    this._ghash.update(e), this._alen += e.length;
  };
  ku.exports = mi2;
});
var A02 = k4((J5, Pu) => {
  var cb = kf2(), E0 = Ae2().Buffer, Du = vr4(), lb = qe2();
  function Tn(t, e, r, n) {
    Du.call(this), this._cipher = new cb.AES(e), this._prev = E0.from(r), this._cache = E0.allocUnsafe(0), this._secCache = E0.allocUnsafe(0), this._decrypt = n, this._mode = t;
  }
  lb(Tn, Du);
  Tn.prototype._update = function(t) {
    return this._mode.encrypt(this, t, this._decrypt);
  };
  Tn.prototype._final = function() {
    this._cipher.scrub();
  };
  Pu.exports = Tn;
});
var Pf2 = k4(($5, Tu) => {
  var gi = Ae2().Buffer, vb = vn2();
  function pb(t, e, r, n) {
    if (gi.isBuffer(t) || (t = gi.from(t, "binary")), e && (gi.isBuffer(e) || (e = gi.from(e, "binary")), e.length !== 8))
      throw new RangeError("salt should be Buffer with 8 byte length");
    for (var i = r / 8, o2 = gi.alloc(i), p3 = gi.alloc(n || 0), y4 = gi.alloc(0); i > 0 || n > 0; ) {
      var w2 = new vb();
      w2.update(y4), w2.update(t), e && w2.update(e), y4 = w2.digest();
      var x = 0;
      if (i > 0) {
        var M4 = o2.length - i;
        x = Math.min(i, y4.length), y4.copy(o2, M4, 0, x), i -= x;
      }
      if (x < y4.length && n > 0) {
        var E2 = p3.length - n, A4 = Math.min(n, y4.length - x);
        y4.copy(p3, E2, x, x + A4), n -= A4;
      }
    }
    return y4.fill(0), { key: o2, iv: p3 };
  }
  Tu.exports = pb;
});
var Ou2 = k4((q0) => {
  var Cu = Dn2(), bb = S02(), br = Ae2().Buffer, mb = A02(), Nu = vr4(), gb = kf2(), yb = Pf2(), _b = qe2();
  function Tf(t, e, r) {
    Nu.call(this), this._cache = new Cn(), this._cipher = new gb.AES(e), this._prev = br.from(r), this._mode = t, this._autopadding = true;
  }
  _b(Tf, Nu);
  Tf.prototype._update = function(t) {
    this._cache.add(t);
    for (var e, r, n = []; e = this._cache.get(); )
      r = this._mode.encrypt(this, e), n.push(r);
    return br.concat(n);
  };
  var wb = br.alloc(16, 16);
  Tf.prototype._final = function() {
    var t = this._cache.flush();
    if (this._autopadding)
      return t = this._mode.encrypt(this, t), this._cipher.scrub(), t;
    if (!t.equals(wb))
      throw this._cipher.scrub(), new Error("data not multiple of block length");
  };
  Tf.prototype.setAutoPadding = function(t) {
    return this._autopadding = !!t, this;
  };
  function Cn() {
    this.cache = br.allocUnsafe(0);
  }
  Cn.prototype.add = function(t) {
    this.cache = br.concat([this.cache, t]);
  };
  Cn.prototype.get = function() {
    if (this.cache.length > 15) {
      var t = this.cache.slice(0, 16);
      return this.cache = this.cache.slice(16), t;
    }
    return null;
  };
  Cn.prototype.flush = function() {
    for (var t = 16 - this.cache.length, e = br.allocUnsafe(t), r = -1; ++r < t; )
      e.writeUInt8(t, r);
    return br.concat([this.cache, e]);
  };
  function Lu(t, e, r) {
    var n = Cu[t.toLowerCase()];
    if (!n)
      throw new TypeError("invalid suite type");
    if (typeof e == "string" && (e = br.from(e)), e.length !== n.key / 8)
      throw new TypeError("invalid key length " + e.length);
    if (typeof r == "string" && (r = br.from(r)), n.mode !== "GCM" && r.length !== n.iv)
      throw new TypeError("invalid iv length " + r.length);
    return n.type === "stream" ? new mb(n.module, e, r) : n.type === "auth" ? new bb(n.module, e, r) : new Tf(n.module, e, r);
  }
  function xb(t, e) {
    var r = Cu[t.toLowerCase()];
    if (!r)
      throw new TypeError("invalid suite type");
    var n = yb(e, false, r.key, r.iv);
    return Lu(t, n.key, n.iv);
  }
  q0.createCipheriv = Lu;
  q0.createCipher = xb;
});
var Fu2 = k4((B0) => {
  var Mb = S02(), Hi = Ae2().Buffer, zu = Dn2(), Sb = A02(), Uu = vr4(), Eb = kf2(), Ab = Pf2(), qb = qe2();
  function Cf(t, e, r) {
    Uu.call(this), this._cache = new Nn(), this._last = void 0, this._cipher = new Eb.AES(e), this._prev = Hi.from(r), this._mode = t, this._autopadding = true;
  }
  qb(Cf, Uu);
  Cf.prototype._update = function(t) {
    this._cache.add(t);
    for (var e, r, n = []; e = this._cache.get(this._autopadding); )
      r = this._mode.decrypt(this, e), n.push(r);
    return Hi.concat(n);
  };
  Cf.prototype._final = function() {
    var t = this._cache.flush();
    if (this._autopadding)
      return Bb(this._mode.decrypt(this, t));
    if (t)
      throw new Error("data not multiple of block length");
  };
  Cf.prototype.setAutoPadding = function(t) {
    return this._autopadding = !!t, this;
  };
  function Nn() {
    this.cache = Hi.allocUnsafe(0);
  }
  Nn.prototype.add = function(t) {
    this.cache = Hi.concat([this.cache, t]);
  };
  Nn.prototype.get = function(t) {
    var e;
    if (t) {
      if (this.cache.length > 16)
        return e = this.cache.slice(0, 16), this.cache = this.cache.slice(16), e;
    } else if (this.cache.length >= 16)
      return e = this.cache.slice(0, 16), this.cache = this.cache.slice(16), e;
    return null;
  };
  Nn.prototype.flush = function() {
    if (this.cache.length)
      return this.cache;
  };
  function Bb(t) {
    var e = t[15];
    if (e < 1 || e > 16)
      throw new Error("unable to decrypt data");
    for (var r = -1; ++r < e; )
      if (t[r + (16 - e)] !== e)
        throw new Error("unable to decrypt data");
    if (e !== 16)
      return t.slice(0, 16 - e);
  }
  function Hu(t, e, r) {
    var n = zu[t.toLowerCase()];
    if (!n)
      throw new TypeError("invalid suite type");
    if (typeof r == "string" && (r = Hi.from(r)), n.mode !== "GCM" && r.length !== n.iv)
      throw new TypeError("invalid iv length " + r.length);
    if (typeof e == "string" && (e = Hi.from(e)), e.length !== n.key / 8)
      throw new TypeError("invalid key length " + e.length);
    return n.type === "stream" ? new Sb(n.module, e, r, true) : n.type === "auth" ? new Mb(n.module, e, r, true) : new Cf(n.module, e, r);
  }
  function Rb(t, e) {
    var r = zu[t.toLowerCase()];
    if (!r)
      throw new TypeError("invalid suite type");
    var n = Ab(e, false, r.key, r.iv);
    return Hu(t, n.key, n.iv);
  }
  B0.createDecipher = Rb;
  B0.createDecipheriv = Hu;
});
var Ln2 = k4((Kt2) => {
  var Ku = Ou2(), ju = Fu2(), Ib = _02();
  function kb() {
    return Object.keys(Ib);
  }
  Kt2.createCipher = Kt2.Cipher = Ku.createCipher;
  Kt2.createCipheriv = Kt2.Cipheriv = Ku.createCipheriv;
  Kt2.createDecipher = Kt2.Decipher = ju.createDecipher;
  Kt2.createDecipheriv = Kt2.Decipheriv = ju.createDecipheriv;
  Kt2.listCiphers = Kt2.getCiphers = kb;
});
var Wu2 = k4((mr) => {
  mr["des-ecb"] = { key: 8, iv: 0 };
  mr["des-cbc"] = mr.des = { key: 8, iv: 8 };
  mr["des-ede3-cbc"] = mr.des3 = { key: 24, iv: 8 };
  mr["des-ede3"] = { key: 24, iv: 0 };
  mr["des-ede-cbc"] = { key: 16, iv: 8 };
  mr["des-ede"] = { key: 16, iv: 0 };
});
var Yu2 = k4((jt2) => {
  var Vu = au2(), R0 = Ln2(), Zr3 = Dn2(), gr2 = Wu2(), Zu = Pf2();
  function Db(t, e) {
    t = t.toLowerCase();
    var r, n;
    if (Zr3[t])
      r = Zr3[t].key, n = Zr3[t].iv;
    else if (gr2[t])
      r = gr2[t].key * 8, n = gr2[t].iv;
    else
      throw new TypeError("invalid suite type");
    var i = Zu(e, false, r, n);
    return Gu(t, i.key, i.iv);
  }
  function Pb(t, e) {
    t = t.toLowerCase();
    var r, n;
    if (Zr3[t])
      r = Zr3[t].key, n = Zr3[t].iv;
    else if (gr2[t])
      r = gr2[t].key * 8, n = gr2[t].iv;
    else
      throw new TypeError("invalid suite type");
    var i = Zu(e, false, r, n);
    return Xu(t, i.key, i.iv);
  }
  function Gu(t, e, r) {
    if (t = t.toLowerCase(), Zr3[t])
      return R0.createCipheriv(t, e, r);
    if (gr2[t])
      return new Vu({ key: e, iv: r, mode: t });
    throw new TypeError("invalid suite type");
  }
  function Xu(t, e, r) {
    if (t = t.toLowerCase(), Zr3[t])
      return R0.createDecipheriv(t, e, r);
    if (gr2[t])
      return new Vu({ key: e, iv: r, mode: t, decrypt: true });
    throw new TypeError("invalid suite type");
  }
  function Tb() {
    return Object.keys(gr2).concat(R0.getCiphers());
  }
  jt2.createCipher = jt2.Cipher = Db;
  jt2.createCipheriv = jt2.Cipheriv = Gu;
  jt2.createDecipher = jt2.Decipher = Pb;
  jt2.createDecipheriv = jt2.Decipheriv = Xu;
  jt2.listCiphers = jt2.getCiphers = Tb;
});
var Fe2 = k4((Ju, I0) => {
  (function(t, e) {
    "use strict";
    function r(S3, v2) {
      if (!S3)
        throw new Error(v2 || "Assertion failed");
    }
    function n(S3, v2) {
      S3.super_ = v2;
      var _2 = function() {
      };
      _2.prototype = v2.prototype, S3.prototype = new _2(), S3.prototype.constructor = S3;
    }
    function i(S3, v2, _2) {
      if (i.isBN(S3))
        return S3;
      this.negative = 0, this.words = null, this.length = 0, this.red = null, S3 !== null && ((v2 === "le" || v2 === "be") && (_2 = v2, v2 = 10), this._init(S3 || 0, v2 || 10, _2 || "be"));
    }
    typeof t == "object" ? t.exports = i : e.BN = i, i.BN = i, i.wordSize = 26;
    var o2;
    try {
      typeof window != "undefined" && typeof window.Buffer != "undefined" ? o2 = window.Buffer : o2 = export_default.Buffer;
    } catch {
    }
    i.isBN = function(v2) {
      return v2 instanceof i ? true : v2 !== null && typeof v2 == "object" && v2.constructor.wordSize === i.wordSize && Array.isArray(v2.words);
    }, i.max = function(v2, _2) {
      return v2.cmp(_2) > 0 ? v2 : _2;
    }, i.min = function(v2, _2) {
      return v2.cmp(_2) < 0 ? v2 : _2;
    }, i.prototype._init = function(v2, _2, c5) {
      if (typeof v2 == "number")
        return this._initNumber(v2, _2, c5);
      if (typeof v2 == "object")
        return this._initArray(v2, _2, c5);
      _2 === "hex" && (_2 = 16), r(_2 === (_2 | 0) && _2 >= 2 && _2 <= 36), v2 = v2.toString().replace(/\s+/g, "");
      var f = 0;
      v2[0] === "-" && (f++, this.negative = 1), f < v2.length && (_2 === 16 ? this._parseHex(v2, f, c5) : (this._parseBase(v2, _2, f), c5 === "le" && this._initArray(this.toArray(), _2, c5)));
    }, i.prototype._initNumber = function(v2, _2, c5) {
      v2 < 0 && (this.negative = 1, v2 = -v2), v2 < 67108864 ? (this.words = [v2 & 67108863], this.length = 1) : v2 < 4503599627370496 ? (this.words = [v2 & 67108863, v2 / 67108864 & 67108863], this.length = 2) : (r(v2 < 9007199254740992), this.words = [v2 & 67108863, v2 / 67108864 & 67108863, 1], this.length = 3), c5 === "le" && this._initArray(this.toArray(), _2, c5);
    }, i.prototype._initArray = function(v2, _2, c5) {
      if (r(typeof v2.length == "number"), v2.length <= 0)
        return this.words = [0], this.length = 1, this;
      this.length = Math.ceil(v2.length / 3), this.words = new Array(this.length);
      for (var f = 0; f < this.length; f++)
        this.words[f] = 0;
      var a, u, l = 0;
      if (c5 === "be")
        for (f = v2.length - 1, a = 0; f >= 0; f -= 3)
          u = v2[f] | v2[f - 1] << 8 | v2[f - 2] << 16, this.words[a] |= u << l & 67108863, this.words[a + 1] = u >>> 26 - l & 67108863, l += 24, l >= 26 && (l -= 26, a++);
      else if (c5 === "le")
        for (f = 0, a = 0; f < v2.length; f += 3)
          u = v2[f] | v2[f + 1] << 8 | v2[f + 2] << 16, this.words[a] |= u << l & 67108863, this.words[a + 1] = u >>> 26 - l & 67108863, l += 24, l >= 26 && (l -= 26, a++);
      return this.strip();
    };
    function p3(S3, v2) {
      var _2 = S3.charCodeAt(v2);
      return _2 >= 65 && _2 <= 70 ? _2 - 55 : _2 >= 97 && _2 <= 102 ? _2 - 87 : _2 - 48 & 15;
    }
    function y4(S3, v2, _2) {
      var c5 = p3(S3, _2);
      return _2 - 1 >= v2 && (c5 |= p3(S3, _2 - 1) << 4), c5;
    }
    i.prototype._parseHex = function(v2, _2, c5) {
      this.length = Math.ceil((v2.length - _2) / 6), this.words = new Array(this.length);
      for (var f = 0; f < this.length; f++)
        this.words[f] = 0;
      var a = 0, u = 0, l;
      if (c5 === "be")
        for (f = v2.length - 1; f >= _2; f -= 2)
          l = y4(v2, _2, f) << a, this.words[u] |= l & 67108863, a >= 18 ? (a -= 18, u += 1, this.words[u] |= l >>> 26) : a += 8;
      else {
        var d4 = v2.length - _2;
        for (f = d4 % 2 === 0 ? _2 + 1 : _2; f < v2.length; f += 2)
          l = y4(v2, _2, f) << a, this.words[u] |= l & 67108863, a >= 18 ? (a -= 18, u += 1, this.words[u] |= l >>> 26) : a += 8;
      }
      this.strip();
    };
    function w2(S3, v2, _2, c5) {
      for (var f = 0, a = Math.min(S3.length, _2), u = v2; u < a; u++) {
        var l = S3.charCodeAt(u) - 48;
        f *= c5, l >= 49 ? f += l - 49 + 10 : l >= 17 ? f += l - 17 + 10 : f += l;
      }
      return f;
    }
    i.prototype._parseBase = function(v2, _2, c5) {
      this.words = [0], this.length = 1;
      for (var f = 0, a = 1; a <= 67108863; a *= _2)
        f++;
      f--, a = a / _2 | 0;
      for (var u = v2.length - c5, l = u % f, d4 = Math.min(u, u - l) + c5, h = 0, b2 = c5; b2 < d4; b2 += f)
        h = w2(v2, b2, b2 + f, _2), this.imuln(a), this.words[0] + h < 67108864 ? this.words[0] += h : this._iaddn(h);
      if (l !== 0) {
        var m3 = 1;
        for (h = w2(v2, b2, v2.length, _2), b2 = 0; b2 < l; b2++)
          m3 *= _2;
        this.imuln(m3), this.words[0] + h < 67108864 ? this.words[0] += h : this._iaddn(h);
      }
      this.strip();
    }, i.prototype.copy = function(v2) {
      v2.words = new Array(this.length);
      for (var _2 = 0; _2 < this.length; _2++)
        v2.words[_2] = this.words[_2];
      v2.length = this.length, v2.negative = this.negative, v2.red = this.red;
    }, i.prototype.clone = function() {
      var v2 = new i(null);
      return this.copy(v2), v2;
    }, i.prototype._expand = function(v2) {
      for (; this.length < v2; )
        this.words[this.length++] = 0;
      return this;
    }, i.prototype.strip = function() {
      for (; this.length > 1 && this.words[this.length - 1] === 0; )
        this.length--;
      return this._normSign();
    }, i.prototype._normSign = function() {
      return this.length === 1 && this.words[0] === 0 && (this.negative = 0), this;
    }, i.prototype.inspect = function() {
      return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
    };
    var x = ["", "0", "00", "000", "0000", "00000", "000000", "0000000", "00000000", "000000000", "0000000000", "00000000000", "000000000000", "0000000000000", "00000000000000", "000000000000000", "0000000000000000", "00000000000000000", "000000000000000000", "0000000000000000000", "00000000000000000000", "000000000000000000000", "0000000000000000000000", "00000000000000000000000", "000000000000000000000000", "0000000000000000000000000"], M4 = [0, 0, 25, 16, 12, 11, 10, 9, 8, 8, 7, 7, 7, 7, 6, 6, 6, 6, 6, 6, 6, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5], E2 = [0, 0, 33554432, 43046721, 16777216, 48828125, 60466176, 40353607, 16777216, 43046721, 1e7, 19487171, 35831808, 62748517, 7529536, 11390625, 16777216, 24137569, 34012224, 47045881, 64e6, 4084101, 5153632, 6436343, 7962624, 9765625, 11881376, 14348907, 17210368, 20511149, 243e5, 28629151, 33554432, 39135393, 45435424, 52521875, 60466176];
    i.prototype.toString = function(v2, _2) {
      v2 = v2 || 10, _2 = _2 | 0 || 1;
      var c5;
      if (v2 === 16 || v2 === "hex") {
        c5 = "";
        for (var f = 0, a = 0, u = 0; u < this.length; u++) {
          var l = this.words[u], d4 = ((l << f | a) & 16777215).toString(16);
          a = l >>> 24 - f & 16777215, a !== 0 || u !== this.length - 1 ? c5 = x[6 - d4.length] + d4 + c5 : c5 = d4 + c5, f += 2, f >= 26 && (f -= 26, u--);
        }
        for (a !== 0 && (c5 = a.toString(16) + c5); c5.length % _2 !== 0; )
          c5 = "0" + c5;
        return this.negative !== 0 && (c5 = "-" + c5), c5;
      }
      if (v2 === (v2 | 0) && v2 >= 2 && v2 <= 36) {
        var h = M4[v2], b2 = E2[v2];
        c5 = "";
        var m3 = this.clone();
        for (m3.negative = 0; !m3.isZero(); ) {
          var s = m3.modn(b2).toString(v2);
          m3 = m3.idivn(b2), m3.isZero() ? c5 = s + c5 : c5 = x[h - s.length] + s + c5;
        }
        for (this.isZero() && (c5 = "0" + c5); c5.length % _2 !== 0; )
          c5 = "0" + c5;
        return this.negative !== 0 && (c5 = "-" + c5), c5;
      }
      r(false, "Base should be between 2 and 36");
    }, i.prototype.toNumber = function() {
      var v2 = this.words[0];
      return this.length === 2 ? v2 += this.words[1] * 67108864 : this.length === 3 && this.words[2] === 1 ? v2 += 4503599627370496 + this.words[1] * 67108864 : this.length > 2 && r(false, "Number can only safely store up to 53 bits"), this.negative !== 0 ? -v2 : v2;
    }, i.prototype.toJSON = function() {
      return this.toString(16);
    }, i.prototype.toBuffer = function(v2, _2) {
      return r(typeof o2 != "undefined"), this.toArrayLike(o2, v2, _2);
    }, i.prototype.toArray = function(v2, _2) {
      return this.toArrayLike(Array, v2, _2);
    }, i.prototype.toArrayLike = function(v2, _2, c5) {
      var f = this.byteLength(), a = c5 || Math.max(1, f);
      r(f <= a, "byte array longer than desired length"), r(a > 0, "Requested array length <= 0"), this.strip();
      var u = _2 === "le", l = new v2(a), d4, h, b2 = this.clone();
      if (u) {
        for (h = 0; !b2.isZero(); h++)
          d4 = b2.andln(255), b2.iushrn(8), l[h] = d4;
        for (; h < a; h++)
          l[h] = 0;
      } else {
        for (h = 0; h < a - f; h++)
          l[h] = 0;
        for (h = 0; !b2.isZero(); h++)
          d4 = b2.andln(255), b2.iushrn(8), l[a - h - 1] = d4;
      }
      return l;
    }, Math.clz32 ? i.prototype._countBits = function(v2) {
      return 32 - Math.clz32(v2);
    } : i.prototype._countBits = function(v2) {
      var _2 = v2, c5 = 0;
      return _2 >= 4096 && (c5 += 13, _2 >>>= 13), _2 >= 64 && (c5 += 7, _2 >>>= 7), _2 >= 8 && (c5 += 4, _2 >>>= 4), _2 >= 2 && (c5 += 2, _2 >>>= 2), c5 + _2;
    }, i.prototype._zeroBits = function(v2) {
      if (v2 === 0)
        return 26;
      var _2 = v2, c5 = 0;
      return (_2 & 8191) === 0 && (c5 += 13, _2 >>>= 13), (_2 & 127) === 0 && (c5 += 7, _2 >>>= 7), (_2 & 15) === 0 && (c5 += 4, _2 >>>= 4), (_2 & 3) === 0 && (c5 += 2, _2 >>>= 2), (_2 & 1) === 0 && c5++, c5;
    }, i.prototype.bitLength = function() {
      var v2 = this.words[this.length - 1], _2 = this._countBits(v2);
      return (this.length - 1) * 26 + _2;
    };
    function A4(S3) {
      for (var v2 = new Array(S3.bitLength()), _2 = 0; _2 < v2.length; _2++) {
        var c5 = _2 / 26 | 0, f = _2 % 26;
        v2[_2] = (S3.words[c5] & 1 << f) >>> f;
      }
      return v2;
    }
    i.prototype.zeroBits = function() {
      if (this.isZero())
        return 0;
      for (var v2 = 0, _2 = 0; _2 < this.length; _2++) {
        var c5 = this._zeroBits(this.words[_2]);
        if (v2 += c5, c5 !== 26)
          break;
      }
      return v2;
    }, i.prototype.byteLength = function() {
      return Math.ceil(this.bitLength() / 8);
    }, i.prototype.toTwos = function(v2) {
      return this.negative !== 0 ? this.abs().inotn(v2).iaddn(1) : this.clone();
    }, i.prototype.fromTwos = function(v2) {
      return this.testn(v2 - 1) ? this.notn(v2).iaddn(1).ineg() : this.clone();
    }, i.prototype.isNeg = function() {
      return this.negative !== 0;
    }, i.prototype.neg = function() {
      return this.clone().ineg();
    }, i.prototype.ineg = function() {
      return this.isZero() || (this.negative ^= 1), this;
    }, i.prototype.iuor = function(v2) {
      for (; this.length < v2.length; )
        this.words[this.length++] = 0;
      for (var _2 = 0; _2 < v2.length; _2++)
        this.words[_2] = this.words[_2] | v2.words[_2];
      return this.strip();
    }, i.prototype.ior = function(v2) {
      return r((this.negative | v2.negative) === 0), this.iuor(v2);
    }, i.prototype.or = function(v2) {
      return this.length > v2.length ? this.clone().ior(v2) : v2.clone().ior(this);
    }, i.prototype.uor = function(v2) {
      return this.length > v2.length ? this.clone().iuor(v2) : v2.clone().iuor(this);
    }, i.prototype.iuand = function(v2) {
      var _2;
      this.length > v2.length ? _2 = v2 : _2 = this;
      for (var c5 = 0; c5 < _2.length; c5++)
        this.words[c5] = this.words[c5] & v2.words[c5];
      return this.length = _2.length, this.strip();
    }, i.prototype.iand = function(v2) {
      return r((this.negative | v2.negative) === 0), this.iuand(v2);
    }, i.prototype.and = function(v2) {
      return this.length > v2.length ? this.clone().iand(v2) : v2.clone().iand(this);
    }, i.prototype.uand = function(v2) {
      return this.length > v2.length ? this.clone().iuand(v2) : v2.clone().iuand(this);
    }, i.prototype.iuxor = function(v2) {
      var _2, c5;
      this.length > v2.length ? (_2 = this, c5 = v2) : (_2 = v2, c5 = this);
      for (var f = 0; f < c5.length; f++)
        this.words[f] = _2.words[f] ^ c5.words[f];
      if (this !== _2)
        for (; f < _2.length; f++)
          this.words[f] = _2.words[f];
      return this.length = _2.length, this.strip();
    }, i.prototype.ixor = function(v2) {
      return r((this.negative | v2.negative) === 0), this.iuxor(v2);
    }, i.prototype.xor = function(v2) {
      return this.length > v2.length ? this.clone().ixor(v2) : v2.clone().ixor(this);
    }, i.prototype.uxor = function(v2) {
      return this.length > v2.length ? this.clone().iuxor(v2) : v2.clone().iuxor(this);
    }, i.prototype.inotn = function(v2) {
      r(typeof v2 == "number" && v2 >= 0);
      var _2 = Math.ceil(v2 / 26) | 0, c5 = v2 % 26;
      this._expand(_2), c5 > 0 && _2--;
      for (var f = 0; f < _2; f++)
        this.words[f] = ~this.words[f] & 67108863;
      return c5 > 0 && (this.words[f] = ~this.words[f] & 67108863 >> 26 - c5), this.strip();
    }, i.prototype.notn = function(v2) {
      return this.clone().inotn(v2);
    }, i.prototype.setn = function(v2, _2) {
      r(typeof v2 == "number" && v2 >= 0);
      var c5 = v2 / 26 | 0, f = v2 % 26;
      return this._expand(c5 + 1), _2 ? this.words[c5] = this.words[c5] | 1 << f : this.words[c5] = this.words[c5] & ~(1 << f), this.strip();
    }, i.prototype.iadd = function(v2) {
      var _2;
      if (this.negative !== 0 && v2.negative === 0)
        return this.negative = 0, _2 = this.isub(v2), this.negative ^= 1, this._normSign();
      if (this.negative === 0 && v2.negative !== 0)
        return v2.negative = 0, _2 = this.isub(v2), v2.negative = 1, _2._normSign();
      var c5, f;
      this.length > v2.length ? (c5 = this, f = v2) : (c5 = v2, f = this);
      for (var a = 0, u = 0; u < f.length; u++)
        _2 = (c5.words[u] | 0) + (f.words[u] | 0) + a, this.words[u] = _2 & 67108863, a = _2 >>> 26;
      for (; a !== 0 && u < c5.length; u++)
        _2 = (c5.words[u] | 0) + a, this.words[u] = _2 & 67108863, a = _2 >>> 26;
      if (this.length = c5.length, a !== 0)
        this.words[this.length] = a, this.length++;
      else if (c5 !== this)
        for (; u < c5.length; u++)
          this.words[u] = c5.words[u];
      return this;
    }, i.prototype.add = function(v2) {
      var _2;
      return v2.negative !== 0 && this.negative === 0 ? (v2.negative = 0, _2 = this.sub(v2), v2.negative ^= 1, _2) : v2.negative === 0 && this.negative !== 0 ? (this.negative = 0, _2 = v2.sub(this), this.negative = 1, _2) : this.length > v2.length ? this.clone().iadd(v2) : v2.clone().iadd(this);
    }, i.prototype.isub = function(v2) {
      if (v2.negative !== 0) {
        v2.negative = 0;
        var _2 = this.iadd(v2);
        return v2.negative = 1, _2._normSign();
      } else if (this.negative !== 0)
        return this.negative = 0, this.iadd(v2), this.negative = 1, this._normSign();
      var c5 = this.cmp(v2);
      if (c5 === 0)
        return this.negative = 0, this.length = 1, this.words[0] = 0, this;
      var f, a;
      c5 > 0 ? (f = this, a = v2) : (f = v2, a = this);
      for (var u = 0, l = 0; l < a.length; l++)
        _2 = (f.words[l] | 0) - (a.words[l] | 0) + u, u = _2 >> 26, this.words[l] = _2 & 67108863;
      for (; u !== 0 && l < f.length; l++)
        _2 = (f.words[l] | 0) + u, u = _2 >> 26, this.words[l] = _2 & 67108863;
      if (u === 0 && l < f.length && f !== this)
        for (; l < f.length; l++)
          this.words[l] = f.words[l];
      return this.length = Math.max(this.length, l), f !== this && (this.negative = 1), this.strip();
    }, i.prototype.sub = function(v2) {
      return this.clone().isub(v2);
    };
    function I3(S3, v2, _2) {
      _2.negative = v2.negative ^ S3.negative;
      var c5 = S3.length + v2.length | 0;
      _2.length = c5, c5 = c5 - 1 | 0;
      var f = S3.words[0] | 0, a = v2.words[0] | 0, u = f * a, l = u & 67108863, d4 = u / 67108864 | 0;
      _2.words[0] = l;
      for (var h = 1; h < c5; h++) {
        for (var b2 = d4 >>> 26, m3 = d4 & 67108863, s = Math.min(h, v2.length - 1), g2 = Math.max(0, h - S3.length + 1); g2 <= s; g2++) {
          var q = h - g2 | 0;
          f = S3.words[q] | 0, a = v2.words[g2] | 0, u = f * a + m3, b2 += u / 67108864 | 0, m3 = u & 67108863;
        }
        _2.words[h] = m3 | 0, d4 = b2 | 0;
      }
      return d4 !== 0 ? _2.words[h] = d4 | 0 : _2.length--, _2.strip();
    }
    var D6 = function(v2, _2, c5) {
      var f = v2.words, a = _2.words, u = c5.words, l = 0, d4, h, b2, m3 = f[0] | 0, s = m3 & 8191, g2 = m3 >>> 13, q = f[1] | 0, R3 = q & 8191, B3 = q >>> 13, P2 = f[2] | 0, T4 = P2 & 8191, N4 = P2 >>> 13, ze = f[3] | 0, O = ze & 8191, z = ze >>> 13, Er3 = f[4] | 0, U2 = Er3 & 8191, H3 = Er3 >>> 13, Ar = f[5] | 0, F4 = Ar & 8191, K4 = Ar >>> 13, qr2 = f[6] | 0, j2 = qr2 & 8191, W4 = qr2 >>> 13, Br2 = f[7] | 0, V3 = Br2 & 8191, Z5 = Br2 >>> 13, Rr2 = f[8] | 0, G4 = Rr2 & 8191, X5 = Rr2 >>> 13, Ir2 = f[9] | 0, Y4 = Ir2 & 8191, J3 = Ir2 >>> 13, kr2 = a[0] | 0, $4 = kr2 & 8191, Q3 = kr2 >>> 13, Dr = a[1] | 0, ee2 = Dr & 8191, te = Dr >>> 13, Pr2 = a[2] | 0, re2 = Pr2 & 8191, ie = Pr2 >>> 13, Tr2 = a[3] | 0, fe = Tr2 & 8191, ne = Tr2 >>> 13, Cr2 = a[4] | 0, ae2 = Cr2 & 8191, se = Cr2 >>> 13, Nr2 = a[5] | 0, oe = Nr2 & 8191, he2 = Nr2 >>> 13, Lr4 = a[6] | 0, ue2 = Lr4 & 8191, de4 = Lr4 >>> 13, Or2 = a[7] | 0, ce2 = Or2 & 8191, le2 = Or2 >>> 13, zr = a[8] | 0, ve2 = zr & 8191, pe = zr >>> 13, Ur3 = a[9] | 0, be = Ur3 & 8191, me = Ur3 >>> 13;
      c5.negative = v2.negative ^ _2.negative, c5.length = 19, d4 = Math.imul(s, $4), h = Math.imul(s, Q3), h = h + Math.imul(g2, $4) | 0, b2 = Math.imul(g2, Q3);
      var dr2 = (l + d4 | 0) + ((h & 8191) << 13) | 0;
      l = (b2 + (h >>> 13) | 0) + (dr2 >>> 26) | 0, dr2 &= 67108863, d4 = Math.imul(R3, $4), h = Math.imul(R3, Q3), h = h + Math.imul(B3, $4) | 0, b2 = Math.imul(B3, Q3), d4 = d4 + Math.imul(s, ee2) | 0, h = h + Math.imul(s, te) | 0, h = h + Math.imul(g2, ee2) | 0, b2 = b2 + Math.imul(g2, te) | 0;
      var _e2 = (l + d4 | 0) + ((h & 8191) << 13) | 0;
      l = (b2 + (h >>> 13) | 0) + (_e2 >>> 26) | 0, _e2 &= 67108863, d4 = Math.imul(T4, $4), h = Math.imul(T4, Q3), h = h + Math.imul(N4, $4) | 0, b2 = Math.imul(N4, Q3), d4 = d4 + Math.imul(R3, ee2) | 0, h = h + Math.imul(R3, te) | 0, h = h + Math.imul(B3, ee2) | 0, b2 = b2 + Math.imul(B3, te) | 0, d4 = d4 + Math.imul(s, re2) | 0, h = h + Math.imul(s, ie) | 0, h = h + Math.imul(g2, re2) | 0, b2 = b2 + Math.imul(g2, ie) | 0;
      var we2 = (l + d4 | 0) + ((h & 8191) << 13) | 0;
      l = (b2 + (h >>> 13) | 0) + (we2 >>> 26) | 0, we2 &= 67108863, d4 = Math.imul(O, $4), h = Math.imul(O, Q3), h = h + Math.imul(z, $4) | 0, b2 = Math.imul(z, Q3), d4 = d4 + Math.imul(T4, ee2) | 0, h = h + Math.imul(T4, te) | 0, h = h + Math.imul(N4, ee2) | 0, b2 = b2 + Math.imul(N4, te) | 0, d4 = d4 + Math.imul(R3, re2) | 0, h = h + Math.imul(R3, ie) | 0, h = h + Math.imul(B3, re2) | 0, b2 = b2 + Math.imul(B3, ie) | 0, d4 = d4 + Math.imul(s, fe) | 0, h = h + Math.imul(s, ne) | 0, h = h + Math.imul(g2, fe) | 0, b2 = b2 + Math.imul(g2, ne) | 0;
      var At2 = (l + d4 | 0) + ((h & 8191) << 13) | 0;
      l = (b2 + (h >>> 13) | 0) + (At2 >>> 26) | 0, At2 &= 67108863, d4 = Math.imul(U2, $4), h = Math.imul(U2, Q3), h = h + Math.imul(H3, $4) | 0, b2 = Math.imul(H3, Q3), d4 = d4 + Math.imul(O, ee2) | 0, h = h + Math.imul(O, te) | 0, h = h + Math.imul(z, ee2) | 0, b2 = b2 + Math.imul(z, te) | 0, d4 = d4 + Math.imul(T4, re2) | 0, h = h + Math.imul(T4, ie) | 0, h = h + Math.imul(N4, re2) | 0, b2 = b2 + Math.imul(N4, ie) | 0, d4 = d4 + Math.imul(R3, fe) | 0, h = h + Math.imul(R3, ne) | 0, h = h + Math.imul(B3, fe) | 0, b2 = b2 + Math.imul(B3, ne) | 0, d4 = d4 + Math.imul(s, ae2) | 0, h = h + Math.imul(s, se) | 0, h = h + Math.imul(g2, ae2) | 0, b2 = b2 + Math.imul(g2, se) | 0;
      var qt2 = (l + d4 | 0) + ((h & 8191) << 13) | 0;
      l = (b2 + (h >>> 13) | 0) + (qt2 >>> 26) | 0, qt2 &= 67108863, d4 = Math.imul(F4, $4), h = Math.imul(F4, Q3), h = h + Math.imul(K4, $4) | 0, b2 = Math.imul(K4, Q3), d4 = d4 + Math.imul(U2, ee2) | 0, h = h + Math.imul(U2, te) | 0, h = h + Math.imul(H3, ee2) | 0, b2 = b2 + Math.imul(H3, te) | 0, d4 = d4 + Math.imul(O, re2) | 0, h = h + Math.imul(O, ie) | 0, h = h + Math.imul(z, re2) | 0, b2 = b2 + Math.imul(z, ie) | 0, d4 = d4 + Math.imul(T4, fe) | 0, h = h + Math.imul(T4, ne) | 0, h = h + Math.imul(N4, fe) | 0, b2 = b2 + Math.imul(N4, ne) | 0, d4 = d4 + Math.imul(R3, ae2) | 0, h = h + Math.imul(R3, se) | 0, h = h + Math.imul(B3, ae2) | 0, b2 = b2 + Math.imul(B3, se) | 0, d4 = d4 + Math.imul(s, oe) | 0, h = h + Math.imul(s, he2) | 0, h = h + Math.imul(g2, oe) | 0, b2 = b2 + Math.imul(g2, he2) | 0;
      var Bt = (l + d4 | 0) + ((h & 8191) << 13) | 0;
      l = (b2 + (h >>> 13) | 0) + (Bt >>> 26) | 0, Bt &= 67108863, d4 = Math.imul(j2, $4), h = Math.imul(j2, Q3), h = h + Math.imul(W4, $4) | 0, b2 = Math.imul(W4, Q3), d4 = d4 + Math.imul(F4, ee2) | 0, h = h + Math.imul(F4, te) | 0, h = h + Math.imul(K4, ee2) | 0, b2 = b2 + Math.imul(K4, te) | 0, d4 = d4 + Math.imul(U2, re2) | 0, h = h + Math.imul(U2, ie) | 0, h = h + Math.imul(H3, re2) | 0, b2 = b2 + Math.imul(H3, ie) | 0, d4 = d4 + Math.imul(O, fe) | 0, h = h + Math.imul(O, ne) | 0, h = h + Math.imul(z, fe) | 0, b2 = b2 + Math.imul(z, ne) | 0, d4 = d4 + Math.imul(T4, ae2) | 0, h = h + Math.imul(T4, se) | 0, h = h + Math.imul(N4, ae2) | 0, b2 = b2 + Math.imul(N4, se) | 0, d4 = d4 + Math.imul(R3, oe) | 0, h = h + Math.imul(R3, he2) | 0, h = h + Math.imul(B3, oe) | 0, b2 = b2 + Math.imul(B3, he2) | 0, d4 = d4 + Math.imul(s, ue2) | 0, h = h + Math.imul(s, de4) | 0, h = h + Math.imul(g2, ue2) | 0, b2 = b2 + Math.imul(g2, de4) | 0;
      var Rt2 = (l + d4 | 0) + ((h & 8191) << 13) | 0;
      l = (b2 + (h >>> 13) | 0) + (Rt2 >>> 26) | 0, Rt2 &= 67108863, d4 = Math.imul(V3, $4), h = Math.imul(V3, Q3), h = h + Math.imul(Z5, $4) | 0, b2 = Math.imul(Z5, Q3), d4 = d4 + Math.imul(j2, ee2) | 0, h = h + Math.imul(j2, te) | 0, h = h + Math.imul(W4, ee2) | 0, b2 = b2 + Math.imul(W4, te) | 0, d4 = d4 + Math.imul(F4, re2) | 0, h = h + Math.imul(F4, ie) | 0, h = h + Math.imul(K4, re2) | 0, b2 = b2 + Math.imul(K4, ie) | 0, d4 = d4 + Math.imul(U2, fe) | 0, h = h + Math.imul(U2, ne) | 0, h = h + Math.imul(H3, fe) | 0, b2 = b2 + Math.imul(H3, ne) | 0, d4 = d4 + Math.imul(O, ae2) | 0, h = h + Math.imul(O, se) | 0, h = h + Math.imul(z, ae2) | 0, b2 = b2 + Math.imul(z, se) | 0, d4 = d4 + Math.imul(T4, oe) | 0, h = h + Math.imul(T4, he2) | 0, h = h + Math.imul(N4, oe) | 0, b2 = b2 + Math.imul(N4, he2) | 0, d4 = d4 + Math.imul(R3, ue2) | 0, h = h + Math.imul(R3, de4) | 0, h = h + Math.imul(B3, ue2) | 0, b2 = b2 + Math.imul(B3, de4) | 0, d4 = d4 + Math.imul(s, ce2) | 0, h = h + Math.imul(s, le2) | 0, h = h + Math.imul(g2, ce2) | 0, b2 = b2 + Math.imul(g2, le2) | 0;
      var It2 = (l + d4 | 0) + ((h & 8191) << 13) | 0;
      l = (b2 + (h >>> 13) | 0) + (It2 >>> 26) | 0, It2 &= 67108863, d4 = Math.imul(G4, $4), h = Math.imul(G4, Q3), h = h + Math.imul(X5, $4) | 0, b2 = Math.imul(X5, Q3), d4 = d4 + Math.imul(V3, ee2) | 0, h = h + Math.imul(V3, te) | 0, h = h + Math.imul(Z5, ee2) | 0, b2 = b2 + Math.imul(Z5, te) | 0, d4 = d4 + Math.imul(j2, re2) | 0, h = h + Math.imul(j2, ie) | 0, h = h + Math.imul(W4, re2) | 0, b2 = b2 + Math.imul(W4, ie) | 0, d4 = d4 + Math.imul(F4, fe) | 0, h = h + Math.imul(F4, ne) | 0, h = h + Math.imul(K4, fe) | 0, b2 = b2 + Math.imul(K4, ne) | 0, d4 = d4 + Math.imul(U2, ae2) | 0, h = h + Math.imul(U2, se) | 0, h = h + Math.imul(H3, ae2) | 0, b2 = b2 + Math.imul(H3, se) | 0, d4 = d4 + Math.imul(O, oe) | 0, h = h + Math.imul(O, he2) | 0, h = h + Math.imul(z, oe) | 0, b2 = b2 + Math.imul(z, he2) | 0, d4 = d4 + Math.imul(T4, ue2) | 0, h = h + Math.imul(T4, de4) | 0, h = h + Math.imul(N4, ue2) | 0, b2 = b2 + Math.imul(N4, de4) | 0, d4 = d4 + Math.imul(R3, ce2) | 0, h = h + Math.imul(R3, le2) | 0, h = h + Math.imul(B3, ce2) | 0, b2 = b2 + Math.imul(B3, le2) | 0, d4 = d4 + Math.imul(s, ve2) | 0, h = h + Math.imul(s, pe) | 0, h = h + Math.imul(g2, ve2) | 0, b2 = b2 + Math.imul(g2, pe) | 0;
      var kt2 = (l + d4 | 0) + ((h & 8191) << 13) | 0;
      l = (b2 + (h >>> 13) | 0) + (kt2 >>> 26) | 0, kt2 &= 67108863, d4 = Math.imul(Y4, $4), h = Math.imul(Y4, Q3), h = h + Math.imul(J3, $4) | 0, b2 = Math.imul(J3, Q3), d4 = d4 + Math.imul(G4, ee2) | 0, h = h + Math.imul(G4, te) | 0, h = h + Math.imul(X5, ee2) | 0, b2 = b2 + Math.imul(X5, te) | 0, d4 = d4 + Math.imul(V3, re2) | 0, h = h + Math.imul(V3, ie) | 0, h = h + Math.imul(Z5, re2) | 0, b2 = b2 + Math.imul(Z5, ie) | 0, d4 = d4 + Math.imul(j2, fe) | 0, h = h + Math.imul(j2, ne) | 0, h = h + Math.imul(W4, fe) | 0, b2 = b2 + Math.imul(W4, ne) | 0, d4 = d4 + Math.imul(F4, ae2) | 0, h = h + Math.imul(F4, se) | 0, h = h + Math.imul(K4, ae2) | 0, b2 = b2 + Math.imul(K4, se) | 0, d4 = d4 + Math.imul(U2, oe) | 0, h = h + Math.imul(U2, he2) | 0, h = h + Math.imul(H3, oe) | 0, b2 = b2 + Math.imul(H3, he2) | 0, d4 = d4 + Math.imul(O, ue2) | 0, h = h + Math.imul(O, de4) | 0, h = h + Math.imul(z, ue2) | 0, b2 = b2 + Math.imul(z, de4) | 0, d4 = d4 + Math.imul(T4, ce2) | 0, h = h + Math.imul(T4, le2) | 0, h = h + Math.imul(N4, ce2) | 0, b2 = b2 + Math.imul(N4, le2) | 0, d4 = d4 + Math.imul(R3, ve2) | 0, h = h + Math.imul(R3, pe) | 0, h = h + Math.imul(B3, ve2) | 0, b2 = b2 + Math.imul(B3, pe) | 0, d4 = d4 + Math.imul(s, be) | 0, h = h + Math.imul(s, me) | 0, h = h + Math.imul(g2, be) | 0, b2 = b2 + Math.imul(g2, me) | 0;
      var Dt = (l + d4 | 0) + ((h & 8191) << 13) | 0;
      l = (b2 + (h >>> 13) | 0) + (Dt >>> 26) | 0, Dt &= 67108863, d4 = Math.imul(Y4, ee2), h = Math.imul(Y4, te), h = h + Math.imul(J3, ee2) | 0, b2 = Math.imul(J3, te), d4 = d4 + Math.imul(G4, re2) | 0, h = h + Math.imul(G4, ie) | 0, h = h + Math.imul(X5, re2) | 0, b2 = b2 + Math.imul(X5, ie) | 0, d4 = d4 + Math.imul(V3, fe) | 0, h = h + Math.imul(V3, ne) | 0, h = h + Math.imul(Z5, fe) | 0, b2 = b2 + Math.imul(Z5, ne) | 0, d4 = d4 + Math.imul(j2, ae2) | 0, h = h + Math.imul(j2, se) | 0, h = h + Math.imul(W4, ae2) | 0, b2 = b2 + Math.imul(W4, se) | 0, d4 = d4 + Math.imul(F4, oe) | 0, h = h + Math.imul(F4, he2) | 0, h = h + Math.imul(K4, oe) | 0, b2 = b2 + Math.imul(K4, he2) | 0, d4 = d4 + Math.imul(U2, ue2) | 0, h = h + Math.imul(U2, de4) | 0, h = h + Math.imul(H3, ue2) | 0, b2 = b2 + Math.imul(H3, de4) | 0, d4 = d4 + Math.imul(O, ce2) | 0, h = h + Math.imul(O, le2) | 0, h = h + Math.imul(z, ce2) | 0, b2 = b2 + Math.imul(z, le2) | 0, d4 = d4 + Math.imul(T4, ve2) | 0, h = h + Math.imul(T4, pe) | 0, h = h + Math.imul(N4, ve2) | 0, b2 = b2 + Math.imul(N4, pe) | 0, d4 = d4 + Math.imul(R3, be) | 0, h = h + Math.imul(R3, me) | 0, h = h + Math.imul(B3, be) | 0, b2 = b2 + Math.imul(B3, me) | 0;
      var Pt2 = (l + d4 | 0) + ((h & 8191) << 13) | 0;
      l = (b2 + (h >>> 13) | 0) + (Pt2 >>> 26) | 0, Pt2 &= 67108863, d4 = Math.imul(Y4, re2), h = Math.imul(Y4, ie), h = h + Math.imul(J3, re2) | 0, b2 = Math.imul(J3, ie), d4 = d4 + Math.imul(G4, fe) | 0, h = h + Math.imul(G4, ne) | 0, h = h + Math.imul(X5, fe) | 0, b2 = b2 + Math.imul(X5, ne) | 0, d4 = d4 + Math.imul(V3, ae2) | 0, h = h + Math.imul(V3, se) | 0, h = h + Math.imul(Z5, ae2) | 0, b2 = b2 + Math.imul(Z5, se) | 0, d4 = d4 + Math.imul(j2, oe) | 0, h = h + Math.imul(j2, he2) | 0, h = h + Math.imul(W4, oe) | 0, b2 = b2 + Math.imul(W4, he2) | 0, d4 = d4 + Math.imul(F4, ue2) | 0, h = h + Math.imul(F4, de4) | 0, h = h + Math.imul(K4, ue2) | 0, b2 = b2 + Math.imul(K4, de4) | 0, d4 = d4 + Math.imul(U2, ce2) | 0, h = h + Math.imul(U2, le2) | 0, h = h + Math.imul(H3, ce2) | 0, b2 = b2 + Math.imul(H3, le2) | 0, d4 = d4 + Math.imul(O, ve2) | 0, h = h + Math.imul(O, pe) | 0, h = h + Math.imul(z, ve2) | 0, b2 = b2 + Math.imul(z, pe) | 0, d4 = d4 + Math.imul(T4, be) | 0, h = h + Math.imul(T4, me) | 0, h = h + Math.imul(N4, be) | 0, b2 = b2 + Math.imul(N4, me) | 0;
      var Tt2 = (l + d4 | 0) + ((h & 8191) << 13) | 0;
      l = (b2 + (h >>> 13) | 0) + (Tt2 >>> 26) | 0, Tt2 &= 67108863, d4 = Math.imul(Y4, fe), h = Math.imul(Y4, ne), h = h + Math.imul(J3, fe) | 0, b2 = Math.imul(J3, ne), d4 = d4 + Math.imul(G4, ae2) | 0, h = h + Math.imul(G4, se) | 0, h = h + Math.imul(X5, ae2) | 0, b2 = b2 + Math.imul(X5, se) | 0, d4 = d4 + Math.imul(V3, oe) | 0, h = h + Math.imul(V3, he2) | 0, h = h + Math.imul(Z5, oe) | 0, b2 = b2 + Math.imul(Z5, he2) | 0, d4 = d4 + Math.imul(j2, ue2) | 0, h = h + Math.imul(j2, de4) | 0, h = h + Math.imul(W4, ue2) | 0, b2 = b2 + Math.imul(W4, de4) | 0, d4 = d4 + Math.imul(F4, ce2) | 0, h = h + Math.imul(F4, le2) | 0, h = h + Math.imul(K4, ce2) | 0, b2 = b2 + Math.imul(K4, le2) | 0, d4 = d4 + Math.imul(U2, ve2) | 0, h = h + Math.imul(U2, pe) | 0, h = h + Math.imul(H3, ve2) | 0, b2 = b2 + Math.imul(H3, pe) | 0, d4 = d4 + Math.imul(O, be) | 0, h = h + Math.imul(O, me) | 0, h = h + Math.imul(z, be) | 0, b2 = b2 + Math.imul(z, me) | 0;
      var Ct2 = (l + d4 | 0) + ((h & 8191) << 13) | 0;
      l = (b2 + (h >>> 13) | 0) + (Ct2 >>> 26) | 0, Ct2 &= 67108863, d4 = Math.imul(Y4, ae2), h = Math.imul(Y4, se), h = h + Math.imul(J3, ae2) | 0, b2 = Math.imul(J3, se), d4 = d4 + Math.imul(G4, oe) | 0, h = h + Math.imul(G4, he2) | 0, h = h + Math.imul(X5, oe) | 0, b2 = b2 + Math.imul(X5, he2) | 0, d4 = d4 + Math.imul(V3, ue2) | 0, h = h + Math.imul(V3, de4) | 0, h = h + Math.imul(Z5, ue2) | 0, b2 = b2 + Math.imul(Z5, de4) | 0, d4 = d4 + Math.imul(j2, ce2) | 0, h = h + Math.imul(j2, le2) | 0, h = h + Math.imul(W4, ce2) | 0, b2 = b2 + Math.imul(W4, le2) | 0, d4 = d4 + Math.imul(F4, ve2) | 0, h = h + Math.imul(F4, pe) | 0, h = h + Math.imul(K4, ve2) | 0, b2 = b2 + Math.imul(K4, pe) | 0, d4 = d4 + Math.imul(U2, be) | 0, h = h + Math.imul(U2, me) | 0, h = h + Math.imul(H3, be) | 0, b2 = b2 + Math.imul(H3, me) | 0;
      var Nt2 = (l + d4 | 0) + ((h & 8191) << 13) | 0;
      l = (b2 + (h >>> 13) | 0) + (Nt2 >>> 26) | 0, Nt2 &= 67108863, d4 = Math.imul(Y4, oe), h = Math.imul(Y4, he2), h = h + Math.imul(J3, oe) | 0, b2 = Math.imul(J3, he2), d4 = d4 + Math.imul(G4, ue2) | 0, h = h + Math.imul(G4, de4) | 0, h = h + Math.imul(X5, ue2) | 0, b2 = b2 + Math.imul(X5, de4) | 0, d4 = d4 + Math.imul(V3, ce2) | 0, h = h + Math.imul(V3, le2) | 0, h = h + Math.imul(Z5, ce2) | 0, b2 = b2 + Math.imul(Z5, le2) | 0, d4 = d4 + Math.imul(j2, ve2) | 0, h = h + Math.imul(j2, pe) | 0, h = h + Math.imul(W4, ve2) | 0, b2 = b2 + Math.imul(W4, pe) | 0, d4 = d4 + Math.imul(F4, be) | 0, h = h + Math.imul(F4, me) | 0, h = h + Math.imul(K4, be) | 0, b2 = b2 + Math.imul(K4, me) | 0;
      var Lt2 = (l + d4 | 0) + ((h & 8191) << 13) | 0;
      l = (b2 + (h >>> 13) | 0) + (Lt2 >>> 26) | 0, Lt2 &= 67108863, d4 = Math.imul(Y4, ue2), h = Math.imul(Y4, de4), h = h + Math.imul(J3, ue2) | 0, b2 = Math.imul(J3, de4), d4 = d4 + Math.imul(G4, ce2) | 0, h = h + Math.imul(G4, le2) | 0, h = h + Math.imul(X5, ce2) | 0, b2 = b2 + Math.imul(X5, le2) | 0, d4 = d4 + Math.imul(V3, ve2) | 0, h = h + Math.imul(V3, pe) | 0, h = h + Math.imul(Z5, ve2) | 0, b2 = b2 + Math.imul(Z5, pe) | 0, d4 = d4 + Math.imul(j2, be) | 0, h = h + Math.imul(j2, me) | 0, h = h + Math.imul(W4, be) | 0, b2 = b2 + Math.imul(W4, me) | 0;
      var Ot = (l + d4 | 0) + ((h & 8191) << 13) | 0;
      l = (b2 + (h >>> 13) | 0) + (Ot >>> 26) | 0, Ot &= 67108863, d4 = Math.imul(Y4, ce2), h = Math.imul(Y4, le2), h = h + Math.imul(J3, ce2) | 0, b2 = Math.imul(J3, le2), d4 = d4 + Math.imul(G4, ve2) | 0, h = h + Math.imul(G4, pe) | 0, h = h + Math.imul(X5, ve2) | 0, b2 = b2 + Math.imul(X5, pe) | 0, d4 = d4 + Math.imul(V3, be) | 0, h = h + Math.imul(V3, me) | 0, h = h + Math.imul(Z5, be) | 0, b2 = b2 + Math.imul(Z5, me) | 0;
      var zt2 = (l + d4 | 0) + ((h & 8191) << 13) | 0;
      l = (b2 + (h >>> 13) | 0) + (zt2 >>> 26) | 0, zt2 &= 67108863, d4 = Math.imul(Y4, ve2), h = Math.imul(Y4, pe), h = h + Math.imul(J3, ve2) | 0, b2 = Math.imul(J3, pe), d4 = d4 + Math.imul(G4, be) | 0, h = h + Math.imul(G4, me) | 0, h = h + Math.imul(X5, be) | 0, b2 = b2 + Math.imul(X5, me) | 0;
      var Ut = (l + d4 | 0) + ((h & 8191) << 13) | 0;
      l = (b2 + (h >>> 13) | 0) + (Ut >>> 26) | 0, Ut &= 67108863, d4 = Math.imul(Y4, be), h = Math.imul(Y4, me), h = h + Math.imul(J3, be) | 0, b2 = Math.imul(J3, me);
      var Ht = (l + d4 | 0) + ((h & 8191) << 13) | 0;
      return l = (b2 + (h >>> 13) | 0) + (Ht >>> 26) | 0, Ht &= 67108863, u[0] = dr2, u[1] = _e2, u[2] = we2, u[3] = At2, u[4] = qt2, u[5] = Bt, u[6] = Rt2, u[7] = It2, u[8] = kt2, u[9] = Dt, u[10] = Pt2, u[11] = Tt2, u[12] = Ct2, u[13] = Nt2, u[14] = Lt2, u[15] = Ot, u[16] = zt2, u[17] = Ut, u[18] = Ht, l !== 0 && (u[19] = l, c5.length++), c5;
    };
    Math.imul || (D6 = I3);
    function C(S3, v2, _2) {
      _2.negative = v2.negative ^ S3.negative, _2.length = S3.length + v2.length;
      for (var c5 = 0, f = 0, a = 0; a < _2.length - 1; a++) {
        var u = f;
        f = 0;
        for (var l = c5 & 67108863, d4 = Math.min(a, v2.length - 1), h = Math.max(0, a - S3.length + 1); h <= d4; h++) {
          var b2 = a - h, m3 = S3.words[b2] | 0, s = v2.words[h] | 0, g2 = m3 * s, q = g2 & 67108863;
          u = u + (g2 / 67108864 | 0) | 0, q = q + l | 0, l = q & 67108863, u = u + (q >>> 26) | 0, f += u >>> 26, u &= 67108863;
        }
        _2.words[a] = l, c5 = u, u = f;
      }
      return c5 !== 0 ? _2.words[a] = c5 : _2.length--, _2.strip();
    }
    function ge2(S3, v2, _2) {
      var c5 = new L4();
      return c5.mulp(S3, v2, _2);
    }
    i.prototype.mulTo = function(v2, _2) {
      var c5, f = this.length + v2.length;
      return this.length === 10 && v2.length === 10 ? c5 = D6(this, v2, _2) : f < 63 ? c5 = I3(this, v2, _2) : f < 1024 ? c5 = C(this, v2, _2) : c5 = ge2(this, v2, _2), c5;
    };
    function L4(S3, v2) {
      this.x = S3, this.y = v2;
    }
    L4.prototype.makeRBT = function(v2) {
      for (var _2 = new Array(v2), c5 = i.prototype._countBits(v2) - 1, f = 0; f < v2; f++)
        _2[f] = this.revBin(f, c5, v2);
      return _2;
    }, L4.prototype.revBin = function(v2, _2, c5) {
      if (v2 === 0 || v2 === c5 - 1)
        return v2;
      for (var f = 0, a = 0; a < _2; a++)
        f |= (v2 & 1) << _2 - a - 1, v2 >>= 1;
      return f;
    }, L4.prototype.permute = function(v2, _2, c5, f, a, u) {
      for (var l = 0; l < u; l++)
        f[l] = _2[v2[l]], a[l] = c5[v2[l]];
    }, L4.prototype.transform = function(v2, _2, c5, f, a, u) {
      this.permute(u, v2, _2, c5, f, a);
      for (var l = 1; l < a; l <<= 1)
        for (var d4 = l << 1, h = Math.cos(2 * Math.PI / d4), b2 = Math.sin(2 * Math.PI / d4), m3 = 0; m3 < a; m3 += d4)
          for (var s = h, g2 = b2, q = 0; q < l; q++) {
            var R3 = c5[m3 + q], B3 = f[m3 + q], P2 = c5[m3 + q + l], T4 = f[m3 + q + l], N4 = s * P2 - g2 * T4;
            T4 = s * T4 + g2 * P2, P2 = N4, c5[m3 + q] = R3 + P2, f[m3 + q] = B3 + T4, c5[m3 + q + l] = R3 - P2, f[m3 + q + l] = B3 - T4, q !== d4 && (N4 = h * s - b2 * g2, g2 = h * g2 + b2 * s, s = N4);
          }
    }, L4.prototype.guessLen13b = function(v2, _2) {
      var c5 = Math.max(_2, v2) | 1, f = c5 & 1, a = 0;
      for (c5 = c5 / 2 | 0; c5; c5 = c5 >>> 1)
        a++;
      return 1 << a + 1 + f;
    }, L4.prototype.conjugate = function(v2, _2, c5) {
      if (!(c5 <= 1))
        for (var f = 0; f < c5 / 2; f++) {
          var a = v2[f];
          v2[f] = v2[c5 - f - 1], v2[c5 - f - 1] = a, a = _2[f], _2[f] = -_2[c5 - f - 1], _2[c5 - f - 1] = -a;
        }
    }, L4.prototype.normalize13b = function(v2, _2) {
      for (var c5 = 0, f = 0; f < _2 / 2; f++) {
        var a = Math.round(v2[2 * f + 1] / _2) * 8192 + Math.round(v2[2 * f] / _2) + c5;
        v2[f] = a & 67108863, a < 67108864 ? c5 = 0 : c5 = a / 67108864 | 0;
      }
      return v2;
    }, L4.prototype.convert13b = function(v2, _2, c5, f) {
      for (var a = 0, u = 0; u < _2; u++)
        a = a + (v2[u] | 0), c5[2 * u] = a & 8191, a = a >>> 13, c5[2 * u + 1] = a & 8191, a = a >>> 13;
      for (u = 2 * _2; u < f; ++u)
        c5[u] = 0;
      r(a === 0), r((a & -8192) === 0);
    }, L4.prototype.stub = function(v2) {
      for (var _2 = new Array(v2), c5 = 0; c5 < v2; c5++)
        _2[c5] = 0;
      return _2;
    }, L4.prototype.mulp = function(v2, _2, c5) {
      var f = 2 * this.guessLen13b(v2.length, _2.length), a = this.makeRBT(f), u = this.stub(f), l = new Array(f), d4 = new Array(f), h = new Array(f), b2 = new Array(f), m3 = new Array(f), s = new Array(f), g2 = c5.words;
      g2.length = f, this.convert13b(v2.words, v2.length, l, f), this.convert13b(_2.words, _2.length, b2, f), this.transform(l, u, d4, h, f, a), this.transform(b2, u, m3, s, f, a);
      for (var q = 0; q < f; q++) {
        var R3 = d4[q] * m3[q] - h[q] * s[q];
        h[q] = d4[q] * s[q] + h[q] * m3[q], d4[q] = R3;
      }
      return this.conjugate(d4, h, f), this.transform(d4, h, g2, u, f, a), this.conjugate(g2, u, f), this.normalize13b(g2, f), c5.negative = v2.negative ^ _2.negative, c5.length = v2.length + _2.length, c5.strip();
    }, i.prototype.mul = function(v2) {
      var _2 = new i(null);
      return _2.words = new Array(this.length + v2.length), this.mulTo(v2, _2);
    }, i.prototype.mulf = function(v2) {
      var _2 = new i(null);
      return _2.words = new Array(this.length + v2.length), ge2(this, v2, _2);
    }, i.prototype.imul = function(v2) {
      return this.clone().mulTo(v2, this);
    }, i.prototype.imuln = function(v2) {
      r(typeof v2 == "number"), r(v2 < 67108864);
      for (var _2 = 0, c5 = 0; c5 < this.length; c5++) {
        var f = (this.words[c5] | 0) * v2, a = (f & 67108863) + (_2 & 67108863);
        _2 >>= 26, _2 += f / 67108864 | 0, _2 += a >>> 26, this.words[c5] = a & 67108863;
      }
      return _2 !== 0 && (this.words[c5] = _2, this.length++), this;
    }, i.prototype.muln = function(v2) {
      return this.clone().imuln(v2);
    }, i.prototype.sqr = function() {
      return this.mul(this);
    }, i.prototype.isqr = function() {
      return this.imul(this.clone());
    }, i.prototype.pow = function(v2) {
      var _2 = A4(v2);
      if (_2.length === 0)
        return new i(1);
      for (var c5 = this, f = 0; f < _2.length && _2[f] === 0; f++, c5 = c5.sqr())
        ;
      if (++f < _2.length)
        for (var a = c5.sqr(); f < _2.length; f++, a = a.sqr())
          _2[f] !== 0 && (c5 = c5.mul(a));
      return c5;
    }, i.prototype.iushln = function(v2) {
      r(typeof v2 == "number" && v2 >= 0);
      var _2 = v2 % 26, c5 = (v2 - _2) / 26, f = 67108863 >>> 26 - _2 << 26 - _2, a;
      if (_2 !== 0) {
        var u = 0;
        for (a = 0; a < this.length; a++) {
          var l = this.words[a] & f, d4 = (this.words[a] | 0) - l << _2;
          this.words[a] = d4 | u, u = l >>> 26 - _2;
        }
        u && (this.words[a] = u, this.length++);
      }
      if (c5 !== 0) {
        for (a = this.length - 1; a >= 0; a--)
          this.words[a + c5] = this.words[a];
        for (a = 0; a < c5; a++)
          this.words[a] = 0;
        this.length += c5;
      }
      return this.strip();
    }, i.prototype.ishln = function(v2) {
      return r(this.negative === 0), this.iushln(v2);
    }, i.prototype.iushrn = function(v2, _2, c5) {
      r(typeof v2 == "number" && v2 >= 0);
      var f;
      _2 ? f = (_2 - _2 % 26) / 26 : f = 0;
      var a = v2 % 26, u = Math.min((v2 - a) / 26, this.length), l = 67108863 ^ 67108863 >>> a << a, d4 = c5;
      if (f -= u, f = Math.max(0, f), d4) {
        for (var h = 0; h < u; h++)
          d4.words[h] = this.words[h];
        d4.length = u;
      }
      if (u !== 0)
        if (this.length > u)
          for (this.length -= u, h = 0; h < this.length; h++)
            this.words[h] = this.words[h + u];
        else
          this.words[0] = 0, this.length = 1;
      var b2 = 0;
      for (h = this.length - 1; h >= 0 && (b2 !== 0 || h >= f); h--) {
        var m3 = this.words[h] | 0;
        this.words[h] = b2 << 26 - a | m3 >>> a, b2 = m3 & l;
      }
      return d4 && b2 !== 0 && (d4.words[d4.length++] = b2), this.length === 0 && (this.words[0] = 0, this.length = 1), this.strip();
    }, i.prototype.ishrn = function(v2, _2, c5) {
      return r(this.negative === 0), this.iushrn(v2, _2, c5);
    }, i.prototype.shln = function(v2) {
      return this.clone().ishln(v2);
    }, i.prototype.ushln = function(v2) {
      return this.clone().iushln(v2);
    }, i.prototype.shrn = function(v2) {
      return this.clone().ishrn(v2);
    }, i.prototype.ushrn = function(v2) {
      return this.clone().iushrn(v2);
    }, i.prototype.testn = function(v2) {
      r(typeof v2 == "number" && v2 >= 0);
      var _2 = v2 % 26, c5 = (v2 - _2) / 26, f = 1 << _2;
      if (this.length <= c5)
        return false;
      var a = this.words[c5];
      return !!(a & f);
    }, i.prototype.imaskn = function(v2) {
      r(typeof v2 == "number" && v2 >= 0);
      var _2 = v2 % 26, c5 = (v2 - _2) / 26;
      if (r(this.negative === 0, "imaskn works only with positive numbers"), this.length <= c5)
        return this;
      if (_2 !== 0 && c5++, this.length = Math.min(c5, this.length), _2 !== 0) {
        var f = 67108863 ^ 67108863 >>> _2 << _2;
        this.words[this.length - 1] &= f;
      }
      return this.strip();
    }, i.prototype.maskn = function(v2) {
      return this.clone().imaskn(v2);
    }, i.prototype.iaddn = function(v2) {
      return r(typeof v2 == "number"), r(v2 < 67108864), v2 < 0 ? this.isubn(-v2) : this.negative !== 0 ? this.length === 1 && (this.words[0] | 0) < v2 ? (this.words[0] = v2 - (this.words[0] | 0), this.negative = 0, this) : (this.negative = 0, this.isubn(v2), this.negative = 1, this) : this._iaddn(v2);
    }, i.prototype._iaddn = function(v2) {
      this.words[0] += v2;
      for (var _2 = 0; _2 < this.length && this.words[_2] >= 67108864; _2++)
        this.words[_2] -= 67108864, _2 === this.length - 1 ? this.words[_2 + 1] = 1 : this.words[_2 + 1]++;
      return this.length = Math.max(this.length, _2 + 1), this;
    }, i.prototype.isubn = function(v2) {
      if (r(typeof v2 == "number"), r(v2 < 67108864), v2 < 0)
        return this.iaddn(-v2);
      if (this.negative !== 0)
        return this.negative = 0, this.iaddn(v2), this.negative = 1, this;
      if (this.words[0] -= v2, this.length === 1 && this.words[0] < 0)
        this.words[0] = -this.words[0], this.negative = 1;
      else
        for (var _2 = 0; _2 < this.length && this.words[_2] < 0; _2++)
          this.words[_2] += 67108864, this.words[_2 + 1] -= 1;
      return this.strip();
    }, i.prototype.addn = function(v2) {
      return this.clone().iaddn(v2);
    }, i.prototype.subn = function(v2) {
      return this.clone().isubn(v2);
    }, i.prototype.iabs = function() {
      return this.negative = 0, this;
    }, i.prototype.abs = function() {
      return this.clone().iabs();
    }, i.prototype._ishlnsubmul = function(v2, _2, c5) {
      var f = v2.length + c5, a;
      this._expand(f);
      var u, l = 0;
      for (a = 0; a < v2.length; a++) {
        u = (this.words[a + c5] | 0) + l;
        var d4 = (v2.words[a] | 0) * _2;
        u -= d4 & 67108863, l = (u >> 26) - (d4 / 67108864 | 0), this.words[a + c5] = u & 67108863;
      }
      for (; a < this.length - c5; a++)
        u = (this.words[a + c5] | 0) + l, l = u >> 26, this.words[a + c5] = u & 67108863;
      if (l === 0)
        return this.strip();
      for (r(l === -1), l = 0, a = 0; a < this.length; a++)
        u = -(this.words[a] | 0) + l, l = u >> 26, this.words[a] = u & 67108863;
      return this.negative = 1, this.strip();
    }, i.prototype._wordDiv = function(v2, _2) {
      var c5 = this.length - v2.length, f = this.clone(), a = v2, u = a.words[a.length - 1] | 0, l = this._countBits(u);
      c5 = 26 - l, c5 !== 0 && (a = a.ushln(c5), f.iushln(c5), u = a.words[a.length - 1] | 0);
      var d4 = f.length - a.length, h;
      if (_2 !== "mod") {
        h = new i(null), h.length = d4 + 1, h.words = new Array(h.length);
        for (var b2 = 0; b2 < h.length; b2++)
          h.words[b2] = 0;
      }
      var m3 = f.clone()._ishlnsubmul(a, 1, d4);
      m3.negative === 0 && (f = m3, h && (h.words[d4] = 1));
      for (var s = d4 - 1; s >= 0; s--) {
        var g2 = (f.words[a.length + s] | 0) * 67108864 + (f.words[a.length + s - 1] | 0);
        for (g2 = Math.min(g2 / u | 0, 67108863), f._ishlnsubmul(a, g2, s); f.negative !== 0; )
          g2--, f.negative = 0, f._ishlnsubmul(a, 1, s), f.isZero() || (f.negative ^= 1);
        h && (h.words[s] = g2);
      }
      return h && h.strip(), f.strip(), _2 !== "div" && c5 !== 0 && f.iushrn(c5), { div: h || null, mod: f };
    }, i.prototype.divmod = function(v2, _2, c5) {
      if (r(!v2.isZero()), this.isZero())
        return { div: new i(0), mod: new i(0) };
      var f, a, u;
      return this.negative !== 0 && v2.negative === 0 ? (u = this.neg().divmod(v2, _2), _2 !== "mod" && (f = u.div.neg()), _2 !== "div" && (a = u.mod.neg(), c5 && a.negative !== 0 && a.iadd(v2)), { div: f, mod: a }) : this.negative === 0 && v2.negative !== 0 ? (u = this.divmod(v2.neg(), _2), _2 !== "mod" && (f = u.div.neg()), { div: f, mod: u.mod }) : (this.negative & v2.negative) !== 0 ? (u = this.neg().divmod(v2.neg(), _2), _2 !== "div" && (a = u.mod.neg(), c5 && a.negative !== 0 && a.isub(v2)), { div: u.div, mod: a }) : v2.length > this.length || this.cmp(v2) < 0 ? { div: new i(0), mod: this } : v2.length === 1 ? _2 === "div" ? { div: this.divn(v2.words[0]), mod: null } : _2 === "mod" ? { div: null, mod: new i(this.modn(v2.words[0])) } : { div: this.divn(v2.words[0]), mod: new i(this.modn(v2.words[0])) } : this._wordDiv(v2, _2);
    }, i.prototype.div = function(v2) {
      return this.divmod(v2, "div", false).div;
    }, i.prototype.mod = function(v2) {
      return this.divmod(v2, "mod", false).mod;
    }, i.prototype.umod = function(v2) {
      return this.divmod(v2, "mod", true).mod;
    }, i.prototype.divRound = function(v2) {
      var _2 = this.divmod(v2);
      if (_2.mod.isZero())
        return _2.div;
      var c5 = _2.div.negative !== 0 ? _2.mod.isub(v2) : _2.mod, f = v2.ushrn(1), a = v2.andln(1), u = c5.cmp(f);
      return u < 0 || a === 1 && u === 0 ? _2.div : _2.div.negative !== 0 ? _2.div.isubn(1) : _2.div.iaddn(1);
    }, i.prototype.modn = function(v2) {
      r(v2 <= 67108863);
      for (var _2 = (1 << 26) % v2, c5 = 0, f = this.length - 1; f >= 0; f--)
        c5 = (_2 * c5 + (this.words[f] | 0)) % v2;
      return c5;
    }, i.prototype.idivn = function(v2) {
      r(v2 <= 67108863);
      for (var _2 = 0, c5 = this.length - 1; c5 >= 0; c5--) {
        var f = (this.words[c5] | 0) + _2 * 67108864;
        this.words[c5] = f / v2 | 0, _2 = f % v2;
      }
      return this.strip();
    }, i.prototype.divn = function(v2) {
      return this.clone().idivn(v2);
    }, i.prototype.egcd = function(v2) {
      r(v2.negative === 0), r(!v2.isZero());
      var _2 = this, c5 = v2.clone();
      _2.negative !== 0 ? _2 = _2.umod(v2) : _2 = _2.clone();
      for (var f = new i(1), a = new i(0), u = new i(0), l = new i(1), d4 = 0; _2.isEven() && c5.isEven(); )
        _2.iushrn(1), c5.iushrn(1), ++d4;
      for (var h = c5.clone(), b2 = _2.clone(); !_2.isZero(); ) {
        for (var m3 = 0, s = 1; (_2.words[0] & s) === 0 && m3 < 26; ++m3, s <<= 1)
          ;
        if (m3 > 0)
          for (_2.iushrn(m3); m3-- > 0; )
            (f.isOdd() || a.isOdd()) && (f.iadd(h), a.isub(b2)), f.iushrn(1), a.iushrn(1);
        for (var g2 = 0, q = 1; (c5.words[0] & q) === 0 && g2 < 26; ++g2, q <<= 1)
          ;
        if (g2 > 0)
          for (c5.iushrn(g2); g2-- > 0; )
            (u.isOdd() || l.isOdd()) && (u.iadd(h), l.isub(b2)), u.iushrn(1), l.iushrn(1);
        _2.cmp(c5) >= 0 ? (_2.isub(c5), f.isub(u), a.isub(l)) : (c5.isub(_2), u.isub(f), l.isub(a));
      }
      return { a: u, b: l, gcd: c5.iushln(d4) };
    }, i.prototype._invmp = function(v2) {
      r(v2.negative === 0), r(!v2.isZero());
      var _2 = this, c5 = v2.clone();
      _2.negative !== 0 ? _2 = _2.umod(v2) : _2 = _2.clone();
      for (var f = new i(1), a = new i(0), u = c5.clone(); _2.cmpn(1) > 0 && c5.cmpn(1) > 0; ) {
        for (var l = 0, d4 = 1; (_2.words[0] & d4) === 0 && l < 26; ++l, d4 <<= 1)
          ;
        if (l > 0)
          for (_2.iushrn(l); l-- > 0; )
            f.isOdd() && f.iadd(u), f.iushrn(1);
        for (var h = 0, b2 = 1; (c5.words[0] & b2) === 0 && h < 26; ++h, b2 <<= 1)
          ;
        if (h > 0)
          for (c5.iushrn(h); h-- > 0; )
            a.isOdd() && a.iadd(u), a.iushrn(1);
        _2.cmp(c5) >= 0 ? (_2.isub(c5), f.isub(a)) : (c5.isub(_2), a.isub(f));
      }
      var m3;
      return _2.cmpn(1) === 0 ? m3 = f : m3 = a, m3.cmpn(0) < 0 && m3.iadd(v2), m3;
    }, i.prototype.gcd = function(v2) {
      if (this.isZero())
        return v2.abs();
      if (v2.isZero())
        return this.abs();
      var _2 = this.clone(), c5 = v2.clone();
      _2.negative = 0, c5.negative = 0;
      for (var f = 0; _2.isEven() && c5.isEven(); f++)
        _2.iushrn(1), c5.iushrn(1);
      do {
        for (; _2.isEven(); )
          _2.iushrn(1);
        for (; c5.isEven(); )
          c5.iushrn(1);
        var a = _2.cmp(c5);
        if (a < 0) {
          var u = _2;
          _2 = c5, c5 = u;
        } else if (a === 0 || c5.cmpn(1) === 0)
          break;
        _2.isub(c5);
      } while (true);
      return c5.iushln(f);
    }, i.prototype.invm = function(v2) {
      return this.egcd(v2).a.umod(v2);
    }, i.prototype.isEven = function() {
      return (this.words[0] & 1) === 0;
    }, i.prototype.isOdd = function() {
      return (this.words[0] & 1) === 1;
    }, i.prototype.andln = function(v2) {
      return this.words[0] & v2;
    }, i.prototype.bincn = function(v2) {
      r(typeof v2 == "number");
      var _2 = v2 % 26, c5 = (v2 - _2) / 26, f = 1 << _2;
      if (this.length <= c5)
        return this._expand(c5 + 1), this.words[c5] |= f, this;
      for (var a = f, u = c5; a !== 0 && u < this.length; u++) {
        var l = this.words[u] | 0;
        l += a, a = l >>> 26, l &= 67108863, this.words[u] = l;
      }
      return a !== 0 && (this.words[u] = a, this.length++), this;
    }, i.prototype.isZero = function() {
      return this.length === 1 && this.words[0] === 0;
    }, i.prototype.cmpn = function(v2) {
      var _2 = v2 < 0;
      if (this.negative !== 0 && !_2)
        return -1;
      if (this.negative === 0 && _2)
        return 1;
      this.strip();
      var c5;
      if (this.length > 1)
        c5 = 1;
      else {
        _2 && (v2 = -v2), r(v2 <= 67108863, "Number is too big");
        var f = this.words[0] | 0;
        c5 = f === v2 ? 0 : f < v2 ? -1 : 1;
      }
      return this.negative !== 0 ? -c5 | 0 : c5;
    }, i.prototype.cmp = function(v2) {
      if (this.negative !== 0 && v2.negative === 0)
        return -1;
      if (this.negative === 0 && v2.negative !== 0)
        return 1;
      var _2 = this.ucmp(v2);
      return this.negative !== 0 ? -_2 | 0 : _2;
    }, i.prototype.ucmp = function(v2) {
      if (this.length > v2.length)
        return 1;
      if (this.length < v2.length)
        return -1;
      for (var _2 = 0, c5 = this.length - 1; c5 >= 0; c5--) {
        var f = this.words[c5] | 0, a = v2.words[c5] | 0;
        if (f !== a) {
          f < a ? _2 = -1 : f > a && (_2 = 1);
          break;
        }
      }
      return _2;
    }, i.prototype.gtn = function(v2) {
      return this.cmpn(v2) === 1;
    }, i.prototype.gt = function(v2) {
      return this.cmp(v2) === 1;
    }, i.prototype.gten = function(v2) {
      return this.cmpn(v2) >= 0;
    }, i.prototype.gte = function(v2) {
      return this.cmp(v2) >= 0;
    }, i.prototype.ltn = function(v2) {
      return this.cmpn(v2) === -1;
    }, i.prototype.lt = function(v2) {
      return this.cmp(v2) === -1;
    }, i.prototype.lten = function(v2) {
      return this.cmpn(v2) <= 0;
    }, i.prototype.lte = function(v2) {
      return this.cmp(v2) <= 0;
    }, i.prototype.eqn = function(v2) {
      return this.cmpn(v2) === 0;
    }, i.prototype.eq = function(v2) {
      return this.cmp(v2) === 0;
    }, i.red = function(v2) {
      return new Ee2(v2);
    }, i.prototype.toRed = function(v2) {
      return r(!this.red, "Already a number in reduction context"), r(this.negative === 0, "red works only with positives"), v2.convertTo(this)._forceRed(v2);
    }, i.prototype.fromRed = function() {
      return r(this.red, "fromRed works only with numbers in reduction context"), this.red.convertFrom(this);
    }, i.prototype._forceRed = function(v2) {
      return this.red = v2, this;
    }, i.prototype.forceRed = function(v2) {
      return r(!this.red, "Already a number in reduction context"), this._forceRed(v2);
    }, i.prototype.redAdd = function(v2) {
      return r(this.red, "redAdd works only with red numbers"), this.red.add(this, v2);
    }, i.prototype.redIAdd = function(v2) {
      return r(this.red, "redIAdd works only with red numbers"), this.red.iadd(this, v2);
    }, i.prototype.redSub = function(v2) {
      return r(this.red, "redSub works only with red numbers"), this.red.sub(this, v2);
    }, i.prototype.redISub = function(v2) {
      return r(this.red, "redISub works only with red numbers"), this.red.isub(this, v2);
    }, i.prototype.redShl = function(v2) {
      return r(this.red, "redShl works only with red numbers"), this.red.shl(this, v2);
    }, i.prototype.redMul = function(v2) {
      return r(this.red, "redMul works only with red numbers"), this.red._verify2(this, v2), this.red.mul(this, v2);
    }, i.prototype.redIMul = function(v2) {
      return r(this.red, "redMul works only with red numbers"), this.red._verify2(this, v2), this.red.imul(this, v2);
    }, i.prototype.redSqr = function() {
      return r(this.red, "redSqr works only with red numbers"), this.red._verify1(this), this.red.sqr(this);
    }, i.prototype.redISqr = function() {
      return r(this.red, "redISqr works only with red numbers"), this.red._verify1(this), this.red.isqr(this);
    }, i.prototype.redSqrt = function() {
      return r(this.red, "redSqrt works only with red numbers"), this.red._verify1(this), this.red.sqrt(this);
    }, i.prototype.redInvm = function() {
      return r(this.red, "redInvm works only with red numbers"), this.red._verify1(this), this.red.invm(this);
    }, i.prototype.redNeg = function() {
      return r(this.red, "redNeg works only with red numbers"), this.red._verify1(this), this.red.neg(this);
    }, i.prototype.redPow = function(v2) {
      return r(this.red && !v2.red, "redPow(normalNum)"), this.red._verify1(this), this.red.pow(this, v2);
    };
    var ye = { k256: null, p224: null, p192: null, p25519: null };
    function Re(S3, v2) {
      this.name = S3, this.p = new i(v2, 16), this.n = this.p.bitLength(), this.k = new i(1).iushln(this.n).isub(this.p), this.tmp = this._tmp();
    }
    Re.prototype._tmp = function() {
      var v2 = new i(null);
      return v2.words = new Array(Math.ceil(this.n / 13)), v2;
    }, Re.prototype.ireduce = function(v2) {
      var _2 = v2, c5;
      do
        this.split(_2, this.tmp), _2 = this.imulK(_2), _2 = _2.iadd(this.tmp), c5 = _2.bitLength();
      while (c5 > this.n);
      var f = c5 < this.n ? -1 : _2.ucmp(this.p);
      return f === 0 ? (_2.words[0] = 0, _2.length = 1) : f > 0 ? _2.isub(this.p) : _2.strip !== void 0 ? _2.strip() : _2._strip(), _2;
    }, Re.prototype.split = function(v2, _2) {
      v2.iushrn(this.n, 0, _2);
    }, Re.prototype.imulK = function(v2) {
      return v2.imul(this.k);
    };
    function xe3() {
      Re.call(this, "k256", "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f");
    }
    n(xe3, Re), xe3.prototype.split = function(v2, _2) {
      for (var c5 = 4194303, f = Math.min(v2.length, 9), a = 0; a < f; a++)
        _2.words[a] = v2.words[a];
      if (_2.length = f, v2.length <= 9) {
        v2.words[0] = 0, v2.length = 1;
        return;
      }
      var u = v2.words[9];
      for (_2.words[_2.length++] = u & c5, a = 10; a < v2.length; a++) {
        var l = v2.words[a] | 0;
        v2.words[a - 10] = (l & c5) << 4 | u >>> 22, u = l;
      }
      u >>>= 22, v2.words[a - 10] = u, u === 0 && v2.length > 10 ? v2.length -= 10 : v2.length -= 9;
    }, xe3.prototype.imulK = function(v2) {
      v2.words[v2.length] = 0, v2.words[v2.length + 1] = 0, v2.length += 2;
      for (var _2 = 0, c5 = 0; c5 < v2.length; c5++) {
        var f = v2.words[c5] | 0;
        _2 += f * 977, v2.words[c5] = _2 & 67108863, _2 = f * 64 + (_2 / 67108864 | 0);
      }
      return v2.words[v2.length - 1] === 0 && (v2.length--, v2.words[v2.length - 1] === 0 && v2.length--), v2;
    };
    function ke() {
      Re.call(this, "p224", "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001");
    }
    n(ke, Re);
    function Me() {
      Re.call(this, "p192", "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff");
    }
    n(Me, Re);
    function Ce3() {
      Re.call(this, "25519", "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed");
    }
    n(Ce3, Re), Ce3.prototype.imulK = function(v2) {
      for (var _2 = 0, c5 = 0; c5 < v2.length; c5++) {
        var f = (v2.words[c5] | 0) * 19 + _2, a = f & 67108863;
        f >>>= 26, v2.words[c5] = a, _2 = f;
      }
      return _2 !== 0 && (v2.words[v2.length++] = _2), v2;
    }, i._prime = function(v2) {
      if (ye[v2])
        return ye[v2];
      var _2;
      if (v2 === "k256")
        _2 = new xe3();
      else if (v2 === "p224")
        _2 = new ke();
      else if (v2 === "p192")
        _2 = new Me();
      else if (v2 === "p25519")
        _2 = new Ce3();
      else
        throw new Error("Unknown prime " + v2);
      return ye[v2] = _2, _2;
    };
    function Ee2(S3) {
      if (typeof S3 == "string") {
        var v2 = i._prime(S3);
        this.m = v2.p, this.prime = v2;
      } else
        r(S3.gtn(1), "modulus must be greater than 1"), this.m = S3, this.prime = null;
    }
    Ee2.prototype._verify1 = function(v2) {
      r(v2.negative === 0, "red works only with positives"), r(v2.red, "red works only with red numbers");
    }, Ee2.prototype._verify2 = function(v2, _2) {
      r((v2.negative | _2.negative) === 0, "red works only with positives"), r(v2.red && v2.red === _2.red, "red works only with red numbers");
    }, Ee2.prototype.imod = function(v2) {
      return this.prime ? this.prime.ireduce(v2)._forceRed(this) : v2.umod(this.m)._forceRed(this);
    }, Ee2.prototype.neg = function(v2) {
      return v2.isZero() ? v2.clone() : this.m.sub(v2)._forceRed(this);
    }, Ee2.prototype.add = function(v2, _2) {
      this._verify2(v2, _2);
      var c5 = v2.add(_2);
      return c5.cmp(this.m) >= 0 && c5.isub(this.m), c5._forceRed(this);
    }, Ee2.prototype.iadd = function(v2, _2) {
      this._verify2(v2, _2);
      var c5 = v2.iadd(_2);
      return c5.cmp(this.m) >= 0 && c5.isub(this.m), c5;
    }, Ee2.prototype.sub = function(v2, _2) {
      this._verify2(v2, _2);
      var c5 = v2.sub(_2);
      return c5.cmpn(0) < 0 && c5.iadd(this.m), c5._forceRed(this);
    }, Ee2.prototype.isub = function(v2, _2) {
      this._verify2(v2, _2);
      var c5 = v2.isub(_2);
      return c5.cmpn(0) < 0 && c5.iadd(this.m), c5;
    }, Ee2.prototype.shl = function(v2, _2) {
      return this._verify1(v2), this.imod(v2.ushln(_2));
    }, Ee2.prototype.imul = function(v2, _2) {
      return this._verify2(v2, _2), this.imod(v2.imul(_2));
    }, Ee2.prototype.mul = function(v2, _2) {
      return this._verify2(v2, _2), this.imod(v2.mul(_2));
    }, Ee2.prototype.isqr = function(v2) {
      return this.imul(v2, v2.clone());
    }, Ee2.prototype.sqr = function(v2) {
      return this.mul(v2, v2);
    }, Ee2.prototype.sqrt = function(v2) {
      if (v2.isZero())
        return v2.clone();
      var _2 = this.m.andln(3);
      if (r(_2 % 2 === 1), _2 === 3) {
        var c5 = this.m.add(new i(1)).iushrn(2);
        return this.pow(v2, c5);
      }
      for (var f = this.m.subn(1), a = 0; !f.isZero() && f.andln(1) === 0; )
        a++, f.iushrn(1);
      r(!f.isZero());
      var u = new i(1).toRed(this), l = u.redNeg(), d4 = this.m.subn(1).iushrn(1), h = this.m.bitLength();
      for (h = new i(2 * h * h).toRed(this); this.pow(h, d4).cmp(l) !== 0; )
        h.redIAdd(l);
      for (var b2 = this.pow(h, f), m3 = this.pow(v2, f.addn(1).iushrn(1)), s = this.pow(v2, f), g2 = a; s.cmp(u) !== 0; ) {
        for (var q = s, R3 = 0; q.cmp(u) !== 0; R3++)
          q = q.redSqr();
        r(R3 < g2);
        var B3 = this.pow(b2, new i(1).iushln(g2 - R3 - 1));
        m3 = m3.redMul(B3), b2 = B3.redSqr(), s = s.redMul(b2), g2 = R3;
      }
      return m3;
    }, Ee2.prototype.invm = function(v2) {
      var _2 = v2._invmp(this.m);
      return _2.negative !== 0 ? (_2.negative = 0, this.imod(_2).redNeg()) : this.imod(_2);
    }, Ee2.prototype.pow = function(v2, _2) {
      if (_2.isZero())
        return new i(1).toRed(this);
      if (_2.cmpn(1) === 0)
        return v2.clone();
      var c5 = 4, f = new Array(1 << c5);
      f[0] = new i(1).toRed(this), f[1] = v2;
      for (var a = 2; a < f.length; a++)
        f[a] = this.mul(f[a - 1], v2);
      var u = f[0], l = 0, d4 = 0, h = _2.bitLength() % 26;
      for (h === 0 && (h = 26), a = _2.length - 1; a >= 0; a--) {
        for (var b2 = _2.words[a], m3 = h - 1; m3 >= 0; m3--) {
          var s = b2 >> m3 & 1;
          if (u !== f[0] && (u = this.sqr(u)), s === 0 && l === 0) {
            d4 = 0;
            continue;
          }
          l <<= 1, l |= s, d4++, !(d4 !== c5 && (a !== 0 || m3 !== 0)) && (u = this.mul(u, f[l]), d4 = 0, l = 0);
        }
        h = 26;
      }
      return u;
    }, Ee2.prototype.convertTo = function(v2) {
      var _2 = v2.umod(this.m);
      return _2 === v2 ? _2.clone() : _2;
    }, Ee2.prototype.convertFrom = function(v2) {
      var _2 = v2.clone();
      return _2.red = null, _2;
    }, i.mont = function(v2) {
      return new Ne3(v2);
    };
    function Ne3(S3) {
      Ee2.call(this, S3), this.shift = this.m.bitLength(), this.shift % 26 !== 0 && (this.shift += 26 - this.shift % 26), this.r = new i(1).iushln(this.shift), this.r2 = this.imod(this.r.sqr()), this.rinv = this.r._invmp(this.m), this.minv = this.rinv.mul(this.r).isubn(1).div(this.m), this.minv = this.minv.umod(this.r), this.minv = this.r.sub(this.minv);
    }
    n(Ne3, Ee2), Ne3.prototype.convertTo = function(v2) {
      return this.imod(v2.ushln(this.shift));
    }, Ne3.prototype.convertFrom = function(v2) {
      var _2 = this.imod(v2.mul(this.rinv));
      return _2.red = null, _2;
    }, Ne3.prototype.imul = function(v2, _2) {
      if (v2.isZero() || _2.isZero())
        return v2.words[0] = 0, v2.length = 1, v2;
      var c5 = v2.imul(_2), f = c5.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), a = c5.isub(f).iushrn(this.shift), u = a;
      return a.cmp(this.m) >= 0 ? u = a.isub(this.m) : a.cmpn(0) < 0 && (u = a.iadd(this.m)), u._forceRed(this);
    }, Ne3.prototype.mul = function(v2, _2) {
      if (v2.isZero() || _2.isZero())
        return new i(0)._forceRed(this);
      var c5 = v2.mul(_2), f = c5.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), a = c5.isub(f).iushrn(this.shift), u = a;
      return a.cmp(this.m) >= 0 ? u = a.isub(this.m) : a.cmpn(0) < 0 && (u = a.iadd(this.m)), u._forceRed(this);
    }, Ne3.prototype.invm = function(v2) {
      var _2 = this.imod(v2._invmp(this.m).mul(this.r2));
      return _2._forceRed(this);
    };
  })(typeof I0 == "undefined" || I0, Ju);
});
var On2 = k4((fm, P0) => {
  var k0;
  P0.exports = function(e) {
    return k0 || (k0 = new Gr2(null)), k0.generate(e);
  };
  function Gr2(t) {
    this.rand = t;
  }
  P0.exports.Rand = Gr2;
  Gr2.prototype.generate = function(e) {
    return this._rand(e);
  };
  Gr2.prototype._rand = function(e) {
    if (this.rand.getBytes)
      return this.rand.getBytes(e);
    for (var r = new Uint8Array(e), n = 0; n < r.length; n++)
      r[n] = this.rand.getByte();
    return r;
  };
  if (typeof self == "object")
    self.crypto && self.crypto.getRandomValues ? Gr2.prototype._rand = function(e) {
      var r = new Uint8Array(e);
      return self.crypto.getRandomValues(r), r;
    } : self.msCrypto && self.msCrypto.getRandomValues ? Gr2.prototype._rand = function(e) {
      var r = new Uint8Array(e);
      return self.msCrypto.getRandomValues(r), r;
    } : typeof window == "object" && (Gr2.prototype._rand = function() {
      throw new Error("Not implemented yet");
    });
  else
    try {
      if (D0 = h9, typeof D0.randomBytes != "function")
        throw new Error("Not supported");
      Gr2.prototype._rand = function(e) {
        return D0.randomBytes(e);
      };
    } catch {
    }
  var D0;
});
var T02 = k4((nm, $u) => {
  var yi = Fe2(), Cb = On2();
  function _i(t) {
    this.rand = t || new Cb.Rand();
  }
  $u.exports = _i;
  _i.create = function(e) {
    return new _i(e);
  };
  _i.prototype._randbelow = function(e) {
    var r = e.bitLength(), n = Math.ceil(r / 8);
    do
      var i = new yi(this.rand.generate(n));
    while (i.cmp(e) >= 0);
    return i;
  };
  _i.prototype._randrange = function(e, r) {
    var n = r.sub(e);
    return e.add(this._randbelow(n));
  };
  _i.prototype.test = function(e, r, n) {
    var i = e.bitLength(), o2 = yi.mont(e), p3 = new yi(1).toRed(o2);
    r || (r = Math.max(1, i / 48 | 0));
    for (var y4 = e.subn(1), w2 = 0; !y4.testn(w2); w2++)
      ;
    for (var x = e.shrn(w2), M4 = y4.toRed(o2), E2 = true; r > 0; r--) {
      var A4 = this._randrange(new yi(2), y4);
      n && n(A4);
      var I3 = A4.toRed(o2).redPow(x);
      if (!(I3.cmp(p3) === 0 || I3.cmp(M4) === 0)) {
        for (var D6 = 1; D6 < w2; D6++) {
          if (I3 = I3.redSqr(), I3.cmp(p3) === 0)
            return false;
          if (I3.cmp(M4) === 0)
            break;
        }
        if (D6 === w2)
          return false;
      }
    }
    return E2;
  };
  _i.prototype.getDivisor = function(e, r) {
    var n = e.bitLength(), i = yi.mont(e), o2 = new yi(1).toRed(i);
    r || (r = Math.max(1, n / 48 | 0));
    for (var p3 = e.subn(1), y4 = 0; !p3.testn(y4); y4++)
      ;
    for (var w2 = e.shrn(y4), x = p3.toRed(i); r > 0; r--) {
      var M4 = this._randrange(new yi(2), p3), E2 = e.gcd(M4);
      if (E2.cmpn(1) !== 0)
        return E2;
      var A4 = M4.toRed(i).redPow(w2);
      if (!(A4.cmp(o2) === 0 || A4.cmp(x) === 0)) {
        for (var I3 = 1; I3 < y4; I3++) {
          if (A4 = A4.redSqr(), A4.cmp(o2) === 0)
            return A4.fromRed().subn(1).gcd(e);
          if (A4.cmp(x) === 0)
            break;
        }
        if (I3 === y4)
          return A4 = A4.redSqr(), A4.fromRed().subn(1).gcd(e);
      }
    }
    return false;
  };
});
var U02 = k4((um, td) => {
  var Nb = fi2();
  td.exports = z0;
  z0.simpleSieve = L0;
  z0.fermatTest = O0;
  var Ge2 = Fe2(), Lb = new Ge2(24), Ob = T02(), Qu = new Ob(), zb = new Ge2(1), N0 = new Ge2(2), Ub = new Ge2(5), am = new Ge2(16), sm = new Ge2(8), Hb = new Ge2(10), Fb = new Ge2(3), om = new Ge2(7), Kb = new Ge2(11), ed = new Ge2(4), hm = new Ge2(12), C0 = null;
  function jb() {
    if (C0 !== null)
      return C0;
    var t = 1048576, e = [];
    e[0] = 2;
    for (var r = 1, n = 3; n < t; n += 2) {
      for (var i = Math.ceil(Math.sqrt(n)), o2 = 0; o2 < r && e[o2] <= i && n % e[o2] !== 0; o2++)
        ;
      r !== o2 && e[o2] <= i || (e[r++] = n);
    }
    return C0 = e, e;
  }
  function L0(t) {
    for (var e = jb(), r = 0; r < e.length; r++)
      if (t.modn(e[r]) === 0)
        return t.cmpn(e[r]) === 0;
    return true;
  }
  function O0(t) {
    var e = Ge2.mont(t);
    return N0.toRed(e).redPow(t.subn(1)).fromRed().cmpn(1) === 0;
  }
  function z0(t, e) {
    if (t < 16)
      return e === 2 || e === 5 ? new Ge2([140, 123]) : new Ge2([140, 39]);
    e = new Ge2(e);
    for (var r, n; ; ) {
      for (r = new Ge2(Nb(Math.ceil(t / 8))); r.bitLength() > t; )
        r.ishrn(1);
      if (r.isEven() && r.iadd(zb), r.testn(1) || r.iadd(N0), e.cmp(N0)) {
        if (!e.cmp(Ub))
          for (; r.mod(Hb).cmp(Fb); )
            r.iadd(ed);
      } else
        for (; r.mod(Lb).cmp(Kb); )
          r.iadd(ed);
      if (n = r.shrn(1), L0(n) && L0(r) && O0(n) && O0(r) && Qu.test(n) && Qu.test(r))
        return r;
    }
  }
});
var rd2 = k4((dm, Wb) => {
  Wb.exports = { modp1: { gen: "02", prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a63a3620ffffffffffffffff" }, modp2: { gen: "02", prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece65381ffffffffffffffff" }, modp5: { gen: "02", prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca237327ffffffffffffffff" }, modp14: { gen: "02", prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aacaa68ffffffffffffffff" }, modp15: { gen: "02", prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a93ad2caffffffffffffffff" }, modp16: { gen: "02", prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a92108011a723c12a787e6d788719a10bdba5b2699c327186af4e23c1a946834b6150bda2583e9ca2ad44ce8dbbbc2db04de8ef92e8efc141fbecaa6287c59474e6bc05d99b2964fa090c3a2233ba186515be7ed1f612970cee2d7afb81bdd762170481cd0069127d5b05aa993b4ea988d8fddc186ffb7dc90a6c08f4df435c934063199ffffffffffffffff" }, modp17: { gen: "02", prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a92108011a723c12a787e6d788719a10bdba5b2699c327186af4e23c1a946834b6150bda2583e9ca2ad44ce8dbbbc2db04de8ef92e8efc141fbecaa6287c59474e6bc05d99b2964fa090c3a2233ba186515be7ed1f612970cee2d7afb81bdd762170481cd0069127d5b05aa993b4ea988d8fddc186ffb7dc90a6c08f4df435c93402849236c3fab4d27c7026c1d4dcb2602646dec9751e763dba37bdf8ff9406ad9e530ee5db382f413001aeb06a53ed9027d831179727b0865a8918da3edbebcf9b14ed44ce6cbaced4bb1bdb7f1447e6cc254b332051512bd7af426fb8f401378cd2bf5983ca01c64b92ecf032ea15d1721d03f482d7ce6e74fef6d55e702f46980c82b5a84031900b1c9e59e7c97fbec7e8f323a97a7e36cc88be0f1d45b7ff585ac54bd407b22b4154aacc8f6d7ebf48e1d814cc5ed20f8037e0a79715eef29be32806a1d58bb7c5da76f550aa3d8a1fbff0eb19ccb1a313d55cda56c9ec2ef29632387fe8d76e3c0468043e8f663f4860ee12bf2d5b0b7474d6e694f91e6dcc4024ffffffffffffffff" }, modp18: { gen: "02", prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a92108011a723c12a787e6d788719a10bdba5b2699c327186af4e23c1a946834b6150bda2583e9ca2ad44ce8dbbbc2db04de8ef92e8efc141fbecaa6287c59474e6bc05d99b2964fa090c3a2233ba186515be7ed1f612970cee2d7afb81bdd762170481cd0069127d5b05aa993b4ea988d8fddc186ffb7dc90a6c08f4df435c93402849236c3fab4d27c7026c1d4dcb2602646dec9751e763dba37bdf8ff9406ad9e530ee5db382f413001aeb06a53ed9027d831179727b0865a8918da3edbebcf9b14ed44ce6cbaced4bb1bdb7f1447e6cc254b332051512bd7af426fb8f401378cd2bf5983ca01c64b92ecf032ea15d1721d03f482d7ce6e74fef6d55e702f46980c82b5a84031900b1c9e59e7c97fbec7e8f323a97a7e36cc88be0f1d45b7ff585ac54bd407b22b4154aacc8f6d7ebf48e1d814cc5ed20f8037e0a79715eef29be32806a1d58bb7c5da76f550aa3d8a1fbff0eb19ccb1a313d55cda56c9ec2ef29632387fe8d76e3c0468043e8f663f4860ee12bf2d5b0b7474d6e694f91e6dbe115974a3926f12fee5e438777cb6a932df8cd8bec4d073b931ba3bc832b68d9dd300741fa7bf8afc47ed2576f6936ba424663aab639c5ae4f5683423b4742bf1c978238f16cbe39d652de3fdb8befc848ad922222e04a4037c0713eb57a81a23f0c73473fc646cea306b4bcbc8862f8385ddfa9d4b7fa2c087e879683303ed5bdd3a062b3cf5b3a278a66d2a13f83f44f82ddf310ee074ab6a364597e899a0255dc164f31cc50846851df9ab48195ded7ea1b1d510bd7ee74d73faf36bc31ecfa268359046f4eb879f924009438b481c6cd7889a002ed5ee382bc9190da6fc026e479558e4475677e9aa9e3050e2765694dfc81f56e880b96e7160c980dd98edd3dfffffffffffffffff" } };
});
var ad2 = k4((cm, nd) => {
  var mt = Fe2(), Vb = T02(), id = new Vb(), Zb = new mt(24), Gb = new mt(11), Xb = new mt(10), Yb = new mt(3), Jb = new mt(7), fd = U02(), $b = fi2();
  nd.exports = yr2;
  function Qb(t, e) {
    return e = e || "utf8", ut.isBuffer(t) || (t = new ut(t, e)), this._pub = new mt(t), this;
  }
  function e6(t, e) {
    return e = e || "utf8", ut.isBuffer(t) || (t = new ut(t, e)), this._priv = new mt(t), this;
  }
  var zn = {};
  function t6(t, e) {
    var r = e.toString("hex"), n = [r, t.toString(16)].join("_");
    if (n in zn)
      return zn[n];
    var i = 0;
    if (t.isEven() || !fd.simpleSieve || !fd.fermatTest(t) || !id.test(t))
      return i += 1, r === "02" || r === "05" ? i += 8 : i += 4, zn[n] = i, i;
    id.test(t.shrn(1)) || (i += 2);
    var o2;
    switch (r) {
      case "02":
        t.mod(Zb).cmp(Gb) && (i += 8);
        break;
      case "05":
        o2 = t.mod(Xb), o2.cmp(Yb) && o2.cmp(Jb) && (i += 8);
        break;
      default:
        i += 4;
    }
    return zn[n] = i, i;
  }
  function yr2(t, e, r) {
    this.setGenerator(e), this.__prime = new mt(t), this._prime = mt.mont(this.__prime), this._primeLen = t.length, this._pub = void 0, this._priv = void 0, this._primeCode = void 0, r ? (this.setPublicKey = Qb, this.setPrivateKey = e6) : this._primeCode = 8;
  }
  Object.defineProperty(yr2.prototype, "verifyError", { enumerable: true, get: function() {
    return typeof this._primeCode != "number" && (this._primeCode = t6(this.__prime, this.__gen)), this._primeCode;
  } });
  yr2.prototype.generateKeys = function() {
    return this._priv || (this._priv = new mt($b(this._primeLen))), this._pub = this._gen.toRed(this._prime).redPow(this._priv).fromRed(), this.getPublicKey();
  };
  yr2.prototype.computeSecret = function(t) {
    t = new mt(t), t = t.toRed(this._prime);
    var e = t.redPow(this._priv).fromRed(), r = new ut(e.toArray()), n = this.getPrime();
    if (r.length < n.length) {
      var i = new ut(n.length - r.length);
      i.fill(0), r = ut.concat([i, r]);
    }
    return r;
  };
  yr2.prototype.getPublicKey = function(e) {
    return Un(this._pub, e);
  };
  yr2.prototype.getPrivateKey = function(e) {
    return Un(this._priv, e);
  };
  yr2.prototype.getPrime = function(t) {
    return Un(this.__prime, t);
  };
  yr2.prototype.getGenerator = function(t) {
    return Un(this._gen, t);
  };
  yr2.prototype.setGenerator = function(t, e) {
    return e = e || "utf8", ut.isBuffer(t) || (t = new ut(t, e)), this.__gen = t, this._gen = new mt(t), this;
  };
  function Un(t, e) {
    var r = new ut(t.toArray());
    return e ? r.toString(e) : r;
  }
});
var hd2 = k4((Fi) => {
  var r6 = U02(), sd = rd2(), H0 = ad2();
  function i6(t) {
    var e = new ut(sd[t].prime, "hex"), r = new ut(sd[t].gen, "hex");
    return new H0(e, r);
  }
  var f6 = { binary: true, hex: true, base64: true };
  function od(t, e, r, n) {
    return ut.isBuffer(e) || f6[e] === void 0 ? od(t, "binary", e, r) : (e = e || "binary", n = n || "binary", r = r || new ut([2]), ut.isBuffer(r) || (r = new ut(r, n)), typeof t == "number" ? new H0(r6(t, r), r, true) : (ut.isBuffer(t) || (t = new ut(t, e)), new H0(t, r, true)));
  }
  Fi.DiffieHellmanGroup = Fi.createDiffieHellmanGroup = Fi.getDiffieHellman = i6;
  Fi.createDiffieHellman = Fi.DiffieHellman = od;
});
var dd2 = k4((ud, F0) => {
  (function(t, e) {
    "use strict";
    function r(c5, f) {
      if (!c5)
        throw new Error(f || "Assertion failed");
    }
    function n(c5, f) {
      c5.super_ = f;
      var a = function() {
      };
      a.prototype = f.prototype, c5.prototype = new a(), c5.prototype.constructor = c5;
    }
    function i(c5, f, a) {
      if (i.isBN(c5))
        return c5;
      this.negative = 0, this.words = null, this.length = 0, this.red = null, c5 !== null && ((f === "le" || f === "be") && (a = f, f = 10), this._init(c5 || 0, f || 10, a || "be"));
    }
    typeof t == "object" ? t.exports = i : e.BN = i, i.BN = i, i.wordSize = 26;
    var o2;
    try {
      typeof window != "undefined" && typeof window.Buffer != "undefined" ? o2 = window.Buffer : o2 = export_default.Buffer;
    } catch {
    }
    i.isBN = function(f) {
      return f instanceof i ? true : f !== null && typeof f == "object" && f.constructor.wordSize === i.wordSize && Array.isArray(f.words);
    }, i.max = function(f, a) {
      return f.cmp(a) > 0 ? f : a;
    }, i.min = function(f, a) {
      return f.cmp(a) < 0 ? f : a;
    }, i.prototype._init = function(f, a, u) {
      if (typeof f == "number")
        return this._initNumber(f, a, u);
      if (typeof f == "object")
        return this._initArray(f, a, u);
      a === "hex" && (a = 16), r(a === (a | 0) && a >= 2 && a <= 36), f = f.toString().replace(/\s+/g, "");
      var l = 0;
      f[0] === "-" && (l++, this.negative = 1), l < f.length && (a === 16 ? this._parseHex(f, l, u) : (this._parseBase(f, a, l), u === "le" && this._initArray(this.toArray(), a, u)));
    }, i.prototype._initNumber = function(f, a, u) {
      f < 0 && (this.negative = 1, f = -f), f < 67108864 ? (this.words = [f & 67108863], this.length = 1) : f < 4503599627370496 ? (this.words = [f & 67108863, f / 67108864 & 67108863], this.length = 2) : (r(f < 9007199254740992), this.words = [f & 67108863, f / 67108864 & 67108863, 1], this.length = 3), u === "le" && this._initArray(this.toArray(), a, u);
    }, i.prototype._initArray = function(f, a, u) {
      if (r(typeof f.length == "number"), f.length <= 0)
        return this.words = [0], this.length = 1, this;
      this.length = Math.ceil(f.length / 3), this.words = new Array(this.length);
      for (var l = 0; l < this.length; l++)
        this.words[l] = 0;
      var d4, h, b2 = 0;
      if (u === "be")
        for (l = f.length - 1, d4 = 0; l >= 0; l -= 3)
          h = f[l] | f[l - 1] << 8 | f[l - 2] << 16, this.words[d4] |= h << b2 & 67108863, this.words[d4 + 1] = h >>> 26 - b2 & 67108863, b2 += 24, b2 >= 26 && (b2 -= 26, d4++);
      else if (u === "le")
        for (l = 0, d4 = 0; l < f.length; l += 3)
          h = f[l] | f[l + 1] << 8 | f[l + 2] << 16, this.words[d4] |= h << b2 & 67108863, this.words[d4 + 1] = h >>> 26 - b2 & 67108863, b2 += 24, b2 >= 26 && (b2 -= 26, d4++);
      return this._strip();
    };
    function p3(c5, f) {
      var a = c5.charCodeAt(f);
      if (a >= 48 && a <= 57)
        return a - 48;
      if (a >= 65 && a <= 70)
        return a - 55;
      if (a >= 97 && a <= 102)
        return a - 87;
      r(false, "Invalid character in " + c5);
    }
    function y4(c5, f, a) {
      var u = p3(c5, a);
      return a - 1 >= f && (u |= p3(c5, a - 1) << 4), u;
    }
    i.prototype._parseHex = function(f, a, u) {
      this.length = Math.ceil((f.length - a) / 6), this.words = new Array(this.length);
      for (var l = 0; l < this.length; l++)
        this.words[l] = 0;
      var d4 = 0, h = 0, b2;
      if (u === "be")
        for (l = f.length - 1; l >= a; l -= 2)
          b2 = y4(f, a, l) << d4, this.words[h] |= b2 & 67108863, d4 >= 18 ? (d4 -= 18, h += 1, this.words[h] |= b2 >>> 26) : d4 += 8;
      else {
        var m3 = f.length - a;
        for (l = m3 % 2 === 0 ? a + 1 : a; l < f.length; l += 2)
          b2 = y4(f, a, l) << d4, this.words[h] |= b2 & 67108863, d4 >= 18 ? (d4 -= 18, h += 1, this.words[h] |= b2 >>> 26) : d4 += 8;
      }
      this._strip();
    };
    function w2(c5, f, a, u) {
      for (var l = 0, d4 = 0, h = Math.min(c5.length, a), b2 = f; b2 < h; b2++) {
        var m3 = c5.charCodeAt(b2) - 48;
        l *= u, m3 >= 49 ? d4 = m3 - 49 + 10 : m3 >= 17 ? d4 = m3 - 17 + 10 : d4 = m3, r(m3 >= 0 && d4 < u, "Invalid character"), l += d4;
      }
      return l;
    }
    i.prototype._parseBase = function(f, a, u) {
      this.words = [0], this.length = 1;
      for (var l = 0, d4 = 1; d4 <= 67108863; d4 *= a)
        l++;
      l--, d4 = d4 / a | 0;
      for (var h = f.length - u, b2 = h % l, m3 = Math.min(h, h - b2) + u, s = 0, g2 = u; g2 < m3; g2 += l)
        s = w2(f, g2, g2 + l, a), this.imuln(d4), this.words[0] + s < 67108864 ? this.words[0] += s : this._iaddn(s);
      if (b2 !== 0) {
        var q = 1;
        for (s = w2(f, g2, f.length, a), g2 = 0; g2 < b2; g2++)
          q *= a;
        this.imuln(q), this.words[0] + s < 67108864 ? this.words[0] += s : this._iaddn(s);
      }
      this._strip();
    }, i.prototype.copy = function(f) {
      f.words = new Array(this.length);
      for (var a = 0; a < this.length; a++)
        f.words[a] = this.words[a];
      f.length = this.length, f.negative = this.negative, f.red = this.red;
    };
    function x(c5, f) {
      c5.words = f.words, c5.length = f.length, c5.negative = f.negative, c5.red = f.red;
    }
    if (i.prototype._move = function(f) {
      x(f, this);
    }, i.prototype.clone = function() {
      var f = new i(null);
      return this.copy(f), f;
    }, i.prototype._expand = function(f) {
      for (; this.length < f; )
        this.words[this.length++] = 0;
      return this;
    }, i.prototype._strip = function() {
      for (; this.length > 1 && this.words[this.length - 1] === 0; )
        this.length--;
      return this._normSign();
    }, i.prototype._normSign = function() {
      return this.length === 1 && this.words[0] === 0 && (this.negative = 0), this;
    }, typeof Symbol != "undefined" && typeof Symbol.for == "function")
      try {
        i.prototype[Symbol.for("nodejs.util.inspect.custom")] = M4;
      } catch {
        i.prototype.inspect = M4;
      }
    else
      i.prototype.inspect = M4;
    function M4() {
      return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
    }
    var E2 = ["", "0", "00", "000", "0000", "00000", "000000", "0000000", "00000000", "000000000", "0000000000", "00000000000", "000000000000", "0000000000000", "00000000000000", "000000000000000", "0000000000000000", "00000000000000000", "000000000000000000", "0000000000000000000", "00000000000000000000", "000000000000000000000", "0000000000000000000000", "00000000000000000000000", "000000000000000000000000", "0000000000000000000000000"], A4 = [0, 0, 25, 16, 12, 11, 10, 9, 8, 8, 7, 7, 7, 7, 6, 6, 6, 6, 6, 6, 6, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5], I3 = [0, 0, 33554432, 43046721, 16777216, 48828125, 60466176, 40353607, 16777216, 43046721, 1e7, 19487171, 35831808, 62748517, 7529536, 11390625, 16777216, 24137569, 34012224, 47045881, 64e6, 4084101, 5153632, 6436343, 7962624, 9765625, 11881376, 14348907, 17210368, 20511149, 243e5, 28629151, 33554432, 39135393, 45435424, 52521875, 60466176];
    i.prototype.toString = function(f, a) {
      f = f || 10, a = a | 0 || 1;
      var u;
      if (f === 16 || f === "hex") {
        u = "";
        for (var l = 0, d4 = 0, h = 0; h < this.length; h++) {
          var b2 = this.words[h], m3 = ((b2 << l | d4) & 16777215).toString(16);
          d4 = b2 >>> 24 - l & 16777215, l += 2, l >= 26 && (l -= 26, h--), d4 !== 0 || h !== this.length - 1 ? u = E2[6 - m3.length] + m3 + u : u = m3 + u;
        }
        for (d4 !== 0 && (u = d4.toString(16) + u); u.length % a !== 0; )
          u = "0" + u;
        return this.negative !== 0 && (u = "-" + u), u;
      }
      if (f === (f | 0) && f >= 2 && f <= 36) {
        var s = A4[f], g2 = I3[f];
        u = "";
        var q = this.clone();
        for (q.negative = 0; !q.isZero(); ) {
          var R3 = q.modrn(g2).toString(f);
          q = q.idivn(g2), q.isZero() ? u = R3 + u : u = E2[s - R3.length] + R3 + u;
        }
        for (this.isZero() && (u = "0" + u); u.length % a !== 0; )
          u = "0" + u;
        return this.negative !== 0 && (u = "-" + u), u;
      }
      r(false, "Base should be between 2 and 36");
    }, i.prototype.toNumber = function() {
      var f = this.words[0];
      return this.length === 2 ? f += this.words[1] * 67108864 : this.length === 3 && this.words[2] === 1 ? f += 4503599627370496 + this.words[1] * 67108864 : this.length > 2 && r(false, "Number can only safely store up to 53 bits"), this.negative !== 0 ? -f : f;
    }, i.prototype.toJSON = function() {
      return this.toString(16, 2);
    }, o2 && (i.prototype.toBuffer = function(f, a) {
      return this.toArrayLike(o2, f, a);
    }), i.prototype.toArray = function(f, a) {
      return this.toArrayLike(Array, f, a);
    };
    var D6 = function(f, a) {
      return f.allocUnsafe ? f.allocUnsafe(a) : new f(a);
    };
    i.prototype.toArrayLike = function(f, a, u) {
      this._strip();
      var l = this.byteLength(), d4 = u || Math.max(1, l);
      r(l <= d4, "byte array longer than desired length"), r(d4 > 0, "Requested array length <= 0");
      var h = D6(f, d4), b2 = a === "le" ? "LE" : "BE";
      return this["_toArrayLike" + b2](h, l), h;
    }, i.prototype._toArrayLikeLE = function(f, a) {
      for (var u = 0, l = 0, d4 = 0, h = 0; d4 < this.length; d4++) {
        var b2 = this.words[d4] << h | l;
        f[u++] = b2 & 255, u < f.length && (f[u++] = b2 >> 8 & 255), u < f.length && (f[u++] = b2 >> 16 & 255), h === 6 ? (u < f.length && (f[u++] = b2 >> 24 & 255), l = 0, h = 0) : (l = b2 >>> 24, h += 2);
      }
      if (u < f.length)
        for (f[u++] = l; u < f.length; )
          f[u++] = 0;
    }, i.prototype._toArrayLikeBE = function(f, a) {
      for (var u = f.length - 1, l = 0, d4 = 0, h = 0; d4 < this.length; d4++) {
        var b2 = this.words[d4] << h | l;
        f[u--] = b2 & 255, u >= 0 && (f[u--] = b2 >> 8 & 255), u >= 0 && (f[u--] = b2 >> 16 & 255), h === 6 ? (u >= 0 && (f[u--] = b2 >> 24 & 255), l = 0, h = 0) : (l = b2 >>> 24, h += 2);
      }
      if (u >= 0)
        for (f[u--] = l; u >= 0; )
          f[u--] = 0;
    }, Math.clz32 ? i.prototype._countBits = function(f) {
      return 32 - Math.clz32(f);
    } : i.prototype._countBits = function(f) {
      var a = f, u = 0;
      return a >= 4096 && (u += 13, a >>>= 13), a >= 64 && (u += 7, a >>>= 7), a >= 8 && (u += 4, a >>>= 4), a >= 2 && (u += 2, a >>>= 2), u + a;
    }, i.prototype._zeroBits = function(f) {
      if (f === 0)
        return 26;
      var a = f, u = 0;
      return (a & 8191) === 0 && (u += 13, a >>>= 13), (a & 127) === 0 && (u += 7, a >>>= 7), (a & 15) === 0 && (u += 4, a >>>= 4), (a & 3) === 0 && (u += 2, a >>>= 2), (a & 1) === 0 && u++, u;
    }, i.prototype.bitLength = function() {
      var f = this.words[this.length - 1], a = this._countBits(f);
      return (this.length - 1) * 26 + a;
    };
    function C(c5) {
      for (var f = new Array(c5.bitLength()), a = 0; a < f.length; a++) {
        var u = a / 26 | 0, l = a % 26;
        f[a] = c5.words[u] >>> l & 1;
      }
      return f;
    }
    i.prototype.zeroBits = function() {
      if (this.isZero())
        return 0;
      for (var f = 0, a = 0; a < this.length; a++) {
        var u = this._zeroBits(this.words[a]);
        if (f += u, u !== 26)
          break;
      }
      return f;
    }, i.prototype.byteLength = function() {
      return Math.ceil(this.bitLength() / 8);
    }, i.prototype.toTwos = function(f) {
      return this.negative !== 0 ? this.abs().inotn(f).iaddn(1) : this.clone();
    }, i.prototype.fromTwos = function(f) {
      return this.testn(f - 1) ? this.notn(f).iaddn(1).ineg() : this.clone();
    }, i.prototype.isNeg = function() {
      return this.negative !== 0;
    }, i.prototype.neg = function() {
      return this.clone().ineg();
    }, i.prototype.ineg = function() {
      return this.isZero() || (this.negative ^= 1), this;
    }, i.prototype.iuor = function(f) {
      for (; this.length < f.length; )
        this.words[this.length++] = 0;
      for (var a = 0; a < f.length; a++)
        this.words[a] = this.words[a] | f.words[a];
      return this._strip();
    }, i.prototype.ior = function(f) {
      return r((this.negative | f.negative) === 0), this.iuor(f);
    }, i.prototype.or = function(f) {
      return this.length > f.length ? this.clone().ior(f) : f.clone().ior(this);
    }, i.prototype.uor = function(f) {
      return this.length > f.length ? this.clone().iuor(f) : f.clone().iuor(this);
    }, i.prototype.iuand = function(f) {
      var a;
      this.length > f.length ? a = f : a = this;
      for (var u = 0; u < a.length; u++)
        this.words[u] = this.words[u] & f.words[u];
      return this.length = a.length, this._strip();
    }, i.prototype.iand = function(f) {
      return r((this.negative | f.negative) === 0), this.iuand(f);
    }, i.prototype.and = function(f) {
      return this.length > f.length ? this.clone().iand(f) : f.clone().iand(this);
    }, i.prototype.uand = function(f) {
      return this.length > f.length ? this.clone().iuand(f) : f.clone().iuand(this);
    }, i.prototype.iuxor = function(f) {
      var a, u;
      this.length > f.length ? (a = this, u = f) : (a = f, u = this);
      for (var l = 0; l < u.length; l++)
        this.words[l] = a.words[l] ^ u.words[l];
      if (this !== a)
        for (; l < a.length; l++)
          this.words[l] = a.words[l];
      return this.length = a.length, this._strip();
    }, i.prototype.ixor = function(f) {
      return r((this.negative | f.negative) === 0), this.iuxor(f);
    }, i.prototype.xor = function(f) {
      return this.length > f.length ? this.clone().ixor(f) : f.clone().ixor(this);
    }, i.prototype.uxor = function(f) {
      return this.length > f.length ? this.clone().iuxor(f) : f.clone().iuxor(this);
    }, i.prototype.inotn = function(f) {
      r(typeof f == "number" && f >= 0);
      var a = Math.ceil(f / 26) | 0, u = f % 26;
      this._expand(a), u > 0 && a--;
      for (var l = 0; l < a; l++)
        this.words[l] = ~this.words[l] & 67108863;
      return u > 0 && (this.words[l] = ~this.words[l] & 67108863 >> 26 - u), this._strip();
    }, i.prototype.notn = function(f) {
      return this.clone().inotn(f);
    }, i.prototype.setn = function(f, a) {
      r(typeof f == "number" && f >= 0);
      var u = f / 26 | 0, l = f % 26;
      return this._expand(u + 1), a ? this.words[u] = this.words[u] | 1 << l : this.words[u] = this.words[u] & ~(1 << l), this._strip();
    }, i.prototype.iadd = function(f) {
      var a;
      if (this.negative !== 0 && f.negative === 0)
        return this.negative = 0, a = this.isub(f), this.negative ^= 1, this._normSign();
      if (this.negative === 0 && f.negative !== 0)
        return f.negative = 0, a = this.isub(f), f.negative = 1, a._normSign();
      var u, l;
      this.length > f.length ? (u = this, l = f) : (u = f, l = this);
      for (var d4 = 0, h = 0; h < l.length; h++)
        a = (u.words[h] | 0) + (l.words[h] | 0) + d4, this.words[h] = a & 67108863, d4 = a >>> 26;
      for (; d4 !== 0 && h < u.length; h++)
        a = (u.words[h] | 0) + d4, this.words[h] = a & 67108863, d4 = a >>> 26;
      if (this.length = u.length, d4 !== 0)
        this.words[this.length] = d4, this.length++;
      else if (u !== this)
        for (; h < u.length; h++)
          this.words[h] = u.words[h];
      return this;
    }, i.prototype.add = function(f) {
      var a;
      return f.negative !== 0 && this.negative === 0 ? (f.negative = 0, a = this.sub(f), f.negative ^= 1, a) : f.negative === 0 && this.negative !== 0 ? (this.negative = 0, a = f.sub(this), this.negative = 1, a) : this.length > f.length ? this.clone().iadd(f) : f.clone().iadd(this);
    }, i.prototype.isub = function(f) {
      if (f.negative !== 0) {
        f.negative = 0;
        var a = this.iadd(f);
        return f.negative = 1, a._normSign();
      } else if (this.negative !== 0)
        return this.negative = 0, this.iadd(f), this.negative = 1, this._normSign();
      var u = this.cmp(f);
      if (u === 0)
        return this.negative = 0, this.length = 1, this.words[0] = 0, this;
      var l, d4;
      u > 0 ? (l = this, d4 = f) : (l = f, d4 = this);
      for (var h = 0, b2 = 0; b2 < d4.length; b2++)
        a = (l.words[b2] | 0) - (d4.words[b2] | 0) + h, h = a >> 26, this.words[b2] = a & 67108863;
      for (; h !== 0 && b2 < l.length; b2++)
        a = (l.words[b2] | 0) + h, h = a >> 26, this.words[b2] = a & 67108863;
      if (h === 0 && b2 < l.length && l !== this)
        for (; b2 < l.length; b2++)
          this.words[b2] = l.words[b2];
      return this.length = Math.max(this.length, b2), l !== this && (this.negative = 1), this._strip();
    }, i.prototype.sub = function(f) {
      return this.clone().isub(f);
    };
    function ge2(c5, f, a) {
      a.negative = f.negative ^ c5.negative;
      var u = c5.length + f.length | 0;
      a.length = u, u = u - 1 | 0;
      var l = c5.words[0] | 0, d4 = f.words[0] | 0, h = l * d4, b2 = h & 67108863, m3 = h / 67108864 | 0;
      a.words[0] = b2;
      for (var s = 1; s < u; s++) {
        for (var g2 = m3 >>> 26, q = m3 & 67108863, R3 = Math.min(s, f.length - 1), B3 = Math.max(0, s - c5.length + 1); B3 <= R3; B3++) {
          var P2 = s - B3 | 0;
          l = c5.words[P2] | 0, d4 = f.words[B3] | 0, h = l * d4 + q, g2 += h / 67108864 | 0, q = h & 67108863;
        }
        a.words[s] = q | 0, m3 = g2 | 0;
      }
      return m3 !== 0 ? a.words[s] = m3 | 0 : a.length--, a._strip();
    }
    var L4 = function(f, a, u) {
      var l = f.words, d4 = a.words, h = u.words, b2 = 0, m3, s, g2, q = l[0] | 0, R3 = q & 8191, B3 = q >>> 13, P2 = l[1] | 0, T4 = P2 & 8191, N4 = P2 >>> 13, ze = l[2] | 0, O = ze & 8191, z = ze >>> 13, Er3 = l[3] | 0, U2 = Er3 & 8191, H3 = Er3 >>> 13, Ar = l[4] | 0, F4 = Ar & 8191, K4 = Ar >>> 13, qr2 = l[5] | 0, j2 = qr2 & 8191, W4 = qr2 >>> 13, Br2 = l[6] | 0, V3 = Br2 & 8191, Z5 = Br2 >>> 13, Rr2 = l[7] | 0, G4 = Rr2 & 8191, X5 = Rr2 >>> 13, Ir2 = l[8] | 0, Y4 = Ir2 & 8191, J3 = Ir2 >>> 13, kr2 = l[9] | 0, $4 = kr2 & 8191, Q3 = kr2 >>> 13, Dr = d4[0] | 0, ee2 = Dr & 8191, te = Dr >>> 13, Pr2 = d4[1] | 0, re2 = Pr2 & 8191, ie = Pr2 >>> 13, Tr2 = d4[2] | 0, fe = Tr2 & 8191, ne = Tr2 >>> 13, Cr2 = d4[3] | 0, ae2 = Cr2 & 8191, se = Cr2 >>> 13, Nr2 = d4[4] | 0, oe = Nr2 & 8191, he2 = Nr2 >>> 13, Lr4 = d4[5] | 0, ue2 = Lr4 & 8191, de4 = Lr4 >>> 13, Or2 = d4[6] | 0, ce2 = Or2 & 8191, le2 = Or2 >>> 13, zr = d4[7] | 0, ve2 = zr & 8191, pe = zr >>> 13, Ur3 = d4[8] | 0, be = Ur3 & 8191, me = Ur3 >>> 13, dr2 = d4[9] | 0, _e2 = dr2 & 8191, we2 = dr2 >>> 13;
      u.negative = f.negative ^ a.negative, u.length = 19, m3 = Math.imul(R3, ee2), s = Math.imul(R3, te), s = s + Math.imul(B3, ee2) | 0, g2 = Math.imul(B3, te);
      var At2 = (b2 + m3 | 0) + ((s & 8191) << 13) | 0;
      b2 = (g2 + (s >>> 13) | 0) + (At2 >>> 26) | 0, At2 &= 67108863, m3 = Math.imul(T4, ee2), s = Math.imul(T4, te), s = s + Math.imul(N4, ee2) | 0, g2 = Math.imul(N4, te), m3 = m3 + Math.imul(R3, re2) | 0, s = s + Math.imul(R3, ie) | 0, s = s + Math.imul(B3, re2) | 0, g2 = g2 + Math.imul(B3, ie) | 0;
      var qt2 = (b2 + m3 | 0) + ((s & 8191) << 13) | 0;
      b2 = (g2 + (s >>> 13) | 0) + (qt2 >>> 26) | 0, qt2 &= 67108863, m3 = Math.imul(O, ee2), s = Math.imul(O, te), s = s + Math.imul(z, ee2) | 0, g2 = Math.imul(z, te), m3 = m3 + Math.imul(T4, re2) | 0, s = s + Math.imul(T4, ie) | 0, s = s + Math.imul(N4, re2) | 0, g2 = g2 + Math.imul(N4, ie) | 0, m3 = m3 + Math.imul(R3, fe) | 0, s = s + Math.imul(R3, ne) | 0, s = s + Math.imul(B3, fe) | 0, g2 = g2 + Math.imul(B3, ne) | 0;
      var Bt = (b2 + m3 | 0) + ((s & 8191) << 13) | 0;
      b2 = (g2 + (s >>> 13) | 0) + (Bt >>> 26) | 0, Bt &= 67108863, m3 = Math.imul(U2, ee2), s = Math.imul(U2, te), s = s + Math.imul(H3, ee2) | 0, g2 = Math.imul(H3, te), m3 = m3 + Math.imul(O, re2) | 0, s = s + Math.imul(O, ie) | 0, s = s + Math.imul(z, re2) | 0, g2 = g2 + Math.imul(z, ie) | 0, m3 = m3 + Math.imul(T4, fe) | 0, s = s + Math.imul(T4, ne) | 0, s = s + Math.imul(N4, fe) | 0, g2 = g2 + Math.imul(N4, ne) | 0, m3 = m3 + Math.imul(R3, ae2) | 0, s = s + Math.imul(R3, se) | 0, s = s + Math.imul(B3, ae2) | 0, g2 = g2 + Math.imul(B3, se) | 0;
      var Rt2 = (b2 + m3 | 0) + ((s & 8191) << 13) | 0;
      b2 = (g2 + (s >>> 13) | 0) + (Rt2 >>> 26) | 0, Rt2 &= 67108863, m3 = Math.imul(F4, ee2), s = Math.imul(F4, te), s = s + Math.imul(K4, ee2) | 0, g2 = Math.imul(K4, te), m3 = m3 + Math.imul(U2, re2) | 0, s = s + Math.imul(U2, ie) | 0, s = s + Math.imul(H3, re2) | 0, g2 = g2 + Math.imul(H3, ie) | 0, m3 = m3 + Math.imul(O, fe) | 0, s = s + Math.imul(O, ne) | 0, s = s + Math.imul(z, fe) | 0, g2 = g2 + Math.imul(z, ne) | 0, m3 = m3 + Math.imul(T4, ae2) | 0, s = s + Math.imul(T4, se) | 0, s = s + Math.imul(N4, ae2) | 0, g2 = g2 + Math.imul(N4, se) | 0, m3 = m3 + Math.imul(R3, oe) | 0, s = s + Math.imul(R3, he2) | 0, s = s + Math.imul(B3, oe) | 0, g2 = g2 + Math.imul(B3, he2) | 0;
      var It2 = (b2 + m3 | 0) + ((s & 8191) << 13) | 0;
      b2 = (g2 + (s >>> 13) | 0) + (It2 >>> 26) | 0, It2 &= 67108863, m3 = Math.imul(j2, ee2), s = Math.imul(j2, te), s = s + Math.imul(W4, ee2) | 0, g2 = Math.imul(W4, te), m3 = m3 + Math.imul(F4, re2) | 0, s = s + Math.imul(F4, ie) | 0, s = s + Math.imul(K4, re2) | 0, g2 = g2 + Math.imul(K4, ie) | 0, m3 = m3 + Math.imul(U2, fe) | 0, s = s + Math.imul(U2, ne) | 0, s = s + Math.imul(H3, fe) | 0, g2 = g2 + Math.imul(H3, ne) | 0, m3 = m3 + Math.imul(O, ae2) | 0, s = s + Math.imul(O, se) | 0, s = s + Math.imul(z, ae2) | 0, g2 = g2 + Math.imul(z, se) | 0, m3 = m3 + Math.imul(T4, oe) | 0, s = s + Math.imul(T4, he2) | 0, s = s + Math.imul(N4, oe) | 0, g2 = g2 + Math.imul(N4, he2) | 0, m3 = m3 + Math.imul(R3, ue2) | 0, s = s + Math.imul(R3, de4) | 0, s = s + Math.imul(B3, ue2) | 0, g2 = g2 + Math.imul(B3, de4) | 0;
      var kt2 = (b2 + m3 | 0) + ((s & 8191) << 13) | 0;
      b2 = (g2 + (s >>> 13) | 0) + (kt2 >>> 26) | 0, kt2 &= 67108863, m3 = Math.imul(V3, ee2), s = Math.imul(V3, te), s = s + Math.imul(Z5, ee2) | 0, g2 = Math.imul(Z5, te), m3 = m3 + Math.imul(j2, re2) | 0, s = s + Math.imul(j2, ie) | 0, s = s + Math.imul(W4, re2) | 0, g2 = g2 + Math.imul(W4, ie) | 0, m3 = m3 + Math.imul(F4, fe) | 0, s = s + Math.imul(F4, ne) | 0, s = s + Math.imul(K4, fe) | 0, g2 = g2 + Math.imul(K4, ne) | 0, m3 = m3 + Math.imul(U2, ae2) | 0, s = s + Math.imul(U2, se) | 0, s = s + Math.imul(H3, ae2) | 0, g2 = g2 + Math.imul(H3, se) | 0, m3 = m3 + Math.imul(O, oe) | 0, s = s + Math.imul(O, he2) | 0, s = s + Math.imul(z, oe) | 0, g2 = g2 + Math.imul(z, he2) | 0, m3 = m3 + Math.imul(T4, ue2) | 0, s = s + Math.imul(T4, de4) | 0, s = s + Math.imul(N4, ue2) | 0, g2 = g2 + Math.imul(N4, de4) | 0, m3 = m3 + Math.imul(R3, ce2) | 0, s = s + Math.imul(R3, le2) | 0, s = s + Math.imul(B3, ce2) | 0, g2 = g2 + Math.imul(B3, le2) | 0;
      var Dt = (b2 + m3 | 0) + ((s & 8191) << 13) | 0;
      b2 = (g2 + (s >>> 13) | 0) + (Dt >>> 26) | 0, Dt &= 67108863, m3 = Math.imul(G4, ee2), s = Math.imul(G4, te), s = s + Math.imul(X5, ee2) | 0, g2 = Math.imul(X5, te), m3 = m3 + Math.imul(V3, re2) | 0, s = s + Math.imul(V3, ie) | 0, s = s + Math.imul(Z5, re2) | 0, g2 = g2 + Math.imul(Z5, ie) | 0, m3 = m3 + Math.imul(j2, fe) | 0, s = s + Math.imul(j2, ne) | 0, s = s + Math.imul(W4, fe) | 0, g2 = g2 + Math.imul(W4, ne) | 0, m3 = m3 + Math.imul(F4, ae2) | 0, s = s + Math.imul(F4, se) | 0, s = s + Math.imul(K4, ae2) | 0, g2 = g2 + Math.imul(K4, se) | 0, m3 = m3 + Math.imul(U2, oe) | 0, s = s + Math.imul(U2, he2) | 0, s = s + Math.imul(H3, oe) | 0, g2 = g2 + Math.imul(H3, he2) | 0, m3 = m3 + Math.imul(O, ue2) | 0, s = s + Math.imul(O, de4) | 0, s = s + Math.imul(z, ue2) | 0, g2 = g2 + Math.imul(z, de4) | 0, m3 = m3 + Math.imul(T4, ce2) | 0, s = s + Math.imul(T4, le2) | 0, s = s + Math.imul(N4, ce2) | 0, g2 = g2 + Math.imul(N4, le2) | 0, m3 = m3 + Math.imul(R3, ve2) | 0, s = s + Math.imul(R3, pe) | 0, s = s + Math.imul(B3, ve2) | 0, g2 = g2 + Math.imul(B3, pe) | 0;
      var Pt2 = (b2 + m3 | 0) + ((s & 8191) << 13) | 0;
      b2 = (g2 + (s >>> 13) | 0) + (Pt2 >>> 26) | 0, Pt2 &= 67108863, m3 = Math.imul(Y4, ee2), s = Math.imul(Y4, te), s = s + Math.imul(J3, ee2) | 0, g2 = Math.imul(J3, te), m3 = m3 + Math.imul(G4, re2) | 0, s = s + Math.imul(G4, ie) | 0, s = s + Math.imul(X5, re2) | 0, g2 = g2 + Math.imul(X5, ie) | 0, m3 = m3 + Math.imul(V3, fe) | 0, s = s + Math.imul(V3, ne) | 0, s = s + Math.imul(Z5, fe) | 0, g2 = g2 + Math.imul(Z5, ne) | 0, m3 = m3 + Math.imul(j2, ae2) | 0, s = s + Math.imul(j2, se) | 0, s = s + Math.imul(W4, ae2) | 0, g2 = g2 + Math.imul(W4, se) | 0, m3 = m3 + Math.imul(F4, oe) | 0, s = s + Math.imul(F4, he2) | 0, s = s + Math.imul(K4, oe) | 0, g2 = g2 + Math.imul(K4, he2) | 0, m3 = m3 + Math.imul(U2, ue2) | 0, s = s + Math.imul(U2, de4) | 0, s = s + Math.imul(H3, ue2) | 0, g2 = g2 + Math.imul(H3, de4) | 0, m3 = m3 + Math.imul(O, ce2) | 0, s = s + Math.imul(O, le2) | 0, s = s + Math.imul(z, ce2) | 0, g2 = g2 + Math.imul(z, le2) | 0, m3 = m3 + Math.imul(T4, ve2) | 0, s = s + Math.imul(T4, pe) | 0, s = s + Math.imul(N4, ve2) | 0, g2 = g2 + Math.imul(N4, pe) | 0, m3 = m3 + Math.imul(R3, be) | 0, s = s + Math.imul(R3, me) | 0, s = s + Math.imul(B3, be) | 0, g2 = g2 + Math.imul(B3, me) | 0;
      var Tt2 = (b2 + m3 | 0) + ((s & 8191) << 13) | 0;
      b2 = (g2 + (s >>> 13) | 0) + (Tt2 >>> 26) | 0, Tt2 &= 67108863, m3 = Math.imul($4, ee2), s = Math.imul($4, te), s = s + Math.imul(Q3, ee2) | 0, g2 = Math.imul(Q3, te), m3 = m3 + Math.imul(Y4, re2) | 0, s = s + Math.imul(Y4, ie) | 0, s = s + Math.imul(J3, re2) | 0, g2 = g2 + Math.imul(J3, ie) | 0, m3 = m3 + Math.imul(G4, fe) | 0, s = s + Math.imul(G4, ne) | 0, s = s + Math.imul(X5, fe) | 0, g2 = g2 + Math.imul(X5, ne) | 0, m3 = m3 + Math.imul(V3, ae2) | 0, s = s + Math.imul(V3, se) | 0, s = s + Math.imul(Z5, ae2) | 0, g2 = g2 + Math.imul(Z5, se) | 0, m3 = m3 + Math.imul(j2, oe) | 0, s = s + Math.imul(j2, he2) | 0, s = s + Math.imul(W4, oe) | 0, g2 = g2 + Math.imul(W4, he2) | 0, m3 = m3 + Math.imul(F4, ue2) | 0, s = s + Math.imul(F4, de4) | 0, s = s + Math.imul(K4, ue2) | 0, g2 = g2 + Math.imul(K4, de4) | 0, m3 = m3 + Math.imul(U2, ce2) | 0, s = s + Math.imul(U2, le2) | 0, s = s + Math.imul(H3, ce2) | 0, g2 = g2 + Math.imul(H3, le2) | 0, m3 = m3 + Math.imul(O, ve2) | 0, s = s + Math.imul(O, pe) | 0, s = s + Math.imul(z, ve2) | 0, g2 = g2 + Math.imul(z, pe) | 0, m3 = m3 + Math.imul(T4, be) | 0, s = s + Math.imul(T4, me) | 0, s = s + Math.imul(N4, be) | 0, g2 = g2 + Math.imul(N4, me) | 0, m3 = m3 + Math.imul(R3, _e2) | 0, s = s + Math.imul(R3, we2) | 0, s = s + Math.imul(B3, _e2) | 0, g2 = g2 + Math.imul(B3, we2) | 0;
      var Ct2 = (b2 + m3 | 0) + ((s & 8191) << 13) | 0;
      b2 = (g2 + (s >>> 13) | 0) + (Ct2 >>> 26) | 0, Ct2 &= 67108863, m3 = Math.imul($4, re2), s = Math.imul($4, ie), s = s + Math.imul(Q3, re2) | 0, g2 = Math.imul(Q3, ie), m3 = m3 + Math.imul(Y4, fe) | 0, s = s + Math.imul(Y4, ne) | 0, s = s + Math.imul(J3, fe) | 0, g2 = g2 + Math.imul(J3, ne) | 0, m3 = m3 + Math.imul(G4, ae2) | 0, s = s + Math.imul(G4, se) | 0, s = s + Math.imul(X5, ae2) | 0, g2 = g2 + Math.imul(X5, se) | 0, m3 = m3 + Math.imul(V3, oe) | 0, s = s + Math.imul(V3, he2) | 0, s = s + Math.imul(Z5, oe) | 0, g2 = g2 + Math.imul(Z5, he2) | 0, m3 = m3 + Math.imul(j2, ue2) | 0, s = s + Math.imul(j2, de4) | 0, s = s + Math.imul(W4, ue2) | 0, g2 = g2 + Math.imul(W4, de4) | 0, m3 = m3 + Math.imul(F4, ce2) | 0, s = s + Math.imul(F4, le2) | 0, s = s + Math.imul(K4, ce2) | 0, g2 = g2 + Math.imul(K4, le2) | 0, m3 = m3 + Math.imul(U2, ve2) | 0, s = s + Math.imul(U2, pe) | 0, s = s + Math.imul(H3, ve2) | 0, g2 = g2 + Math.imul(H3, pe) | 0, m3 = m3 + Math.imul(O, be) | 0, s = s + Math.imul(O, me) | 0, s = s + Math.imul(z, be) | 0, g2 = g2 + Math.imul(z, me) | 0, m3 = m3 + Math.imul(T4, _e2) | 0, s = s + Math.imul(T4, we2) | 0, s = s + Math.imul(N4, _e2) | 0, g2 = g2 + Math.imul(N4, we2) | 0;
      var Nt2 = (b2 + m3 | 0) + ((s & 8191) << 13) | 0;
      b2 = (g2 + (s >>> 13) | 0) + (Nt2 >>> 26) | 0, Nt2 &= 67108863, m3 = Math.imul($4, fe), s = Math.imul($4, ne), s = s + Math.imul(Q3, fe) | 0, g2 = Math.imul(Q3, ne), m3 = m3 + Math.imul(Y4, ae2) | 0, s = s + Math.imul(Y4, se) | 0, s = s + Math.imul(J3, ae2) | 0, g2 = g2 + Math.imul(J3, se) | 0, m3 = m3 + Math.imul(G4, oe) | 0, s = s + Math.imul(G4, he2) | 0, s = s + Math.imul(X5, oe) | 0, g2 = g2 + Math.imul(X5, he2) | 0, m3 = m3 + Math.imul(V3, ue2) | 0, s = s + Math.imul(V3, de4) | 0, s = s + Math.imul(Z5, ue2) | 0, g2 = g2 + Math.imul(Z5, de4) | 0, m3 = m3 + Math.imul(j2, ce2) | 0, s = s + Math.imul(j2, le2) | 0, s = s + Math.imul(W4, ce2) | 0, g2 = g2 + Math.imul(W4, le2) | 0, m3 = m3 + Math.imul(F4, ve2) | 0, s = s + Math.imul(F4, pe) | 0, s = s + Math.imul(K4, ve2) | 0, g2 = g2 + Math.imul(K4, pe) | 0, m3 = m3 + Math.imul(U2, be) | 0, s = s + Math.imul(U2, me) | 0, s = s + Math.imul(H3, be) | 0, g2 = g2 + Math.imul(H3, me) | 0, m3 = m3 + Math.imul(O, _e2) | 0, s = s + Math.imul(O, we2) | 0, s = s + Math.imul(z, _e2) | 0, g2 = g2 + Math.imul(z, we2) | 0;
      var Lt2 = (b2 + m3 | 0) + ((s & 8191) << 13) | 0;
      b2 = (g2 + (s >>> 13) | 0) + (Lt2 >>> 26) | 0, Lt2 &= 67108863, m3 = Math.imul($4, ae2), s = Math.imul($4, se), s = s + Math.imul(Q3, ae2) | 0, g2 = Math.imul(Q3, se), m3 = m3 + Math.imul(Y4, oe) | 0, s = s + Math.imul(Y4, he2) | 0, s = s + Math.imul(J3, oe) | 0, g2 = g2 + Math.imul(J3, he2) | 0, m3 = m3 + Math.imul(G4, ue2) | 0, s = s + Math.imul(G4, de4) | 0, s = s + Math.imul(X5, ue2) | 0, g2 = g2 + Math.imul(X5, de4) | 0, m3 = m3 + Math.imul(V3, ce2) | 0, s = s + Math.imul(V3, le2) | 0, s = s + Math.imul(Z5, ce2) | 0, g2 = g2 + Math.imul(Z5, le2) | 0, m3 = m3 + Math.imul(j2, ve2) | 0, s = s + Math.imul(j2, pe) | 0, s = s + Math.imul(W4, ve2) | 0, g2 = g2 + Math.imul(W4, pe) | 0, m3 = m3 + Math.imul(F4, be) | 0, s = s + Math.imul(F4, me) | 0, s = s + Math.imul(K4, be) | 0, g2 = g2 + Math.imul(K4, me) | 0, m3 = m3 + Math.imul(U2, _e2) | 0, s = s + Math.imul(U2, we2) | 0, s = s + Math.imul(H3, _e2) | 0, g2 = g2 + Math.imul(H3, we2) | 0;
      var Ot = (b2 + m3 | 0) + ((s & 8191) << 13) | 0;
      b2 = (g2 + (s >>> 13) | 0) + (Ot >>> 26) | 0, Ot &= 67108863, m3 = Math.imul($4, oe), s = Math.imul($4, he2), s = s + Math.imul(Q3, oe) | 0, g2 = Math.imul(Q3, he2), m3 = m3 + Math.imul(Y4, ue2) | 0, s = s + Math.imul(Y4, de4) | 0, s = s + Math.imul(J3, ue2) | 0, g2 = g2 + Math.imul(J3, de4) | 0, m3 = m3 + Math.imul(G4, ce2) | 0, s = s + Math.imul(G4, le2) | 0, s = s + Math.imul(X5, ce2) | 0, g2 = g2 + Math.imul(X5, le2) | 0, m3 = m3 + Math.imul(V3, ve2) | 0, s = s + Math.imul(V3, pe) | 0, s = s + Math.imul(Z5, ve2) | 0, g2 = g2 + Math.imul(Z5, pe) | 0, m3 = m3 + Math.imul(j2, be) | 0, s = s + Math.imul(j2, me) | 0, s = s + Math.imul(W4, be) | 0, g2 = g2 + Math.imul(W4, me) | 0, m3 = m3 + Math.imul(F4, _e2) | 0, s = s + Math.imul(F4, we2) | 0, s = s + Math.imul(K4, _e2) | 0, g2 = g2 + Math.imul(K4, we2) | 0;
      var zt2 = (b2 + m3 | 0) + ((s & 8191) << 13) | 0;
      b2 = (g2 + (s >>> 13) | 0) + (zt2 >>> 26) | 0, zt2 &= 67108863, m3 = Math.imul($4, ue2), s = Math.imul($4, de4), s = s + Math.imul(Q3, ue2) | 0, g2 = Math.imul(Q3, de4), m3 = m3 + Math.imul(Y4, ce2) | 0, s = s + Math.imul(Y4, le2) | 0, s = s + Math.imul(J3, ce2) | 0, g2 = g2 + Math.imul(J3, le2) | 0, m3 = m3 + Math.imul(G4, ve2) | 0, s = s + Math.imul(G4, pe) | 0, s = s + Math.imul(X5, ve2) | 0, g2 = g2 + Math.imul(X5, pe) | 0, m3 = m3 + Math.imul(V3, be) | 0, s = s + Math.imul(V3, me) | 0, s = s + Math.imul(Z5, be) | 0, g2 = g2 + Math.imul(Z5, me) | 0, m3 = m3 + Math.imul(j2, _e2) | 0, s = s + Math.imul(j2, we2) | 0, s = s + Math.imul(W4, _e2) | 0, g2 = g2 + Math.imul(W4, we2) | 0;
      var Ut = (b2 + m3 | 0) + ((s & 8191) << 13) | 0;
      b2 = (g2 + (s >>> 13) | 0) + (Ut >>> 26) | 0, Ut &= 67108863, m3 = Math.imul($4, ce2), s = Math.imul($4, le2), s = s + Math.imul(Q3, ce2) | 0, g2 = Math.imul(Q3, le2), m3 = m3 + Math.imul(Y4, ve2) | 0, s = s + Math.imul(Y4, pe) | 0, s = s + Math.imul(J3, ve2) | 0, g2 = g2 + Math.imul(J3, pe) | 0, m3 = m3 + Math.imul(G4, be) | 0, s = s + Math.imul(G4, me) | 0, s = s + Math.imul(X5, be) | 0, g2 = g2 + Math.imul(X5, me) | 0, m3 = m3 + Math.imul(V3, _e2) | 0, s = s + Math.imul(V3, we2) | 0, s = s + Math.imul(Z5, _e2) | 0, g2 = g2 + Math.imul(Z5, we2) | 0;
      var Ht = (b2 + m3 | 0) + ((s & 8191) << 13) | 0;
      b2 = (g2 + (s >>> 13) | 0) + (Ht >>> 26) | 0, Ht &= 67108863, m3 = Math.imul($4, ve2), s = Math.imul($4, pe), s = s + Math.imul(Q3, ve2) | 0, g2 = Math.imul(Q3, pe), m3 = m3 + Math.imul(Y4, be) | 0, s = s + Math.imul(Y4, me) | 0, s = s + Math.imul(J3, be) | 0, g2 = g2 + Math.imul(J3, me) | 0, m3 = m3 + Math.imul(G4, _e2) | 0, s = s + Math.imul(G4, we2) | 0, s = s + Math.imul(X5, _e2) | 0, g2 = g2 + Math.imul(X5, we2) | 0;
      var ei = (b2 + m3 | 0) + ((s & 8191) << 13) | 0;
      b2 = (g2 + (s >>> 13) | 0) + (ei >>> 26) | 0, ei &= 67108863, m3 = Math.imul($4, be), s = Math.imul($4, me), s = s + Math.imul(Q3, be) | 0, g2 = Math.imul(Q3, me), m3 = m3 + Math.imul(Y4, _e2) | 0, s = s + Math.imul(Y4, we2) | 0, s = s + Math.imul(J3, _e2) | 0, g2 = g2 + Math.imul(J3, we2) | 0;
      var ti = (b2 + m3 | 0) + ((s & 8191) << 13) | 0;
      b2 = (g2 + (s >>> 13) | 0) + (ti >>> 26) | 0, ti &= 67108863, m3 = Math.imul($4, _e2), s = Math.imul($4, we2), s = s + Math.imul(Q3, _e2) | 0, g2 = Math.imul(Q3, we2);
      var ri = (b2 + m3 | 0) + ((s & 8191) << 13) | 0;
      return b2 = (g2 + (s >>> 13) | 0) + (ri >>> 26) | 0, ri &= 67108863, h[0] = At2, h[1] = qt2, h[2] = Bt, h[3] = Rt2, h[4] = It2, h[5] = kt2, h[6] = Dt, h[7] = Pt2, h[8] = Tt2, h[9] = Ct2, h[10] = Nt2, h[11] = Lt2, h[12] = Ot, h[13] = zt2, h[14] = Ut, h[15] = Ht, h[16] = ei, h[17] = ti, h[18] = ri, b2 !== 0 && (h[19] = b2, u.length++), u;
    };
    Math.imul || (L4 = ge2);
    function ye(c5, f, a) {
      a.negative = f.negative ^ c5.negative, a.length = c5.length + f.length;
      for (var u = 0, l = 0, d4 = 0; d4 < a.length - 1; d4++) {
        var h = l;
        l = 0;
        for (var b2 = u & 67108863, m3 = Math.min(d4, f.length - 1), s = Math.max(0, d4 - c5.length + 1); s <= m3; s++) {
          var g2 = d4 - s, q = c5.words[g2] | 0, R3 = f.words[s] | 0, B3 = q * R3, P2 = B3 & 67108863;
          h = h + (B3 / 67108864 | 0) | 0, P2 = P2 + b2 | 0, b2 = P2 & 67108863, h = h + (P2 >>> 26) | 0, l += h >>> 26, h &= 67108863;
        }
        a.words[d4] = b2, u = h, h = l;
      }
      return u !== 0 ? a.words[d4] = u : a.length--, a._strip();
    }
    function Re(c5, f, a) {
      return ye(c5, f, a);
    }
    i.prototype.mulTo = function(f, a) {
      var u, l = this.length + f.length;
      return this.length === 10 && f.length === 10 ? u = L4(this, f, a) : l < 63 ? u = ge2(this, f, a) : l < 1024 ? u = ye(this, f, a) : u = Re(this, f, a), u;
    };
    function xe3(c5, f) {
      this.x = c5, this.y = f;
    }
    xe3.prototype.makeRBT = function(f) {
      for (var a = new Array(f), u = i.prototype._countBits(f) - 1, l = 0; l < f; l++)
        a[l] = this.revBin(l, u, f);
      return a;
    }, xe3.prototype.revBin = function(f, a, u) {
      if (f === 0 || f === u - 1)
        return f;
      for (var l = 0, d4 = 0; d4 < a; d4++)
        l |= (f & 1) << a - d4 - 1, f >>= 1;
      return l;
    }, xe3.prototype.permute = function(f, a, u, l, d4, h) {
      for (var b2 = 0; b2 < h; b2++)
        l[b2] = a[f[b2]], d4[b2] = u[f[b2]];
    }, xe3.prototype.transform = function(f, a, u, l, d4, h) {
      this.permute(h, f, a, u, l, d4);
      for (var b2 = 1; b2 < d4; b2 <<= 1)
        for (var m3 = b2 << 1, s = Math.cos(2 * Math.PI / m3), g2 = Math.sin(2 * Math.PI / m3), q = 0; q < d4; q += m3)
          for (var R3 = s, B3 = g2, P2 = 0; P2 < b2; P2++) {
            var T4 = u[q + P2], N4 = l[q + P2], ze = u[q + P2 + b2], O = l[q + P2 + b2], z = R3 * ze - B3 * O;
            O = R3 * O + B3 * ze, ze = z, u[q + P2] = T4 + ze, l[q + P2] = N4 + O, u[q + P2 + b2] = T4 - ze, l[q + P2 + b2] = N4 - O, P2 !== m3 && (z = s * R3 - g2 * B3, B3 = s * B3 + g2 * R3, R3 = z);
          }
    }, xe3.prototype.guessLen13b = function(f, a) {
      var u = Math.max(a, f) | 1, l = u & 1, d4 = 0;
      for (u = u / 2 | 0; u; u = u >>> 1)
        d4++;
      return 1 << d4 + 1 + l;
    }, xe3.prototype.conjugate = function(f, a, u) {
      if (!(u <= 1))
        for (var l = 0; l < u / 2; l++) {
          var d4 = f[l];
          f[l] = f[u - l - 1], f[u - l - 1] = d4, d4 = a[l], a[l] = -a[u - l - 1], a[u - l - 1] = -d4;
        }
    }, xe3.prototype.normalize13b = function(f, a) {
      for (var u = 0, l = 0; l < a / 2; l++) {
        var d4 = Math.round(f[2 * l + 1] / a) * 8192 + Math.round(f[2 * l] / a) + u;
        f[l] = d4 & 67108863, d4 < 67108864 ? u = 0 : u = d4 / 67108864 | 0;
      }
      return f;
    }, xe3.prototype.convert13b = function(f, a, u, l) {
      for (var d4 = 0, h = 0; h < a; h++)
        d4 = d4 + (f[h] | 0), u[2 * h] = d4 & 8191, d4 = d4 >>> 13, u[2 * h + 1] = d4 & 8191, d4 = d4 >>> 13;
      for (h = 2 * a; h < l; ++h)
        u[h] = 0;
      r(d4 === 0), r((d4 & -8192) === 0);
    }, xe3.prototype.stub = function(f) {
      for (var a = new Array(f), u = 0; u < f; u++)
        a[u] = 0;
      return a;
    }, xe3.prototype.mulp = function(f, a, u) {
      var l = 2 * this.guessLen13b(f.length, a.length), d4 = this.makeRBT(l), h = this.stub(l), b2 = new Array(l), m3 = new Array(l), s = new Array(l), g2 = new Array(l), q = new Array(l), R3 = new Array(l), B3 = u.words;
      B3.length = l, this.convert13b(f.words, f.length, b2, l), this.convert13b(a.words, a.length, g2, l), this.transform(b2, h, m3, s, l, d4), this.transform(g2, h, q, R3, l, d4);
      for (var P2 = 0; P2 < l; P2++) {
        var T4 = m3[P2] * q[P2] - s[P2] * R3[P2];
        s[P2] = m3[P2] * R3[P2] + s[P2] * q[P2], m3[P2] = T4;
      }
      return this.conjugate(m3, s, l), this.transform(m3, s, B3, h, l, d4), this.conjugate(B3, h, l), this.normalize13b(B3, l), u.negative = f.negative ^ a.negative, u.length = f.length + a.length, u._strip();
    }, i.prototype.mul = function(f) {
      var a = new i(null);
      return a.words = new Array(this.length + f.length), this.mulTo(f, a);
    }, i.prototype.mulf = function(f) {
      var a = new i(null);
      return a.words = new Array(this.length + f.length), Re(this, f, a);
    }, i.prototype.imul = function(f) {
      return this.clone().mulTo(f, this);
    }, i.prototype.imuln = function(f) {
      var a = f < 0;
      a && (f = -f), r(typeof f == "number"), r(f < 67108864);
      for (var u = 0, l = 0; l < this.length; l++) {
        var d4 = (this.words[l] | 0) * f, h = (d4 & 67108863) + (u & 67108863);
        u >>= 26, u += d4 / 67108864 | 0, u += h >>> 26, this.words[l] = h & 67108863;
      }
      return u !== 0 && (this.words[l] = u, this.length++), a ? this.ineg() : this;
    }, i.prototype.muln = function(f) {
      return this.clone().imuln(f);
    }, i.prototype.sqr = function() {
      return this.mul(this);
    }, i.prototype.isqr = function() {
      return this.imul(this.clone());
    }, i.prototype.pow = function(f) {
      var a = C(f);
      if (a.length === 0)
        return new i(1);
      for (var u = this, l = 0; l < a.length && a[l] === 0; l++, u = u.sqr())
        ;
      if (++l < a.length)
        for (var d4 = u.sqr(); l < a.length; l++, d4 = d4.sqr())
          a[l] !== 0 && (u = u.mul(d4));
      return u;
    }, i.prototype.iushln = function(f) {
      r(typeof f == "number" && f >= 0);
      var a = f % 26, u = (f - a) / 26, l = 67108863 >>> 26 - a << 26 - a, d4;
      if (a !== 0) {
        var h = 0;
        for (d4 = 0; d4 < this.length; d4++) {
          var b2 = this.words[d4] & l, m3 = (this.words[d4] | 0) - b2 << a;
          this.words[d4] = m3 | h, h = b2 >>> 26 - a;
        }
        h && (this.words[d4] = h, this.length++);
      }
      if (u !== 0) {
        for (d4 = this.length - 1; d4 >= 0; d4--)
          this.words[d4 + u] = this.words[d4];
        for (d4 = 0; d4 < u; d4++)
          this.words[d4] = 0;
        this.length += u;
      }
      return this._strip();
    }, i.prototype.ishln = function(f) {
      return r(this.negative === 0), this.iushln(f);
    }, i.prototype.iushrn = function(f, a, u) {
      r(typeof f == "number" && f >= 0);
      var l;
      a ? l = (a - a % 26) / 26 : l = 0;
      var d4 = f % 26, h = Math.min((f - d4) / 26, this.length), b2 = 67108863 ^ 67108863 >>> d4 << d4, m3 = u;
      if (l -= h, l = Math.max(0, l), m3) {
        for (var s = 0; s < h; s++)
          m3.words[s] = this.words[s];
        m3.length = h;
      }
      if (h !== 0)
        if (this.length > h)
          for (this.length -= h, s = 0; s < this.length; s++)
            this.words[s] = this.words[s + h];
        else
          this.words[0] = 0, this.length = 1;
      var g2 = 0;
      for (s = this.length - 1; s >= 0 && (g2 !== 0 || s >= l); s--) {
        var q = this.words[s] | 0;
        this.words[s] = g2 << 26 - d4 | q >>> d4, g2 = q & b2;
      }
      return m3 && g2 !== 0 && (m3.words[m3.length++] = g2), this.length === 0 && (this.words[0] = 0, this.length = 1), this._strip();
    }, i.prototype.ishrn = function(f, a, u) {
      return r(this.negative === 0), this.iushrn(f, a, u);
    }, i.prototype.shln = function(f) {
      return this.clone().ishln(f);
    }, i.prototype.ushln = function(f) {
      return this.clone().iushln(f);
    }, i.prototype.shrn = function(f) {
      return this.clone().ishrn(f);
    }, i.prototype.ushrn = function(f) {
      return this.clone().iushrn(f);
    }, i.prototype.testn = function(f) {
      r(typeof f == "number" && f >= 0);
      var a = f % 26, u = (f - a) / 26, l = 1 << a;
      if (this.length <= u)
        return false;
      var d4 = this.words[u];
      return !!(d4 & l);
    }, i.prototype.imaskn = function(f) {
      r(typeof f == "number" && f >= 0);
      var a = f % 26, u = (f - a) / 26;
      if (r(this.negative === 0, "imaskn works only with positive numbers"), this.length <= u)
        return this;
      if (a !== 0 && u++, this.length = Math.min(u, this.length), a !== 0) {
        var l = 67108863 ^ 67108863 >>> a << a;
        this.words[this.length - 1] &= l;
      }
      return this._strip();
    }, i.prototype.maskn = function(f) {
      return this.clone().imaskn(f);
    }, i.prototype.iaddn = function(f) {
      return r(typeof f == "number"), r(f < 67108864), f < 0 ? this.isubn(-f) : this.negative !== 0 ? this.length === 1 && (this.words[0] | 0) <= f ? (this.words[0] = f - (this.words[0] | 0), this.negative = 0, this) : (this.negative = 0, this.isubn(f), this.negative = 1, this) : this._iaddn(f);
    }, i.prototype._iaddn = function(f) {
      this.words[0] += f;
      for (var a = 0; a < this.length && this.words[a] >= 67108864; a++)
        this.words[a] -= 67108864, a === this.length - 1 ? this.words[a + 1] = 1 : this.words[a + 1]++;
      return this.length = Math.max(this.length, a + 1), this;
    }, i.prototype.isubn = function(f) {
      if (r(typeof f == "number"), r(f < 67108864), f < 0)
        return this.iaddn(-f);
      if (this.negative !== 0)
        return this.negative = 0, this.iaddn(f), this.negative = 1, this;
      if (this.words[0] -= f, this.length === 1 && this.words[0] < 0)
        this.words[0] = -this.words[0], this.negative = 1;
      else
        for (var a = 0; a < this.length && this.words[a] < 0; a++)
          this.words[a] += 67108864, this.words[a + 1] -= 1;
      return this._strip();
    }, i.prototype.addn = function(f) {
      return this.clone().iaddn(f);
    }, i.prototype.subn = function(f) {
      return this.clone().isubn(f);
    }, i.prototype.iabs = function() {
      return this.negative = 0, this;
    }, i.prototype.abs = function() {
      return this.clone().iabs();
    }, i.prototype._ishlnsubmul = function(f, a, u) {
      var l = f.length + u, d4;
      this._expand(l);
      var h, b2 = 0;
      for (d4 = 0; d4 < f.length; d4++) {
        h = (this.words[d4 + u] | 0) + b2;
        var m3 = (f.words[d4] | 0) * a;
        h -= m3 & 67108863, b2 = (h >> 26) - (m3 / 67108864 | 0), this.words[d4 + u] = h & 67108863;
      }
      for (; d4 < this.length - u; d4++)
        h = (this.words[d4 + u] | 0) + b2, b2 = h >> 26, this.words[d4 + u] = h & 67108863;
      if (b2 === 0)
        return this._strip();
      for (r(b2 === -1), b2 = 0, d4 = 0; d4 < this.length; d4++)
        h = -(this.words[d4] | 0) + b2, b2 = h >> 26, this.words[d4] = h & 67108863;
      return this.negative = 1, this._strip();
    }, i.prototype._wordDiv = function(f, a) {
      var u = this.length - f.length, l = this.clone(), d4 = f, h = d4.words[d4.length - 1] | 0, b2 = this._countBits(h);
      u = 26 - b2, u !== 0 && (d4 = d4.ushln(u), l.iushln(u), h = d4.words[d4.length - 1] | 0);
      var m3 = l.length - d4.length, s;
      if (a !== "mod") {
        s = new i(null), s.length = m3 + 1, s.words = new Array(s.length);
        for (var g2 = 0; g2 < s.length; g2++)
          s.words[g2] = 0;
      }
      var q = l.clone()._ishlnsubmul(d4, 1, m3);
      q.negative === 0 && (l = q, s && (s.words[m3] = 1));
      for (var R3 = m3 - 1; R3 >= 0; R3--) {
        var B3 = (l.words[d4.length + R3] | 0) * 67108864 + (l.words[d4.length + R3 - 1] | 0);
        for (B3 = Math.min(B3 / h | 0, 67108863), l._ishlnsubmul(d4, B3, R3); l.negative !== 0; )
          B3--, l.negative = 0, l._ishlnsubmul(d4, 1, R3), l.isZero() || (l.negative ^= 1);
        s && (s.words[R3] = B3);
      }
      return s && s._strip(), l._strip(), a !== "div" && u !== 0 && l.iushrn(u), { div: s || null, mod: l };
    }, i.prototype.divmod = function(f, a, u) {
      if (r(!f.isZero()), this.isZero())
        return { div: new i(0), mod: new i(0) };
      var l, d4, h;
      return this.negative !== 0 && f.negative === 0 ? (h = this.neg().divmod(f, a), a !== "mod" && (l = h.div.neg()), a !== "div" && (d4 = h.mod.neg(), u && d4.negative !== 0 && d4.iadd(f)), { div: l, mod: d4 }) : this.negative === 0 && f.negative !== 0 ? (h = this.divmod(f.neg(), a), a !== "mod" && (l = h.div.neg()), { div: l, mod: h.mod }) : (this.negative & f.negative) !== 0 ? (h = this.neg().divmod(f.neg(), a), a !== "div" && (d4 = h.mod.neg(), u && d4.negative !== 0 && d4.isub(f)), { div: h.div, mod: d4 }) : f.length > this.length || this.cmp(f) < 0 ? { div: new i(0), mod: this } : f.length === 1 ? a === "div" ? { div: this.divn(f.words[0]), mod: null } : a === "mod" ? { div: null, mod: new i(this.modrn(f.words[0])) } : { div: this.divn(f.words[0]), mod: new i(this.modrn(f.words[0])) } : this._wordDiv(f, a);
    }, i.prototype.div = function(f) {
      return this.divmod(f, "div", false).div;
    }, i.prototype.mod = function(f) {
      return this.divmod(f, "mod", false).mod;
    }, i.prototype.umod = function(f) {
      return this.divmod(f, "mod", true).mod;
    }, i.prototype.divRound = function(f) {
      var a = this.divmod(f);
      if (a.mod.isZero())
        return a.div;
      var u = a.div.negative !== 0 ? a.mod.isub(f) : a.mod, l = f.ushrn(1), d4 = f.andln(1), h = u.cmp(l);
      return h < 0 || d4 === 1 && h === 0 ? a.div : a.div.negative !== 0 ? a.div.isubn(1) : a.div.iaddn(1);
    }, i.prototype.modrn = function(f) {
      var a = f < 0;
      a && (f = -f), r(f <= 67108863);
      for (var u = (1 << 26) % f, l = 0, d4 = this.length - 1; d4 >= 0; d4--)
        l = (u * l + (this.words[d4] | 0)) % f;
      return a ? -l : l;
    }, i.prototype.modn = function(f) {
      return this.modrn(f);
    }, i.prototype.idivn = function(f) {
      var a = f < 0;
      a && (f = -f), r(f <= 67108863);
      for (var u = 0, l = this.length - 1; l >= 0; l--) {
        var d4 = (this.words[l] | 0) + u * 67108864;
        this.words[l] = d4 / f | 0, u = d4 % f;
      }
      return this._strip(), a ? this.ineg() : this;
    }, i.prototype.divn = function(f) {
      return this.clone().idivn(f);
    }, i.prototype.egcd = function(f) {
      r(f.negative === 0), r(!f.isZero());
      var a = this, u = f.clone();
      a.negative !== 0 ? a = a.umod(f) : a = a.clone();
      for (var l = new i(1), d4 = new i(0), h = new i(0), b2 = new i(1), m3 = 0; a.isEven() && u.isEven(); )
        a.iushrn(1), u.iushrn(1), ++m3;
      for (var s = u.clone(), g2 = a.clone(); !a.isZero(); ) {
        for (var q = 0, R3 = 1; (a.words[0] & R3) === 0 && q < 26; ++q, R3 <<= 1)
          ;
        if (q > 0)
          for (a.iushrn(q); q-- > 0; )
            (l.isOdd() || d4.isOdd()) && (l.iadd(s), d4.isub(g2)), l.iushrn(1), d4.iushrn(1);
        for (var B3 = 0, P2 = 1; (u.words[0] & P2) === 0 && B3 < 26; ++B3, P2 <<= 1)
          ;
        if (B3 > 0)
          for (u.iushrn(B3); B3-- > 0; )
            (h.isOdd() || b2.isOdd()) && (h.iadd(s), b2.isub(g2)), h.iushrn(1), b2.iushrn(1);
        a.cmp(u) >= 0 ? (a.isub(u), l.isub(h), d4.isub(b2)) : (u.isub(a), h.isub(l), b2.isub(d4));
      }
      return { a: h, b: b2, gcd: u.iushln(m3) };
    }, i.prototype._invmp = function(f) {
      r(f.negative === 0), r(!f.isZero());
      var a = this, u = f.clone();
      a.negative !== 0 ? a = a.umod(f) : a = a.clone();
      for (var l = new i(1), d4 = new i(0), h = u.clone(); a.cmpn(1) > 0 && u.cmpn(1) > 0; ) {
        for (var b2 = 0, m3 = 1; (a.words[0] & m3) === 0 && b2 < 26; ++b2, m3 <<= 1)
          ;
        if (b2 > 0)
          for (a.iushrn(b2); b2-- > 0; )
            l.isOdd() && l.iadd(h), l.iushrn(1);
        for (var s = 0, g2 = 1; (u.words[0] & g2) === 0 && s < 26; ++s, g2 <<= 1)
          ;
        if (s > 0)
          for (u.iushrn(s); s-- > 0; )
            d4.isOdd() && d4.iadd(h), d4.iushrn(1);
        a.cmp(u) >= 0 ? (a.isub(u), l.isub(d4)) : (u.isub(a), d4.isub(l));
      }
      var q;
      return a.cmpn(1) === 0 ? q = l : q = d4, q.cmpn(0) < 0 && q.iadd(f), q;
    }, i.prototype.gcd = function(f) {
      if (this.isZero())
        return f.abs();
      if (f.isZero())
        return this.abs();
      var a = this.clone(), u = f.clone();
      a.negative = 0, u.negative = 0;
      for (var l = 0; a.isEven() && u.isEven(); l++)
        a.iushrn(1), u.iushrn(1);
      do {
        for (; a.isEven(); )
          a.iushrn(1);
        for (; u.isEven(); )
          u.iushrn(1);
        var d4 = a.cmp(u);
        if (d4 < 0) {
          var h = a;
          a = u, u = h;
        } else if (d4 === 0 || u.cmpn(1) === 0)
          break;
        a.isub(u);
      } while (true);
      return u.iushln(l);
    }, i.prototype.invm = function(f) {
      return this.egcd(f).a.umod(f);
    }, i.prototype.isEven = function() {
      return (this.words[0] & 1) === 0;
    }, i.prototype.isOdd = function() {
      return (this.words[0] & 1) === 1;
    }, i.prototype.andln = function(f) {
      return this.words[0] & f;
    }, i.prototype.bincn = function(f) {
      r(typeof f == "number");
      var a = f % 26, u = (f - a) / 26, l = 1 << a;
      if (this.length <= u)
        return this._expand(u + 1), this.words[u] |= l, this;
      for (var d4 = l, h = u; d4 !== 0 && h < this.length; h++) {
        var b2 = this.words[h] | 0;
        b2 += d4, d4 = b2 >>> 26, b2 &= 67108863, this.words[h] = b2;
      }
      return d4 !== 0 && (this.words[h] = d4, this.length++), this;
    }, i.prototype.isZero = function() {
      return this.length === 1 && this.words[0] === 0;
    }, i.prototype.cmpn = function(f) {
      var a = f < 0;
      if (this.negative !== 0 && !a)
        return -1;
      if (this.negative === 0 && a)
        return 1;
      this._strip();
      var u;
      if (this.length > 1)
        u = 1;
      else {
        a && (f = -f), r(f <= 67108863, "Number is too big");
        var l = this.words[0] | 0;
        u = l === f ? 0 : l < f ? -1 : 1;
      }
      return this.negative !== 0 ? -u | 0 : u;
    }, i.prototype.cmp = function(f) {
      if (this.negative !== 0 && f.negative === 0)
        return -1;
      if (this.negative === 0 && f.negative !== 0)
        return 1;
      var a = this.ucmp(f);
      return this.negative !== 0 ? -a | 0 : a;
    }, i.prototype.ucmp = function(f) {
      if (this.length > f.length)
        return 1;
      if (this.length < f.length)
        return -1;
      for (var a = 0, u = this.length - 1; u >= 0; u--) {
        var l = this.words[u] | 0, d4 = f.words[u] | 0;
        if (l !== d4) {
          l < d4 ? a = -1 : l > d4 && (a = 1);
          break;
        }
      }
      return a;
    }, i.prototype.gtn = function(f) {
      return this.cmpn(f) === 1;
    }, i.prototype.gt = function(f) {
      return this.cmp(f) === 1;
    }, i.prototype.gten = function(f) {
      return this.cmpn(f) >= 0;
    }, i.prototype.gte = function(f) {
      return this.cmp(f) >= 0;
    }, i.prototype.ltn = function(f) {
      return this.cmpn(f) === -1;
    }, i.prototype.lt = function(f) {
      return this.cmp(f) === -1;
    }, i.prototype.lten = function(f) {
      return this.cmpn(f) <= 0;
    }, i.prototype.lte = function(f) {
      return this.cmp(f) <= 0;
    }, i.prototype.eqn = function(f) {
      return this.cmpn(f) === 0;
    }, i.prototype.eq = function(f) {
      return this.cmp(f) === 0;
    }, i.red = function(f) {
      return new v2(f);
    }, i.prototype.toRed = function(f) {
      return r(!this.red, "Already a number in reduction context"), r(this.negative === 0, "red works only with positives"), f.convertTo(this)._forceRed(f);
    }, i.prototype.fromRed = function() {
      return r(this.red, "fromRed works only with numbers in reduction context"), this.red.convertFrom(this);
    }, i.prototype._forceRed = function(f) {
      return this.red = f, this;
    }, i.prototype.forceRed = function(f) {
      return r(!this.red, "Already a number in reduction context"), this._forceRed(f);
    }, i.prototype.redAdd = function(f) {
      return r(this.red, "redAdd works only with red numbers"), this.red.add(this, f);
    }, i.prototype.redIAdd = function(f) {
      return r(this.red, "redIAdd works only with red numbers"), this.red.iadd(this, f);
    }, i.prototype.redSub = function(f) {
      return r(this.red, "redSub works only with red numbers"), this.red.sub(this, f);
    }, i.prototype.redISub = function(f) {
      return r(this.red, "redISub works only with red numbers"), this.red.isub(this, f);
    }, i.prototype.redShl = function(f) {
      return r(this.red, "redShl works only with red numbers"), this.red.shl(this, f);
    }, i.prototype.redMul = function(f) {
      return r(this.red, "redMul works only with red numbers"), this.red._verify2(this, f), this.red.mul(this, f);
    }, i.prototype.redIMul = function(f) {
      return r(this.red, "redMul works only with red numbers"), this.red._verify2(this, f), this.red.imul(this, f);
    }, i.prototype.redSqr = function() {
      return r(this.red, "redSqr works only with red numbers"), this.red._verify1(this), this.red.sqr(this);
    }, i.prototype.redISqr = function() {
      return r(this.red, "redISqr works only with red numbers"), this.red._verify1(this), this.red.isqr(this);
    }, i.prototype.redSqrt = function() {
      return r(this.red, "redSqrt works only with red numbers"), this.red._verify1(this), this.red.sqrt(this);
    }, i.prototype.redInvm = function() {
      return r(this.red, "redInvm works only with red numbers"), this.red._verify1(this), this.red.invm(this);
    }, i.prototype.redNeg = function() {
      return r(this.red, "redNeg works only with red numbers"), this.red._verify1(this), this.red.neg(this);
    }, i.prototype.redPow = function(f) {
      return r(this.red && !f.red, "redPow(normalNum)"), this.red._verify1(this), this.red.pow(this, f);
    };
    var ke = { k256: null, p224: null, p192: null, p25519: null };
    function Me(c5, f) {
      this.name = c5, this.p = new i(f, 16), this.n = this.p.bitLength(), this.k = new i(1).iushln(this.n).isub(this.p), this.tmp = this._tmp();
    }
    Me.prototype._tmp = function() {
      var f = new i(null);
      return f.words = new Array(Math.ceil(this.n / 13)), f;
    }, Me.prototype.ireduce = function(f) {
      var a = f, u;
      do
        this.split(a, this.tmp), a = this.imulK(a), a = a.iadd(this.tmp), u = a.bitLength();
      while (u > this.n);
      var l = u < this.n ? -1 : a.ucmp(this.p);
      return l === 0 ? (a.words[0] = 0, a.length = 1) : l > 0 ? a.isub(this.p) : a.strip !== void 0 ? a.strip() : a._strip(), a;
    }, Me.prototype.split = function(f, a) {
      f.iushrn(this.n, 0, a);
    }, Me.prototype.imulK = function(f) {
      return f.imul(this.k);
    };
    function Ce3() {
      Me.call(this, "k256", "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f");
    }
    n(Ce3, Me), Ce3.prototype.split = function(f, a) {
      for (var u = 4194303, l = Math.min(f.length, 9), d4 = 0; d4 < l; d4++)
        a.words[d4] = f.words[d4];
      if (a.length = l, f.length <= 9) {
        f.words[0] = 0, f.length = 1;
        return;
      }
      var h = f.words[9];
      for (a.words[a.length++] = h & u, d4 = 10; d4 < f.length; d4++) {
        var b2 = f.words[d4] | 0;
        f.words[d4 - 10] = (b2 & u) << 4 | h >>> 22, h = b2;
      }
      h >>>= 22, f.words[d4 - 10] = h, h === 0 && f.length > 10 ? f.length -= 10 : f.length -= 9;
    }, Ce3.prototype.imulK = function(f) {
      f.words[f.length] = 0, f.words[f.length + 1] = 0, f.length += 2;
      for (var a = 0, u = 0; u < f.length; u++) {
        var l = f.words[u] | 0;
        a += l * 977, f.words[u] = a & 67108863, a = l * 64 + (a / 67108864 | 0);
      }
      return f.words[f.length - 1] === 0 && (f.length--, f.words[f.length - 1] === 0 && f.length--), f;
    };
    function Ee2() {
      Me.call(this, "p224", "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001");
    }
    n(Ee2, Me);
    function Ne3() {
      Me.call(this, "p192", "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff");
    }
    n(Ne3, Me);
    function S3() {
      Me.call(this, "25519", "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed");
    }
    n(S3, Me), S3.prototype.imulK = function(f) {
      for (var a = 0, u = 0; u < f.length; u++) {
        var l = (f.words[u] | 0) * 19 + a, d4 = l & 67108863;
        l >>>= 26, f.words[u] = d4, a = l;
      }
      return a !== 0 && (f.words[f.length++] = a), f;
    }, i._prime = function(f) {
      if (ke[f])
        return ke[f];
      var a;
      if (f === "k256")
        a = new Ce3();
      else if (f === "p224")
        a = new Ee2();
      else if (f === "p192")
        a = new Ne3();
      else if (f === "p25519")
        a = new S3();
      else
        throw new Error("Unknown prime " + f);
      return ke[f] = a, a;
    };
    function v2(c5) {
      if (typeof c5 == "string") {
        var f = i._prime(c5);
        this.m = f.p, this.prime = f;
      } else
        r(c5.gtn(1), "modulus must be greater than 1"), this.m = c5, this.prime = null;
    }
    v2.prototype._verify1 = function(f) {
      r(f.negative === 0, "red works only with positives"), r(f.red, "red works only with red numbers");
    }, v2.prototype._verify2 = function(f, a) {
      r((f.negative | a.negative) === 0, "red works only with positives"), r(f.red && f.red === a.red, "red works only with red numbers");
    }, v2.prototype.imod = function(f) {
      return this.prime ? this.prime.ireduce(f)._forceRed(this) : (x(f, f.umod(this.m)._forceRed(this)), f);
    }, v2.prototype.neg = function(f) {
      return f.isZero() ? f.clone() : this.m.sub(f)._forceRed(this);
    }, v2.prototype.add = function(f, a) {
      this._verify2(f, a);
      var u = f.add(a);
      return u.cmp(this.m) >= 0 && u.isub(this.m), u._forceRed(this);
    }, v2.prototype.iadd = function(f, a) {
      this._verify2(f, a);
      var u = f.iadd(a);
      return u.cmp(this.m) >= 0 && u.isub(this.m), u;
    }, v2.prototype.sub = function(f, a) {
      this._verify2(f, a);
      var u = f.sub(a);
      return u.cmpn(0) < 0 && u.iadd(this.m), u._forceRed(this);
    }, v2.prototype.isub = function(f, a) {
      this._verify2(f, a);
      var u = f.isub(a);
      return u.cmpn(0) < 0 && u.iadd(this.m), u;
    }, v2.prototype.shl = function(f, a) {
      return this._verify1(f), this.imod(f.ushln(a));
    }, v2.prototype.imul = function(f, a) {
      return this._verify2(f, a), this.imod(f.imul(a));
    }, v2.prototype.mul = function(f, a) {
      return this._verify2(f, a), this.imod(f.mul(a));
    }, v2.prototype.isqr = function(f) {
      return this.imul(f, f.clone());
    }, v2.prototype.sqr = function(f) {
      return this.mul(f, f);
    }, v2.prototype.sqrt = function(f) {
      if (f.isZero())
        return f.clone();
      var a = this.m.andln(3);
      if (r(a % 2 === 1), a === 3) {
        var u = this.m.add(new i(1)).iushrn(2);
        return this.pow(f, u);
      }
      for (var l = this.m.subn(1), d4 = 0; !l.isZero() && l.andln(1) === 0; )
        d4++, l.iushrn(1);
      r(!l.isZero());
      var h = new i(1).toRed(this), b2 = h.redNeg(), m3 = this.m.subn(1).iushrn(1), s = this.m.bitLength();
      for (s = new i(2 * s * s).toRed(this); this.pow(s, m3).cmp(b2) !== 0; )
        s.redIAdd(b2);
      for (var g2 = this.pow(s, l), q = this.pow(f, l.addn(1).iushrn(1)), R3 = this.pow(f, l), B3 = d4; R3.cmp(h) !== 0; ) {
        for (var P2 = R3, T4 = 0; P2.cmp(h) !== 0; T4++)
          P2 = P2.redSqr();
        r(T4 < B3);
        var N4 = this.pow(g2, new i(1).iushln(B3 - T4 - 1));
        q = q.redMul(N4), g2 = N4.redSqr(), R3 = R3.redMul(g2), B3 = T4;
      }
      return q;
    }, v2.prototype.invm = function(f) {
      var a = f._invmp(this.m);
      return a.negative !== 0 ? (a.negative = 0, this.imod(a).redNeg()) : this.imod(a);
    }, v2.prototype.pow = function(f, a) {
      if (a.isZero())
        return new i(1).toRed(this);
      if (a.cmpn(1) === 0)
        return f.clone();
      var u = 4, l = new Array(1 << u);
      l[0] = new i(1).toRed(this), l[1] = f;
      for (var d4 = 2; d4 < l.length; d4++)
        l[d4] = this.mul(l[d4 - 1], f);
      var h = l[0], b2 = 0, m3 = 0, s = a.bitLength() % 26;
      for (s === 0 && (s = 26), d4 = a.length - 1; d4 >= 0; d4--) {
        for (var g2 = a.words[d4], q = s - 1; q >= 0; q--) {
          var R3 = g2 >> q & 1;
          if (h !== l[0] && (h = this.sqr(h)), R3 === 0 && b2 === 0) {
            m3 = 0;
            continue;
          }
          b2 <<= 1, b2 |= R3, m3++, !(m3 !== u && (d4 !== 0 || q !== 0)) && (h = this.mul(h, l[b2]), m3 = 0, b2 = 0);
        }
        s = 26;
      }
      return h;
    }, v2.prototype.convertTo = function(f) {
      var a = f.umod(this.m);
      return a === f ? a.clone() : a;
    }, v2.prototype.convertFrom = function(f) {
      var a = f.clone();
      return a.red = null, a;
    }, i.mont = function(f) {
      return new _2(f);
    };
    function _2(c5) {
      v2.call(this, c5), this.shift = this.m.bitLength(), this.shift % 26 !== 0 && (this.shift += 26 - this.shift % 26), this.r = new i(1).iushln(this.shift), this.r2 = this.imod(this.r.sqr()), this.rinv = this.r._invmp(this.m), this.minv = this.rinv.mul(this.r).isubn(1).div(this.m), this.minv = this.minv.umod(this.r), this.minv = this.r.sub(this.minv);
    }
    n(_2, v2), _2.prototype.convertTo = function(f) {
      return this.imod(f.ushln(this.shift));
    }, _2.prototype.convertFrom = function(f) {
      var a = this.imod(f.mul(this.rinv));
      return a.red = null, a;
    }, _2.prototype.imul = function(f, a) {
      if (f.isZero() || a.isZero())
        return f.words[0] = 0, f.length = 1, f;
      var u = f.imul(a), l = u.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), d4 = u.isub(l).iushrn(this.shift), h = d4;
      return d4.cmp(this.m) >= 0 ? h = d4.isub(this.m) : d4.cmpn(0) < 0 && (h = d4.iadd(this.m)), h._forceRed(this);
    }, _2.prototype.mul = function(f, a) {
      if (f.isZero() || a.isZero())
        return new i(0)._forceRed(this);
      var u = f.mul(a), l = u.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), d4 = u.isub(l).iushrn(this.shift), h = d4;
      return d4.cmp(this.m) >= 0 ? h = d4.isub(this.m) : d4.cmpn(0) < 0 && (h = d4.iadd(this.m)), h._forceRed(this);
    }, _2.prototype.invm = function(f) {
      var a = this.imod(f._invmp(this.m).mul(this.r2));
      return a._forceRed(this);
    };
  })(typeof F0 == "undefined" || F0, ud);
});
var Hn2 = k4((vm, vd) => {
  var Ki2 = dd2(), n6 = fi2();
  function a6(t) {
    var e = cd(t), r = e.toRed(Ki2.mont(t.modulus)).redPow(new Ki2(t.publicExponent)).fromRed();
    return { blinder: r, unblinder: e.invm(t.modulus) };
  }
  function cd(t) {
    var e = t.modulus.byteLength(), r;
    do
      r = new Ki2(n6(e));
    while (r.cmp(t.modulus) >= 0 || !r.umod(t.prime1) || !r.umod(t.prime2));
    return r;
  }
  function ld(t, e) {
    var r = a6(e), n = e.modulus.byteLength(), i = new Ki2(t).mul(r.blinder).umod(e.modulus), o2 = i.toRed(Ki2.mont(e.prime1)), p3 = i.toRed(Ki2.mont(e.prime2)), y4 = e.coefficient, w2 = e.prime1, x = e.prime2, M4 = o2.redPow(e.exponent1).fromRed(), E2 = p3.redPow(e.exponent2).fromRed(), A4 = M4.isub(E2).imul(y4).umod(w2).imul(x);
    return E2.iadd(A4).imul(r.unblinder).umod(e.modulus).toArrayLike(ut, "be", n);
  }
  ld.getr = cd;
  vd.exports = ld;
});
var pd2 = k4((pm, s6) => {
  s6.exports = { name: "elliptic", version: "6.5.4", description: "EC cryptography", main: "lib/elliptic.js", files: ["lib"], scripts: { lint: "eslint lib test", "lint:fix": "npm run lint -- --fix", unit: "istanbul test _mocha --reporter=spec test/index.js", test: "npm run lint && npm run unit", version: "grunt dist && git add dist/" }, repository: { type: "git", url: "git@github.com:indutny/elliptic" }, keywords: ["EC", "Elliptic", "curve", "Cryptography"], author: "Fedor Indutny <fedor@indutny.com>", license: "MIT", bugs: { url: "https://github.com/indutny/elliptic/issues" }, homepage: "https://github.com/indutny/elliptic", devDependencies: { brfs: "^2.0.2", coveralls: "^3.1.0", eslint: "^7.6.0", grunt: "^1.2.1", "grunt-browserify": "^5.3.0", "grunt-cli": "^1.3.2", "grunt-contrib-connect": "^3.0.0", "grunt-contrib-copy": "^1.0.0", "grunt-contrib-uglify": "^5.0.0", "grunt-mocha-istanbul": "^5.0.2", "grunt-saucelabs": "^9.0.1", istanbul: "^0.4.5", mocha: "^8.0.1" }, dependencies: { "bn.js": "^4.11.9", brorand: "^1.1.0", "hash.js": "^1.0.0", "hmac-drbg": "^1.0.1", inherits: "^2.0.4", "minimalistic-assert": "^1.0.1", "minimalistic-crypto-utils": "^1.0.1" } };
});
var K02 = k4((gd) => {
  "use strict";
  var Fn = gd;
  function o6(t, e) {
    if (Array.isArray(t))
      return t.slice();
    if (!t)
      return [];
    var r = [];
    if (typeof t != "string") {
      for (var n = 0; n < t.length; n++)
        r[n] = t[n] | 0;
      return r;
    }
    if (e === "hex") {
      t = t.replace(/[^a-z0-9]+/ig, ""), t.length % 2 !== 0 && (t = "0" + t);
      for (var n = 0; n < t.length; n += 2)
        r.push(parseInt(t[n] + t[n + 1], 16));
    } else
      for (var n = 0; n < t.length; n++) {
        var i = t.charCodeAt(n), o2 = i >> 8, p3 = i & 255;
        o2 ? r.push(o2, p3) : r.push(p3);
      }
    return r;
  }
  Fn.toArray = o6;
  function bd(t) {
    return t.length === 1 ? "0" + t : t;
  }
  Fn.zero2 = bd;
  function md(t) {
    for (var e = "", r = 0; r < t.length; r++)
      e += bd(t[r].toString(16));
    return e;
  }
  Fn.toHex = md;
  Fn.encode = function(e, r) {
    return r === "hex" ? md(e) : e;
  };
});
var ht3 = k4((yd) => {
  "use strict";
  var Wt2 = yd, h6 = Fe2(), u6 = ot3(), Kn = K02();
  Wt2.assert = u6;
  Wt2.toArray = Kn.toArray;
  Wt2.zero2 = Kn.zero2;
  Wt2.toHex = Kn.toHex;
  Wt2.encode = Kn.encode;
  function d6(t, e, r) {
    var n = new Array(Math.max(t.bitLength(), r) + 1);
    n.fill(0);
    for (var i = 1 << e + 1, o2 = t.clone(), p3 = 0; p3 < n.length; p3++) {
      var y4, w2 = o2.andln(i - 1);
      o2.isOdd() ? (w2 > (i >> 1) - 1 ? y4 = (i >> 1) - w2 : y4 = w2, o2.isubn(y4)) : y4 = 0, n[p3] = y4, o2.iushrn(1);
    }
    return n;
  }
  Wt2.getNAF = d6;
  function c6(t, e) {
    var r = [[], []];
    t = t.clone(), e = e.clone();
    for (var n = 0, i = 0, o2; t.cmpn(-n) > 0 || e.cmpn(-i) > 0; ) {
      var p3 = t.andln(3) + n & 3, y4 = e.andln(3) + i & 3;
      p3 === 3 && (p3 = -1), y4 === 3 && (y4 = -1);
      var w2;
      (p3 & 1) === 0 ? w2 = 0 : (o2 = t.andln(7) + n & 7, (o2 === 3 || o2 === 5) && y4 === 2 ? w2 = -p3 : w2 = p3), r[0].push(w2);
      var x;
      (y4 & 1) === 0 ? x = 0 : (o2 = e.andln(7) + i & 7, (o2 === 3 || o2 === 5) && p3 === 2 ? x = -y4 : x = y4), r[1].push(x), 2 * n === w2 + 1 && (n = 1 - n), 2 * i === x + 1 && (i = 1 - i), t.iushrn(1), e.iushrn(1);
    }
    return r;
  }
  Wt2.getJSF = c6;
  function l6(t, e, r) {
    var n = "_" + e;
    t.prototype[e] = function() {
      return this[n] !== void 0 ? this[n] : this[n] = r.call(this);
    };
  }
  Wt2.cachedProperty = l6;
  function v6(t) {
    return typeof t == "string" ? Wt2.toArray(t, "hex") : t;
  }
  Wt2.parseBytes = v6;
  function p6(t) {
    return new h6(t, "hex", "le");
  }
  Wt2.intFromLE = p6;
});
var Lf2 = k4((gm, _d) => {
  "use strict";
  var wi = Fe2(), Nf = ht3(), jn = Nf.getNAF, b6 = Nf.getJSF, Wn = Nf.assert;
  function Xr2(t, e) {
    this.type = t, this.p = new wi(e.p, 16), this.red = e.prime ? wi.red(e.prime) : wi.mont(this.p), this.zero = new wi(0).toRed(this.red), this.one = new wi(1).toRed(this.red), this.two = new wi(2).toRed(this.red), this.n = e.n && new wi(e.n, 16), this.g = e.g && this.pointFromJSON(e.g, e.gRed), this._wnafT1 = new Array(4), this._wnafT2 = new Array(4), this._wnafT3 = new Array(4), this._wnafT4 = new Array(4), this._bitLength = this.n ? this.n.bitLength() : 0;
    var r = this.n && this.p.div(this.n);
    !r || r.cmpn(100) > 0 ? this.redN = null : (this._maxwellTrick = true, this.redN = this.n.toRed(this.red));
  }
  _d.exports = Xr2;
  Xr2.prototype.point = function() {
    throw new Error("Not implemented");
  };
  Xr2.prototype.validate = function() {
    throw new Error("Not implemented");
  };
  Xr2.prototype._fixedNafMul = function(e, r) {
    Wn(e.precomputed);
    var n = e._getDoubles(), i = jn(r, 1, this._bitLength), o2 = (1 << n.step + 1) - (n.step % 2 === 0 ? 2 : 1);
    o2 /= 3;
    var p3 = [], y4, w2;
    for (y4 = 0; y4 < i.length; y4 += n.step) {
      w2 = 0;
      for (var x = y4 + n.step - 1; x >= y4; x--)
        w2 = (w2 << 1) + i[x];
      p3.push(w2);
    }
    for (var M4 = this.jpoint(null, null, null), E2 = this.jpoint(null, null, null), A4 = o2; A4 > 0; A4--) {
      for (y4 = 0; y4 < p3.length; y4++)
        w2 = p3[y4], w2 === A4 ? E2 = E2.mixedAdd(n.points[y4]) : w2 === -A4 && (E2 = E2.mixedAdd(n.points[y4].neg()));
      M4 = M4.add(E2);
    }
    return M4.toP();
  };
  Xr2.prototype._wnafMul = function(e, r) {
    var n = 4, i = e._getNAFPoints(n);
    n = i.wnd;
    for (var o2 = i.points, p3 = jn(r, n, this._bitLength), y4 = this.jpoint(null, null, null), w2 = p3.length - 1; w2 >= 0; w2--) {
      for (var x = 0; w2 >= 0 && p3[w2] === 0; w2--)
        x++;
      if (w2 >= 0 && x++, y4 = y4.dblp(x), w2 < 0)
        break;
      var M4 = p3[w2];
      Wn(M4 !== 0), e.type === "affine" ? M4 > 0 ? y4 = y4.mixedAdd(o2[M4 - 1 >> 1]) : y4 = y4.mixedAdd(o2[-M4 - 1 >> 1].neg()) : M4 > 0 ? y4 = y4.add(o2[M4 - 1 >> 1]) : y4 = y4.add(o2[-M4 - 1 >> 1].neg());
    }
    return e.type === "affine" ? y4.toP() : y4;
  };
  Xr2.prototype._wnafMulAdd = function(e, r, n, i, o2) {
    var p3 = this._wnafT1, y4 = this._wnafT2, w2 = this._wnafT3, x = 0, M4, E2, A4;
    for (M4 = 0; M4 < i; M4++) {
      A4 = r[M4];
      var I3 = A4._getNAFPoints(e);
      p3[M4] = I3.wnd, y4[M4] = I3.points;
    }
    for (M4 = i - 1; M4 >= 1; M4 -= 2) {
      var D6 = M4 - 1, C = M4;
      if (p3[D6] !== 1 || p3[C] !== 1) {
        w2[D6] = jn(n[D6], p3[D6], this._bitLength), w2[C] = jn(n[C], p3[C], this._bitLength), x = Math.max(w2[D6].length, x), x = Math.max(w2[C].length, x);
        continue;
      }
      var ge2 = [r[D6], null, null, r[C]];
      r[D6].y.cmp(r[C].y) === 0 ? (ge2[1] = r[D6].add(r[C]), ge2[2] = r[D6].toJ().mixedAdd(r[C].neg())) : r[D6].y.cmp(r[C].y.redNeg()) === 0 ? (ge2[1] = r[D6].toJ().mixedAdd(r[C]), ge2[2] = r[D6].add(r[C].neg())) : (ge2[1] = r[D6].toJ().mixedAdd(r[C]), ge2[2] = r[D6].toJ().mixedAdd(r[C].neg()));
      var L4 = [-3, -1, -5, -7, 0, 7, 5, 1, 3], ye = b6(n[D6], n[C]);
      for (x = Math.max(ye[0].length, x), w2[D6] = new Array(x), w2[C] = new Array(x), E2 = 0; E2 < x; E2++) {
        var Re = ye[0][E2] | 0, xe3 = ye[1][E2] | 0;
        w2[D6][E2] = L4[(Re + 1) * 3 + (xe3 + 1)], w2[C][E2] = 0, y4[D6] = ge2;
      }
    }
    var ke = this.jpoint(null, null, null), Me = this._wnafT4;
    for (M4 = x; M4 >= 0; M4--) {
      for (var Ce3 = 0; M4 >= 0; ) {
        var Ee2 = true;
        for (E2 = 0; E2 < i; E2++)
          Me[E2] = w2[E2][M4] | 0, Me[E2] !== 0 && (Ee2 = false);
        if (!Ee2)
          break;
        Ce3++, M4--;
      }
      if (M4 >= 0 && Ce3++, ke = ke.dblp(Ce3), M4 < 0)
        break;
      for (E2 = 0; E2 < i; E2++) {
        var Ne3 = Me[E2];
        Ne3 !== 0 && (Ne3 > 0 ? A4 = y4[E2][Ne3 - 1 >> 1] : Ne3 < 0 && (A4 = y4[E2][-Ne3 - 1 >> 1].neg()), A4.type === "affine" ? ke = ke.mixedAdd(A4) : ke = ke.add(A4));
      }
    }
    for (M4 = 0; M4 < i; M4++)
      y4[M4] = null;
    return o2 ? ke : ke.toP();
  };
  function gt2(t, e) {
    this.curve = t, this.type = e, this.precomputed = null;
  }
  Xr2.BasePoint = gt2;
  gt2.prototype.eq = function() {
    throw new Error("Not implemented");
  };
  gt2.prototype.validate = function() {
    return this.curve.validate(this);
  };
  Xr2.prototype.decodePoint = function(e, r) {
    e = Nf.toArray(e, r);
    var n = this.p.byteLength();
    if ((e[0] === 4 || e[0] === 6 || e[0] === 7) && e.length - 1 === 2 * n) {
      e[0] === 6 ? Wn(e[e.length - 1] % 2 === 0) : e[0] === 7 && Wn(e[e.length - 1] % 2 === 1);
      var i = this.point(e.slice(1, 1 + n), e.slice(1 + n, 1 + 2 * n));
      return i;
    } else if ((e[0] === 2 || e[0] === 3) && e.length - 1 === n)
      return this.pointFromX(e.slice(1, 1 + n), e[0] === 3);
    throw new Error("Unknown point format");
  };
  gt2.prototype.encodeCompressed = function(e) {
    return this.encode(e, true);
  };
  gt2.prototype._encode = function(e) {
    var r = this.curve.p.byteLength(), n = this.getX().toArray("be", r);
    return e ? [this.getY().isEven() ? 2 : 3].concat(n) : [4].concat(n, this.getY().toArray("be", r));
  };
  gt2.prototype.encode = function(e, r) {
    return Nf.encode(this._encode(r), e);
  };
  gt2.prototype.precompute = function(e) {
    if (this.precomputed)
      return this;
    var r = { doubles: null, naf: null, beta: null };
    return r.naf = this._getNAFPoints(8), r.doubles = this._getDoubles(4, e), r.beta = this._getBeta(), this.precomputed = r, this;
  };
  gt2.prototype._hasDoubles = function(e) {
    if (!this.precomputed)
      return false;
    var r = this.precomputed.doubles;
    return r ? r.points.length >= Math.ceil((e.bitLength() + 1) / r.step) : false;
  };
  gt2.prototype._getDoubles = function(e, r) {
    if (this.precomputed && this.precomputed.doubles)
      return this.precomputed.doubles;
    for (var n = [this], i = this, o2 = 0; o2 < r; o2 += e) {
      for (var p3 = 0; p3 < e; p3++)
        i = i.dbl();
      n.push(i);
    }
    return { step: e, points: n };
  };
  gt2.prototype._getNAFPoints = function(e) {
    if (this.precomputed && this.precomputed.naf)
      return this.precomputed.naf;
    for (var r = [this], n = (1 << e) - 1, i = n === 1 ? null : this.dbl(), o2 = 1; o2 < n; o2++)
      r[o2] = r[o2 - 1].add(i);
    return { wnd: e, points: r };
  };
  gt2.prototype._getBeta = function() {
    return null;
  };
  gt2.prototype.dblp = function(e) {
    for (var r = this, n = 0; n < e; n++)
      r = r.dbl();
    return r;
  };
});
var xd2 = k4((ym, wd) => {
  "use strict";
  var m6 = ht3(), Oe = Fe2(), j0 = qe2(), ji = Lf2(), g6 = m6.assert;
  function yt2(t) {
    ji.call(this, "short", t), this.a = new Oe(t.a, 16).toRed(this.red), this.b = new Oe(t.b, 16).toRed(this.red), this.tinv = this.two.redInvm(), this.zeroA = this.a.fromRed().cmpn(0) === 0, this.threeA = this.a.fromRed().sub(this.p).cmpn(-3) === 0, this.endo = this._getEndomorphism(t), this._endoWnafT1 = new Array(4), this._endoWnafT2 = new Array(4);
  }
  j0(yt2, ji);
  wd.exports = yt2;
  yt2.prototype._getEndomorphism = function(e) {
    if (!(!this.zeroA || !this.g || !this.n || this.p.modn(3) !== 1)) {
      var r, n;
      if (e.beta)
        r = new Oe(e.beta, 16).toRed(this.red);
      else {
        var i = this._getEndoRoots(this.p);
        r = i[0].cmp(i[1]) < 0 ? i[0] : i[1], r = r.toRed(this.red);
      }
      if (e.lambda)
        n = new Oe(e.lambda, 16);
      else {
        var o2 = this._getEndoRoots(this.n);
        this.g.mul(o2[0]).x.cmp(this.g.x.redMul(r)) === 0 ? n = o2[0] : (n = o2[1], g6(this.g.mul(n).x.cmp(this.g.x.redMul(r)) === 0));
      }
      var p3;
      return e.basis ? p3 = e.basis.map(function(y4) {
        return { a: new Oe(y4.a, 16), b: new Oe(y4.b, 16) };
      }) : p3 = this._getEndoBasis(n), { beta: r, lambda: n, basis: p3 };
    }
  };
  yt2.prototype._getEndoRoots = function(e) {
    var r = e === this.p ? this.red : Oe.mont(e), n = new Oe(2).toRed(r).redInvm(), i = n.redNeg(), o2 = new Oe(3).toRed(r).redNeg().redSqrt().redMul(n), p3 = i.redAdd(o2).fromRed(), y4 = i.redSub(o2).fromRed();
    return [p3, y4];
  };
  yt2.prototype._getEndoBasis = function(e) {
    for (var r = this.n.ushrn(Math.floor(this.n.bitLength() / 2)), n = e, i = this.n.clone(), o2 = new Oe(1), p3 = new Oe(0), y4 = new Oe(0), w2 = new Oe(1), x, M4, E2, A4, I3, D6, C, ge2 = 0, L4, ye; n.cmpn(0) !== 0; ) {
      var Re = i.div(n);
      L4 = i.sub(Re.mul(n)), ye = y4.sub(Re.mul(o2));
      var xe3 = w2.sub(Re.mul(p3));
      if (!E2 && L4.cmp(r) < 0)
        x = C.neg(), M4 = o2, E2 = L4.neg(), A4 = ye;
      else if (E2 && ++ge2 === 2)
        break;
      C = L4, i = n, n = L4, y4 = o2, o2 = ye, w2 = p3, p3 = xe3;
    }
    I3 = L4.neg(), D6 = ye;
    var ke = E2.sqr().add(A4.sqr()), Me = I3.sqr().add(D6.sqr());
    return Me.cmp(ke) >= 0 && (I3 = x, D6 = M4), E2.negative && (E2 = E2.neg(), A4 = A4.neg()), I3.negative && (I3 = I3.neg(), D6 = D6.neg()), [{ a: E2, b: A4 }, { a: I3, b: D6 }];
  };
  yt2.prototype._endoSplit = function(e) {
    var r = this.endo.basis, n = r[0], i = r[1], o2 = i.b.mul(e).divRound(this.n), p3 = n.b.neg().mul(e).divRound(this.n), y4 = o2.mul(n.a), w2 = p3.mul(i.a), x = o2.mul(n.b), M4 = p3.mul(i.b), E2 = e.sub(y4).sub(w2), A4 = x.add(M4).neg();
    return { k1: E2, k2: A4 };
  };
  yt2.prototype.pointFromX = function(e, r) {
    e = new Oe(e, 16), e.red || (e = e.toRed(this.red));
    var n = e.redSqr().redMul(e).redIAdd(e.redMul(this.a)).redIAdd(this.b), i = n.redSqrt();
    if (i.redSqr().redSub(n).cmp(this.zero) !== 0)
      throw new Error("invalid point");
    var o2 = i.fromRed().isOdd();
    return (r && !o2 || !r && o2) && (i = i.redNeg()), this.point(e, i);
  };
  yt2.prototype.validate = function(e) {
    if (e.inf)
      return true;
    var r = e.x, n = e.y, i = this.a.redMul(r), o2 = r.redSqr().redMul(r).redIAdd(i).redIAdd(this.b);
    return n.redSqr().redISub(o2).cmpn(0) === 0;
  };
  yt2.prototype._endoWnafMulAdd = function(e, r, n) {
    for (var i = this._endoWnafT1, o2 = this._endoWnafT2, p3 = 0; p3 < e.length; p3++) {
      var y4 = this._endoSplit(r[p3]), w2 = e[p3], x = w2._getBeta();
      y4.k1.negative && (y4.k1.ineg(), w2 = w2.neg(true)), y4.k2.negative && (y4.k2.ineg(), x = x.neg(true)), i[p3 * 2] = w2, i[p3 * 2 + 1] = x, o2[p3 * 2] = y4.k1, o2[p3 * 2 + 1] = y4.k2;
    }
    for (var M4 = this._wnafMulAdd(1, i, o2, p3 * 2, n), E2 = 0; E2 < p3 * 2; E2++)
      i[E2] = null, o2[E2] = null;
    return M4;
  };
  function We(t, e, r, n) {
    ji.BasePoint.call(this, t, "affine"), e === null && r === null ? (this.x = null, this.y = null, this.inf = true) : (this.x = new Oe(e, 16), this.y = new Oe(r, 16), n && (this.x.forceRed(this.curve.red), this.y.forceRed(this.curve.red)), this.x.red || (this.x = this.x.toRed(this.curve.red)), this.y.red || (this.y = this.y.toRed(this.curve.red)), this.inf = false);
  }
  j0(We, ji.BasePoint);
  yt2.prototype.point = function(e, r, n) {
    return new We(this, e, r, n);
  };
  yt2.prototype.pointFromJSON = function(e, r) {
    return We.fromJSON(this, e, r);
  };
  We.prototype._getBeta = function() {
    if (!!this.curve.endo) {
      var e = this.precomputed;
      if (e && e.beta)
        return e.beta;
      var r = this.curve.point(this.x.redMul(this.curve.endo.beta), this.y);
      if (e) {
        var n = this.curve, i = function(o2) {
          return n.point(o2.x.redMul(n.endo.beta), o2.y);
        };
        e.beta = r, r.precomputed = { beta: null, naf: e.naf && { wnd: e.naf.wnd, points: e.naf.points.map(i) }, doubles: e.doubles && { step: e.doubles.step, points: e.doubles.points.map(i) } };
      }
      return r;
    }
  };
  We.prototype.toJSON = function() {
    return this.precomputed ? [this.x, this.y, this.precomputed && { doubles: this.precomputed.doubles && { step: this.precomputed.doubles.step, points: this.precomputed.doubles.points.slice(1) }, naf: this.precomputed.naf && { wnd: this.precomputed.naf.wnd, points: this.precomputed.naf.points.slice(1) } }] : [this.x, this.y];
  };
  We.fromJSON = function(e, r, n) {
    typeof r == "string" && (r = JSON.parse(r));
    var i = e.point(r[0], r[1], n);
    if (!r[2])
      return i;
    function o2(y4) {
      return e.point(y4[0], y4[1], n);
    }
    var p3 = r[2];
    return i.precomputed = { beta: null, doubles: p3.doubles && { step: p3.doubles.step, points: [i].concat(p3.doubles.points.map(o2)) }, naf: p3.naf && { wnd: p3.naf.wnd, points: [i].concat(p3.naf.points.map(o2)) } }, i;
  };
  We.prototype.inspect = function() {
    return this.isInfinity() ? "<EC Point Infinity>" : "<EC Point x: " + this.x.fromRed().toString(16, 2) + " y: " + this.y.fromRed().toString(16, 2) + ">";
  };
  We.prototype.isInfinity = function() {
    return this.inf;
  };
  We.prototype.add = function(e) {
    if (this.inf)
      return e;
    if (e.inf)
      return this;
    if (this.eq(e))
      return this.dbl();
    if (this.neg().eq(e))
      return this.curve.point(null, null);
    if (this.x.cmp(e.x) === 0)
      return this.curve.point(null, null);
    var r = this.y.redSub(e.y);
    r.cmpn(0) !== 0 && (r = r.redMul(this.x.redSub(e.x).redInvm()));
    var n = r.redSqr().redISub(this.x).redISub(e.x), i = r.redMul(this.x.redSub(n)).redISub(this.y);
    return this.curve.point(n, i);
  };
  We.prototype.dbl = function() {
    if (this.inf)
      return this;
    var e = this.y.redAdd(this.y);
    if (e.cmpn(0) === 0)
      return this.curve.point(null, null);
    var r = this.curve.a, n = this.x.redSqr(), i = e.redInvm(), o2 = n.redAdd(n).redIAdd(n).redIAdd(r).redMul(i), p3 = o2.redSqr().redISub(this.x.redAdd(this.x)), y4 = o2.redMul(this.x.redSub(p3)).redISub(this.y);
    return this.curve.point(p3, y4);
  };
  We.prototype.getX = function() {
    return this.x.fromRed();
  };
  We.prototype.getY = function() {
    return this.y.fromRed();
  };
  We.prototype.mul = function(e) {
    return e = new Oe(e, 16), this.isInfinity() ? this : this._hasDoubles(e) ? this.curve._fixedNafMul(this, e) : this.curve.endo ? this.curve._endoWnafMulAdd([this], [e]) : this.curve._wnafMul(this, e);
  };
  We.prototype.mulAdd = function(e, r, n) {
    var i = [this, r], o2 = [e, n];
    return this.curve.endo ? this.curve._endoWnafMulAdd(i, o2) : this.curve._wnafMulAdd(1, i, o2, 2);
  };
  We.prototype.jmulAdd = function(e, r, n) {
    var i = [this, r], o2 = [e, n];
    return this.curve.endo ? this.curve._endoWnafMulAdd(i, o2, true) : this.curve._wnafMulAdd(1, i, o2, 2, true);
  };
  We.prototype.eq = function(e) {
    return this === e || this.inf === e.inf && (this.inf || this.x.cmp(e.x) === 0 && this.y.cmp(e.y) === 0);
  };
  We.prototype.neg = function(e) {
    if (this.inf)
      return this;
    var r = this.curve.point(this.x, this.y.redNeg());
    if (e && this.precomputed) {
      var n = this.precomputed, i = function(o2) {
        return o2.neg();
      };
      r.precomputed = { naf: n.naf && { wnd: n.naf.wnd, points: n.naf.points.map(i) }, doubles: n.doubles && { step: n.doubles.step, points: n.doubles.points.map(i) } };
    }
    return r;
  };
  We.prototype.toJ = function() {
    if (this.inf)
      return this.curve.jpoint(null, null, null);
    var e = this.curve.jpoint(this.x, this.y, this.curve.one);
    return e;
  };
  function Xe2(t, e, r, n) {
    ji.BasePoint.call(this, t, "jacobian"), e === null && r === null && n === null ? (this.x = this.curve.one, this.y = this.curve.one, this.z = new Oe(0)) : (this.x = new Oe(e, 16), this.y = new Oe(r, 16), this.z = new Oe(n, 16)), this.x.red || (this.x = this.x.toRed(this.curve.red)), this.y.red || (this.y = this.y.toRed(this.curve.red)), this.z.red || (this.z = this.z.toRed(this.curve.red)), this.zOne = this.z === this.curve.one;
  }
  j0(Xe2, ji.BasePoint);
  yt2.prototype.jpoint = function(e, r, n) {
    return new Xe2(this, e, r, n);
  };
  Xe2.prototype.toP = function() {
    if (this.isInfinity())
      return this.curve.point(null, null);
    var e = this.z.redInvm(), r = e.redSqr(), n = this.x.redMul(r), i = this.y.redMul(r).redMul(e);
    return this.curve.point(n, i);
  };
  Xe2.prototype.neg = function() {
    return this.curve.jpoint(this.x, this.y.redNeg(), this.z);
  };
  Xe2.prototype.add = function(e) {
    if (this.isInfinity())
      return e;
    if (e.isInfinity())
      return this;
    var r = e.z.redSqr(), n = this.z.redSqr(), i = this.x.redMul(r), o2 = e.x.redMul(n), p3 = this.y.redMul(r.redMul(e.z)), y4 = e.y.redMul(n.redMul(this.z)), w2 = i.redSub(o2), x = p3.redSub(y4);
    if (w2.cmpn(0) === 0)
      return x.cmpn(0) !== 0 ? this.curve.jpoint(null, null, null) : this.dbl();
    var M4 = w2.redSqr(), E2 = M4.redMul(w2), A4 = i.redMul(M4), I3 = x.redSqr().redIAdd(E2).redISub(A4).redISub(A4), D6 = x.redMul(A4.redISub(I3)).redISub(p3.redMul(E2)), C = this.z.redMul(e.z).redMul(w2);
    return this.curve.jpoint(I3, D6, C);
  };
  Xe2.prototype.mixedAdd = function(e) {
    if (this.isInfinity())
      return e.toJ();
    if (e.isInfinity())
      return this;
    var r = this.z.redSqr(), n = this.x, i = e.x.redMul(r), o2 = this.y, p3 = e.y.redMul(r).redMul(this.z), y4 = n.redSub(i), w2 = o2.redSub(p3);
    if (y4.cmpn(0) === 0)
      return w2.cmpn(0) !== 0 ? this.curve.jpoint(null, null, null) : this.dbl();
    var x = y4.redSqr(), M4 = x.redMul(y4), E2 = n.redMul(x), A4 = w2.redSqr().redIAdd(M4).redISub(E2).redISub(E2), I3 = w2.redMul(E2.redISub(A4)).redISub(o2.redMul(M4)), D6 = this.z.redMul(y4);
    return this.curve.jpoint(A4, I3, D6);
  };
  Xe2.prototype.dblp = function(e) {
    if (e === 0)
      return this;
    if (this.isInfinity())
      return this;
    if (!e)
      return this.dbl();
    var r;
    if (this.curve.zeroA || this.curve.threeA) {
      var n = this;
      for (r = 0; r < e; r++)
        n = n.dbl();
      return n;
    }
    var i = this.curve.a, o2 = this.curve.tinv, p3 = this.x, y4 = this.y, w2 = this.z, x = w2.redSqr().redSqr(), M4 = y4.redAdd(y4);
    for (r = 0; r < e; r++) {
      var E2 = p3.redSqr(), A4 = M4.redSqr(), I3 = A4.redSqr(), D6 = E2.redAdd(E2).redIAdd(E2).redIAdd(i.redMul(x)), C = p3.redMul(A4), ge2 = D6.redSqr().redISub(C.redAdd(C)), L4 = C.redISub(ge2), ye = D6.redMul(L4);
      ye = ye.redIAdd(ye).redISub(I3);
      var Re = M4.redMul(w2);
      r + 1 < e && (x = x.redMul(I3)), p3 = ge2, w2 = Re, M4 = ye;
    }
    return this.curve.jpoint(p3, M4.redMul(o2), w2);
  };
  Xe2.prototype.dbl = function() {
    return this.isInfinity() ? this : this.curve.zeroA ? this._zeroDbl() : this.curve.threeA ? this._threeDbl() : this._dbl();
  };
  Xe2.prototype._zeroDbl = function() {
    var e, r, n;
    if (this.zOne) {
      var i = this.x.redSqr(), o2 = this.y.redSqr(), p3 = o2.redSqr(), y4 = this.x.redAdd(o2).redSqr().redISub(i).redISub(p3);
      y4 = y4.redIAdd(y4);
      var w2 = i.redAdd(i).redIAdd(i), x = w2.redSqr().redISub(y4).redISub(y4), M4 = p3.redIAdd(p3);
      M4 = M4.redIAdd(M4), M4 = M4.redIAdd(M4), e = x, r = w2.redMul(y4.redISub(x)).redISub(M4), n = this.y.redAdd(this.y);
    } else {
      var E2 = this.x.redSqr(), A4 = this.y.redSqr(), I3 = A4.redSqr(), D6 = this.x.redAdd(A4).redSqr().redISub(E2).redISub(I3);
      D6 = D6.redIAdd(D6);
      var C = E2.redAdd(E2).redIAdd(E2), ge2 = C.redSqr(), L4 = I3.redIAdd(I3);
      L4 = L4.redIAdd(L4), L4 = L4.redIAdd(L4), e = ge2.redISub(D6).redISub(D6), r = C.redMul(D6.redISub(e)).redISub(L4), n = this.y.redMul(this.z), n = n.redIAdd(n);
    }
    return this.curve.jpoint(e, r, n);
  };
  Xe2.prototype._threeDbl = function() {
    var e, r, n;
    if (this.zOne) {
      var i = this.x.redSqr(), o2 = this.y.redSqr(), p3 = o2.redSqr(), y4 = this.x.redAdd(o2).redSqr().redISub(i).redISub(p3);
      y4 = y4.redIAdd(y4);
      var w2 = i.redAdd(i).redIAdd(i).redIAdd(this.curve.a), x = w2.redSqr().redISub(y4).redISub(y4);
      e = x;
      var M4 = p3.redIAdd(p3);
      M4 = M4.redIAdd(M4), M4 = M4.redIAdd(M4), r = w2.redMul(y4.redISub(x)).redISub(M4), n = this.y.redAdd(this.y);
    } else {
      var E2 = this.z.redSqr(), A4 = this.y.redSqr(), I3 = this.x.redMul(A4), D6 = this.x.redSub(E2).redMul(this.x.redAdd(E2));
      D6 = D6.redAdd(D6).redIAdd(D6);
      var C = I3.redIAdd(I3);
      C = C.redIAdd(C);
      var ge2 = C.redAdd(C);
      e = D6.redSqr().redISub(ge2), n = this.y.redAdd(this.z).redSqr().redISub(A4).redISub(E2);
      var L4 = A4.redSqr();
      L4 = L4.redIAdd(L4), L4 = L4.redIAdd(L4), L4 = L4.redIAdd(L4), r = D6.redMul(C.redISub(e)).redISub(L4);
    }
    return this.curve.jpoint(e, r, n);
  };
  Xe2.prototype._dbl = function() {
    var e = this.curve.a, r = this.x, n = this.y, i = this.z, o2 = i.redSqr().redSqr(), p3 = r.redSqr(), y4 = n.redSqr(), w2 = p3.redAdd(p3).redIAdd(p3).redIAdd(e.redMul(o2)), x = r.redAdd(r);
    x = x.redIAdd(x);
    var M4 = x.redMul(y4), E2 = w2.redSqr().redISub(M4.redAdd(M4)), A4 = M4.redISub(E2), I3 = y4.redSqr();
    I3 = I3.redIAdd(I3), I3 = I3.redIAdd(I3), I3 = I3.redIAdd(I3);
    var D6 = w2.redMul(A4).redISub(I3), C = n.redAdd(n).redMul(i);
    return this.curve.jpoint(E2, D6, C);
  };
  Xe2.prototype.trpl = function() {
    if (!this.curve.zeroA)
      return this.dbl().add(this);
    var e = this.x.redSqr(), r = this.y.redSqr(), n = this.z.redSqr(), i = r.redSqr(), o2 = e.redAdd(e).redIAdd(e), p3 = o2.redSqr(), y4 = this.x.redAdd(r).redSqr().redISub(e).redISub(i);
    y4 = y4.redIAdd(y4), y4 = y4.redAdd(y4).redIAdd(y4), y4 = y4.redISub(p3);
    var w2 = y4.redSqr(), x = i.redIAdd(i);
    x = x.redIAdd(x), x = x.redIAdd(x), x = x.redIAdd(x);
    var M4 = o2.redIAdd(y4).redSqr().redISub(p3).redISub(w2).redISub(x), E2 = r.redMul(M4);
    E2 = E2.redIAdd(E2), E2 = E2.redIAdd(E2);
    var A4 = this.x.redMul(w2).redISub(E2);
    A4 = A4.redIAdd(A4), A4 = A4.redIAdd(A4);
    var I3 = this.y.redMul(M4.redMul(x.redISub(M4)).redISub(y4.redMul(w2)));
    I3 = I3.redIAdd(I3), I3 = I3.redIAdd(I3), I3 = I3.redIAdd(I3);
    var D6 = this.z.redAdd(y4).redSqr().redISub(n).redISub(w2);
    return this.curve.jpoint(A4, I3, D6);
  };
  Xe2.prototype.mul = function(e, r) {
    return e = new Oe(e, r), this.curve._wnafMul(this, e);
  };
  Xe2.prototype.eq = function(e) {
    if (e.type === "affine")
      return this.eq(e.toJ());
    if (this === e)
      return true;
    var r = this.z.redSqr(), n = e.z.redSqr();
    if (this.x.redMul(n).redISub(e.x.redMul(r)).cmpn(0) !== 0)
      return false;
    var i = r.redMul(this.z), o2 = n.redMul(e.z);
    return this.y.redMul(o2).redISub(e.y.redMul(i)).cmpn(0) === 0;
  };
  Xe2.prototype.eqXToP = function(e) {
    var r = this.z.redSqr(), n = e.toRed(this.curve.red).redMul(r);
    if (this.x.cmp(n) === 0)
      return true;
    for (var i = e.clone(), o2 = this.curve.redN.redMul(r); ; ) {
      if (i.iadd(this.curve.n), i.cmp(this.curve.p) >= 0)
        return false;
      if (n.redIAdd(o2), this.x.cmp(n) === 0)
        return true;
    }
  };
  Xe2.prototype.inspect = function() {
    return this.isInfinity() ? "<EC JPoint Infinity>" : "<EC JPoint x: " + this.x.toString(16, 2) + " y: " + this.y.toString(16, 2) + " z: " + this.z.toString(16, 2) + ">";
  };
  Xe2.prototype.isInfinity = function() {
    return this.z.cmpn(0) === 0;
  };
});
var Ed2 = k4((_m, Sd) => {
  "use strict";
  var Wi = Fe2(), Md = qe2(), Vn = Lf2(), y6 = ht3();
  function Vi(t) {
    Vn.call(this, "mont", t), this.a = new Wi(t.a, 16).toRed(this.red), this.b = new Wi(t.b, 16).toRed(this.red), this.i4 = new Wi(4).toRed(this.red).redInvm(), this.two = new Wi(2).toRed(this.red), this.a24 = this.i4.redMul(this.a.redAdd(this.two));
  }
  Md(Vi, Vn);
  Sd.exports = Vi;
  Vi.prototype.validate = function(e) {
    var r = e.normalize().x, n = r.redSqr(), i = n.redMul(r).redAdd(n.redMul(this.a)).redAdd(r), o2 = i.redSqrt();
    return o2.redSqr().cmp(i) === 0;
  };
  function Ve2(t, e, r) {
    Vn.BasePoint.call(this, t, "projective"), e === null && r === null ? (this.x = this.curve.one, this.z = this.curve.zero) : (this.x = new Wi(e, 16), this.z = new Wi(r, 16), this.x.red || (this.x = this.x.toRed(this.curve.red)), this.z.red || (this.z = this.z.toRed(this.curve.red)));
  }
  Md(Ve2, Vn.BasePoint);
  Vi.prototype.decodePoint = function(e, r) {
    return this.point(y6.toArray(e, r), 1);
  };
  Vi.prototype.point = function(e, r) {
    return new Ve2(this, e, r);
  };
  Vi.prototype.pointFromJSON = function(e) {
    return Ve2.fromJSON(this, e);
  };
  Ve2.prototype.precompute = function() {
  };
  Ve2.prototype._encode = function() {
    return this.getX().toArray("be", this.curve.p.byteLength());
  };
  Ve2.fromJSON = function(e, r) {
    return new Ve2(e, r[0], r[1] || e.one);
  };
  Ve2.prototype.inspect = function() {
    return this.isInfinity() ? "<EC Point Infinity>" : "<EC Point x: " + this.x.fromRed().toString(16, 2) + " z: " + this.z.fromRed().toString(16, 2) + ">";
  };
  Ve2.prototype.isInfinity = function() {
    return this.z.cmpn(0) === 0;
  };
  Ve2.prototype.dbl = function() {
    var e = this.x.redAdd(this.z), r = e.redSqr(), n = this.x.redSub(this.z), i = n.redSqr(), o2 = r.redSub(i), p3 = r.redMul(i), y4 = o2.redMul(i.redAdd(this.curve.a24.redMul(o2)));
    return this.curve.point(p3, y4);
  };
  Ve2.prototype.add = function() {
    throw new Error("Not supported on Montgomery curve");
  };
  Ve2.prototype.diffAdd = function(e, r) {
    var n = this.x.redAdd(this.z), i = this.x.redSub(this.z), o2 = e.x.redAdd(e.z), p3 = e.x.redSub(e.z), y4 = p3.redMul(n), w2 = o2.redMul(i), x = r.z.redMul(y4.redAdd(w2).redSqr()), M4 = r.x.redMul(y4.redISub(w2).redSqr());
    return this.curve.point(x, M4);
  };
  Ve2.prototype.mul = function(e) {
    for (var r = e.clone(), n = this, i = this.curve.point(null, null), o2 = this, p3 = []; r.cmpn(0) !== 0; r.iushrn(1))
      p3.push(r.andln(1));
    for (var y4 = p3.length - 1; y4 >= 0; y4--)
      p3[y4] === 0 ? (n = n.diffAdd(i, o2), i = i.dbl()) : (i = n.diffAdd(i, o2), n = n.dbl());
    return i;
  };
  Ve2.prototype.mulAdd = function() {
    throw new Error("Not supported on Montgomery curve");
  };
  Ve2.prototype.jumlAdd = function() {
    throw new Error("Not supported on Montgomery curve");
  };
  Ve2.prototype.eq = function(e) {
    return this.getX().cmp(e.getX()) === 0;
  };
  Ve2.prototype.normalize = function() {
    return this.x = this.x.redMul(this.z.redInvm()), this.z = this.curve.one, this;
  };
  Ve2.prototype.getX = function() {
    return this.normalize(), this.x.fromRed();
  };
});
var Bd2 = k4((wm, qd) => {
  "use strict";
  var _6 = ht3(), _r2 = Fe2(), Ad = qe2(), Zn = Lf2(), w6 = _6.assert;
  function ir2(t) {
    this.twisted = (t.a | 0) !== 1, this.mOneA = this.twisted && (t.a | 0) === -1, this.extended = this.mOneA, Zn.call(this, "edwards", t), this.a = new _r2(t.a, 16).umod(this.red.m), this.a = this.a.toRed(this.red), this.c = new _r2(t.c, 16).toRed(this.red), this.c2 = this.c.redSqr(), this.d = new _r2(t.d, 16).toRed(this.red), this.dd = this.d.redAdd(this.d), w6(!this.twisted || this.c.fromRed().cmpn(1) === 0), this.oneC = (t.c | 0) === 1;
  }
  Ad(ir2, Zn);
  qd.exports = ir2;
  ir2.prototype._mulA = function(e) {
    return this.mOneA ? e.redNeg() : this.a.redMul(e);
  };
  ir2.prototype._mulC = function(e) {
    return this.oneC ? e : this.c.redMul(e);
  };
  ir2.prototype.jpoint = function(e, r, n, i) {
    return this.point(e, r, n, i);
  };
  ir2.prototype.pointFromX = function(e, r) {
    e = new _r2(e, 16), e.red || (e = e.toRed(this.red));
    var n = e.redSqr(), i = this.c2.redSub(this.a.redMul(n)), o2 = this.one.redSub(this.c2.redMul(this.d).redMul(n)), p3 = i.redMul(o2.redInvm()), y4 = p3.redSqrt();
    if (y4.redSqr().redSub(p3).cmp(this.zero) !== 0)
      throw new Error("invalid point");
    var w2 = y4.fromRed().isOdd();
    return (r && !w2 || !r && w2) && (y4 = y4.redNeg()), this.point(e, y4);
  };
  ir2.prototype.pointFromY = function(e, r) {
    e = new _r2(e, 16), e.red || (e = e.toRed(this.red));
    var n = e.redSqr(), i = n.redSub(this.c2), o2 = n.redMul(this.d).redMul(this.c2).redSub(this.a), p3 = i.redMul(o2.redInvm());
    if (p3.cmp(this.zero) === 0) {
      if (r)
        throw new Error("invalid point");
      return this.point(this.zero, e);
    }
    var y4 = p3.redSqrt();
    if (y4.redSqr().redSub(p3).cmp(this.zero) !== 0)
      throw new Error("invalid point");
    return y4.fromRed().isOdd() !== r && (y4 = y4.redNeg()), this.point(y4, e);
  };
  ir2.prototype.validate = function(e) {
    if (e.isInfinity())
      return true;
    e.normalize();
    var r = e.x.redSqr(), n = e.y.redSqr(), i = r.redMul(this.a).redAdd(n), o2 = this.c2.redMul(this.one.redAdd(this.d.redMul(r).redMul(n)));
    return i.cmp(o2) === 0;
  };
  function Te(t, e, r, n, i) {
    Zn.BasePoint.call(this, t, "projective"), e === null && r === null && n === null ? (this.x = this.curve.zero, this.y = this.curve.one, this.z = this.curve.one, this.t = this.curve.zero, this.zOne = true) : (this.x = new _r2(e, 16), this.y = new _r2(r, 16), this.z = n ? new _r2(n, 16) : this.curve.one, this.t = i && new _r2(i, 16), this.x.red || (this.x = this.x.toRed(this.curve.red)), this.y.red || (this.y = this.y.toRed(this.curve.red)), this.z.red || (this.z = this.z.toRed(this.curve.red)), this.t && !this.t.red && (this.t = this.t.toRed(this.curve.red)), this.zOne = this.z === this.curve.one, this.curve.extended && !this.t && (this.t = this.x.redMul(this.y), this.zOne || (this.t = this.t.redMul(this.z.redInvm()))));
  }
  Ad(Te, Zn.BasePoint);
  ir2.prototype.pointFromJSON = function(e) {
    return Te.fromJSON(this, e);
  };
  ir2.prototype.point = function(e, r, n, i) {
    return new Te(this, e, r, n, i);
  };
  Te.fromJSON = function(e, r) {
    return new Te(e, r[0], r[1], r[2]);
  };
  Te.prototype.inspect = function() {
    return this.isInfinity() ? "<EC Point Infinity>" : "<EC Point x: " + this.x.fromRed().toString(16, 2) + " y: " + this.y.fromRed().toString(16, 2) + " z: " + this.z.fromRed().toString(16, 2) + ">";
  };
  Te.prototype.isInfinity = function() {
    return this.x.cmpn(0) === 0 && (this.y.cmp(this.z) === 0 || this.zOne && this.y.cmp(this.curve.c) === 0);
  };
  Te.prototype._extDbl = function() {
    var e = this.x.redSqr(), r = this.y.redSqr(), n = this.z.redSqr();
    n = n.redIAdd(n);
    var i = this.curve._mulA(e), o2 = this.x.redAdd(this.y).redSqr().redISub(e).redISub(r), p3 = i.redAdd(r), y4 = p3.redSub(n), w2 = i.redSub(r), x = o2.redMul(y4), M4 = p3.redMul(w2), E2 = o2.redMul(w2), A4 = y4.redMul(p3);
    return this.curve.point(x, M4, A4, E2);
  };
  Te.prototype._projDbl = function() {
    var e = this.x.redAdd(this.y).redSqr(), r = this.x.redSqr(), n = this.y.redSqr(), i, o2, p3, y4, w2, x;
    if (this.curve.twisted) {
      y4 = this.curve._mulA(r);
      var M4 = y4.redAdd(n);
      this.zOne ? (i = e.redSub(r).redSub(n).redMul(M4.redSub(this.curve.two)), o2 = M4.redMul(y4.redSub(n)), p3 = M4.redSqr().redSub(M4).redSub(M4)) : (w2 = this.z.redSqr(), x = M4.redSub(w2).redISub(w2), i = e.redSub(r).redISub(n).redMul(x), o2 = M4.redMul(y4.redSub(n)), p3 = M4.redMul(x));
    } else
      y4 = r.redAdd(n), w2 = this.curve._mulC(this.z).redSqr(), x = y4.redSub(w2).redSub(w2), i = this.curve._mulC(e.redISub(y4)).redMul(x), o2 = this.curve._mulC(y4).redMul(r.redISub(n)), p3 = y4.redMul(x);
    return this.curve.point(i, o2, p3);
  };
  Te.prototype.dbl = function() {
    return this.isInfinity() ? this : this.curve.extended ? this._extDbl() : this._projDbl();
  };
  Te.prototype._extAdd = function(e) {
    var r = this.y.redSub(this.x).redMul(e.y.redSub(e.x)), n = this.y.redAdd(this.x).redMul(e.y.redAdd(e.x)), i = this.t.redMul(this.curve.dd).redMul(e.t), o2 = this.z.redMul(e.z.redAdd(e.z)), p3 = n.redSub(r), y4 = o2.redSub(i), w2 = o2.redAdd(i), x = n.redAdd(r), M4 = p3.redMul(y4), E2 = w2.redMul(x), A4 = p3.redMul(x), I3 = y4.redMul(w2);
    return this.curve.point(M4, E2, I3, A4);
  };
  Te.prototype._projAdd = function(e) {
    var r = this.z.redMul(e.z), n = r.redSqr(), i = this.x.redMul(e.x), o2 = this.y.redMul(e.y), p3 = this.curve.d.redMul(i).redMul(o2), y4 = n.redSub(p3), w2 = n.redAdd(p3), x = this.x.redAdd(this.y).redMul(e.x.redAdd(e.y)).redISub(i).redISub(o2), M4 = r.redMul(y4).redMul(x), E2, A4;
    return this.curve.twisted ? (E2 = r.redMul(w2).redMul(o2.redSub(this.curve._mulA(i))), A4 = y4.redMul(w2)) : (E2 = r.redMul(w2).redMul(o2.redSub(i)), A4 = this.curve._mulC(y4).redMul(w2)), this.curve.point(M4, E2, A4);
  };
  Te.prototype.add = function(e) {
    return this.isInfinity() ? e : e.isInfinity() ? this : this.curve.extended ? this._extAdd(e) : this._projAdd(e);
  };
  Te.prototype.mul = function(e) {
    return this._hasDoubles(e) ? this.curve._fixedNafMul(this, e) : this.curve._wnafMul(this, e);
  };
  Te.prototype.mulAdd = function(e, r, n) {
    return this.curve._wnafMulAdd(1, [this, r], [e, n], 2, false);
  };
  Te.prototype.jmulAdd = function(e, r, n) {
    return this.curve._wnafMulAdd(1, [this, r], [e, n], 2, true);
  };
  Te.prototype.normalize = function() {
    if (this.zOne)
      return this;
    var e = this.z.redInvm();
    return this.x = this.x.redMul(e), this.y = this.y.redMul(e), this.t && (this.t = this.t.redMul(e)), this.z = this.curve.one, this.zOne = true, this;
  };
  Te.prototype.neg = function() {
    return this.curve.point(this.x.redNeg(), this.y, this.z, this.t && this.t.redNeg());
  };
  Te.prototype.getX = function() {
    return this.normalize(), this.x.fromRed();
  };
  Te.prototype.getY = function() {
    return this.normalize(), this.y.fromRed();
  };
  Te.prototype.eq = function(e) {
    return this === e || this.getX().cmp(e.getX()) === 0 && this.getY().cmp(e.getY()) === 0;
  };
  Te.prototype.eqXToP = function(e) {
    var r = e.toRed(this.curve.red).redMul(this.z);
    if (this.x.cmp(r) === 0)
      return true;
    for (var n = e.clone(), i = this.curve.redN.redMul(this.z); ; ) {
      if (n.iadd(this.curve.n), n.cmp(this.curve.p) >= 0)
        return false;
      if (r.redIAdd(i), this.x.cmp(r) === 0)
        return true;
    }
  };
  Te.prototype.toP = Te.prototype.normalize;
  Te.prototype.mixedAdd = Te.prototype.add;
});
var W02 = k4((Rd) => {
  "use strict";
  var Gn = Rd;
  Gn.base = Lf2();
  Gn.short = xd2();
  Gn.mont = Ed2();
  Gn.edwards = Bd2();
});
var Vt2 = k4((Pe) => {
  "use strict";
  var x6 = ot3(), M6 = qe2();
  Pe.inherits = M6;
  function S6(t, e) {
    return (t.charCodeAt(e) & 64512) !== 55296 || e < 0 || e + 1 >= t.length ? false : (t.charCodeAt(e + 1) & 64512) === 56320;
  }
  function E6(t, e) {
    if (Array.isArray(t))
      return t.slice();
    if (!t)
      return [];
    var r = [];
    if (typeof t == "string")
      if (e) {
        if (e === "hex")
          for (t = t.replace(/[^a-z0-9]+/ig, ""), t.length % 2 !== 0 && (t = "0" + t), i = 0; i < t.length; i += 2)
            r.push(parseInt(t[i] + t[i + 1], 16));
      } else
        for (var n = 0, i = 0; i < t.length; i++) {
          var o2 = t.charCodeAt(i);
          o2 < 128 ? r[n++] = o2 : o2 < 2048 ? (r[n++] = o2 >> 6 | 192, r[n++] = o2 & 63 | 128) : S6(t, i) ? (o2 = 65536 + ((o2 & 1023) << 10) + (t.charCodeAt(++i) & 1023), r[n++] = o2 >> 18 | 240, r[n++] = o2 >> 12 & 63 | 128, r[n++] = o2 >> 6 & 63 | 128, r[n++] = o2 & 63 | 128) : (r[n++] = o2 >> 12 | 224, r[n++] = o2 >> 6 & 63 | 128, r[n++] = o2 & 63 | 128);
        }
    else
      for (i = 0; i < t.length; i++)
        r[i] = t[i] | 0;
    return r;
  }
  Pe.toArray = E6;
  function A6(t) {
    for (var e = "", r = 0; r < t.length; r++)
      e += kd(t[r].toString(16));
    return e;
  }
  Pe.toHex = A6;
  function Id(t) {
    var e = t >>> 24 | t >>> 8 & 65280 | t << 8 & 16711680 | (t & 255) << 24;
    return e >>> 0;
  }
  Pe.htonl = Id;
  function q6(t, e) {
    for (var r = "", n = 0; n < t.length; n++) {
      var i = t[n];
      e === "little" && (i = Id(i)), r += Dd(i.toString(16));
    }
    return r;
  }
  Pe.toHex32 = q6;
  function kd(t) {
    return t.length === 1 ? "0" + t : t;
  }
  Pe.zero2 = kd;
  function Dd(t) {
    return t.length === 7 ? "0" + t : t.length === 6 ? "00" + t : t.length === 5 ? "000" + t : t.length === 4 ? "0000" + t : t.length === 3 ? "00000" + t : t.length === 2 ? "000000" + t : t.length === 1 ? "0000000" + t : t;
  }
  Pe.zero8 = Dd;
  function B6(t, e, r, n) {
    var i = r - e;
    x6(i % 4 === 0);
    for (var o2 = new Array(i / 4), p3 = 0, y4 = e; p3 < o2.length; p3++, y4 += 4) {
      var w2;
      n === "big" ? w2 = t[y4] << 24 | t[y4 + 1] << 16 | t[y4 + 2] << 8 | t[y4 + 3] : w2 = t[y4 + 3] << 24 | t[y4 + 2] << 16 | t[y4 + 1] << 8 | t[y4], o2[p3] = w2 >>> 0;
    }
    return o2;
  }
  Pe.join32 = B6;
  function R6(t, e) {
    for (var r = new Array(t.length * 4), n = 0, i = 0; n < t.length; n++, i += 4) {
      var o2 = t[n];
      e === "big" ? (r[i] = o2 >>> 24, r[i + 1] = o2 >>> 16 & 255, r[i + 2] = o2 >>> 8 & 255, r[i + 3] = o2 & 255) : (r[i + 3] = o2 >>> 24, r[i + 2] = o2 >>> 16 & 255, r[i + 1] = o2 >>> 8 & 255, r[i] = o2 & 255);
    }
    return r;
  }
  Pe.split32 = R6;
  function I6(t, e) {
    return t >>> e | t << 32 - e;
  }
  Pe.rotr32 = I6;
  function k6(t, e) {
    return t << e | t >>> 32 - e;
  }
  Pe.rotl32 = k6;
  function D6(t, e) {
    return t + e >>> 0;
  }
  Pe.sum32 = D6;
  function P6(t, e, r) {
    return t + e + r >>> 0;
  }
  Pe.sum32_3 = P6;
  function T6(t, e, r, n) {
    return t + e + r + n >>> 0;
  }
  Pe.sum32_4 = T6;
  function C6(t, e, r, n, i) {
    return t + e + r + n + i >>> 0;
  }
  Pe.sum32_5 = C6;
  function N6(t, e, r, n) {
    var i = t[e], o2 = t[e + 1], p3 = n + o2 >>> 0, y4 = (p3 < n ? 1 : 0) + r + i;
    t[e] = y4 >>> 0, t[e + 1] = p3;
  }
  Pe.sum64 = N6;
  function L6(t, e, r, n) {
    var i = e + n >>> 0, o2 = (i < e ? 1 : 0) + t + r;
    return o2 >>> 0;
  }
  Pe.sum64_hi = L6;
  function O6(t, e, r, n) {
    var i = e + n;
    return i >>> 0;
  }
  Pe.sum64_lo = O6;
  function z6(t, e, r, n, i, o2, p3, y4) {
    var w2 = 0, x = e;
    x = x + n >>> 0, w2 += x < e ? 1 : 0, x = x + o2 >>> 0, w2 += x < o2 ? 1 : 0, x = x + y4 >>> 0, w2 += x < y4 ? 1 : 0;
    var M4 = t + r + i + p3 + w2;
    return M4 >>> 0;
  }
  Pe.sum64_4_hi = z6;
  function U6(t, e, r, n, i, o2, p3, y4) {
    var w2 = e + n + o2 + y4;
    return w2 >>> 0;
  }
  Pe.sum64_4_lo = U6;
  function H6(t, e, r, n, i, o2, p3, y4, w2, x) {
    var M4 = 0, E2 = e;
    E2 = E2 + n >>> 0, M4 += E2 < e ? 1 : 0, E2 = E2 + o2 >>> 0, M4 += E2 < o2 ? 1 : 0, E2 = E2 + y4 >>> 0, M4 += E2 < y4 ? 1 : 0, E2 = E2 + x >>> 0, M4 += E2 < x ? 1 : 0;
    var A4 = t + r + i + p3 + w2 + M4;
    return A4 >>> 0;
  }
  Pe.sum64_5_hi = H6;
  function F6(t, e, r, n, i, o2, p3, y4, w2, x) {
    var M4 = e + n + o2 + y4 + x;
    return M4 >>> 0;
  }
  Pe.sum64_5_lo = F6;
  function K6(t, e, r) {
    var n = e << 32 - r | t >>> r;
    return n >>> 0;
  }
  Pe.rotr64_hi = K6;
  function j6(t, e, r) {
    var n = t << 32 - r | e >>> r;
    return n >>> 0;
  }
  Pe.rotr64_lo = j6;
  function W6(t, e, r) {
    return t >>> r;
  }
  Pe.shr64_hi = W6;
  function V6(t, e, r) {
    var n = t << 32 - r | e >>> r;
    return n >>> 0;
  }
  Pe.shr64_lo = V6;
});
var Zi2 = k4((Td) => {
  "use strict";
  var Pd = Vt2(), Z6 = ot3();
  function Xn() {
    this.pending = null, this.pendingTotal = 0, this.blockSize = this.constructor.blockSize, this.outSize = this.constructor.outSize, this.hmacStrength = this.constructor.hmacStrength, this.padLength = this.constructor.padLength / 8, this.endian = "big", this._delta8 = this.blockSize / 8, this._delta32 = this.blockSize / 32;
  }
  Td.BlockHash = Xn;
  Xn.prototype.update = function(e, r) {
    if (e = Pd.toArray(e, r), this.pending ? this.pending = this.pending.concat(e) : this.pending = e, this.pendingTotal += e.length, this.pending.length >= this._delta8) {
      e = this.pending;
      var n = e.length % this._delta8;
      this.pending = e.slice(e.length - n, e.length), this.pending.length === 0 && (this.pending = null), e = Pd.join32(e, 0, e.length - n, this.endian);
      for (var i = 0; i < e.length; i += this._delta32)
        this._update(e, i, i + this._delta32);
    }
    return this;
  };
  Xn.prototype.digest = function(e) {
    return this.update(this._pad()), Z6(this.pending === null), this._digest(e);
  };
  Xn.prototype._pad = function() {
    var e = this.pendingTotal, r = this._delta8, n = r - (e + this.padLength) % r, i = new Array(n + this.padLength);
    i[0] = 128;
    for (var o2 = 1; o2 < n; o2++)
      i[o2] = 0;
    if (e <<= 3, this.endian === "big") {
      for (var p3 = 8; p3 < this.padLength; p3++)
        i[o2++] = 0;
      i[o2++] = 0, i[o2++] = 0, i[o2++] = 0, i[o2++] = 0, i[o2++] = e >>> 24 & 255, i[o2++] = e >>> 16 & 255, i[o2++] = e >>> 8 & 255, i[o2++] = e & 255;
    } else
      for (i[o2++] = e & 255, i[o2++] = e >>> 8 & 255, i[o2++] = e >>> 16 & 255, i[o2++] = e >>> 24 & 255, i[o2++] = 0, i[o2++] = 0, i[o2++] = 0, i[o2++] = 0, p3 = 8; p3 < this.padLength; p3++)
        i[o2++] = 0;
    return i;
  };
});
var V02 = k4((wr2) => {
  "use strict";
  var G6 = Vt2(), fr = G6.rotr32;
  function X6(t, e, r, n) {
    if (t === 0)
      return Cd(e, r, n);
    if (t === 1 || t === 3)
      return Ld(e, r, n);
    if (t === 2)
      return Nd(e, r, n);
  }
  wr2.ft_1 = X6;
  function Cd(t, e, r) {
    return t & e ^ ~t & r;
  }
  wr2.ch32 = Cd;
  function Nd(t, e, r) {
    return t & e ^ t & r ^ e & r;
  }
  wr2.maj32 = Nd;
  function Ld(t, e, r) {
    return t ^ e ^ r;
  }
  wr2.p32 = Ld;
  function Y6(t) {
    return fr(t, 2) ^ fr(t, 13) ^ fr(t, 22);
  }
  wr2.s0_256 = Y6;
  function J6(t) {
    return fr(t, 6) ^ fr(t, 11) ^ fr(t, 25);
  }
  wr2.s1_256 = J6;
  function $6(t) {
    return fr(t, 7) ^ fr(t, 18) ^ t >>> 3;
  }
  wr2.g0_256 = $6;
  function Q6(t) {
    return fr(t, 17) ^ fr(t, 19) ^ t >>> 10;
  }
  wr2.g1_256 = Q6;
});
var Ud2 = k4((Am, zd) => {
  "use strict";
  var Gi = Vt2(), e3 = Zi2(), t3 = V02(), Z0 = Gi.rotl32, Of = Gi.sum32, r3 = Gi.sum32_5, i3 = t3.ft_1, Od = e3.BlockHash, f3 = [1518500249, 1859775393, 2400959708, 3395469782];
  function nr() {
    if (!(this instanceof nr))
      return new nr();
    Od.call(this), this.h = [1732584193, 4023233417, 2562383102, 271733878, 3285377520], this.W = new Array(80);
  }
  Gi.inherits(nr, Od);
  zd.exports = nr;
  nr.blockSize = 512;
  nr.outSize = 160;
  nr.hmacStrength = 80;
  nr.padLength = 64;
  nr.prototype._update = function(e, r) {
    for (var n = this.W, i = 0; i < 16; i++)
      n[i] = e[r + i];
    for (; i < n.length; i++)
      n[i] = Z0(n[i - 3] ^ n[i - 8] ^ n[i - 14] ^ n[i - 16], 1);
    var o2 = this.h[0], p3 = this.h[1], y4 = this.h[2], w2 = this.h[3], x = this.h[4];
    for (i = 0; i < n.length; i++) {
      var M4 = ~~(i / 20), E2 = r3(Z0(o2, 5), i3(M4, p3, y4, w2), x, n[i], f3[M4]);
      x = w2, w2 = y4, y4 = Z0(p3, 30), p3 = o2, o2 = E2;
    }
    this.h[0] = Of(this.h[0], o2), this.h[1] = Of(this.h[1], p3), this.h[2] = Of(this.h[2], y4), this.h[3] = Of(this.h[3], w2), this.h[4] = Of(this.h[4], x);
  };
  nr.prototype._digest = function(e) {
    return e === "hex" ? Gi.toHex32(this.h, "big") : Gi.split32(this.h, "big");
  };
});
var G02 = k4((qm, Fd) => {
  "use strict";
  var Xi = Vt2(), n3 = Zi2(), Yi = V02(), a3 = ot3(), Zt2 = Xi.sum32, s3 = Xi.sum32_4, o3 = Xi.sum32_5, h3 = Yi.ch32, u3 = Yi.maj32, d32 = Yi.s0_256, c32 = Yi.s1_256, l3 = Yi.g0_256, v3 = Yi.g1_256, Hd = n3.BlockHash, p3 = [1116352408, 1899447441, 3049323471, 3921009573, 961987163, 1508970993, 2453635748, 2870763221, 3624381080, 310598401, 607225278, 1426881987, 1925078388, 2162078206, 2614888103, 3248222580, 3835390401, 4022224774, 264347078, 604807628, 770255983, 1249150122, 1555081692, 1996064986, 2554220882, 2821834349, 2952996808, 3210313671, 3336571891, 3584528711, 113926993, 338241895, 666307205, 773529912, 1294757372, 1396182291, 1695183700, 1986661051, 2177026350, 2456956037, 2730485921, 2820302411, 3259730800, 3345764771, 3516065817, 3600352804, 4094571909, 275423344, 430227734, 506948616, 659060556, 883997877, 958139571, 1322822218, 1537002063, 1747873779, 1955562222, 2024104815, 2227730452, 2361852424, 2428436474, 2756734187, 3204031479, 3329325298];
  function ar() {
    if (!(this instanceof ar))
      return new ar();
    Hd.call(this), this.h = [1779033703, 3144134277, 1013904242, 2773480762, 1359893119, 2600822924, 528734635, 1541459225], this.k = p3, this.W = new Array(64);
  }
  Xi.inherits(ar, Hd);
  Fd.exports = ar;
  ar.blockSize = 512;
  ar.outSize = 256;
  ar.hmacStrength = 192;
  ar.padLength = 64;
  ar.prototype._update = function(e, r) {
    for (var n = this.W, i = 0; i < 16; i++)
      n[i] = e[r + i];
    for (; i < n.length; i++)
      n[i] = s3(v3(n[i - 2]), n[i - 7], l3(n[i - 15]), n[i - 16]);
    var o2 = this.h[0], p4 = this.h[1], y4 = this.h[2], w2 = this.h[3], x = this.h[4], M4 = this.h[5], E2 = this.h[6], A4 = this.h[7];
    for (a3(this.k.length === n.length), i = 0; i < n.length; i++) {
      var I3 = o3(A4, c32(x), h3(x, M4, E2), this.k[i], n[i]), D6 = Zt2(d32(o2), u3(o2, p4, y4));
      A4 = E2, E2 = M4, M4 = x, x = Zt2(w2, I3), w2 = y4, y4 = p4, p4 = o2, o2 = Zt2(I3, D6);
    }
    this.h[0] = Zt2(this.h[0], o2), this.h[1] = Zt2(this.h[1], p4), this.h[2] = Zt2(this.h[2], y4), this.h[3] = Zt2(this.h[3], w2), this.h[4] = Zt2(this.h[4], x), this.h[5] = Zt2(this.h[5], M4), this.h[6] = Zt2(this.h[6], E2), this.h[7] = Zt2(this.h[7], A4);
  };
  ar.prototype._digest = function(e) {
    return e === "hex" ? Xi.toHex32(this.h, "big") : Xi.split32(this.h, "big");
  };
});
var Wd2 = k4((Bm, jd) => {
  "use strict";
  var X0 = Vt2(), Kd = G02();
  function xr2() {
    if (!(this instanceof xr2))
      return new xr2();
    Kd.call(this), this.h = [3238371032, 914150663, 812702999, 4144912697, 4290775857, 1750603025, 1694076839, 3204075428];
  }
  X0.inherits(xr2, Kd);
  jd.exports = xr2;
  xr2.blockSize = 512;
  xr2.outSize = 224;
  xr2.hmacStrength = 192;
  xr2.padLength = 64;
  xr2.prototype._digest = function(e) {
    return e === "hex" ? X0.toHex32(this.h.slice(0, 7), "big") : X0.split32(this.h.slice(0, 7), "big");
  };
});
var $02 = k4((Rm, Xd) => {
  "use strict";
  var nt = Vt2(), b3 = Zi2(), m3 = ot3(), sr = nt.rotr64_hi, or2 = nt.rotr64_lo, Vd = nt.shr64_hi, Zd = nt.shr64_lo, Yr2 = nt.sum64, Y0 = nt.sum64_hi, J0 = nt.sum64_lo, g3 = nt.sum64_4_hi, y32 = nt.sum64_4_lo, _3 = nt.sum64_5_hi, w3 = nt.sum64_5_lo, Gd = b3.BlockHash, x3 = [1116352408, 3609767458, 1899447441, 602891725, 3049323471, 3964484399, 3921009573, 2173295548, 961987163, 4081628472, 1508970993, 3053834265, 2453635748, 2937671579, 2870763221, 3664609560, 3624381080, 2734883394, 310598401, 1164996542, 607225278, 1323610764, 1426881987, 3590304994, 1925078388, 4068182383, 2162078206, 991336113, 2614888103, 633803317, 3248222580, 3479774868, 3835390401, 2666613458, 4022224774, 944711139, 264347078, 2341262773, 604807628, 2007800933, 770255983, 1495990901, 1249150122, 1856431235, 1555081692, 3175218132, 1996064986, 2198950837, 2554220882, 3999719339, 2821834349, 766784016, 2952996808, 2566594879, 3210313671, 3203337956, 3336571891, 1034457026, 3584528711, 2466948901, 113926993, 3758326383, 338241895, 168717936, 666307205, 1188179964, 773529912, 1546045734, 1294757372, 1522805485, 1396182291, 2643833823, 1695183700, 2343527390, 1986661051, 1014477480, 2177026350, 1206759142, 2456956037, 344077627, 2730485921, 1290863460, 2820302411, 3158454273, 3259730800, 3505952657, 3345764771, 106217008, 3516065817, 3606008344, 3600352804, 1432725776, 4094571909, 1467031594, 275423344, 851169720, 430227734, 3100823752, 506948616, 1363258195, 659060556, 3750685593, 883997877, 3785050280, 958139571, 3318307427, 1322822218, 3812723403, 1537002063, 2003034995, 1747873779, 3602036899, 1955562222, 1575990012, 2024104815, 1125592928, 2227730452, 2716904306, 2361852424, 442776044, 2428436474, 593698344, 2756734187, 3733110249, 3204031479, 2999351573, 3329325298, 3815920427, 3391569614, 3928383900, 3515267271, 566280711, 3940187606, 3454069534, 4118630271, 4000239992, 116418474, 1914138554, 174292421, 2731055270, 289380356, 3203993006, 460393269, 320620315, 685471733, 587496836, 852142971, 1086792851, 1017036298, 365543100, 1126000580, 2618297676, 1288033470, 3409855158, 1501505948, 4234509866, 1607167915, 987167468, 1816402316, 1246189591];
  function Gt() {
    if (!(this instanceof Gt))
      return new Gt();
    Gd.call(this), this.h = [1779033703, 4089235720, 3144134277, 2227873595, 1013904242, 4271175723, 2773480762, 1595750129, 1359893119, 2917565137, 2600822924, 725511199, 528734635, 4215389547, 1541459225, 327033209], this.k = x3, this.W = new Array(160);
  }
  nt.inherits(Gt, Gd);
  Xd.exports = Gt;
  Gt.blockSize = 1024;
  Gt.outSize = 512;
  Gt.hmacStrength = 192;
  Gt.padLength = 128;
  Gt.prototype._prepareBlock = function(e, r) {
    for (var n = this.W, i = 0; i < 32; i++)
      n[i] = e[r + i];
    for (; i < n.length; i += 2) {
      var o2 = P3(n[i - 4], n[i - 3]), p3 = T32(n[i - 4], n[i - 3]), y4 = n[i - 14], w2 = n[i - 13], x = k32(n[i - 30], n[i - 29]), M4 = D32(n[i - 30], n[i - 29]), E2 = n[i - 32], A4 = n[i - 31];
      n[i] = g3(o2, p3, y4, w2, x, M4, E2, A4), n[i + 1] = y32(o2, p3, y4, w2, x, M4, E2, A4);
    }
  };
  Gt.prototype._update = function(e, r) {
    this._prepareBlock(e, r);
    var n = this.W, i = this.h[0], o2 = this.h[1], p3 = this.h[2], y4 = this.h[3], w2 = this.h[4], x = this.h[5], M4 = this.h[6], E2 = this.h[7], A4 = this.h[8], I4 = this.h[9], D6 = this.h[10], C = this.h[11], ge2 = this.h[12], L4 = this.h[13], ye = this.h[14], Re = this.h[15];
    m3(this.k.length === n.length);
    for (var xe3 = 0; xe3 < n.length; xe3 += 2) {
      var ke = ye, Me = Re, Ce3 = R3(A4, I4), Ee2 = I3(A4, I4), Ne3 = M32(A4, I4, D6, C, ge2, L4), S4 = S3(A4, I4, D6, C, ge2, L4), v2 = this.k[xe3], _2 = this.k[xe3 + 1], c5 = n[xe3], f = n[xe3 + 1], a = _3(ke, Me, Ce3, Ee2, Ne3, S4, v2, _2, c5, f), u = w3(ke, Me, Ce3, Ee2, Ne3, S4, v2, _2, c5, f);
      ke = q3(i, o2), Me = B3(i, o2), Ce3 = E3(i, o2, p3, y4, w2, x), Ee2 = A32(i, o2, p3, y4, w2, x);
      var l = Y0(ke, Me, Ce3, Ee2), d4 = J0(ke, Me, Ce3, Ee2);
      ye = ge2, Re = L4, ge2 = D6, L4 = C, D6 = A4, C = I4, A4 = Y0(M4, E2, a, u), I4 = J0(E2, E2, a, u), M4 = w2, E2 = x, w2 = p3, x = y4, p3 = i, y4 = o2, i = Y0(a, u, l, d4), o2 = J0(a, u, l, d4);
    }
    Yr2(this.h, 0, i, o2), Yr2(this.h, 2, p3, y4), Yr2(this.h, 4, w2, x), Yr2(this.h, 6, M4, E2), Yr2(this.h, 8, A4, I4), Yr2(this.h, 10, D6, C), Yr2(this.h, 12, ge2, L4), Yr2(this.h, 14, ye, Re);
  };
  Gt.prototype._digest = function(e) {
    return e === "hex" ? nt.toHex32(this.h, "big") : nt.split32(this.h, "big");
  };
  function M32(t, e, r, n, i) {
    var o2 = t & r ^ ~t & i;
    return o2 < 0 && (o2 += 4294967296), o2;
  }
  function S3(t, e, r, n, i, o2) {
    var p3 = e & n ^ ~e & o2;
    return p3 < 0 && (p3 += 4294967296), p3;
  }
  function E3(t, e, r, n, i) {
    var o2 = t & r ^ t & i ^ r & i;
    return o2 < 0 && (o2 += 4294967296), o2;
  }
  function A32(t, e, r, n, i, o2) {
    var p3 = e & n ^ e & o2 ^ n & o2;
    return p3 < 0 && (p3 += 4294967296), p3;
  }
  function q3(t, e) {
    var r = sr(t, e, 28), n = sr(e, t, 2), i = sr(e, t, 7), o2 = r ^ n ^ i;
    return o2 < 0 && (o2 += 4294967296), o2;
  }
  function B3(t, e) {
    var r = or2(t, e, 28), n = or2(e, t, 2), i = or2(e, t, 7), o2 = r ^ n ^ i;
    return o2 < 0 && (o2 += 4294967296), o2;
  }
  function R3(t, e) {
    var r = sr(t, e, 14), n = sr(t, e, 18), i = sr(e, t, 9), o2 = r ^ n ^ i;
    return o2 < 0 && (o2 += 4294967296), o2;
  }
  function I3(t, e) {
    var r = or2(t, e, 14), n = or2(t, e, 18), i = or2(e, t, 9), o2 = r ^ n ^ i;
    return o2 < 0 && (o2 += 4294967296), o2;
  }
  function k32(t, e) {
    var r = sr(t, e, 1), n = sr(t, e, 8), i = Vd(t, e, 7), o2 = r ^ n ^ i;
    return o2 < 0 && (o2 += 4294967296), o2;
  }
  function D32(t, e) {
    var r = or2(t, e, 1), n = or2(t, e, 8), i = Zd(t, e, 7), o2 = r ^ n ^ i;
    return o2 < 0 && (o2 += 4294967296), o2;
  }
  function P3(t, e) {
    var r = sr(t, e, 19), n = sr(e, t, 29), i = Vd(t, e, 6), o2 = r ^ n ^ i;
    return o2 < 0 && (o2 += 4294967296), o2;
  }
  function T32(t, e) {
    var r = or2(t, e, 19), n = or2(e, t, 29), i = Zd(t, e, 6), o2 = r ^ n ^ i;
    return o2 < 0 && (o2 += 4294967296), o2;
  }
});
var $d2 = k4((Im, Jd) => {
  "use strict";
  var Q0 = Vt2(), Yd = $02();
  function Mr() {
    if (!(this instanceof Mr))
      return new Mr();
    Yd.call(this), this.h = [3418070365, 3238371032, 1654270250, 914150663, 2438529370, 812702999, 355462360, 4144912697, 1731405415, 4290775857, 2394180231, 1750603025, 3675008525, 1694076839, 1203062813, 3204075428];
  }
  Q0.inherits(Mr, Yd);
  Jd.exports = Mr;
  Mr.blockSize = 1024;
  Mr.outSize = 384;
  Mr.hmacStrength = 192;
  Mr.padLength = 128;
  Mr.prototype._digest = function(e) {
    return e === "hex" ? Q0.toHex32(this.h.slice(0, 12), "big") : Q0.split32(this.h.slice(0, 12), "big");
  };
});
var Qd2 = k4((Ji) => {
  "use strict";
  Ji.sha1 = Ud2();
  Ji.sha224 = Wd2();
  Ji.sha256 = G02();
  Ji.sha384 = $d2();
  Ji.sha512 = $02();
});
var nc2 = k4((fc) => {
  "use strict";
  var xi = Vt2(), C3 = Zi2(), Yn = xi.rotl32, ec = xi.sum32, zf = xi.sum32_3, tc = xi.sum32_4, ic = C3.BlockHash;
  function hr() {
    if (!(this instanceof hr))
      return new hr();
    ic.call(this), this.h = [1732584193, 4023233417, 2562383102, 271733878, 3285377520], this.endian = "little";
  }
  xi.inherits(hr, ic);
  fc.ripemd160 = hr;
  hr.blockSize = 512;
  hr.outSize = 160;
  hr.hmacStrength = 192;
  hr.padLength = 64;
  hr.prototype._update = function(e, r) {
    for (var n = this.h[0], i = this.h[1], o2 = this.h[2], p3 = this.h[3], y4 = this.h[4], w2 = n, x = i, M4 = o2, E2 = p3, A4 = y4, I3 = 0; I3 < 80; I3++) {
      var D6 = ec(Yn(tc(n, rc(I3, i, o2, p3), e[O3[I3] + r], N32(I3)), U3[I3]), y4);
      n = y4, y4 = p3, p3 = Yn(o2, 10), o2 = i, i = D6, D6 = ec(Yn(tc(w2, rc(79 - I3, x, M4, E2), e[z3[I3] + r], L32(I3)), H3[I3]), A4), w2 = A4, A4 = E2, E2 = Yn(M4, 10), M4 = x, x = D6;
    }
    D6 = zf(this.h[1], o2, E2), this.h[1] = zf(this.h[2], p3, A4), this.h[2] = zf(this.h[3], y4, w2), this.h[3] = zf(this.h[4], n, x), this.h[4] = zf(this.h[0], i, M4), this.h[0] = D6;
  };
  hr.prototype._digest = function(e) {
    return e === "hex" ? xi.toHex32(this.h, "little") : xi.split32(this.h, "little");
  };
  function rc(t, e, r, n) {
    return t <= 15 ? e ^ r ^ n : t <= 31 ? e & r | ~e & n : t <= 47 ? (e | ~r) ^ n : t <= 63 ? e & n | r & ~n : e ^ (r | ~n);
  }
  function N32(t) {
    return t <= 15 ? 0 : t <= 31 ? 1518500249 : t <= 47 ? 1859775393 : t <= 63 ? 2400959708 : 2840853838;
  }
  function L32(t) {
    return t <= 15 ? 1352829926 : t <= 31 ? 1548603684 : t <= 47 ? 1836072691 : t <= 63 ? 2053994217 : 0;
  }
  var O3 = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8, 3, 10, 14, 4, 9, 15, 8, 1, 2, 7, 0, 6, 13, 11, 5, 12, 1, 9, 11, 10, 0, 8, 12, 4, 13, 3, 7, 15, 14, 5, 6, 2, 4, 0, 5, 9, 7, 12, 2, 10, 14, 1, 3, 8, 11, 6, 15, 13], z3 = [5, 14, 7, 0, 9, 2, 11, 4, 13, 6, 15, 8, 1, 10, 3, 12, 6, 11, 3, 7, 0, 13, 5, 10, 14, 15, 8, 12, 4, 9, 1, 2, 15, 5, 1, 3, 7, 14, 6, 9, 11, 8, 12, 2, 10, 0, 4, 13, 8, 6, 4, 1, 3, 11, 15, 0, 5, 12, 2, 13, 9, 7, 10, 14, 12, 15, 10, 4, 1, 5, 8, 7, 6, 2, 13, 14, 0, 3, 9, 11], U3 = [11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8, 7, 6, 8, 13, 11, 9, 7, 15, 7, 12, 15, 9, 11, 7, 13, 12, 11, 13, 6, 7, 14, 9, 13, 15, 14, 8, 13, 6, 5, 12, 7, 5, 11, 12, 14, 15, 14, 15, 9, 8, 9, 14, 5, 6, 8, 6, 5, 12, 9, 15, 5, 11, 6, 8, 13, 12, 5, 12, 13, 14, 11, 8, 5, 6], H3 = [8, 9, 9, 11, 13, 15, 15, 5, 7, 7, 8, 11, 14, 14, 12, 6, 9, 13, 15, 7, 12, 8, 9, 11, 7, 7, 12, 7, 6, 15, 13, 11, 9, 7, 15, 11, 8, 6, 6, 14, 12, 13, 5, 14, 13, 13, 7, 5, 15, 5, 8, 11, 14, 14, 6, 14, 6, 9, 12, 9, 12, 5, 15, 8, 8, 5, 12, 9, 12, 5, 14, 6, 8, 13, 6, 5, 15, 13, 11, 11];
});
var sc2 = k4((Pm, ac) => {
  "use strict";
  var F32 = Vt2(), K32 = ot3();
  function $i(t, e, r) {
    if (!(this instanceof $i))
      return new $i(t, e, r);
    this.Hash = t, this.blockSize = t.blockSize / 8, this.outSize = t.outSize / 8, this.inner = null, this.outer = null, this._init(F32.toArray(e, r));
  }
  ac.exports = $i;
  $i.prototype._init = function(e) {
    e.length > this.blockSize && (e = new this.Hash().update(e).digest()), K32(e.length <= this.blockSize);
    for (var r = e.length; r < this.blockSize; r++)
      e.push(0);
    for (r = 0; r < e.length; r++)
      e[r] ^= 54;
    for (this.inner = new this.Hash().update(e), r = 0; r < e.length; r++)
      e[r] ^= 106;
    this.outer = new this.Hash().update(e);
  };
  $i.prototype.update = function(e, r) {
    return this.inner.update(e, r), this;
  };
  $i.prototype.digest = function(e) {
    return this.outer.update(this.inner.digest()), this.outer.digest(e);
  };
});
var Jn2 = k4((oc) => {
  var Ye2 = oc;
  Ye2.utils = Vt2();
  Ye2.common = Zi2();
  Ye2.sha = Qd2();
  Ye2.ripemd = nc2();
  Ye2.hmac = sc2();
  Ye2.sha1 = Ye2.sha.sha1;
  Ye2.sha256 = Ye2.sha.sha256;
  Ye2.sha224 = Ye2.sha.sha224;
  Ye2.sha384 = Ye2.sha.sha384;
  Ye2.sha512 = Ye2.sha.sha512;
  Ye2.ripemd160 = Ye2.ripemd.ripemd160;
});
var uc2 = k4((Cm, hc) => {
  hc.exports = { doubles: { step: 4, points: [["e60fce93b59e9ec53011aabc21c23e97b2a31369b87a5ae9c44ee89e2a6dec0a", "f7e3507399e595929db99f34f57937101296891e44d23f0be1f32cce69616821"], ["8282263212c609d9ea2a6e3e172de238d8c39cabd5ac1ca10646e23fd5f51508", "11f8a8098557dfe45e8256e830b60ace62d613ac2f7b17bed31b6eaff6e26caf"], ["175e159f728b865a72f99cc6c6fc846de0b93833fd2222ed73fce5b551e5b739", "d3506e0d9e3c79eba4ef97a51ff71f5eacb5955add24345c6efa6ffee9fed695"], ["363d90d447b00c9c99ceac05b6262ee053441c7e55552ffe526bad8f83ff4640", "4e273adfc732221953b445397f3363145b9a89008199ecb62003c7f3bee9de9"], ["8b4b5f165df3c2be8c6244b5b745638843e4a781a15bcd1b69f79a55dffdf80c", "4aad0a6f68d308b4b3fbd7813ab0da04f9e336546162ee56b3eff0c65fd4fd36"], ["723cbaa6e5db996d6bf771c00bd548c7b700dbffa6c0e77bcb6115925232fcda", "96e867b5595cc498a921137488824d6e2660a0653779494801dc069d9eb39f5f"], ["eebfa4d493bebf98ba5feec812c2d3b50947961237a919839a533eca0e7dd7fa", "5d9a8ca3970ef0f269ee7edaf178089d9ae4cdc3a711f712ddfd4fdae1de8999"], ["100f44da696e71672791d0a09b7bde459f1215a29b3c03bfefd7835b39a48db0", "cdd9e13192a00b772ec8f3300c090666b7ff4a18ff5195ac0fbd5cd62bc65a09"], ["e1031be262c7ed1b1dc9227a4a04c017a77f8d4464f3b3852c8acde6e534fd2d", "9d7061928940405e6bb6a4176597535af292dd419e1ced79a44f18f29456a00d"], ["feea6cae46d55b530ac2839f143bd7ec5cf8b266a41d6af52d5e688d9094696d", "e57c6b6c97dce1bab06e4e12bf3ecd5c981c8957cc41442d3155debf18090088"], ["da67a91d91049cdcb367be4be6ffca3cfeed657d808583de33fa978bc1ec6cb1", "9bacaa35481642bc41f463f7ec9780e5dec7adc508f740a17e9ea8e27a68be1d"], ["53904faa0b334cdda6e000935ef22151ec08d0f7bb11069f57545ccc1a37b7c0", "5bc087d0bc80106d88c9eccac20d3c1c13999981e14434699dcb096b022771c8"], ["8e7bcd0bd35983a7719cca7764ca906779b53a043a9b8bcaeff959f43ad86047", "10b7770b2a3da4b3940310420ca9514579e88e2e47fd68b3ea10047e8460372a"], ["385eed34c1cdff21e6d0818689b81bde71a7f4f18397e6690a841e1599c43862", "283bebc3e8ea23f56701de19e9ebf4576b304eec2086dc8cc0458fe5542e5453"], ["6f9d9b803ecf191637c73a4413dfa180fddf84a5947fbc9c606ed86c3fac3a7", "7c80c68e603059ba69b8e2a30e45c4d47ea4dd2f5c281002d86890603a842160"], ["3322d401243c4e2582a2147c104d6ecbf774d163db0f5e5313b7e0e742d0e6bd", "56e70797e9664ef5bfb019bc4ddaf9b72805f63ea2873af624f3a2e96c28b2a0"], ["85672c7d2de0b7da2bd1770d89665868741b3f9af7643397721d74d28134ab83", "7c481b9b5b43b2eb6374049bfa62c2e5e77f17fcc5298f44c8e3094f790313a6"], ["948bf809b1988a46b06c9f1919413b10f9226c60f668832ffd959af60c82a0a", "53a562856dcb6646dc6b74c5d1c3418c6d4dff08c97cd2bed4cb7f88d8c8e589"], ["6260ce7f461801c34f067ce0f02873a8f1b0e44dfc69752accecd819f38fd8e8", "bc2da82b6fa5b571a7f09049776a1ef7ecd292238051c198c1a84e95b2b4ae17"], ["e5037de0afc1d8d43d8348414bbf4103043ec8f575bfdc432953cc8d2037fa2d", "4571534baa94d3b5f9f98d09fb990bddbd5f5b03ec481f10e0e5dc841d755bda"], ["e06372b0f4a207adf5ea905e8f1771b4e7e8dbd1c6a6c5b725866a0ae4fce725", "7a908974bce18cfe12a27bb2ad5a488cd7484a7787104870b27034f94eee31dd"], ["213c7a715cd5d45358d0bbf9dc0ce02204b10bdde2a3f58540ad6908d0559754", "4b6dad0b5ae462507013ad06245ba190bb4850f5f36a7eeddff2c27534b458f2"], ["4e7c272a7af4b34e8dbb9352a5419a87e2838c70adc62cddf0cc3a3b08fbd53c", "17749c766c9d0b18e16fd09f6def681b530b9614bff7dd33e0b3941817dcaae6"], ["fea74e3dbe778b1b10f238ad61686aa5c76e3db2be43057632427e2840fb27b6", "6e0568db9b0b13297cf674deccb6af93126b596b973f7b77701d3db7f23cb96f"], ["76e64113f677cf0e10a2570d599968d31544e179b760432952c02a4417bdde39", "c90ddf8dee4e95cf577066d70681f0d35e2a33d2b56d2032b4b1752d1901ac01"], ["c738c56b03b2abe1e8281baa743f8f9a8f7cc643df26cbee3ab150242bcbb891", "893fb578951ad2537f718f2eacbfbbbb82314eef7880cfe917e735d9699a84c3"], ["d895626548b65b81e264c7637c972877d1d72e5f3a925014372e9f6588f6c14b", "febfaa38f2bc7eae728ec60818c340eb03428d632bb067e179363ed75d7d991f"], ["b8da94032a957518eb0f6433571e8761ceffc73693e84edd49150a564f676e03", "2804dfa44805a1e4d7c99cc9762808b092cc584d95ff3b511488e4e74efdf6e7"], ["e80fea14441fb33a7d8adab9475d7fab2019effb5156a792f1a11778e3c0df5d", "eed1de7f638e00771e89768ca3ca94472d155e80af322ea9fcb4291b6ac9ec78"], ["a301697bdfcd704313ba48e51d567543f2a182031efd6915ddc07bbcc4e16070", "7370f91cfb67e4f5081809fa25d40f9b1735dbf7c0a11a130c0d1a041e177ea1"], ["90ad85b389d6b936463f9d0512678de208cc330b11307fffab7ac63e3fb04ed4", "e507a3620a38261affdcbd9427222b839aefabe1582894d991d4d48cb6ef150"], ["8f68b9d2f63b5f339239c1ad981f162ee88c5678723ea3351b7b444c9ec4c0da", "662a9f2dba063986de1d90c2b6be215dbbea2cfe95510bfdf23cbf79501fff82"], ["e4f3fb0176af85d65ff99ff9198c36091f48e86503681e3e6686fd5053231e11", "1e63633ad0ef4f1c1661a6d0ea02b7286cc7e74ec951d1c9822c38576feb73bc"], ["8c00fa9b18ebf331eb961537a45a4266c7034f2f0d4e1d0716fb6eae20eae29e", "efa47267fea521a1a9dc343a3736c974c2fadafa81e36c54e7d2a4c66702414b"], ["e7a26ce69dd4829f3e10cec0a9e98ed3143d084f308b92c0997fddfc60cb3e41", "2a758e300fa7984b471b006a1aafbb18d0a6b2c0420e83e20e8a9421cf2cfd51"], ["b6459e0ee3662ec8d23540c223bcbdc571cbcb967d79424f3cf29eb3de6b80ef", "67c876d06f3e06de1dadf16e5661db3c4b3ae6d48e35b2ff30bf0b61a71ba45"], ["d68a80c8280bb840793234aa118f06231d6f1fc67e73c5a5deda0f5b496943e8", "db8ba9fff4b586d00c4b1f9177b0e28b5b0e7b8f7845295a294c84266b133120"], ["324aed7df65c804252dc0270907a30b09612aeb973449cea4095980fc28d3d5d", "648a365774b61f2ff130c0c35aec1f4f19213b0c7e332843967224af96ab7c84"], ["4df9c14919cde61f6d51dfdbe5fee5dceec4143ba8d1ca888e8bd373fd054c96", "35ec51092d8728050974c23a1d85d4b5d506cdc288490192ebac06cad10d5d"], ["9c3919a84a474870faed8a9c1cc66021523489054d7f0308cbfc99c8ac1f98cd", "ddb84f0f4a4ddd57584f044bf260e641905326f76c64c8e6be7e5e03d4fc599d"], ["6057170b1dd12fdf8de05f281d8e06bb91e1493a8b91d4cc5a21382120a959e5", "9a1af0b26a6a4807add9a2daf71df262465152bc3ee24c65e899be932385a2a8"], ["a576df8e23a08411421439a4518da31880cef0fba7d4df12b1a6973eecb94266", "40a6bf20e76640b2c92b97afe58cd82c432e10a7f514d9f3ee8be11ae1b28ec8"], ["7778a78c28dec3e30a05fe9629de8c38bb30d1f5cf9a3a208f763889be58ad71", "34626d9ab5a5b22ff7098e12f2ff580087b38411ff24ac563b513fc1fd9f43ac"], ["928955ee637a84463729fd30e7afd2ed5f96274e5ad7e5cb09eda9c06d903ac", "c25621003d3f42a827b78a13093a95eeac3d26efa8a8d83fc5180e935bcd091f"], ["85d0fef3ec6db109399064f3a0e3b2855645b4a907ad354527aae75163d82751", "1f03648413a38c0be29d496e582cf5663e8751e96877331582c237a24eb1f962"], ["ff2b0dce97eece97c1c9b6041798b85dfdfb6d8882da20308f5404824526087e", "493d13fef524ba188af4c4dc54d07936c7b7ed6fb90e2ceb2c951e01f0c29907"], ["827fbbe4b1e880ea9ed2b2e6301b212b57f1ee148cd6dd28780e5e2cf856e241", "c60f9c923c727b0b71bef2c67d1d12687ff7a63186903166d605b68baec293ec"], ["eaa649f21f51bdbae7be4ae34ce6e5217a58fdce7f47f9aa7f3b58fa2120e2b3", "be3279ed5bbbb03ac69a80f89879aa5a01a6b965f13f7e59d47a5305ba5ad93d"], ["e4a42d43c5cf169d9391df6decf42ee541b6d8f0c9a137401e23632dda34d24f", "4d9f92e716d1c73526fc99ccfb8ad34ce886eedfa8d8e4f13a7f7131deba9414"], ["1ec80fef360cbdd954160fadab352b6b92b53576a88fea4947173b9d4300bf19", "aeefe93756b5340d2f3a4958a7abbf5e0146e77f6295a07b671cdc1cc107cefd"], ["146a778c04670c2f91b00af4680dfa8bce3490717d58ba889ddb5928366642be", "b318e0ec3354028add669827f9d4b2870aaa971d2f7e5ed1d0b297483d83efd0"], ["fa50c0f61d22e5f07e3acebb1aa07b128d0012209a28b9776d76a8793180eef9", "6b84c6922397eba9b72cd2872281a68a5e683293a57a213b38cd8d7d3f4f2811"], ["da1d61d0ca721a11b1a5bf6b7d88e8421a288ab5d5bba5220e53d32b5f067ec2", "8157f55a7c99306c79c0766161c91e2966a73899d279b48a655fba0f1ad836f1"], ["a8e282ff0c9706907215ff98e8fd416615311de0446f1e062a73b0610d064e13", "7f97355b8db81c09abfb7f3c5b2515888b679a3e50dd6bd6cef7c73111f4cc0c"], ["174a53b9c9a285872d39e56e6913cab15d59b1fa512508c022f382de8319497c", "ccc9dc37abfc9c1657b4155f2c47f9e6646b3a1d8cb9854383da13ac079afa73"], ["959396981943785c3d3e57edf5018cdbe039e730e4918b3d884fdff09475b7ba", "2e7e552888c331dd8ba0386a4b9cd6849c653f64c8709385e9b8abf87524f2fd"], ["d2a63a50ae401e56d645a1153b109a8fcca0a43d561fba2dbb51340c9d82b151", "e82d86fb6443fcb7565aee58b2948220a70f750af484ca52d4142174dcf89405"], ["64587e2335471eb890ee7896d7cfdc866bacbdbd3839317b3436f9b45617e073", "d99fcdd5bf6902e2ae96dd6447c299a185b90a39133aeab358299e5e9faf6589"], ["8481bde0e4e4d885b3a546d3e549de042f0aa6cea250e7fd358d6c86dd45e458", "38ee7b8cba5404dd84a25bf39cecb2ca900a79c42b262e556d64b1b59779057e"], ["13464a57a78102aa62b6979ae817f4637ffcfed3c4b1ce30bcd6303f6caf666b", "69be159004614580ef7e433453ccb0ca48f300a81d0942e13f495a907f6ecc27"], ["bc4a9df5b713fe2e9aef430bcc1dc97a0cd9ccede2f28588cada3a0d2d83f366", "d3a81ca6e785c06383937adf4b798caa6e8a9fbfa547b16d758d666581f33c1"], ["8c28a97bf8298bc0d23d8c749452a32e694b65e30a9472a3954ab30fe5324caa", "40a30463a3305193378fedf31f7cc0eb7ae784f0451cb9459e71dc73cbef9482"], ["8ea9666139527a8c1dd94ce4f071fd23c8b350c5a4bb33748c4ba111faccae0", "620efabbc8ee2782e24e7c0cfb95c5d735b783be9cf0f8e955af34a30e62b945"], ["dd3625faef5ba06074669716bbd3788d89bdde815959968092f76cc4eb9a9787", "7a188fa3520e30d461da2501045731ca941461982883395937f68d00c644a573"], ["f710d79d9eb962297e4f6232b40e8f7feb2bc63814614d692c12de752408221e", "ea98e67232d3b3295d3b535532115ccac8612c721851617526ae47a9c77bfc82"]] }, naf: { wnd: 7, points: [["f9308a019258c31049344f85f89d5229b531c845836f99b08601f113bce036f9", "388f7b0f632de8140fe337e62a37f3566500a99934c2231b6cb9fd7584b8e672"], ["2f8bde4d1a07209355b4a7250a5c5128e88b84bddc619ab7cba8d569b240efe4", "d8ac222636e5e3d6d4dba9dda6c9c426f788271bab0d6840dca87d3aa6ac62d6"], ["5cbdf0646e5db4eaa398f365f2ea7a0e3d419b7e0330e39ce92bddedcac4f9bc", "6aebca40ba255960a3178d6d861a54dba813d0b813fde7b5a5082628087264da"], ["acd484e2f0c7f65309ad178a9f559abde09796974c57e714c35f110dfc27ccbe", "cc338921b0a7d9fd64380971763b61e9add888a4375f8e0f05cc262ac64f9c37"], ["774ae7f858a9411e5ef4246b70c65aac5649980be5c17891bbec17895da008cb", "d984a032eb6b5e190243dd56d7b7b365372db1e2dff9d6a8301d74c9c953c61b"], ["f28773c2d975288bc7d1d205c3748651b075fbc6610e58cddeeddf8f19405aa8", "ab0902e8d880a89758212eb65cdaf473a1a06da521fa91f29b5cb52db03ed81"], ["d7924d4f7d43ea965a465ae3095ff41131e5946f3c85f79e44adbcf8e27e080e", "581e2872a86c72a683842ec228cc6defea40af2bd896d3a5c504dc9ff6a26b58"], ["defdea4cdb677750a420fee807eacf21eb9898ae79b9768766e4faa04a2d4a34", "4211ab0694635168e997b0ead2a93daeced1f4a04a95c0f6cfb199f69e56eb77"], ["2b4ea0a797a443d293ef5cff444f4979f06acfebd7e86d277475656138385b6c", "85e89bc037945d93b343083b5a1c86131a01f60c50269763b570c854e5c09b7a"], ["352bbf4a4cdd12564f93fa332ce333301d9ad40271f8107181340aef25be59d5", "321eb4075348f534d59c18259dda3e1f4a1b3b2e71b1039c67bd3d8bcf81998c"], ["2fa2104d6b38d11b0230010559879124e42ab8dfeff5ff29dc9cdadd4ecacc3f", "2de1068295dd865b64569335bd5dd80181d70ecfc882648423ba76b532b7d67"], ["9248279b09b4d68dab21a9b066edda83263c3d84e09572e269ca0cd7f5453714", "73016f7bf234aade5d1aa71bdea2b1ff3fc0de2a887912ffe54a32ce97cb3402"], ["daed4f2be3a8bf278e70132fb0beb7522f570e144bf615c07e996d443dee8729", "a69dce4a7d6c98e8d4a1aca87ef8d7003f83c230f3afa726ab40e52290be1c55"], ["c44d12c7065d812e8acf28d7cbb19f9011ecd9e9fdf281b0e6a3b5e87d22e7db", "2119a460ce326cdc76c45926c982fdac0e106e861edf61c5a039063f0e0e6482"], ["6a245bf6dc698504c89a20cfded60853152b695336c28063b61c65cbd269e6b4", "e022cf42c2bd4a708b3f5126f16a24ad8b33ba48d0423b6efd5e6348100d8a82"], ["1697ffa6fd9de627c077e3d2fe541084ce13300b0bec1146f95ae57f0d0bd6a5", "b9c398f186806f5d27561506e4557433a2cf15009e498ae7adee9d63d01b2396"], ["605bdb019981718b986d0f07e834cb0d9deb8360ffb7f61df982345ef27a7479", "2972d2de4f8d20681a78d93ec96fe23c26bfae84fb14db43b01e1e9056b8c49"], ["62d14dab4150bf497402fdc45a215e10dcb01c354959b10cfe31c7e9d87ff33d", "80fc06bd8cc5b01098088a1950eed0db01aa132967ab472235f5642483b25eaf"], ["80c60ad0040f27dade5b4b06c408e56b2c50e9f56b9b8b425e555c2f86308b6f", "1c38303f1cc5c30f26e66bad7fe72f70a65eed4cbe7024eb1aa01f56430bd57a"], ["7a9375ad6167ad54aa74c6348cc54d344cc5dc9487d847049d5eabb0fa03c8fb", "d0e3fa9eca8726909559e0d79269046bdc59ea10c70ce2b02d499ec224dc7f7"], ["d528ecd9b696b54c907a9ed045447a79bb408ec39b68df504bb51f459bc3ffc9", "eecf41253136e5f99966f21881fd656ebc4345405c520dbc063465b521409933"], ["49370a4b5f43412ea25f514e8ecdad05266115e4a7ecb1387231808f8b45963", "758f3f41afd6ed428b3081b0512fd62a54c3f3afbb5b6764b653052a12949c9a"], ["77f230936ee88cbbd73df930d64702ef881d811e0e1498e2f1c13eb1fc345d74", "958ef42a7886b6400a08266e9ba1b37896c95330d97077cbbe8eb3c7671c60d6"], ["f2dac991cc4ce4b9ea44887e5c7c0bce58c80074ab9d4dbaeb28531b7739f530", "e0dedc9b3b2f8dad4da1f32dec2531df9eb5fbeb0598e4fd1a117dba703a3c37"], ["463b3d9f662621fb1b4be8fbbe2520125a216cdfc9dae3debcba4850c690d45b", "5ed430d78c296c3543114306dd8622d7c622e27c970a1de31cb377b01af7307e"], ["f16f804244e46e2a09232d4aff3b59976b98fac14328a2d1a32496b49998f247", "cedabd9b82203f7e13d206fcdf4e33d92a6c53c26e5cce26d6579962c4e31df6"], ["caf754272dc84563b0352b7a14311af55d245315ace27c65369e15f7151d41d1", "cb474660ef35f5f2a41b643fa5e460575f4fa9b7962232a5c32f908318a04476"], ["2600ca4b282cb986f85d0f1709979d8b44a09c07cb86d7c124497bc86f082120", "4119b88753c15bd6a693b03fcddbb45d5ac6be74ab5f0ef44b0be9475a7e4b40"], ["7635ca72d7e8432c338ec53cd12220bc01c48685e24f7dc8c602a7746998e435", "91b649609489d613d1d5e590f78e6d74ecfc061d57048bad9e76f302c5b9c61"], ["754e3239f325570cdbbf4a87deee8a66b7f2b33479d468fbc1a50743bf56cc18", "673fb86e5bda30fb3cd0ed304ea49a023ee33d0197a695d0c5d98093c536683"], ["e3e6bd1071a1e96aff57859c82d570f0330800661d1c952f9fe2694691d9b9e8", "59c9e0bba394e76f40c0aa58379a3cb6a5a2283993e90c4167002af4920e37f5"], ["186b483d056a033826ae73d88f732985c4ccb1f32ba35f4b4cc47fdcf04aa6eb", "3b952d32c67cf77e2e17446e204180ab21fb8090895138b4a4a797f86e80888b"], ["df9d70a6b9876ce544c98561f4be4f725442e6d2b737d9c91a8321724ce0963f", "55eb2dafd84d6ccd5f862b785dc39d4ab157222720ef9da217b8c45cf2ba2417"], ["5edd5cc23c51e87a497ca815d5dce0f8ab52554f849ed8995de64c5f34ce7143", "efae9c8dbc14130661e8cec030c89ad0c13c66c0d17a2905cdc706ab7399a868"], ["290798c2b6476830da12fe02287e9e777aa3fba1c355b17a722d362f84614fba", "e38da76dcd440621988d00bcf79af25d5b29c094db2a23146d003afd41943e7a"], ["af3c423a95d9f5b3054754efa150ac39cd29552fe360257362dfdecef4053b45", "f98a3fd831eb2b749a93b0e6f35cfb40c8cd5aa667a15581bc2feded498fd9c6"], ["766dbb24d134e745cccaa28c99bf274906bb66b26dcf98df8d2fed50d884249a", "744b1152eacbe5e38dcc887980da38b897584a65fa06cedd2c924f97cbac5996"], ["59dbf46f8c94759ba21277c33784f41645f7b44f6c596a58ce92e666191abe3e", "c534ad44175fbc300f4ea6ce648309a042ce739a7919798cd85e216c4a307f6e"], ["f13ada95103c4537305e691e74e9a4a8dd647e711a95e73cb62dc6018cfd87b8", "e13817b44ee14de663bf4bc808341f326949e21a6a75c2570778419bdaf5733d"], ["7754b4fa0e8aced06d4167a2c59cca4cda1869c06ebadfb6488550015a88522c", "30e93e864e669d82224b967c3020b8fa8d1e4e350b6cbcc537a48b57841163a2"], ["948dcadf5990e048aa3874d46abef9d701858f95de8041d2a6828c99e2262519", "e491a42537f6e597d5d28a3224b1bc25df9154efbd2ef1d2cbba2cae5347d57e"], ["7962414450c76c1689c7b48f8202ec37fb224cf5ac0bfa1570328a8a3d7c77ab", "100b610ec4ffb4760d5c1fc133ef6f6b12507a051f04ac5760afa5b29db83437"], ["3514087834964b54b15b160644d915485a16977225b8847bb0dd085137ec47ca", "ef0afbb2056205448e1652c48e8127fc6039e77c15c2378b7e7d15a0de293311"], ["d3cc30ad6b483e4bc79ce2c9dd8bc54993e947eb8df787b442943d3f7b527eaf", "8b378a22d827278d89c5e9be8f9508ae3c2ad46290358630afb34db04eede0a4"], ["1624d84780732860ce1c78fcbfefe08b2b29823db913f6493975ba0ff4847610", "68651cf9b6da903e0914448c6cd9d4ca896878f5282be4c8cc06e2a404078575"], ["733ce80da955a8a26902c95633e62a985192474b5af207da6df7b4fd5fc61cd4", "f5435a2bd2badf7d485a4d8b8db9fcce3e1ef8e0201e4578c54673bc1dc5ea1d"], ["15d9441254945064cf1a1c33bbd3b49f8966c5092171e699ef258dfab81c045c", "d56eb30b69463e7234f5137b73b84177434800bacebfc685fc37bbe9efe4070d"], ["a1d0fcf2ec9de675b612136e5ce70d271c21417c9d2b8aaaac138599d0717940", "edd77f50bcb5a3cab2e90737309667f2641462a54070f3d519212d39c197a629"], ["e22fbe15c0af8ccc5780c0735f84dbe9a790badee8245c06c7ca37331cb36980", "a855babad5cd60c88b430a69f53a1a7a38289154964799be43d06d77d31da06"], ["311091dd9860e8e20ee13473c1155f5f69635e394704eaa74009452246cfa9b3", "66db656f87d1f04fffd1f04788c06830871ec5a64feee685bd80f0b1286d8374"], ["34c1fd04d301be89b31c0442d3e6ac24883928b45a9340781867d4232ec2dbdf", "9414685e97b1b5954bd46f730174136d57f1ceeb487443dc5321857ba73abee"], ["f219ea5d6b54701c1c14de5b557eb42a8d13f3abbcd08affcc2a5e6b049b8d63", "4cb95957e83d40b0f73af4544cccf6b1f4b08d3c07b27fb8d8c2962a400766d1"], ["d7b8740f74a8fbaab1f683db8f45de26543a5490bca627087236912469a0b448", "fa77968128d9c92ee1010f337ad4717eff15db5ed3c049b3411e0315eaa4593b"], ["32d31c222f8f6f0ef86f7c98d3a3335ead5bcd32abdd94289fe4d3091aa824bf", "5f3032f5892156e39ccd3d7915b9e1da2e6dac9e6f26e961118d14b8462e1661"], ["7461f371914ab32671045a155d9831ea8793d77cd59592c4340f86cbc18347b5", "8ec0ba238b96bec0cbdddcae0aa442542eee1ff50c986ea6b39847b3cc092ff6"], ["ee079adb1df1860074356a25aa38206a6d716b2c3e67453d287698bad7b2b2d6", "8dc2412aafe3be5c4c5f37e0ecc5f9f6a446989af04c4e25ebaac479ec1c8c1e"], ["16ec93e447ec83f0467b18302ee620f7e65de331874c9dc72bfd8616ba9da6b5", "5e4631150e62fb40d0e8c2a7ca5804a39d58186a50e497139626778e25b0674d"], ["eaa5f980c245f6f038978290afa70b6bd8855897f98b6aa485b96065d537bd99", "f65f5d3e292c2e0819a528391c994624d784869d7e6ea67fb18041024edc07dc"], ["78c9407544ac132692ee1910a02439958ae04877151342ea96c4b6b35a49f51", "f3e0319169eb9b85d5404795539a5e68fa1fbd583c064d2462b675f194a3ddb4"], ["494f4be219a1a77016dcd838431aea0001cdc8ae7a6fc688726578d9702857a5", "42242a969283a5f339ba7f075e36ba2af925ce30d767ed6e55f4b031880d562c"], ["a598a8030da6d86c6bc7f2f5144ea549d28211ea58faa70ebf4c1e665c1fe9b5", "204b5d6f84822c307e4b4a7140737aec23fc63b65b35f86a10026dbd2d864e6b"], ["c41916365abb2b5d09192f5f2dbeafec208f020f12570a184dbadc3e58595997", "4f14351d0087efa49d245b328984989d5caf9450f34bfc0ed16e96b58fa9913"], ["841d6063a586fa475a724604da03bc5b92a2e0d2e0a36acfe4c73a5514742881", "73867f59c0659e81904f9a1c7543698e62562d6744c169ce7a36de01a8d6154"], ["5e95bb399a6971d376026947f89bde2f282b33810928be4ded112ac4d70e20d5", "39f23f366809085beebfc71181313775a99c9aed7d8ba38b161384c746012865"], ["36e4641a53948fd476c39f8a99fd974e5ec07564b5315d8bf99471bca0ef2f66", "d2424b1b1abe4eb8164227b085c9aa9456ea13493fd563e06fd51cf5694c78fc"], ["336581ea7bfbbb290c191a2f507a41cf5643842170e914faeab27c2c579f726", "ead12168595fe1be99252129b6e56b3391f7ab1410cd1e0ef3dcdcabd2fda224"], ["8ab89816dadfd6b6a1f2634fcf00ec8403781025ed6890c4849742706bd43ede", "6fdcef09f2f6d0a044e654aef624136f503d459c3e89845858a47a9129cdd24e"], ["1e33f1a746c9c5778133344d9299fcaa20b0938e8acff2544bb40284b8c5fb94", "60660257dd11b3aa9c8ed618d24edff2306d320f1d03010e33a7d2057f3b3b6"], ["85b7c1dcb3cec1b7ee7f30ded79dd20a0ed1f4cc18cbcfcfa410361fd8f08f31", "3d98a9cdd026dd43f39048f25a8847f4fcafad1895d7a633c6fed3c35e999511"], ["29df9fbd8d9e46509275f4b125d6d45d7fbe9a3b878a7af872a2800661ac5f51", "b4c4fe99c775a606e2d8862179139ffda61dc861c019e55cd2876eb2a27d84b"], ["a0b1cae06b0a847a3fea6e671aaf8adfdfe58ca2f768105c8082b2e449fce252", "ae434102edde0958ec4b19d917a6a28e6b72da1834aff0e650f049503a296cf2"], ["4e8ceafb9b3e9a136dc7ff67e840295b499dfb3b2133e4ba113f2e4c0e121e5", "cf2174118c8b6d7a4b48f6d534ce5c79422c086a63460502b827ce62a326683c"], ["d24a44e047e19b6f5afb81c7ca2f69080a5076689a010919f42725c2b789a33b", "6fb8d5591b466f8fc63db50f1c0f1c69013f996887b8244d2cdec417afea8fa3"], ["ea01606a7a6c9cdd249fdfcfacb99584001edd28abbab77b5104e98e8e3b35d4", "322af4908c7312b0cfbfe369f7a7b3cdb7d4494bc2823700cfd652188a3ea98d"], ["af8addbf2b661c8a6c6328655eb96651252007d8c5ea31be4ad196de8ce2131f", "6749e67c029b85f52a034eafd096836b2520818680e26ac8f3dfbcdb71749700"], ["e3ae1974566ca06cc516d47e0fb165a674a3dabcfca15e722f0e3450f45889", "2aeabe7e4531510116217f07bf4d07300de97e4874f81f533420a72eeb0bd6a4"], ["591ee355313d99721cf6993ffed1e3e301993ff3ed258802075ea8ced397e246", "b0ea558a113c30bea60fc4775460c7901ff0b053d25ca2bdeee98f1a4be5d196"], ["11396d55fda54c49f19aa97318d8da61fa8584e47b084945077cf03255b52984", "998c74a8cd45ac01289d5833a7beb4744ff536b01b257be4c5767bea93ea57a4"], ["3c5d2a1ba39c5a1790000738c9e0c40b8dcdfd5468754b6405540157e017aa7a", "b2284279995a34e2f9d4de7396fc18b80f9b8b9fdd270f6661f79ca4c81bd257"], ["cc8704b8a60a0defa3a99a7299f2e9c3fbc395afb04ac078425ef8a1793cc030", "bdd46039feed17881d1e0862db347f8cf395b74fc4bcdc4e940b74e3ac1f1b13"], ["c533e4f7ea8555aacd9777ac5cad29b97dd4defccc53ee7ea204119b2889b197", "6f0a256bc5efdf429a2fb6242f1a43a2d9b925bb4a4b3a26bb8e0f45eb596096"], ["c14f8f2ccb27d6f109f6d08d03cc96a69ba8c34eec07bbcf566d48e33da6593", "c359d6923bb398f7fd4473e16fe1c28475b740dd098075e6c0e8649113dc3a38"], ["a6cbc3046bc6a450bac24789fa17115a4c9739ed75f8f21ce441f72e0b90e6ef", "21ae7f4680e889bb130619e2c0f95a360ceb573c70603139862afd617fa9b9f"], ["347d6d9a02c48927ebfb86c1359b1caf130a3c0267d11ce6344b39f99d43cc38", "60ea7f61a353524d1c987f6ecec92f086d565ab687870cb12689ff1e31c74448"], ["da6545d2181db8d983f7dcb375ef5866d47c67b1bf31c8cf855ef7437b72656a", "49b96715ab6878a79e78f07ce5680c5d6673051b4935bd897fea824b77dc208a"], ["c40747cc9d012cb1a13b8148309c6de7ec25d6945d657146b9d5994b8feb1111", "5ca560753be2a12fc6de6caf2cb489565db936156b9514e1bb5e83037e0fa2d4"], ["4e42c8ec82c99798ccf3a610be870e78338c7f713348bd34c8203ef4037f3502", "7571d74ee5e0fb92a7a8b33a07783341a5492144cc54bcc40a94473693606437"], ["3775ab7089bc6af823aba2e1af70b236d251cadb0c86743287522a1b3b0dedea", "be52d107bcfa09d8bcb9736a828cfa7fac8db17bf7a76a2c42ad961409018cf7"], ["cee31cbf7e34ec379d94fb814d3d775ad954595d1314ba8846959e3e82f74e26", "8fd64a14c06b589c26b947ae2bcf6bfa0149ef0be14ed4d80f448a01c43b1c6d"], ["b4f9eaea09b6917619f6ea6a4eb5464efddb58fd45b1ebefcdc1a01d08b47986", "39e5c9925b5a54b07433a4f18c61726f8bb131c012ca542eb24a8ac07200682a"], ["d4263dfc3d2df923a0179a48966d30ce84e2515afc3dccc1b77907792ebcc60e", "62dfaf07a0f78feb30e30d6295853ce189e127760ad6cf7fae164e122a208d54"], ["48457524820fa65a4f8d35eb6930857c0032acc0a4a2de422233eeda897612c4", "25a748ab367979d98733c38a1fa1c2e7dc6cc07db2d60a9ae7a76aaa49bd0f77"], ["dfeeef1881101f2cb11644f3a2afdfc2045e19919152923f367a1767c11cceda", "ecfb7056cf1de042f9420bab396793c0c390bde74b4bbdff16a83ae09a9a7517"], ["6d7ef6b17543f8373c573f44e1f389835d89bcbc6062ced36c82df83b8fae859", "cd450ec335438986dfefa10c57fea9bcc521a0959b2d80bbf74b190dca712d10"], ["e75605d59102a5a2684500d3b991f2e3f3c88b93225547035af25af66e04541f", "f5c54754a8f71ee540b9b48728473e314f729ac5308b06938360990e2bfad125"], ["eb98660f4c4dfaa06a2be453d5020bc99a0c2e60abe388457dd43fefb1ed620c", "6cb9a8876d9cb8520609af3add26cd20a0a7cd8a9411131ce85f44100099223e"], ["13e87b027d8514d35939f2e6892b19922154596941888336dc3563e3b8dba942", "fef5a3c68059a6dec5d624114bf1e91aac2b9da568d6abeb2570d55646b8adf1"], ["ee163026e9fd6fe017c38f06a5be6fc125424b371ce2708e7bf4491691e5764a", "1acb250f255dd61c43d94ccc670d0f58f49ae3fa15b96623e5430da0ad6c62b2"], ["b268f5ef9ad51e4d78de3a750c2dc89b1e626d43505867999932e5db33af3d80", "5f310d4b3c99b9ebb19f77d41c1dee018cf0d34fd4191614003e945a1216e423"], ["ff07f3118a9df035e9fad85eb6c7bfe42b02f01ca99ceea3bf7ffdba93c4750d", "438136d603e858a3a5c440c38eccbaddc1d2942114e2eddd4740d098ced1f0d8"], ["8d8b9855c7c052a34146fd20ffb658bea4b9f69e0d825ebec16e8c3ce2b526a1", "cdb559eedc2d79f926baf44fb84ea4d44bcf50fee51d7ceb30e2e7f463036758"], ["52db0b5384dfbf05bfa9d472d7ae26dfe4b851ceca91b1eba54263180da32b63", "c3b997d050ee5d423ebaf66a6db9f57b3180c902875679de924b69d84a7b375"], ["e62f9490d3d51da6395efd24e80919cc7d0f29c3f3fa48c6fff543becbd43352", "6d89ad7ba4876b0b22c2ca280c682862f342c8591f1daf5170e07bfd9ccafa7d"], ["7f30ea2476b399b4957509c88f77d0191afa2ff5cb7b14fd6d8e7d65aaab1193", "ca5ef7d4b231c94c3b15389a5f6311e9daff7bb67b103e9880ef4bff637acaec"], ["5098ff1e1d9f14fb46a210fada6c903fef0fb7b4a1dd1d9ac60a0361800b7a00", "9731141d81fc8f8084d37c6e7542006b3ee1b40d60dfe5362a5b132fd17ddc0"], ["32b78c7de9ee512a72895be6b9cbefa6e2f3c4ccce445c96b9f2c81e2778ad58", "ee1849f513df71e32efc3896ee28260c73bb80547ae2275ba497237794c8753c"], ["e2cb74fddc8e9fbcd076eef2a7c72b0ce37d50f08269dfc074b581550547a4f7", "d3aa2ed71c9dd2247a62df062736eb0baddea9e36122d2be8641abcb005cc4a4"], ["8438447566d4d7bedadc299496ab357426009a35f235cb141be0d99cd10ae3a8", "c4e1020916980a4da5d01ac5e6ad330734ef0d7906631c4f2390426b2edd791f"], ["4162d488b89402039b584c6fc6c308870587d9c46f660b878ab65c82c711d67e", "67163e903236289f776f22c25fb8a3afc1732f2b84b4e95dbda47ae5a0852649"], ["3fad3fa84caf0f34f0f89bfd2dcf54fc175d767aec3e50684f3ba4a4bf5f683d", "cd1bc7cb6cc407bb2f0ca647c718a730cf71872e7d0d2a53fa20efcdfe61826"], ["674f2600a3007a00568c1a7ce05d0816c1fb84bf1370798f1c69532faeb1a86b", "299d21f9413f33b3edf43b257004580b70db57da0b182259e09eecc69e0d38a5"], ["d32f4da54ade74abb81b815ad1fb3b263d82d6c692714bcff87d29bd5ee9f08f", "f9429e738b8e53b968e99016c059707782e14f4535359d582fc416910b3eea87"], ["30e4e670435385556e593657135845d36fbb6931f72b08cb1ed954f1e3ce3ff6", "462f9bce619898638499350113bbc9b10a878d35da70740dc695a559eb88db7b"], ["be2062003c51cc3004682904330e4dee7f3dcd10b01e580bf1971b04d4cad297", "62188bc49d61e5428573d48a74e1c655b1c61090905682a0d5558ed72dccb9bc"], ["93144423ace3451ed29e0fb9ac2af211cb6e84a601df5993c419859fff5df04a", "7c10dfb164c3425f5c71a3f9d7992038f1065224f72bb9d1d902a6d13037b47c"], ["b015f8044f5fcbdcf21ca26d6c34fb8197829205c7b7d2a7cb66418c157b112c", "ab8c1e086d04e813744a655b2df8d5f83b3cdc6faa3088c1d3aea1454e3a1d5f"], ["d5e9e1da649d97d89e4868117a465a3a4f8a18de57a140d36b3f2af341a21b52", "4cb04437f391ed73111a13cc1d4dd0db1693465c2240480d8955e8592f27447a"], ["d3ae41047dd7ca065dbf8ed77b992439983005cd72e16d6f996a5316d36966bb", "bd1aeb21ad22ebb22a10f0303417c6d964f8cdd7df0aca614b10dc14d125ac46"], ["463e2763d885f958fc66cdd22800f0a487197d0a82e377b49f80af87c897b065", "bfefacdb0e5d0fd7df3a311a94de062b26b80c61fbc97508b79992671ef7ca7f"], ["7985fdfd127c0567c6f53ec1bb63ec3158e597c40bfe747c83cddfc910641917", "603c12daf3d9862ef2b25fe1de289aed24ed291e0ec6708703a5bd567f32ed03"], ["74a1ad6b5f76e39db2dd249410eac7f99e74c59cb83d2d0ed5ff1543da7703e9", "cc6157ef18c9c63cd6193d83631bbea0093e0968942e8c33d5737fd790e0db08"], ["30682a50703375f602d416664ba19b7fc9bab42c72747463a71d0896b22f6da3", "553e04f6b018b4fa6c8f39e7f311d3176290d0e0f19ca73f17714d9977a22ff8"], ["9e2158f0d7c0d5f26c3791efefa79597654e7a2b2464f52b1ee6c1347769ef57", "712fcdd1b9053f09003a3481fa7762e9ffd7c8ef35a38509e2fbf2629008373"], ["176e26989a43c9cfeba4029c202538c28172e566e3c4fce7322857f3be327d66", "ed8cc9d04b29eb877d270b4878dc43c19aefd31f4eee09ee7b47834c1fa4b1c3"], ["75d46efea3771e6e68abb89a13ad747ecf1892393dfc4f1b7004788c50374da8", "9852390a99507679fd0b86fd2b39a868d7efc22151346e1a3ca4726586a6bed8"], ["809a20c67d64900ffb698c4c825f6d5f2310fb0451c869345b7319f645605721", "9e994980d9917e22b76b061927fa04143d096ccc54963e6a5ebfa5f3f8e286c1"], ["1b38903a43f7f114ed4500b4eac7083fdefece1cf29c63528d563446f972c180", "4036edc931a60ae889353f77fd53de4a2708b26b6f5da72ad3394119daf408f9"]] } };
});
var $n2 = k4((lc) => {
  "use strict";
  var ts = lc, Jr = Jn2(), es = W02(), j3 = ht3(), dc = j3.assert;
  function cc(t) {
    t.type === "short" ? this.curve = new es.short(t) : t.type === "edwards" ? this.curve = new es.edwards(t) : this.curve = new es.mont(t), this.g = this.curve.g, this.n = this.curve.n, this.hash = t.hash, dc(this.g.validate(), "Invalid curve"), dc(this.g.mul(this.n).isInfinity(), "Invalid curve, G*N != O");
  }
  ts.PresetCurve = cc;
  function $r3(t, e) {
    Object.defineProperty(ts, t, { configurable: true, enumerable: true, get: function() {
      var r = new cc(e);
      return Object.defineProperty(ts, t, { configurable: true, enumerable: true, value: r }), r;
    } });
  }
  $r3("p192", { type: "short", prime: "p192", p: "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff", a: "ffffffff ffffffff ffffffff fffffffe ffffffff fffffffc", b: "64210519 e59c80e7 0fa7e9ab 72243049 feb8deec c146b9b1", n: "ffffffff ffffffff ffffffff 99def836 146bc9b1 b4d22831", hash: Jr.sha256, gRed: false, g: ["188da80e b03090f6 7cbf20eb 43a18800 f4ff0afd 82ff1012", "07192b95 ffc8da78 631011ed 6b24cdd5 73f977a1 1e794811"] });
  $r3("p224", { type: "short", prime: "p224", p: "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001", a: "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff fffffffe", b: "b4050a85 0c04b3ab f5413256 5044b0b7 d7bfd8ba 270b3943 2355ffb4", n: "ffffffff ffffffff ffffffff ffff16a2 e0b8f03e 13dd2945 5c5c2a3d", hash: Jr.sha256, gRed: false, g: ["b70e0cbd 6bb4bf7f 321390b9 4a03c1d3 56c21122 343280d6 115c1d21", "bd376388 b5f723fb 4c22dfe6 cd4375a0 5a074764 44d58199 85007e34"] });
  $r3("p256", { type: "short", prime: null, p: "ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff ffffffff", a: "ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff fffffffc", b: "5ac635d8 aa3a93e7 b3ebbd55 769886bc 651d06b0 cc53b0f6 3bce3c3e 27d2604b", n: "ffffffff 00000000 ffffffff ffffffff bce6faad a7179e84 f3b9cac2 fc632551", hash: Jr.sha256, gRed: false, g: ["6b17d1f2 e12c4247 f8bce6e5 63a440f2 77037d81 2deb33a0 f4a13945 d898c296", "4fe342e2 fe1a7f9b 8ee7eb4a 7c0f9e16 2bce3357 6b315ece cbb64068 37bf51f5"] });
  $r3("p384", { type: "short", prime: null, p: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 ffffffff", a: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 fffffffc", b: "b3312fa7 e23ee7e4 988e056b e3f82d19 181d9c6e fe814112 0314088f 5013875a c656398d 8a2ed19d 2a85c8ed d3ec2aef", n: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff c7634d81 f4372ddf 581a0db2 48b0a77a ecec196a ccc52973", hash: Jr.sha384, gRed: false, g: ["aa87ca22 be8b0537 8eb1c71e f320ad74 6e1d3b62 8ba79b98 59f741e0 82542a38 5502f25d bf55296c 3a545e38 72760ab7", "3617de4a 96262c6f 5d9e98bf 9292dc29 f8f41dbd 289a147c e9da3113 b5f0b8c0 0a60b1ce 1d7e819d 7a431d7c 90ea0e5f"] });
  $r3("p521", { type: "short", prime: null, p: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff", a: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffc", b: "00000051 953eb961 8e1c9a1f 929a21a0 b68540ee a2da725b 99b315f3 b8b48991 8ef109e1 56193951 ec7e937b 1652c0bd 3bb1bf07 3573df88 3d2c34f1 ef451fd4 6b503f00", n: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffa 51868783 bf2f966b 7fcc0148 f709a5d0 3bb5c9b8 899c47ae bb6fb71e 91386409", hash: Jr.sha512, gRed: false, g: ["000000c6 858e06b7 0404e9cd 9e3ecb66 2395b442 9c648139 053fb521 f828af60 6b4d3dba a14b5e77 efe75928 fe1dc127 a2ffa8de 3348b3c1 856a429b f97e7e31 c2e5bd66", "00000118 39296a78 9a3bc004 5c8a5fb4 2c7d1bd9 98f54449 579b4468 17afbd17 273e662c 97ee7299 5ef42640 c550b901 3fad0761 353c7086 a272c240 88be9476 9fd16650"] });
  $r3("curve25519", { type: "mont", prime: "p25519", p: "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed", a: "76d06", b: "1", n: "1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed", hash: Jr.sha256, gRed: false, g: ["9"] });
  $r3("ed25519", { type: "edwards", prime: "p25519", p: "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed", a: "-1", c: "1", d: "52036cee2b6ffe73 8cc740797779e898 00700a4d4141d8ab 75eb4dca135978a3", n: "1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed", hash: Jr.sha256, gRed: false, g: ["216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a", "6666666666666666666666666666666666666666666666666666666666666658"] });
  var rs;
  try {
    rs = uc2();
  } catch {
    rs = void 0;
  }
  $r3("secp256k1", { type: "short", prime: "k256", p: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f", a: "0", b: "7", n: "ffffffff ffffffff ffffffff fffffffe baaedce6 af48a03b bfd25e8c d0364141", h: "1", hash: Jr.sha256, beta: "7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee", lambda: "5363ad4cc05c30e0a5261c028812645a122e22ea20816678df02967c1b23bd72", basis: [{ a: "3086d221a7d46bcde86c90e49284eb15", b: "-e4437ed6010e88286f547fa90abfe4c3" }, { a: "114ca50f7a8e2f3f657c1108d9d44cfd8", b: "3086d221a7d46bcde86c90e49284eb15" }], gRed: false, g: ["79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798", "483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8", rs] });
});
var bc2 = k4((Lm, pc) => {
  "use strict";
  var W32 = Jn2(), Mi = K02(), vc = ot3();
  function Qr2(t) {
    if (!(this instanceof Qr2))
      return new Qr2(t);
    this.hash = t.hash, this.predResist = !!t.predResist, this.outLen = this.hash.outSize, this.minEntropy = t.minEntropy || this.hash.hmacStrength, this._reseed = null, this.reseedInterval = null, this.K = null, this.V = null;
    var e = Mi.toArray(t.entropy, t.entropyEnc || "hex"), r = Mi.toArray(t.nonce, t.nonceEnc || "hex"), n = Mi.toArray(t.pers, t.persEnc || "hex");
    vc(e.length >= this.minEntropy / 8, "Not enough entropy. Minimum is: " + this.minEntropy + " bits"), this._init(e, r, n);
  }
  pc.exports = Qr2;
  Qr2.prototype._init = function(e, r, n) {
    var i = e.concat(r).concat(n);
    this.K = new Array(this.outLen / 8), this.V = new Array(this.outLen / 8);
    for (var o2 = 0; o2 < this.V.length; o2++)
      this.K[o2] = 0, this.V[o2] = 1;
    this._update(i), this._reseed = 1, this.reseedInterval = 281474976710656;
  };
  Qr2.prototype._hmac = function() {
    return new W32.hmac(this.hash, this.K);
  };
  Qr2.prototype._update = function(e) {
    var r = this._hmac().update(this.V).update([0]);
    e && (r = r.update(e)), this.K = r.digest(), this.V = this._hmac().update(this.V).digest(), e && (this.K = this._hmac().update(this.V).update([1]).update(e).digest(), this.V = this._hmac().update(this.V).digest());
  };
  Qr2.prototype.reseed = function(e, r, n, i) {
    typeof r != "string" && (i = n, n = r, r = null), e = Mi.toArray(e, r), n = Mi.toArray(n, i), vc(e.length >= this.minEntropy / 8, "Not enough entropy. Minimum is: " + this.minEntropy + " bits"), this._update(e.concat(n || [])), this._reseed = 1;
  };
  Qr2.prototype.generate = function(e, r, n, i) {
    if (this._reseed > this.reseedInterval)
      throw new Error("Reseed is required");
    typeof r != "string" && (i = n, n = r, r = null), n && (n = Mi.toArray(n, i || "hex"), this._update(n));
    for (var o2 = []; o2.length < e; )
      this.V = this._hmac().update(this.V).digest(), o2 = o2.concat(this.V);
    var p3 = o2.slice(0, e);
    return this._update(n), this._reseed++, Mi.encode(p3, r);
  };
});
var gc2 = k4((Om, mc) => {
  "use strict";
  var V3 = Fe2(), Z32 = ht3(), is = Z32.assert;
  function tt(t, e) {
    this.ec = t, this.priv = null, this.pub = null, e.priv && this._importPrivate(e.priv, e.privEnc), e.pub && this._importPublic(e.pub, e.pubEnc);
  }
  mc.exports = tt;
  tt.fromPublic = function(e, r, n) {
    return r instanceof tt ? r : new tt(e, { pub: r, pubEnc: n });
  };
  tt.fromPrivate = function(e, r, n) {
    return r instanceof tt ? r : new tt(e, { priv: r, privEnc: n });
  };
  tt.prototype.validate = function() {
    var e = this.getPublic();
    return e.isInfinity() ? { result: false, reason: "Invalid public key" } : e.validate() ? e.mul(this.ec.curve.n).isInfinity() ? { result: true, reason: null } : { result: false, reason: "Public key * N != O" } : { result: false, reason: "Public key is not a point" };
  };
  tt.prototype.getPublic = function(e, r) {
    return typeof e == "string" && (r = e, e = null), this.pub || (this.pub = this.ec.g.mul(this.priv)), r ? this.pub.encode(r, e) : this.pub;
  };
  tt.prototype.getPrivate = function(e) {
    return e === "hex" ? this.priv.toString(16, 2) : this.priv;
  };
  tt.prototype._importPrivate = function(e, r) {
    this.priv = new V3(e, r || 16), this.priv = this.priv.umod(this.ec.curve.n);
  };
  tt.prototype._importPublic = function(e, r) {
    if (e.x || e.y) {
      this.ec.curve.type === "mont" ? is(e.x, "Need x coordinate") : (this.ec.curve.type === "short" || this.ec.curve.type === "edwards") && is(e.x && e.y, "Need both x and y coordinate"), this.pub = this.ec.curve.point(e.x, e.y);
      return;
    }
    this.pub = this.ec.curve.decodePoint(e, r);
  };
  tt.prototype.derive = function(e) {
    return e.validate() || is(e.validate(), "public point not validated"), e.mul(this.priv).getX();
  };
  tt.prototype.sign = function(e, r, n) {
    return this.ec.sign(e, this, r, n);
  };
  tt.prototype.verify = function(e, r) {
    return this.ec.verify(e, r, this);
  };
  tt.prototype.inspect = function() {
    return "<Key priv: " + (this.priv && this.priv.toString(16, 2)) + " pub: " + (this.pub && this.pub.inspect()) + " >";
  };
});
var wc2 = k4((zm, _c) => {
  "use strict";
  var Qn = Fe2(), as = ht3(), G32 = as.assert;
  function ea(t, e) {
    if (t instanceof ea)
      return t;
    this._importDER(t, e) || (G32(t.r && t.s, "Signature without r or s"), this.r = new Qn(t.r, 16), this.s = new Qn(t.s, 16), t.recoveryParam === void 0 ? this.recoveryParam = null : this.recoveryParam = t.recoveryParam);
  }
  _c.exports = ea;
  function X32() {
    this.place = 0;
  }
  function fs2(t, e) {
    var r = t[e.place++];
    if (!(r & 128))
      return r;
    var n = r & 15;
    if (n === 0 || n > 4)
      return false;
    for (var i = 0, o2 = 0, p3 = e.place; o2 < n; o2++, p3++)
      i <<= 8, i |= t[p3], i >>>= 0;
    return i <= 127 ? false : (e.place = p3, i);
  }
  function yc(t) {
    for (var e = 0, r = t.length - 1; !t[e] && !(t[e + 1] & 128) && e < r; )
      e++;
    return e === 0 ? t : t.slice(e);
  }
  ea.prototype._importDER = function(e, r) {
    e = as.toArray(e, r);
    var n = new X32();
    if (e[n.place++] !== 48)
      return false;
    var i = fs2(e, n);
    if (i === false || i + n.place !== e.length || e[n.place++] !== 2)
      return false;
    var o2 = fs2(e, n);
    if (o2 === false)
      return false;
    var p3 = e.slice(n.place, o2 + n.place);
    if (n.place += o2, e[n.place++] !== 2)
      return false;
    var y4 = fs2(e, n);
    if (y4 === false || e.length !== y4 + n.place)
      return false;
    var w2 = e.slice(n.place, y4 + n.place);
    if (p3[0] === 0)
      if (p3[1] & 128)
        p3 = p3.slice(1);
      else
        return false;
    if (w2[0] === 0)
      if (w2[1] & 128)
        w2 = w2.slice(1);
      else
        return false;
    return this.r = new Qn(p3), this.s = new Qn(w2), this.recoveryParam = null, true;
  };
  function ns(t, e) {
    if (e < 128) {
      t.push(e);
      return;
    }
    var r = 1 + (Math.log(e) / Math.LN2 >>> 3);
    for (t.push(r | 128); --r; )
      t.push(e >>> (r << 3) & 255);
    t.push(e);
  }
  ea.prototype.toDER = function(e) {
    var r = this.r.toArray(), n = this.s.toArray();
    for (r[0] & 128 && (r = [0].concat(r)), n[0] & 128 && (n = [0].concat(n)), r = yc(r), n = yc(n); !n[0] && !(n[1] & 128); )
      n = n.slice(1);
    var i = [2];
    ns(i, r.length), i = i.concat(r), i.push(2), ns(i, n.length);
    var o2 = i.concat(n), p3 = [48];
    return ns(p3, o2.length), p3 = p3.concat(o2), as.encode(p3, e);
  };
});
var Ec2 = k4((Um, Sc) => {
  "use strict";
  var Si = Fe2(), xc = bc2(), Y32 = ht3(), ss = $n2(), J3 = On2(), Mc = Y32.assert, os3 = gc2(), ta = wc2();
  function _t(t) {
    if (!(this instanceof _t))
      return new _t(t);
    typeof t == "string" && (Mc(Object.prototype.hasOwnProperty.call(ss, t), "Unknown curve " + t), t = ss[t]), t instanceof ss.PresetCurve && (t = { curve: t }), this.curve = t.curve.curve, this.n = this.curve.n, this.nh = this.n.ushrn(1), this.g = this.curve.g, this.g = t.curve.g, this.g.precompute(t.curve.n.bitLength() + 1), this.hash = t.hash || t.curve.hash;
  }
  Sc.exports = _t;
  _t.prototype.keyPair = function(e) {
    return new os3(this, e);
  };
  _t.prototype.keyFromPrivate = function(e, r) {
    return os3.fromPrivate(this, e, r);
  };
  _t.prototype.keyFromPublic = function(e, r) {
    return os3.fromPublic(this, e, r);
  };
  _t.prototype.genKeyPair = function(e) {
    e || (e = {});
    for (var r = new xc({ hash: this.hash, pers: e.pers, persEnc: e.persEnc || "utf8", entropy: e.entropy || J3(this.hash.hmacStrength), entropyEnc: e.entropy && e.entropyEnc || "utf8", nonce: this.n.toArray() }), n = this.n.byteLength(), i = this.n.sub(new Si(2)); ; ) {
      var o2 = new Si(r.generate(n));
      if (!(o2.cmp(i) > 0))
        return o2.iaddn(1), this.keyFromPrivate(o2);
    }
  };
  _t.prototype._truncateToN = function(e, r) {
    var n = e.byteLength() * 8 - this.n.bitLength();
    return n > 0 && (e = e.ushrn(n)), !r && e.cmp(this.n) >= 0 ? e.sub(this.n) : e;
  };
  _t.prototype.sign = function(e, r, n, i) {
    typeof n == "object" && (i = n, n = null), i || (i = {}), r = this.keyFromPrivate(r, n), e = this._truncateToN(new Si(e, 16));
    for (var o2 = this.n.byteLength(), p3 = r.getPrivate().toArray("be", o2), y4 = e.toArray("be", o2), w2 = new xc({ hash: this.hash, entropy: p3, nonce: y4, pers: i.pers, persEnc: i.persEnc || "utf8" }), x = this.n.sub(new Si(1)), M4 = 0; ; M4++) {
      var E2 = i.k ? i.k(M4) : new Si(w2.generate(this.n.byteLength()));
      if (E2 = this._truncateToN(E2, true), !(E2.cmpn(1) <= 0 || E2.cmp(x) >= 0)) {
        var A4 = this.g.mul(E2);
        if (!A4.isInfinity()) {
          var I3 = A4.getX(), D6 = I3.umod(this.n);
          if (D6.cmpn(0) !== 0) {
            var C = E2.invm(this.n).mul(D6.mul(r.getPrivate()).iadd(e));
            if (C = C.umod(this.n), C.cmpn(0) !== 0) {
              var ge2 = (A4.getY().isOdd() ? 1 : 0) | (I3.cmp(D6) !== 0 ? 2 : 0);
              return i.canonical && C.cmp(this.nh) > 0 && (C = this.n.sub(C), ge2 ^= 1), new ta({ r: D6, s: C, recoveryParam: ge2 });
            }
          }
        }
      }
    }
  };
  _t.prototype.verify = function(e, r, n, i) {
    e = this._truncateToN(new Si(e, 16)), n = this.keyFromPublic(n, i), r = new ta(r, "hex");
    var o2 = r.r, p3 = r.s;
    if (o2.cmpn(1) < 0 || o2.cmp(this.n) >= 0 || p3.cmpn(1) < 0 || p3.cmp(this.n) >= 0)
      return false;
    var y4 = p3.invm(this.n), w2 = y4.mul(e).umod(this.n), x = y4.mul(o2).umod(this.n), M4;
    return this.curve._maxwellTrick ? (M4 = this.g.jmulAdd(w2, n.getPublic(), x), M4.isInfinity() ? false : M4.eqXToP(o2)) : (M4 = this.g.mulAdd(w2, n.getPublic(), x), M4.isInfinity() ? false : M4.getX().umod(this.n).cmp(o2) === 0);
  };
  _t.prototype.recoverPubKey = function(t, e, r, n) {
    Mc((3 & r) === r, "The recovery param is more than two bits"), e = new ta(e, n);
    var i = this.n, o2 = new Si(t), p3 = e.r, y4 = e.s, w2 = r & 1, x = r >> 1;
    if (p3.cmp(this.curve.p.umod(this.curve.n)) >= 0 && x)
      throw new Error("Unable to find sencond key candinate");
    x ? p3 = this.curve.pointFromX(p3.add(this.curve.n), w2) : p3 = this.curve.pointFromX(p3, w2);
    var M4 = e.r.invm(i), E2 = i.sub(o2).mul(M4).umod(i), A4 = y4.mul(M4).umod(i);
    return this.g.mulAdd(E2, p3, A4);
  };
  _t.prototype.getKeyRecoveryParam = function(t, e, r, n) {
    if (e = new ta(e, n), e.recoveryParam !== null)
      return e.recoveryParam;
    for (var i = 0; i < 4; i++) {
      var o2;
      try {
        o2 = this.recoverPubKey(t, e, i);
      } catch {
        continue;
      }
      if (o2.eq(r))
        return i;
    }
    throw new Error("Unable to find valid recovery factor");
  };
});
var Rc2 = k4((Hm, Bc) => {
  "use strict";
  var Uf = ht3(), qc = Uf.assert, Ac = Uf.parseBytes, Qi = Uf.cachedProperty;
  function Ze2(t, e) {
    this.eddsa = t, this._secret = Ac(e.secret), t.isPoint(e.pub) ? this._pub = e.pub : this._pubBytes = Ac(e.pub);
  }
  Ze2.fromPublic = function(e, r) {
    return r instanceof Ze2 ? r : new Ze2(e, { pub: r });
  };
  Ze2.fromSecret = function(e, r) {
    return r instanceof Ze2 ? r : new Ze2(e, { secret: r });
  };
  Ze2.prototype.secret = function() {
    return this._secret;
  };
  Qi(Ze2, "pubBytes", function() {
    return this.eddsa.encodePoint(this.pub());
  });
  Qi(Ze2, "pub", function() {
    return this._pubBytes ? this.eddsa.decodePoint(this._pubBytes) : this.eddsa.g.mul(this.priv());
  });
  Qi(Ze2, "privBytes", function() {
    var e = this.eddsa, r = this.hash(), n = e.encodingLength - 1, i = r.slice(0, e.encodingLength);
    return i[0] &= 248, i[n] &= 127, i[n] |= 64, i;
  });
  Qi(Ze2, "priv", function() {
    return this.eddsa.decodeInt(this.privBytes());
  });
  Qi(Ze2, "hash", function() {
    return this.eddsa.hash().update(this.secret()).digest();
  });
  Qi(Ze2, "messagePrefix", function() {
    return this.hash().slice(this.eddsa.encodingLength);
  });
  Ze2.prototype.sign = function(e) {
    return qc(this._secret, "KeyPair can only verify"), this.eddsa.sign(e, this);
  };
  Ze2.prototype.verify = function(e, r) {
    return this.eddsa.verify(e, r, this);
  };
  Ze2.prototype.getSecret = function(e) {
    return qc(this._secret, "KeyPair is public only"), Uf.encode(this.secret(), e);
  };
  Ze2.prototype.getPublic = function(e) {
    return Uf.encode(this.pubBytes(), e);
  };
  Bc.exports = Ze2;
});
var kc2 = k4((Fm, Ic) => {
  "use strict";
  var $32 = Fe2(), ra = ht3(), Q3 = ra.assert, ia = ra.cachedProperty, e4 = ra.parseBytes;
  function Ei(t, e) {
    this.eddsa = t, typeof e != "object" && (e = e4(e)), Array.isArray(e) && (e = { R: e.slice(0, t.encodingLength), S: e.slice(t.encodingLength) }), Q3(e.R && e.S, "Signature without R or S"), t.isPoint(e.R) && (this._R = e.R), e.S instanceof $32 && (this._S = e.S), this._Rencoded = Array.isArray(e.R) ? e.R : e.Rencoded, this._Sencoded = Array.isArray(e.S) ? e.S : e.Sencoded;
  }
  ia(Ei, "S", function() {
    return this.eddsa.decodeInt(this.Sencoded());
  });
  ia(Ei, "R", function() {
    return this.eddsa.decodePoint(this.Rencoded());
  });
  ia(Ei, "Rencoded", function() {
    return this.eddsa.encodePoint(this.R());
  });
  ia(Ei, "Sencoded", function() {
    return this.eddsa.encodeInt(this.S());
  });
  Ei.prototype.toBytes = function() {
    return this.Rencoded().concat(this.Sencoded());
  };
  Ei.prototype.toHex = function() {
    return ra.encode(this.toBytes(), "hex").toUpperCase();
  };
  Ic.exports = Ei;
});
var Nc2 = k4((Km, Cc) => {
  "use strict";
  var t4 = Jn2(), r4 = $n2(), ef = ht3(), i4 = ef.assert, Pc = ef.parseBytes, Tc = Rc2(), Dc = kc2();
  function at2(t) {
    if (i4(t === "ed25519", "only tested with ed25519 so far"), !(this instanceof at2))
      return new at2(t);
    t = r4[t].curve, this.curve = t, this.g = t.g, this.g.precompute(t.n.bitLength() + 1), this.pointClass = t.point().constructor, this.encodingLength = Math.ceil(t.n.bitLength() / 8), this.hash = t4.sha512;
  }
  Cc.exports = at2;
  at2.prototype.sign = function(e, r) {
    e = Pc(e);
    var n = this.keyFromSecret(r), i = this.hashInt(n.messagePrefix(), e), o2 = this.g.mul(i), p3 = this.encodePoint(o2), y4 = this.hashInt(p3, n.pubBytes(), e).mul(n.priv()), w2 = i.add(y4).umod(this.curve.n);
    return this.makeSignature({ R: o2, S: w2, Rencoded: p3 });
  };
  at2.prototype.verify = function(e, r, n) {
    e = Pc(e), r = this.makeSignature(r);
    var i = this.keyFromPublic(n), o2 = this.hashInt(r.Rencoded(), i.pubBytes(), e), p3 = this.g.mul(r.S()), y4 = r.R().add(i.pub().mul(o2));
    return y4.eq(p3);
  };
  at2.prototype.hashInt = function() {
    for (var e = this.hash(), r = 0; r < arguments.length; r++)
      e.update(arguments[r]);
    return ef.intFromLE(e.digest()).umod(this.curve.n);
  };
  at2.prototype.keyFromPublic = function(e) {
    return Tc.fromPublic(this, e);
  };
  at2.prototype.keyFromSecret = function(e) {
    return Tc.fromSecret(this, e);
  };
  at2.prototype.makeSignature = function(e) {
    return e instanceof Dc ? e : new Dc(this, e);
  };
  at2.prototype.encodePoint = function(e) {
    var r = e.getY().toArray("le", this.encodingLength);
    return r[this.encodingLength - 1] |= e.getX().isOdd() ? 128 : 0, r;
  };
  at2.prototype.decodePoint = function(e) {
    e = ef.parseBytes(e);
    var r = e.length - 1, n = e.slice(0, r).concat(e[r] & -129), i = (e[r] & 128) !== 0, o2 = ef.intFromLE(n);
    return this.curve.pointFromY(o2, i);
  };
  at2.prototype.encodeInt = function(e) {
    return e.toArray("le", this.encodingLength);
  };
  at2.prototype.decodeInt = function(e) {
    return ef.intFromLE(e);
  };
  at2.prototype.isPoint = function(e) {
    return e instanceof this.pointClass;
  };
});
var fa2 = k4((Lc) => {
  "use strict";
  var Ai = Lc;
  Ai.version = pd2().version;
  Ai.utils = ht3();
  Ai.rand = On2();
  Ai.curve = W02();
  Ai.curves = $n2();
  Ai.ec = Ec2();
  Ai.eddsa = Nc2();
});
var us2 = k4((Oc, hs) => {
  (function(t, e) {
    "use strict";
    function r(c5, f) {
      if (!c5)
        throw new Error(f || "Assertion failed");
    }
    function n(c5, f) {
      c5.super_ = f;
      var a = function() {
      };
      a.prototype = f.prototype, c5.prototype = new a(), c5.prototype.constructor = c5;
    }
    function i(c5, f, a) {
      if (i.isBN(c5))
        return c5;
      this.negative = 0, this.words = null, this.length = 0, this.red = null, c5 !== null && ((f === "le" || f === "be") && (a = f, f = 10), this._init(c5 || 0, f || 10, a || "be"));
    }
    typeof t == "object" ? t.exports = i : e.BN = i, i.BN = i, i.wordSize = 26;
    var o2;
    try {
      typeof window != "undefined" && typeof window.Buffer != "undefined" ? o2 = window.Buffer : o2 = export_default.Buffer;
    } catch {
    }
    i.isBN = function(f) {
      return f instanceof i ? true : f !== null && typeof f == "object" && f.constructor.wordSize === i.wordSize && Array.isArray(f.words);
    }, i.max = function(f, a) {
      return f.cmp(a) > 0 ? f : a;
    }, i.min = function(f, a) {
      return f.cmp(a) < 0 ? f : a;
    }, i.prototype._init = function(f, a, u) {
      if (typeof f == "number")
        return this._initNumber(f, a, u);
      if (typeof f == "object")
        return this._initArray(f, a, u);
      a === "hex" && (a = 16), r(a === (a | 0) && a >= 2 && a <= 36), f = f.toString().replace(/\s+/g, "");
      var l = 0;
      f[0] === "-" && (l++, this.negative = 1), l < f.length && (a === 16 ? this._parseHex(f, l, u) : (this._parseBase(f, a, l), u === "le" && this._initArray(this.toArray(), a, u)));
    }, i.prototype._initNumber = function(f, a, u) {
      f < 0 && (this.negative = 1, f = -f), f < 67108864 ? (this.words = [f & 67108863], this.length = 1) : f < 4503599627370496 ? (this.words = [f & 67108863, f / 67108864 & 67108863], this.length = 2) : (r(f < 9007199254740992), this.words = [f & 67108863, f / 67108864 & 67108863, 1], this.length = 3), u === "le" && this._initArray(this.toArray(), a, u);
    }, i.prototype._initArray = function(f, a, u) {
      if (r(typeof f.length == "number"), f.length <= 0)
        return this.words = [0], this.length = 1, this;
      this.length = Math.ceil(f.length / 3), this.words = new Array(this.length);
      for (var l = 0; l < this.length; l++)
        this.words[l] = 0;
      var d4, h, b2 = 0;
      if (u === "be")
        for (l = f.length - 1, d4 = 0; l >= 0; l -= 3)
          h = f[l] | f[l - 1] << 8 | f[l - 2] << 16, this.words[d4] |= h << b2 & 67108863, this.words[d4 + 1] = h >>> 26 - b2 & 67108863, b2 += 24, b2 >= 26 && (b2 -= 26, d4++);
      else if (u === "le")
        for (l = 0, d4 = 0; l < f.length; l += 3)
          h = f[l] | f[l + 1] << 8 | f[l + 2] << 16, this.words[d4] |= h << b2 & 67108863, this.words[d4 + 1] = h >>> 26 - b2 & 67108863, b2 += 24, b2 >= 26 && (b2 -= 26, d4++);
      return this._strip();
    };
    function p3(c5, f) {
      var a = c5.charCodeAt(f);
      if (a >= 48 && a <= 57)
        return a - 48;
      if (a >= 65 && a <= 70)
        return a - 55;
      if (a >= 97 && a <= 102)
        return a - 87;
      r(false, "Invalid character in " + c5);
    }
    function y4(c5, f, a) {
      var u = p3(c5, a);
      return a - 1 >= f && (u |= p3(c5, a - 1) << 4), u;
    }
    i.prototype._parseHex = function(f, a, u) {
      this.length = Math.ceil((f.length - a) / 6), this.words = new Array(this.length);
      for (var l = 0; l < this.length; l++)
        this.words[l] = 0;
      var d4 = 0, h = 0, b2;
      if (u === "be")
        for (l = f.length - 1; l >= a; l -= 2)
          b2 = y4(f, a, l) << d4, this.words[h] |= b2 & 67108863, d4 >= 18 ? (d4 -= 18, h += 1, this.words[h] |= b2 >>> 26) : d4 += 8;
      else {
        var m3 = f.length - a;
        for (l = m3 % 2 === 0 ? a + 1 : a; l < f.length; l += 2)
          b2 = y4(f, a, l) << d4, this.words[h] |= b2 & 67108863, d4 >= 18 ? (d4 -= 18, h += 1, this.words[h] |= b2 >>> 26) : d4 += 8;
      }
      this._strip();
    };
    function w2(c5, f, a, u) {
      for (var l = 0, d4 = 0, h = Math.min(c5.length, a), b2 = f; b2 < h; b2++) {
        var m3 = c5.charCodeAt(b2) - 48;
        l *= u, m3 >= 49 ? d4 = m3 - 49 + 10 : m3 >= 17 ? d4 = m3 - 17 + 10 : d4 = m3, r(m3 >= 0 && d4 < u, "Invalid character"), l += d4;
      }
      return l;
    }
    i.prototype._parseBase = function(f, a, u) {
      this.words = [0], this.length = 1;
      for (var l = 0, d4 = 1; d4 <= 67108863; d4 *= a)
        l++;
      l--, d4 = d4 / a | 0;
      for (var h = f.length - u, b2 = h % l, m3 = Math.min(h, h - b2) + u, s = 0, g2 = u; g2 < m3; g2 += l)
        s = w2(f, g2, g2 + l, a), this.imuln(d4), this.words[0] + s < 67108864 ? this.words[0] += s : this._iaddn(s);
      if (b2 !== 0) {
        var q = 1;
        for (s = w2(f, g2, f.length, a), g2 = 0; g2 < b2; g2++)
          q *= a;
        this.imuln(q), this.words[0] + s < 67108864 ? this.words[0] += s : this._iaddn(s);
      }
      this._strip();
    }, i.prototype.copy = function(f) {
      f.words = new Array(this.length);
      for (var a = 0; a < this.length; a++)
        f.words[a] = this.words[a];
      f.length = this.length, f.negative = this.negative, f.red = this.red;
    };
    function x(c5, f) {
      c5.words = f.words, c5.length = f.length, c5.negative = f.negative, c5.red = f.red;
    }
    if (i.prototype._move = function(f) {
      x(f, this);
    }, i.prototype.clone = function() {
      var f = new i(null);
      return this.copy(f), f;
    }, i.prototype._expand = function(f) {
      for (; this.length < f; )
        this.words[this.length++] = 0;
      return this;
    }, i.prototype._strip = function() {
      for (; this.length > 1 && this.words[this.length - 1] === 0; )
        this.length--;
      return this._normSign();
    }, i.prototype._normSign = function() {
      return this.length === 1 && this.words[0] === 0 && (this.negative = 0), this;
    }, typeof Symbol != "undefined" && typeof Symbol.for == "function")
      try {
        i.prototype[Symbol.for("nodejs.util.inspect.custom")] = M4;
      } catch {
        i.prototype.inspect = M4;
      }
    else
      i.prototype.inspect = M4;
    function M4() {
      return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
    }
    var E2 = ["", "0", "00", "000", "0000", "00000", "000000", "0000000", "00000000", "000000000", "0000000000", "00000000000", "000000000000", "0000000000000", "00000000000000", "000000000000000", "0000000000000000", "00000000000000000", "000000000000000000", "0000000000000000000", "00000000000000000000", "000000000000000000000", "0000000000000000000000", "00000000000000000000000", "000000000000000000000000", "0000000000000000000000000"], A4 = [0, 0, 25, 16, 12, 11, 10, 9, 8, 8, 7, 7, 7, 7, 6, 6, 6, 6, 6, 6, 6, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5], I3 = [0, 0, 33554432, 43046721, 16777216, 48828125, 60466176, 40353607, 16777216, 43046721, 1e7, 19487171, 35831808, 62748517, 7529536, 11390625, 16777216, 24137569, 34012224, 47045881, 64e6, 4084101, 5153632, 6436343, 7962624, 9765625, 11881376, 14348907, 17210368, 20511149, 243e5, 28629151, 33554432, 39135393, 45435424, 52521875, 60466176];
    i.prototype.toString = function(f, a) {
      f = f || 10, a = a | 0 || 1;
      var u;
      if (f === 16 || f === "hex") {
        u = "";
        for (var l = 0, d4 = 0, h = 0; h < this.length; h++) {
          var b2 = this.words[h], m3 = ((b2 << l | d4) & 16777215).toString(16);
          d4 = b2 >>> 24 - l & 16777215, l += 2, l >= 26 && (l -= 26, h--), d4 !== 0 || h !== this.length - 1 ? u = E2[6 - m3.length] + m3 + u : u = m3 + u;
        }
        for (d4 !== 0 && (u = d4.toString(16) + u); u.length % a !== 0; )
          u = "0" + u;
        return this.negative !== 0 && (u = "-" + u), u;
      }
      if (f === (f | 0) && f >= 2 && f <= 36) {
        var s = A4[f], g2 = I3[f];
        u = "";
        var q = this.clone();
        for (q.negative = 0; !q.isZero(); ) {
          var R3 = q.modrn(g2).toString(f);
          q = q.idivn(g2), q.isZero() ? u = R3 + u : u = E2[s - R3.length] + R3 + u;
        }
        for (this.isZero() && (u = "0" + u); u.length % a !== 0; )
          u = "0" + u;
        return this.negative !== 0 && (u = "-" + u), u;
      }
      r(false, "Base should be between 2 and 36");
    }, i.prototype.toNumber = function() {
      var f = this.words[0];
      return this.length === 2 ? f += this.words[1] * 67108864 : this.length === 3 && this.words[2] === 1 ? f += 4503599627370496 + this.words[1] * 67108864 : this.length > 2 && r(false, "Number can only safely store up to 53 bits"), this.negative !== 0 ? -f : f;
    }, i.prototype.toJSON = function() {
      return this.toString(16, 2);
    }, o2 && (i.prototype.toBuffer = function(f, a) {
      return this.toArrayLike(o2, f, a);
    }), i.prototype.toArray = function(f, a) {
      return this.toArrayLike(Array, f, a);
    };
    var D6 = function(f, a) {
      return f.allocUnsafe ? f.allocUnsafe(a) : new f(a);
    };
    i.prototype.toArrayLike = function(f, a, u) {
      this._strip();
      var l = this.byteLength(), d4 = u || Math.max(1, l);
      r(l <= d4, "byte array longer than desired length"), r(d4 > 0, "Requested array length <= 0");
      var h = D6(f, d4), b2 = a === "le" ? "LE" : "BE";
      return this["_toArrayLike" + b2](h, l), h;
    }, i.prototype._toArrayLikeLE = function(f, a) {
      for (var u = 0, l = 0, d4 = 0, h = 0; d4 < this.length; d4++) {
        var b2 = this.words[d4] << h | l;
        f[u++] = b2 & 255, u < f.length && (f[u++] = b2 >> 8 & 255), u < f.length && (f[u++] = b2 >> 16 & 255), h === 6 ? (u < f.length && (f[u++] = b2 >> 24 & 255), l = 0, h = 0) : (l = b2 >>> 24, h += 2);
      }
      if (u < f.length)
        for (f[u++] = l; u < f.length; )
          f[u++] = 0;
    }, i.prototype._toArrayLikeBE = function(f, a) {
      for (var u = f.length - 1, l = 0, d4 = 0, h = 0; d4 < this.length; d4++) {
        var b2 = this.words[d4] << h | l;
        f[u--] = b2 & 255, u >= 0 && (f[u--] = b2 >> 8 & 255), u >= 0 && (f[u--] = b2 >> 16 & 255), h === 6 ? (u >= 0 && (f[u--] = b2 >> 24 & 255), l = 0, h = 0) : (l = b2 >>> 24, h += 2);
      }
      if (u >= 0)
        for (f[u--] = l; u >= 0; )
          f[u--] = 0;
    }, Math.clz32 ? i.prototype._countBits = function(f) {
      return 32 - Math.clz32(f);
    } : i.prototype._countBits = function(f) {
      var a = f, u = 0;
      return a >= 4096 && (u += 13, a >>>= 13), a >= 64 && (u += 7, a >>>= 7), a >= 8 && (u += 4, a >>>= 4), a >= 2 && (u += 2, a >>>= 2), u + a;
    }, i.prototype._zeroBits = function(f) {
      if (f === 0)
        return 26;
      var a = f, u = 0;
      return (a & 8191) === 0 && (u += 13, a >>>= 13), (a & 127) === 0 && (u += 7, a >>>= 7), (a & 15) === 0 && (u += 4, a >>>= 4), (a & 3) === 0 && (u += 2, a >>>= 2), (a & 1) === 0 && u++, u;
    }, i.prototype.bitLength = function() {
      var f = this.words[this.length - 1], a = this._countBits(f);
      return (this.length - 1) * 26 + a;
    };
    function C(c5) {
      for (var f = new Array(c5.bitLength()), a = 0; a < f.length; a++) {
        var u = a / 26 | 0, l = a % 26;
        f[a] = c5.words[u] >>> l & 1;
      }
      return f;
    }
    i.prototype.zeroBits = function() {
      if (this.isZero())
        return 0;
      for (var f = 0, a = 0; a < this.length; a++) {
        var u = this._zeroBits(this.words[a]);
        if (f += u, u !== 26)
          break;
      }
      return f;
    }, i.prototype.byteLength = function() {
      return Math.ceil(this.bitLength() / 8);
    }, i.prototype.toTwos = function(f) {
      return this.negative !== 0 ? this.abs().inotn(f).iaddn(1) : this.clone();
    }, i.prototype.fromTwos = function(f) {
      return this.testn(f - 1) ? this.notn(f).iaddn(1).ineg() : this.clone();
    }, i.prototype.isNeg = function() {
      return this.negative !== 0;
    }, i.prototype.neg = function() {
      return this.clone().ineg();
    }, i.prototype.ineg = function() {
      return this.isZero() || (this.negative ^= 1), this;
    }, i.prototype.iuor = function(f) {
      for (; this.length < f.length; )
        this.words[this.length++] = 0;
      for (var a = 0; a < f.length; a++)
        this.words[a] = this.words[a] | f.words[a];
      return this._strip();
    }, i.prototype.ior = function(f) {
      return r((this.negative | f.negative) === 0), this.iuor(f);
    }, i.prototype.or = function(f) {
      return this.length > f.length ? this.clone().ior(f) : f.clone().ior(this);
    }, i.prototype.uor = function(f) {
      return this.length > f.length ? this.clone().iuor(f) : f.clone().iuor(this);
    }, i.prototype.iuand = function(f) {
      var a;
      this.length > f.length ? a = f : a = this;
      for (var u = 0; u < a.length; u++)
        this.words[u] = this.words[u] & f.words[u];
      return this.length = a.length, this._strip();
    }, i.prototype.iand = function(f) {
      return r((this.negative | f.negative) === 0), this.iuand(f);
    }, i.prototype.and = function(f) {
      return this.length > f.length ? this.clone().iand(f) : f.clone().iand(this);
    }, i.prototype.uand = function(f) {
      return this.length > f.length ? this.clone().iuand(f) : f.clone().iuand(this);
    }, i.prototype.iuxor = function(f) {
      var a, u;
      this.length > f.length ? (a = this, u = f) : (a = f, u = this);
      for (var l = 0; l < u.length; l++)
        this.words[l] = a.words[l] ^ u.words[l];
      if (this !== a)
        for (; l < a.length; l++)
          this.words[l] = a.words[l];
      return this.length = a.length, this._strip();
    }, i.prototype.ixor = function(f) {
      return r((this.negative | f.negative) === 0), this.iuxor(f);
    }, i.prototype.xor = function(f) {
      return this.length > f.length ? this.clone().ixor(f) : f.clone().ixor(this);
    }, i.prototype.uxor = function(f) {
      return this.length > f.length ? this.clone().iuxor(f) : f.clone().iuxor(this);
    }, i.prototype.inotn = function(f) {
      r(typeof f == "number" && f >= 0);
      var a = Math.ceil(f / 26) | 0, u = f % 26;
      this._expand(a), u > 0 && a--;
      for (var l = 0; l < a; l++)
        this.words[l] = ~this.words[l] & 67108863;
      return u > 0 && (this.words[l] = ~this.words[l] & 67108863 >> 26 - u), this._strip();
    }, i.prototype.notn = function(f) {
      return this.clone().inotn(f);
    }, i.prototype.setn = function(f, a) {
      r(typeof f == "number" && f >= 0);
      var u = f / 26 | 0, l = f % 26;
      return this._expand(u + 1), a ? this.words[u] = this.words[u] | 1 << l : this.words[u] = this.words[u] & ~(1 << l), this._strip();
    }, i.prototype.iadd = function(f) {
      var a;
      if (this.negative !== 0 && f.negative === 0)
        return this.negative = 0, a = this.isub(f), this.negative ^= 1, this._normSign();
      if (this.negative === 0 && f.negative !== 0)
        return f.negative = 0, a = this.isub(f), f.negative = 1, a._normSign();
      var u, l;
      this.length > f.length ? (u = this, l = f) : (u = f, l = this);
      for (var d4 = 0, h = 0; h < l.length; h++)
        a = (u.words[h] | 0) + (l.words[h] | 0) + d4, this.words[h] = a & 67108863, d4 = a >>> 26;
      for (; d4 !== 0 && h < u.length; h++)
        a = (u.words[h] | 0) + d4, this.words[h] = a & 67108863, d4 = a >>> 26;
      if (this.length = u.length, d4 !== 0)
        this.words[this.length] = d4, this.length++;
      else if (u !== this)
        for (; h < u.length; h++)
          this.words[h] = u.words[h];
      return this;
    }, i.prototype.add = function(f) {
      var a;
      return f.negative !== 0 && this.negative === 0 ? (f.negative = 0, a = this.sub(f), f.negative ^= 1, a) : f.negative === 0 && this.negative !== 0 ? (this.negative = 0, a = f.sub(this), this.negative = 1, a) : this.length > f.length ? this.clone().iadd(f) : f.clone().iadd(this);
    }, i.prototype.isub = function(f) {
      if (f.negative !== 0) {
        f.negative = 0;
        var a = this.iadd(f);
        return f.negative = 1, a._normSign();
      } else if (this.negative !== 0)
        return this.negative = 0, this.iadd(f), this.negative = 1, this._normSign();
      var u = this.cmp(f);
      if (u === 0)
        return this.negative = 0, this.length = 1, this.words[0] = 0, this;
      var l, d4;
      u > 0 ? (l = this, d4 = f) : (l = f, d4 = this);
      for (var h = 0, b2 = 0; b2 < d4.length; b2++)
        a = (l.words[b2] | 0) - (d4.words[b2] | 0) + h, h = a >> 26, this.words[b2] = a & 67108863;
      for (; h !== 0 && b2 < l.length; b2++)
        a = (l.words[b2] | 0) + h, h = a >> 26, this.words[b2] = a & 67108863;
      if (h === 0 && b2 < l.length && l !== this)
        for (; b2 < l.length; b2++)
          this.words[b2] = l.words[b2];
      return this.length = Math.max(this.length, b2), l !== this && (this.negative = 1), this._strip();
    }, i.prototype.sub = function(f) {
      return this.clone().isub(f);
    };
    function ge2(c5, f, a) {
      a.negative = f.negative ^ c5.negative;
      var u = c5.length + f.length | 0;
      a.length = u, u = u - 1 | 0;
      var l = c5.words[0] | 0, d4 = f.words[0] | 0, h = l * d4, b2 = h & 67108863, m3 = h / 67108864 | 0;
      a.words[0] = b2;
      for (var s = 1; s < u; s++) {
        for (var g2 = m3 >>> 26, q = m3 & 67108863, R3 = Math.min(s, f.length - 1), B3 = Math.max(0, s - c5.length + 1); B3 <= R3; B3++) {
          var P2 = s - B3 | 0;
          l = c5.words[P2] | 0, d4 = f.words[B3] | 0, h = l * d4 + q, g2 += h / 67108864 | 0, q = h & 67108863;
        }
        a.words[s] = q | 0, m3 = g2 | 0;
      }
      return m3 !== 0 ? a.words[s] = m3 | 0 : a.length--, a._strip();
    }
    var L4 = function(f, a, u) {
      var l = f.words, d4 = a.words, h = u.words, b2 = 0, m3, s, g2, q = l[0] | 0, R3 = q & 8191, B3 = q >>> 13, P2 = l[1] | 0, T4 = P2 & 8191, N4 = P2 >>> 13, ze = l[2] | 0, O = ze & 8191, z = ze >>> 13, Er3 = l[3] | 0, U2 = Er3 & 8191, H3 = Er3 >>> 13, Ar = l[4] | 0, F4 = Ar & 8191, K4 = Ar >>> 13, qr2 = l[5] | 0, j2 = qr2 & 8191, W4 = qr2 >>> 13, Br2 = l[6] | 0, V3 = Br2 & 8191, Z5 = Br2 >>> 13, Rr2 = l[7] | 0, G4 = Rr2 & 8191, X5 = Rr2 >>> 13, Ir2 = l[8] | 0, Y4 = Ir2 & 8191, J3 = Ir2 >>> 13, kr2 = l[9] | 0, $4 = kr2 & 8191, Q3 = kr2 >>> 13, Dr = d4[0] | 0, ee2 = Dr & 8191, te = Dr >>> 13, Pr2 = d4[1] | 0, re2 = Pr2 & 8191, ie = Pr2 >>> 13, Tr2 = d4[2] | 0, fe = Tr2 & 8191, ne = Tr2 >>> 13, Cr2 = d4[3] | 0, ae2 = Cr2 & 8191, se = Cr2 >>> 13, Nr2 = d4[4] | 0, oe = Nr2 & 8191, he2 = Nr2 >>> 13, Lr4 = d4[5] | 0, ue2 = Lr4 & 8191, de4 = Lr4 >>> 13, Or2 = d4[6] | 0, ce2 = Or2 & 8191, le2 = Or2 >>> 13, zr = d4[7] | 0, ve2 = zr & 8191, pe = zr >>> 13, Ur3 = d4[8] | 0, be = Ur3 & 8191, me = Ur3 >>> 13, dr2 = d4[9] | 0, _e2 = dr2 & 8191, we2 = dr2 >>> 13;
      u.negative = f.negative ^ a.negative, u.length = 19, m3 = Math.imul(R3, ee2), s = Math.imul(R3, te), s = s + Math.imul(B3, ee2) | 0, g2 = Math.imul(B3, te);
      var At2 = (b2 + m3 | 0) + ((s & 8191) << 13) | 0;
      b2 = (g2 + (s >>> 13) | 0) + (At2 >>> 26) | 0, At2 &= 67108863, m3 = Math.imul(T4, ee2), s = Math.imul(T4, te), s = s + Math.imul(N4, ee2) | 0, g2 = Math.imul(N4, te), m3 = m3 + Math.imul(R3, re2) | 0, s = s + Math.imul(R3, ie) | 0, s = s + Math.imul(B3, re2) | 0, g2 = g2 + Math.imul(B3, ie) | 0;
      var qt2 = (b2 + m3 | 0) + ((s & 8191) << 13) | 0;
      b2 = (g2 + (s >>> 13) | 0) + (qt2 >>> 26) | 0, qt2 &= 67108863, m3 = Math.imul(O, ee2), s = Math.imul(O, te), s = s + Math.imul(z, ee2) | 0, g2 = Math.imul(z, te), m3 = m3 + Math.imul(T4, re2) | 0, s = s + Math.imul(T4, ie) | 0, s = s + Math.imul(N4, re2) | 0, g2 = g2 + Math.imul(N4, ie) | 0, m3 = m3 + Math.imul(R3, fe) | 0, s = s + Math.imul(R3, ne) | 0, s = s + Math.imul(B3, fe) | 0, g2 = g2 + Math.imul(B3, ne) | 0;
      var Bt = (b2 + m3 | 0) + ((s & 8191) << 13) | 0;
      b2 = (g2 + (s >>> 13) | 0) + (Bt >>> 26) | 0, Bt &= 67108863, m3 = Math.imul(U2, ee2), s = Math.imul(U2, te), s = s + Math.imul(H3, ee2) | 0, g2 = Math.imul(H3, te), m3 = m3 + Math.imul(O, re2) | 0, s = s + Math.imul(O, ie) | 0, s = s + Math.imul(z, re2) | 0, g2 = g2 + Math.imul(z, ie) | 0, m3 = m3 + Math.imul(T4, fe) | 0, s = s + Math.imul(T4, ne) | 0, s = s + Math.imul(N4, fe) | 0, g2 = g2 + Math.imul(N4, ne) | 0, m3 = m3 + Math.imul(R3, ae2) | 0, s = s + Math.imul(R3, se) | 0, s = s + Math.imul(B3, ae2) | 0, g2 = g2 + Math.imul(B3, se) | 0;
      var Rt2 = (b2 + m3 | 0) + ((s & 8191) << 13) | 0;
      b2 = (g2 + (s >>> 13) | 0) + (Rt2 >>> 26) | 0, Rt2 &= 67108863, m3 = Math.imul(F4, ee2), s = Math.imul(F4, te), s = s + Math.imul(K4, ee2) | 0, g2 = Math.imul(K4, te), m3 = m3 + Math.imul(U2, re2) | 0, s = s + Math.imul(U2, ie) | 0, s = s + Math.imul(H3, re2) | 0, g2 = g2 + Math.imul(H3, ie) | 0, m3 = m3 + Math.imul(O, fe) | 0, s = s + Math.imul(O, ne) | 0, s = s + Math.imul(z, fe) | 0, g2 = g2 + Math.imul(z, ne) | 0, m3 = m3 + Math.imul(T4, ae2) | 0, s = s + Math.imul(T4, se) | 0, s = s + Math.imul(N4, ae2) | 0, g2 = g2 + Math.imul(N4, se) | 0, m3 = m3 + Math.imul(R3, oe) | 0, s = s + Math.imul(R3, he2) | 0, s = s + Math.imul(B3, oe) | 0, g2 = g2 + Math.imul(B3, he2) | 0;
      var It2 = (b2 + m3 | 0) + ((s & 8191) << 13) | 0;
      b2 = (g2 + (s >>> 13) | 0) + (It2 >>> 26) | 0, It2 &= 67108863, m3 = Math.imul(j2, ee2), s = Math.imul(j2, te), s = s + Math.imul(W4, ee2) | 0, g2 = Math.imul(W4, te), m3 = m3 + Math.imul(F4, re2) | 0, s = s + Math.imul(F4, ie) | 0, s = s + Math.imul(K4, re2) | 0, g2 = g2 + Math.imul(K4, ie) | 0, m3 = m3 + Math.imul(U2, fe) | 0, s = s + Math.imul(U2, ne) | 0, s = s + Math.imul(H3, fe) | 0, g2 = g2 + Math.imul(H3, ne) | 0, m3 = m3 + Math.imul(O, ae2) | 0, s = s + Math.imul(O, se) | 0, s = s + Math.imul(z, ae2) | 0, g2 = g2 + Math.imul(z, se) | 0, m3 = m3 + Math.imul(T4, oe) | 0, s = s + Math.imul(T4, he2) | 0, s = s + Math.imul(N4, oe) | 0, g2 = g2 + Math.imul(N4, he2) | 0, m3 = m3 + Math.imul(R3, ue2) | 0, s = s + Math.imul(R3, de4) | 0, s = s + Math.imul(B3, ue2) | 0, g2 = g2 + Math.imul(B3, de4) | 0;
      var kt2 = (b2 + m3 | 0) + ((s & 8191) << 13) | 0;
      b2 = (g2 + (s >>> 13) | 0) + (kt2 >>> 26) | 0, kt2 &= 67108863, m3 = Math.imul(V3, ee2), s = Math.imul(V3, te), s = s + Math.imul(Z5, ee2) | 0, g2 = Math.imul(Z5, te), m3 = m3 + Math.imul(j2, re2) | 0, s = s + Math.imul(j2, ie) | 0, s = s + Math.imul(W4, re2) | 0, g2 = g2 + Math.imul(W4, ie) | 0, m3 = m3 + Math.imul(F4, fe) | 0, s = s + Math.imul(F4, ne) | 0, s = s + Math.imul(K4, fe) | 0, g2 = g2 + Math.imul(K4, ne) | 0, m3 = m3 + Math.imul(U2, ae2) | 0, s = s + Math.imul(U2, se) | 0, s = s + Math.imul(H3, ae2) | 0, g2 = g2 + Math.imul(H3, se) | 0, m3 = m3 + Math.imul(O, oe) | 0, s = s + Math.imul(O, he2) | 0, s = s + Math.imul(z, oe) | 0, g2 = g2 + Math.imul(z, he2) | 0, m3 = m3 + Math.imul(T4, ue2) | 0, s = s + Math.imul(T4, de4) | 0, s = s + Math.imul(N4, ue2) | 0, g2 = g2 + Math.imul(N4, de4) | 0, m3 = m3 + Math.imul(R3, ce2) | 0, s = s + Math.imul(R3, le2) | 0, s = s + Math.imul(B3, ce2) | 0, g2 = g2 + Math.imul(B3, le2) | 0;
      var Dt = (b2 + m3 | 0) + ((s & 8191) << 13) | 0;
      b2 = (g2 + (s >>> 13) | 0) + (Dt >>> 26) | 0, Dt &= 67108863, m3 = Math.imul(G4, ee2), s = Math.imul(G4, te), s = s + Math.imul(X5, ee2) | 0, g2 = Math.imul(X5, te), m3 = m3 + Math.imul(V3, re2) | 0, s = s + Math.imul(V3, ie) | 0, s = s + Math.imul(Z5, re2) | 0, g2 = g2 + Math.imul(Z5, ie) | 0, m3 = m3 + Math.imul(j2, fe) | 0, s = s + Math.imul(j2, ne) | 0, s = s + Math.imul(W4, fe) | 0, g2 = g2 + Math.imul(W4, ne) | 0, m3 = m3 + Math.imul(F4, ae2) | 0, s = s + Math.imul(F4, se) | 0, s = s + Math.imul(K4, ae2) | 0, g2 = g2 + Math.imul(K4, se) | 0, m3 = m3 + Math.imul(U2, oe) | 0, s = s + Math.imul(U2, he2) | 0, s = s + Math.imul(H3, oe) | 0, g2 = g2 + Math.imul(H3, he2) | 0, m3 = m3 + Math.imul(O, ue2) | 0, s = s + Math.imul(O, de4) | 0, s = s + Math.imul(z, ue2) | 0, g2 = g2 + Math.imul(z, de4) | 0, m3 = m3 + Math.imul(T4, ce2) | 0, s = s + Math.imul(T4, le2) | 0, s = s + Math.imul(N4, ce2) | 0, g2 = g2 + Math.imul(N4, le2) | 0, m3 = m3 + Math.imul(R3, ve2) | 0, s = s + Math.imul(R3, pe) | 0, s = s + Math.imul(B3, ve2) | 0, g2 = g2 + Math.imul(B3, pe) | 0;
      var Pt2 = (b2 + m3 | 0) + ((s & 8191) << 13) | 0;
      b2 = (g2 + (s >>> 13) | 0) + (Pt2 >>> 26) | 0, Pt2 &= 67108863, m3 = Math.imul(Y4, ee2), s = Math.imul(Y4, te), s = s + Math.imul(J3, ee2) | 0, g2 = Math.imul(J3, te), m3 = m3 + Math.imul(G4, re2) | 0, s = s + Math.imul(G4, ie) | 0, s = s + Math.imul(X5, re2) | 0, g2 = g2 + Math.imul(X5, ie) | 0, m3 = m3 + Math.imul(V3, fe) | 0, s = s + Math.imul(V3, ne) | 0, s = s + Math.imul(Z5, fe) | 0, g2 = g2 + Math.imul(Z5, ne) | 0, m3 = m3 + Math.imul(j2, ae2) | 0, s = s + Math.imul(j2, se) | 0, s = s + Math.imul(W4, ae2) | 0, g2 = g2 + Math.imul(W4, se) | 0, m3 = m3 + Math.imul(F4, oe) | 0, s = s + Math.imul(F4, he2) | 0, s = s + Math.imul(K4, oe) | 0, g2 = g2 + Math.imul(K4, he2) | 0, m3 = m3 + Math.imul(U2, ue2) | 0, s = s + Math.imul(U2, de4) | 0, s = s + Math.imul(H3, ue2) | 0, g2 = g2 + Math.imul(H3, de4) | 0, m3 = m3 + Math.imul(O, ce2) | 0, s = s + Math.imul(O, le2) | 0, s = s + Math.imul(z, ce2) | 0, g2 = g2 + Math.imul(z, le2) | 0, m3 = m3 + Math.imul(T4, ve2) | 0, s = s + Math.imul(T4, pe) | 0, s = s + Math.imul(N4, ve2) | 0, g2 = g2 + Math.imul(N4, pe) | 0, m3 = m3 + Math.imul(R3, be) | 0, s = s + Math.imul(R3, me) | 0, s = s + Math.imul(B3, be) | 0, g2 = g2 + Math.imul(B3, me) | 0;
      var Tt2 = (b2 + m3 | 0) + ((s & 8191) << 13) | 0;
      b2 = (g2 + (s >>> 13) | 0) + (Tt2 >>> 26) | 0, Tt2 &= 67108863, m3 = Math.imul($4, ee2), s = Math.imul($4, te), s = s + Math.imul(Q3, ee2) | 0, g2 = Math.imul(Q3, te), m3 = m3 + Math.imul(Y4, re2) | 0, s = s + Math.imul(Y4, ie) | 0, s = s + Math.imul(J3, re2) | 0, g2 = g2 + Math.imul(J3, ie) | 0, m3 = m3 + Math.imul(G4, fe) | 0, s = s + Math.imul(G4, ne) | 0, s = s + Math.imul(X5, fe) | 0, g2 = g2 + Math.imul(X5, ne) | 0, m3 = m3 + Math.imul(V3, ae2) | 0, s = s + Math.imul(V3, se) | 0, s = s + Math.imul(Z5, ae2) | 0, g2 = g2 + Math.imul(Z5, se) | 0, m3 = m3 + Math.imul(j2, oe) | 0, s = s + Math.imul(j2, he2) | 0, s = s + Math.imul(W4, oe) | 0, g2 = g2 + Math.imul(W4, he2) | 0, m3 = m3 + Math.imul(F4, ue2) | 0, s = s + Math.imul(F4, de4) | 0, s = s + Math.imul(K4, ue2) | 0, g2 = g2 + Math.imul(K4, de4) | 0, m3 = m3 + Math.imul(U2, ce2) | 0, s = s + Math.imul(U2, le2) | 0, s = s + Math.imul(H3, ce2) | 0, g2 = g2 + Math.imul(H3, le2) | 0, m3 = m3 + Math.imul(O, ve2) | 0, s = s + Math.imul(O, pe) | 0, s = s + Math.imul(z, ve2) | 0, g2 = g2 + Math.imul(z, pe) | 0, m3 = m3 + Math.imul(T4, be) | 0, s = s + Math.imul(T4, me) | 0, s = s + Math.imul(N4, be) | 0, g2 = g2 + Math.imul(N4, me) | 0, m3 = m3 + Math.imul(R3, _e2) | 0, s = s + Math.imul(R3, we2) | 0, s = s + Math.imul(B3, _e2) | 0, g2 = g2 + Math.imul(B3, we2) | 0;
      var Ct2 = (b2 + m3 | 0) + ((s & 8191) << 13) | 0;
      b2 = (g2 + (s >>> 13) | 0) + (Ct2 >>> 26) | 0, Ct2 &= 67108863, m3 = Math.imul($4, re2), s = Math.imul($4, ie), s = s + Math.imul(Q3, re2) | 0, g2 = Math.imul(Q3, ie), m3 = m3 + Math.imul(Y4, fe) | 0, s = s + Math.imul(Y4, ne) | 0, s = s + Math.imul(J3, fe) | 0, g2 = g2 + Math.imul(J3, ne) | 0, m3 = m3 + Math.imul(G4, ae2) | 0, s = s + Math.imul(G4, se) | 0, s = s + Math.imul(X5, ae2) | 0, g2 = g2 + Math.imul(X5, se) | 0, m3 = m3 + Math.imul(V3, oe) | 0, s = s + Math.imul(V3, he2) | 0, s = s + Math.imul(Z5, oe) | 0, g2 = g2 + Math.imul(Z5, he2) | 0, m3 = m3 + Math.imul(j2, ue2) | 0, s = s + Math.imul(j2, de4) | 0, s = s + Math.imul(W4, ue2) | 0, g2 = g2 + Math.imul(W4, de4) | 0, m3 = m3 + Math.imul(F4, ce2) | 0, s = s + Math.imul(F4, le2) | 0, s = s + Math.imul(K4, ce2) | 0, g2 = g2 + Math.imul(K4, le2) | 0, m3 = m3 + Math.imul(U2, ve2) | 0, s = s + Math.imul(U2, pe) | 0, s = s + Math.imul(H3, ve2) | 0, g2 = g2 + Math.imul(H3, pe) | 0, m3 = m3 + Math.imul(O, be) | 0, s = s + Math.imul(O, me) | 0, s = s + Math.imul(z, be) | 0, g2 = g2 + Math.imul(z, me) | 0, m3 = m3 + Math.imul(T4, _e2) | 0, s = s + Math.imul(T4, we2) | 0, s = s + Math.imul(N4, _e2) | 0, g2 = g2 + Math.imul(N4, we2) | 0;
      var Nt2 = (b2 + m3 | 0) + ((s & 8191) << 13) | 0;
      b2 = (g2 + (s >>> 13) | 0) + (Nt2 >>> 26) | 0, Nt2 &= 67108863, m3 = Math.imul($4, fe), s = Math.imul($4, ne), s = s + Math.imul(Q3, fe) | 0, g2 = Math.imul(Q3, ne), m3 = m3 + Math.imul(Y4, ae2) | 0, s = s + Math.imul(Y4, se) | 0, s = s + Math.imul(J3, ae2) | 0, g2 = g2 + Math.imul(J3, se) | 0, m3 = m3 + Math.imul(G4, oe) | 0, s = s + Math.imul(G4, he2) | 0, s = s + Math.imul(X5, oe) | 0, g2 = g2 + Math.imul(X5, he2) | 0, m3 = m3 + Math.imul(V3, ue2) | 0, s = s + Math.imul(V3, de4) | 0, s = s + Math.imul(Z5, ue2) | 0, g2 = g2 + Math.imul(Z5, de4) | 0, m3 = m3 + Math.imul(j2, ce2) | 0, s = s + Math.imul(j2, le2) | 0, s = s + Math.imul(W4, ce2) | 0, g2 = g2 + Math.imul(W4, le2) | 0, m3 = m3 + Math.imul(F4, ve2) | 0, s = s + Math.imul(F4, pe) | 0, s = s + Math.imul(K4, ve2) | 0, g2 = g2 + Math.imul(K4, pe) | 0, m3 = m3 + Math.imul(U2, be) | 0, s = s + Math.imul(U2, me) | 0, s = s + Math.imul(H3, be) | 0, g2 = g2 + Math.imul(H3, me) | 0, m3 = m3 + Math.imul(O, _e2) | 0, s = s + Math.imul(O, we2) | 0, s = s + Math.imul(z, _e2) | 0, g2 = g2 + Math.imul(z, we2) | 0;
      var Lt2 = (b2 + m3 | 0) + ((s & 8191) << 13) | 0;
      b2 = (g2 + (s >>> 13) | 0) + (Lt2 >>> 26) | 0, Lt2 &= 67108863, m3 = Math.imul($4, ae2), s = Math.imul($4, se), s = s + Math.imul(Q3, ae2) | 0, g2 = Math.imul(Q3, se), m3 = m3 + Math.imul(Y4, oe) | 0, s = s + Math.imul(Y4, he2) | 0, s = s + Math.imul(J3, oe) | 0, g2 = g2 + Math.imul(J3, he2) | 0, m3 = m3 + Math.imul(G4, ue2) | 0, s = s + Math.imul(G4, de4) | 0, s = s + Math.imul(X5, ue2) | 0, g2 = g2 + Math.imul(X5, de4) | 0, m3 = m3 + Math.imul(V3, ce2) | 0, s = s + Math.imul(V3, le2) | 0, s = s + Math.imul(Z5, ce2) | 0, g2 = g2 + Math.imul(Z5, le2) | 0, m3 = m3 + Math.imul(j2, ve2) | 0, s = s + Math.imul(j2, pe) | 0, s = s + Math.imul(W4, ve2) | 0, g2 = g2 + Math.imul(W4, pe) | 0, m3 = m3 + Math.imul(F4, be) | 0, s = s + Math.imul(F4, me) | 0, s = s + Math.imul(K4, be) | 0, g2 = g2 + Math.imul(K4, me) | 0, m3 = m3 + Math.imul(U2, _e2) | 0, s = s + Math.imul(U2, we2) | 0, s = s + Math.imul(H3, _e2) | 0, g2 = g2 + Math.imul(H3, we2) | 0;
      var Ot = (b2 + m3 | 0) + ((s & 8191) << 13) | 0;
      b2 = (g2 + (s >>> 13) | 0) + (Ot >>> 26) | 0, Ot &= 67108863, m3 = Math.imul($4, oe), s = Math.imul($4, he2), s = s + Math.imul(Q3, oe) | 0, g2 = Math.imul(Q3, he2), m3 = m3 + Math.imul(Y4, ue2) | 0, s = s + Math.imul(Y4, de4) | 0, s = s + Math.imul(J3, ue2) | 0, g2 = g2 + Math.imul(J3, de4) | 0, m3 = m3 + Math.imul(G4, ce2) | 0, s = s + Math.imul(G4, le2) | 0, s = s + Math.imul(X5, ce2) | 0, g2 = g2 + Math.imul(X5, le2) | 0, m3 = m3 + Math.imul(V3, ve2) | 0, s = s + Math.imul(V3, pe) | 0, s = s + Math.imul(Z5, ve2) | 0, g2 = g2 + Math.imul(Z5, pe) | 0, m3 = m3 + Math.imul(j2, be) | 0, s = s + Math.imul(j2, me) | 0, s = s + Math.imul(W4, be) | 0, g2 = g2 + Math.imul(W4, me) | 0, m3 = m3 + Math.imul(F4, _e2) | 0, s = s + Math.imul(F4, we2) | 0, s = s + Math.imul(K4, _e2) | 0, g2 = g2 + Math.imul(K4, we2) | 0;
      var zt2 = (b2 + m3 | 0) + ((s & 8191) << 13) | 0;
      b2 = (g2 + (s >>> 13) | 0) + (zt2 >>> 26) | 0, zt2 &= 67108863, m3 = Math.imul($4, ue2), s = Math.imul($4, de4), s = s + Math.imul(Q3, ue2) | 0, g2 = Math.imul(Q3, de4), m3 = m3 + Math.imul(Y4, ce2) | 0, s = s + Math.imul(Y4, le2) | 0, s = s + Math.imul(J3, ce2) | 0, g2 = g2 + Math.imul(J3, le2) | 0, m3 = m3 + Math.imul(G4, ve2) | 0, s = s + Math.imul(G4, pe) | 0, s = s + Math.imul(X5, ve2) | 0, g2 = g2 + Math.imul(X5, pe) | 0, m3 = m3 + Math.imul(V3, be) | 0, s = s + Math.imul(V3, me) | 0, s = s + Math.imul(Z5, be) | 0, g2 = g2 + Math.imul(Z5, me) | 0, m3 = m3 + Math.imul(j2, _e2) | 0, s = s + Math.imul(j2, we2) | 0, s = s + Math.imul(W4, _e2) | 0, g2 = g2 + Math.imul(W4, we2) | 0;
      var Ut = (b2 + m3 | 0) + ((s & 8191) << 13) | 0;
      b2 = (g2 + (s >>> 13) | 0) + (Ut >>> 26) | 0, Ut &= 67108863, m3 = Math.imul($4, ce2), s = Math.imul($4, le2), s = s + Math.imul(Q3, ce2) | 0, g2 = Math.imul(Q3, le2), m3 = m3 + Math.imul(Y4, ve2) | 0, s = s + Math.imul(Y4, pe) | 0, s = s + Math.imul(J3, ve2) | 0, g2 = g2 + Math.imul(J3, pe) | 0, m3 = m3 + Math.imul(G4, be) | 0, s = s + Math.imul(G4, me) | 0, s = s + Math.imul(X5, be) | 0, g2 = g2 + Math.imul(X5, me) | 0, m3 = m3 + Math.imul(V3, _e2) | 0, s = s + Math.imul(V3, we2) | 0, s = s + Math.imul(Z5, _e2) | 0, g2 = g2 + Math.imul(Z5, we2) | 0;
      var Ht = (b2 + m3 | 0) + ((s & 8191) << 13) | 0;
      b2 = (g2 + (s >>> 13) | 0) + (Ht >>> 26) | 0, Ht &= 67108863, m3 = Math.imul($4, ve2), s = Math.imul($4, pe), s = s + Math.imul(Q3, ve2) | 0, g2 = Math.imul(Q3, pe), m3 = m3 + Math.imul(Y4, be) | 0, s = s + Math.imul(Y4, me) | 0, s = s + Math.imul(J3, be) | 0, g2 = g2 + Math.imul(J3, me) | 0, m3 = m3 + Math.imul(G4, _e2) | 0, s = s + Math.imul(G4, we2) | 0, s = s + Math.imul(X5, _e2) | 0, g2 = g2 + Math.imul(X5, we2) | 0;
      var ei = (b2 + m3 | 0) + ((s & 8191) << 13) | 0;
      b2 = (g2 + (s >>> 13) | 0) + (ei >>> 26) | 0, ei &= 67108863, m3 = Math.imul($4, be), s = Math.imul($4, me), s = s + Math.imul(Q3, be) | 0, g2 = Math.imul(Q3, me), m3 = m3 + Math.imul(Y4, _e2) | 0, s = s + Math.imul(Y4, we2) | 0, s = s + Math.imul(J3, _e2) | 0, g2 = g2 + Math.imul(J3, we2) | 0;
      var ti = (b2 + m3 | 0) + ((s & 8191) << 13) | 0;
      b2 = (g2 + (s >>> 13) | 0) + (ti >>> 26) | 0, ti &= 67108863, m3 = Math.imul($4, _e2), s = Math.imul($4, we2), s = s + Math.imul(Q3, _e2) | 0, g2 = Math.imul(Q3, we2);
      var ri = (b2 + m3 | 0) + ((s & 8191) << 13) | 0;
      return b2 = (g2 + (s >>> 13) | 0) + (ri >>> 26) | 0, ri &= 67108863, h[0] = At2, h[1] = qt2, h[2] = Bt, h[3] = Rt2, h[4] = It2, h[5] = kt2, h[6] = Dt, h[7] = Pt2, h[8] = Tt2, h[9] = Ct2, h[10] = Nt2, h[11] = Lt2, h[12] = Ot, h[13] = zt2, h[14] = Ut, h[15] = Ht, h[16] = ei, h[17] = ti, h[18] = ri, b2 !== 0 && (h[19] = b2, u.length++), u;
    };
    Math.imul || (L4 = ge2);
    function ye(c5, f, a) {
      a.negative = f.negative ^ c5.negative, a.length = c5.length + f.length;
      for (var u = 0, l = 0, d4 = 0; d4 < a.length - 1; d4++) {
        var h = l;
        l = 0;
        for (var b2 = u & 67108863, m3 = Math.min(d4, f.length - 1), s = Math.max(0, d4 - c5.length + 1); s <= m3; s++) {
          var g2 = d4 - s, q = c5.words[g2] | 0, R3 = f.words[s] | 0, B3 = q * R3, P2 = B3 & 67108863;
          h = h + (B3 / 67108864 | 0) | 0, P2 = P2 + b2 | 0, b2 = P2 & 67108863, h = h + (P2 >>> 26) | 0, l += h >>> 26, h &= 67108863;
        }
        a.words[d4] = b2, u = h, h = l;
      }
      return u !== 0 ? a.words[d4] = u : a.length--, a._strip();
    }
    function Re(c5, f, a) {
      return ye(c5, f, a);
    }
    i.prototype.mulTo = function(f, a) {
      var u, l = this.length + f.length;
      return this.length === 10 && f.length === 10 ? u = L4(this, f, a) : l < 63 ? u = ge2(this, f, a) : l < 1024 ? u = ye(this, f, a) : u = Re(this, f, a), u;
    };
    function xe3(c5, f) {
      this.x = c5, this.y = f;
    }
    xe3.prototype.makeRBT = function(f) {
      for (var a = new Array(f), u = i.prototype._countBits(f) - 1, l = 0; l < f; l++)
        a[l] = this.revBin(l, u, f);
      return a;
    }, xe3.prototype.revBin = function(f, a, u) {
      if (f === 0 || f === u - 1)
        return f;
      for (var l = 0, d4 = 0; d4 < a; d4++)
        l |= (f & 1) << a - d4 - 1, f >>= 1;
      return l;
    }, xe3.prototype.permute = function(f, a, u, l, d4, h) {
      for (var b2 = 0; b2 < h; b2++)
        l[b2] = a[f[b2]], d4[b2] = u[f[b2]];
    }, xe3.prototype.transform = function(f, a, u, l, d4, h) {
      this.permute(h, f, a, u, l, d4);
      for (var b2 = 1; b2 < d4; b2 <<= 1)
        for (var m3 = b2 << 1, s = Math.cos(2 * Math.PI / m3), g2 = Math.sin(2 * Math.PI / m3), q = 0; q < d4; q += m3)
          for (var R3 = s, B3 = g2, P2 = 0; P2 < b2; P2++) {
            var T4 = u[q + P2], N4 = l[q + P2], ze = u[q + P2 + b2], O = l[q + P2 + b2], z = R3 * ze - B3 * O;
            O = R3 * O + B3 * ze, ze = z, u[q + P2] = T4 + ze, l[q + P2] = N4 + O, u[q + P2 + b2] = T4 - ze, l[q + P2 + b2] = N4 - O, P2 !== m3 && (z = s * R3 - g2 * B3, B3 = s * B3 + g2 * R3, R3 = z);
          }
    }, xe3.prototype.guessLen13b = function(f, a) {
      var u = Math.max(a, f) | 1, l = u & 1, d4 = 0;
      for (u = u / 2 | 0; u; u = u >>> 1)
        d4++;
      return 1 << d4 + 1 + l;
    }, xe3.prototype.conjugate = function(f, a, u) {
      if (!(u <= 1))
        for (var l = 0; l < u / 2; l++) {
          var d4 = f[l];
          f[l] = f[u - l - 1], f[u - l - 1] = d4, d4 = a[l], a[l] = -a[u - l - 1], a[u - l - 1] = -d4;
        }
    }, xe3.prototype.normalize13b = function(f, a) {
      for (var u = 0, l = 0; l < a / 2; l++) {
        var d4 = Math.round(f[2 * l + 1] / a) * 8192 + Math.round(f[2 * l] / a) + u;
        f[l] = d4 & 67108863, d4 < 67108864 ? u = 0 : u = d4 / 67108864 | 0;
      }
      return f;
    }, xe3.prototype.convert13b = function(f, a, u, l) {
      for (var d4 = 0, h = 0; h < a; h++)
        d4 = d4 + (f[h] | 0), u[2 * h] = d4 & 8191, d4 = d4 >>> 13, u[2 * h + 1] = d4 & 8191, d4 = d4 >>> 13;
      for (h = 2 * a; h < l; ++h)
        u[h] = 0;
      r(d4 === 0), r((d4 & -8192) === 0);
    }, xe3.prototype.stub = function(f) {
      for (var a = new Array(f), u = 0; u < f; u++)
        a[u] = 0;
      return a;
    }, xe3.prototype.mulp = function(f, a, u) {
      var l = 2 * this.guessLen13b(f.length, a.length), d4 = this.makeRBT(l), h = this.stub(l), b2 = new Array(l), m3 = new Array(l), s = new Array(l), g2 = new Array(l), q = new Array(l), R3 = new Array(l), B3 = u.words;
      B3.length = l, this.convert13b(f.words, f.length, b2, l), this.convert13b(a.words, a.length, g2, l), this.transform(b2, h, m3, s, l, d4), this.transform(g2, h, q, R3, l, d4);
      for (var P2 = 0; P2 < l; P2++) {
        var T4 = m3[P2] * q[P2] - s[P2] * R3[P2];
        s[P2] = m3[P2] * R3[P2] + s[P2] * q[P2], m3[P2] = T4;
      }
      return this.conjugate(m3, s, l), this.transform(m3, s, B3, h, l, d4), this.conjugate(B3, h, l), this.normalize13b(B3, l), u.negative = f.negative ^ a.negative, u.length = f.length + a.length, u._strip();
    }, i.prototype.mul = function(f) {
      var a = new i(null);
      return a.words = new Array(this.length + f.length), this.mulTo(f, a);
    }, i.prototype.mulf = function(f) {
      var a = new i(null);
      return a.words = new Array(this.length + f.length), Re(this, f, a);
    }, i.prototype.imul = function(f) {
      return this.clone().mulTo(f, this);
    }, i.prototype.imuln = function(f) {
      var a = f < 0;
      a && (f = -f), r(typeof f == "number"), r(f < 67108864);
      for (var u = 0, l = 0; l < this.length; l++) {
        var d4 = (this.words[l] | 0) * f, h = (d4 & 67108863) + (u & 67108863);
        u >>= 26, u += d4 / 67108864 | 0, u += h >>> 26, this.words[l] = h & 67108863;
      }
      return u !== 0 && (this.words[l] = u, this.length++), a ? this.ineg() : this;
    }, i.prototype.muln = function(f) {
      return this.clone().imuln(f);
    }, i.prototype.sqr = function() {
      return this.mul(this);
    }, i.prototype.isqr = function() {
      return this.imul(this.clone());
    }, i.prototype.pow = function(f) {
      var a = C(f);
      if (a.length === 0)
        return new i(1);
      for (var u = this, l = 0; l < a.length && a[l] === 0; l++, u = u.sqr())
        ;
      if (++l < a.length)
        for (var d4 = u.sqr(); l < a.length; l++, d4 = d4.sqr())
          a[l] !== 0 && (u = u.mul(d4));
      return u;
    }, i.prototype.iushln = function(f) {
      r(typeof f == "number" && f >= 0);
      var a = f % 26, u = (f - a) / 26, l = 67108863 >>> 26 - a << 26 - a, d4;
      if (a !== 0) {
        var h = 0;
        for (d4 = 0; d4 < this.length; d4++) {
          var b2 = this.words[d4] & l, m3 = (this.words[d4] | 0) - b2 << a;
          this.words[d4] = m3 | h, h = b2 >>> 26 - a;
        }
        h && (this.words[d4] = h, this.length++);
      }
      if (u !== 0) {
        for (d4 = this.length - 1; d4 >= 0; d4--)
          this.words[d4 + u] = this.words[d4];
        for (d4 = 0; d4 < u; d4++)
          this.words[d4] = 0;
        this.length += u;
      }
      return this._strip();
    }, i.prototype.ishln = function(f) {
      return r(this.negative === 0), this.iushln(f);
    }, i.prototype.iushrn = function(f, a, u) {
      r(typeof f == "number" && f >= 0);
      var l;
      a ? l = (a - a % 26) / 26 : l = 0;
      var d4 = f % 26, h = Math.min((f - d4) / 26, this.length), b2 = 67108863 ^ 67108863 >>> d4 << d4, m3 = u;
      if (l -= h, l = Math.max(0, l), m3) {
        for (var s = 0; s < h; s++)
          m3.words[s] = this.words[s];
        m3.length = h;
      }
      if (h !== 0)
        if (this.length > h)
          for (this.length -= h, s = 0; s < this.length; s++)
            this.words[s] = this.words[s + h];
        else
          this.words[0] = 0, this.length = 1;
      var g2 = 0;
      for (s = this.length - 1; s >= 0 && (g2 !== 0 || s >= l); s--) {
        var q = this.words[s] | 0;
        this.words[s] = g2 << 26 - d4 | q >>> d4, g2 = q & b2;
      }
      return m3 && g2 !== 0 && (m3.words[m3.length++] = g2), this.length === 0 && (this.words[0] = 0, this.length = 1), this._strip();
    }, i.prototype.ishrn = function(f, a, u) {
      return r(this.negative === 0), this.iushrn(f, a, u);
    }, i.prototype.shln = function(f) {
      return this.clone().ishln(f);
    }, i.prototype.ushln = function(f) {
      return this.clone().iushln(f);
    }, i.prototype.shrn = function(f) {
      return this.clone().ishrn(f);
    }, i.prototype.ushrn = function(f) {
      return this.clone().iushrn(f);
    }, i.prototype.testn = function(f) {
      r(typeof f == "number" && f >= 0);
      var a = f % 26, u = (f - a) / 26, l = 1 << a;
      if (this.length <= u)
        return false;
      var d4 = this.words[u];
      return !!(d4 & l);
    }, i.prototype.imaskn = function(f) {
      r(typeof f == "number" && f >= 0);
      var a = f % 26, u = (f - a) / 26;
      if (r(this.negative === 0, "imaskn works only with positive numbers"), this.length <= u)
        return this;
      if (a !== 0 && u++, this.length = Math.min(u, this.length), a !== 0) {
        var l = 67108863 ^ 67108863 >>> a << a;
        this.words[this.length - 1] &= l;
      }
      return this._strip();
    }, i.prototype.maskn = function(f) {
      return this.clone().imaskn(f);
    }, i.prototype.iaddn = function(f) {
      return r(typeof f == "number"), r(f < 67108864), f < 0 ? this.isubn(-f) : this.negative !== 0 ? this.length === 1 && (this.words[0] | 0) <= f ? (this.words[0] = f - (this.words[0] | 0), this.negative = 0, this) : (this.negative = 0, this.isubn(f), this.negative = 1, this) : this._iaddn(f);
    }, i.prototype._iaddn = function(f) {
      this.words[0] += f;
      for (var a = 0; a < this.length && this.words[a] >= 67108864; a++)
        this.words[a] -= 67108864, a === this.length - 1 ? this.words[a + 1] = 1 : this.words[a + 1]++;
      return this.length = Math.max(this.length, a + 1), this;
    }, i.prototype.isubn = function(f) {
      if (r(typeof f == "number"), r(f < 67108864), f < 0)
        return this.iaddn(-f);
      if (this.negative !== 0)
        return this.negative = 0, this.iaddn(f), this.negative = 1, this;
      if (this.words[0] -= f, this.length === 1 && this.words[0] < 0)
        this.words[0] = -this.words[0], this.negative = 1;
      else
        for (var a = 0; a < this.length && this.words[a] < 0; a++)
          this.words[a] += 67108864, this.words[a + 1] -= 1;
      return this._strip();
    }, i.prototype.addn = function(f) {
      return this.clone().iaddn(f);
    }, i.prototype.subn = function(f) {
      return this.clone().isubn(f);
    }, i.prototype.iabs = function() {
      return this.negative = 0, this;
    }, i.prototype.abs = function() {
      return this.clone().iabs();
    }, i.prototype._ishlnsubmul = function(f, a, u) {
      var l = f.length + u, d4;
      this._expand(l);
      var h, b2 = 0;
      for (d4 = 0; d4 < f.length; d4++) {
        h = (this.words[d4 + u] | 0) + b2;
        var m3 = (f.words[d4] | 0) * a;
        h -= m3 & 67108863, b2 = (h >> 26) - (m3 / 67108864 | 0), this.words[d4 + u] = h & 67108863;
      }
      for (; d4 < this.length - u; d4++)
        h = (this.words[d4 + u] | 0) + b2, b2 = h >> 26, this.words[d4 + u] = h & 67108863;
      if (b2 === 0)
        return this._strip();
      for (r(b2 === -1), b2 = 0, d4 = 0; d4 < this.length; d4++)
        h = -(this.words[d4] | 0) + b2, b2 = h >> 26, this.words[d4] = h & 67108863;
      return this.negative = 1, this._strip();
    }, i.prototype._wordDiv = function(f, a) {
      var u = this.length - f.length, l = this.clone(), d4 = f, h = d4.words[d4.length - 1] | 0, b2 = this._countBits(h);
      u = 26 - b2, u !== 0 && (d4 = d4.ushln(u), l.iushln(u), h = d4.words[d4.length - 1] | 0);
      var m3 = l.length - d4.length, s;
      if (a !== "mod") {
        s = new i(null), s.length = m3 + 1, s.words = new Array(s.length);
        for (var g2 = 0; g2 < s.length; g2++)
          s.words[g2] = 0;
      }
      var q = l.clone()._ishlnsubmul(d4, 1, m3);
      q.negative === 0 && (l = q, s && (s.words[m3] = 1));
      for (var R3 = m3 - 1; R3 >= 0; R3--) {
        var B3 = (l.words[d4.length + R3] | 0) * 67108864 + (l.words[d4.length + R3 - 1] | 0);
        for (B3 = Math.min(B3 / h | 0, 67108863), l._ishlnsubmul(d4, B3, R3); l.negative !== 0; )
          B3--, l.negative = 0, l._ishlnsubmul(d4, 1, R3), l.isZero() || (l.negative ^= 1);
        s && (s.words[R3] = B3);
      }
      return s && s._strip(), l._strip(), a !== "div" && u !== 0 && l.iushrn(u), { div: s || null, mod: l };
    }, i.prototype.divmod = function(f, a, u) {
      if (r(!f.isZero()), this.isZero())
        return { div: new i(0), mod: new i(0) };
      var l, d4, h;
      return this.negative !== 0 && f.negative === 0 ? (h = this.neg().divmod(f, a), a !== "mod" && (l = h.div.neg()), a !== "div" && (d4 = h.mod.neg(), u && d4.negative !== 0 && d4.iadd(f)), { div: l, mod: d4 }) : this.negative === 0 && f.negative !== 0 ? (h = this.divmod(f.neg(), a), a !== "mod" && (l = h.div.neg()), { div: l, mod: h.mod }) : (this.negative & f.negative) !== 0 ? (h = this.neg().divmod(f.neg(), a), a !== "div" && (d4 = h.mod.neg(), u && d4.negative !== 0 && d4.isub(f)), { div: h.div, mod: d4 }) : f.length > this.length || this.cmp(f) < 0 ? { div: new i(0), mod: this } : f.length === 1 ? a === "div" ? { div: this.divn(f.words[0]), mod: null } : a === "mod" ? { div: null, mod: new i(this.modrn(f.words[0])) } : { div: this.divn(f.words[0]), mod: new i(this.modrn(f.words[0])) } : this._wordDiv(f, a);
    }, i.prototype.div = function(f) {
      return this.divmod(f, "div", false).div;
    }, i.prototype.mod = function(f) {
      return this.divmod(f, "mod", false).mod;
    }, i.prototype.umod = function(f) {
      return this.divmod(f, "mod", true).mod;
    }, i.prototype.divRound = function(f) {
      var a = this.divmod(f);
      if (a.mod.isZero())
        return a.div;
      var u = a.div.negative !== 0 ? a.mod.isub(f) : a.mod, l = f.ushrn(1), d4 = f.andln(1), h = u.cmp(l);
      return h < 0 || d4 === 1 && h === 0 ? a.div : a.div.negative !== 0 ? a.div.isubn(1) : a.div.iaddn(1);
    }, i.prototype.modrn = function(f) {
      var a = f < 0;
      a && (f = -f), r(f <= 67108863);
      for (var u = (1 << 26) % f, l = 0, d4 = this.length - 1; d4 >= 0; d4--)
        l = (u * l + (this.words[d4] | 0)) % f;
      return a ? -l : l;
    }, i.prototype.modn = function(f) {
      return this.modrn(f);
    }, i.prototype.idivn = function(f) {
      var a = f < 0;
      a && (f = -f), r(f <= 67108863);
      for (var u = 0, l = this.length - 1; l >= 0; l--) {
        var d4 = (this.words[l] | 0) + u * 67108864;
        this.words[l] = d4 / f | 0, u = d4 % f;
      }
      return this._strip(), a ? this.ineg() : this;
    }, i.prototype.divn = function(f) {
      return this.clone().idivn(f);
    }, i.prototype.egcd = function(f) {
      r(f.negative === 0), r(!f.isZero());
      var a = this, u = f.clone();
      a.negative !== 0 ? a = a.umod(f) : a = a.clone();
      for (var l = new i(1), d4 = new i(0), h = new i(0), b2 = new i(1), m3 = 0; a.isEven() && u.isEven(); )
        a.iushrn(1), u.iushrn(1), ++m3;
      for (var s = u.clone(), g2 = a.clone(); !a.isZero(); ) {
        for (var q = 0, R3 = 1; (a.words[0] & R3) === 0 && q < 26; ++q, R3 <<= 1)
          ;
        if (q > 0)
          for (a.iushrn(q); q-- > 0; )
            (l.isOdd() || d4.isOdd()) && (l.iadd(s), d4.isub(g2)), l.iushrn(1), d4.iushrn(1);
        for (var B3 = 0, P2 = 1; (u.words[0] & P2) === 0 && B3 < 26; ++B3, P2 <<= 1)
          ;
        if (B3 > 0)
          for (u.iushrn(B3); B3-- > 0; )
            (h.isOdd() || b2.isOdd()) && (h.iadd(s), b2.isub(g2)), h.iushrn(1), b2.iushrn(1);
        a.cmp(u) >= 0 ? (a.isub(u), l.isub(h), d4.isub(b2)) : (u.isub(a), h.isub(l), b2.isub(d4));
      }
      return { a: h, b: b2, gcd: u.iushln(m3) };
    }, i.prototype._invmp = function(f) {
      r(f.negative === 0), r(!f.isZero());
      var a = this, u = f.clone();
      a.negative !== 0 ? a = a.umod(f) : a = a.clone();
      for (var l = new i(1), d4 = new i(0), h = u.clone(); a.cmpn(1) > 0 && u.cmpn(1) > 0; ) {
        for (var b2 = 0, m3 = 1; (a.words[0] & m3) === 0 && b2 < 26; ++b2, m3 <<= 1)
          ;
        if (b2 > 0)
          for (a.iushrn(b2); b2-- > 0; )
            l.isOdd() && l.iadd(h), l.iushrn(1);
        for (var s = 0, g2 = 1; (u.words[0] & g2) === 0 && s < 26; ++s, g2 <<= 1)
          ;
        if (s > 0)
          for (u.iushrn(s); s-- > 0; )
            d4.isOdd() && d4.iadd(h), d4.iushrn(1);
        a.cmp(u) >= 0 ? (a.isub(u), l.isub(d4)) : (u.isub(a), d4.isub(l));
      }
      var q;
      return a.cmpn(1) === 0 ? q = l : q = d4, q.cmpn(0) < 0 && q.iadd(f), q;
    }, i.prototype.gcd = function(f) {
      if (this.isZero())
        return f.abs();
      if (f.isZero())
        return this.abs();
      var a = this.clone(), u = f.clone();
      a.negative = 0, u.negative = 0;
      for (var l = 0; a.isEven() && u.isEven(); l++)
        a.iushrn(1), u.iushrn(1);
      do {
        for (; a.isEven(); )
          a.iushrn(1);
        for (; u.isEven(); )
          u.iushrn(1);
        var d4 = a.cmp(u);
        if (d4 < 0) {
          var h = a;
          a = u, u = h;
        } else if (d4 === 0 || u.cmpn(1) === 0)
          break;
        a.isub(u);
      } while (true);
      return u.iushln(l);
    }, i.prototype.invm = function(f) {
      return this.egcd(f).a.umod(f);
    }, i.prototype.isEven = function() {
      return (this.words[0] & 1) === 0;
    }, i.prototype.isOdd = function() {
      return (this.words[0] & 1) === 1;
    }, i.prototype.andln = function(f) {
      return this.words[0] & f;
    }, i.prototype.bincn = function(f) {
      r(typeof f == "number");
      var a = f % 26, u = (f - a) / 26, l = 1 << a;
      if (this.length <= u)
        return this._expand(u + 1), this.words[u] |= l, this;
      for (var d4 = l, h = u; d4 !== 0 && h < this.length; h++) {
        var b2 = this.words[h] | 0;
        b2 += d4, d4 = b2 >>> 26, b2 &= 67108863, this.words[h] = b2;
      }
      return d4 !== 0 && (this.words[h] = d4, this.length++), this;
    }, i.prototype.isZero = function() {
      return this.length === 1 && this.words[0] === 0;
    }, i.prototype.cmpn = function(f) {
      var a = f < 0;
      if (this.negative !== 0 && !a)
        return -1;
      if (this.negative === 0 && a)
        return 1;
      this._strip();
      var u;
      if (this.length > 1)
        u = 1;
      else {
        a && (f = -f), r(f <= 67108863, "Number is too big");
        var l = this.words[0] | 0;
        u = l === f ? 0 : l < f ? -1 : 1;
      }
      return this.negative !== 0 ? -u | 0 : u;
    }, i.prototype.cmp = function(f) {
      if (this.negative !== 0 && f.negative === 0)
        return -1;
      if (this.negative === 0 && f.negative !== 0)
        return 1;
      var a = this.ucmp(f);
      return this.negative !== 0 ? -a | 0 : a;
    }, i.prototype.ucmp = function(f) {
      if (this.length > f.length)
        return 1;
      if (this.length < f.length)
        return -1;
      for (var a = 0, u = this.length - 1; u >= 0; u--) {
        var l = this.words[u] | 0, d4 = f.words[u] | 0;
        if (l !== d4) {
          l < d4 ? a = -1 : l > d4 && (a = 1);
          break;
        }
      }
      return a;
    }, i.prototype.gtn = function(f) {
      return this.cmpn(f) === 1;
    }, i.prototype.gt = function(f) {
      return this.cmp(f) === 1;
    }, i.prototype.gten = function(f) {
      return this.cmpn(f) >= 0;
    }, i.prototype.gte = function(f) {
      return this.cmp(f) >= 0;
    }, i.prototype.ltn = function(f) {
      return this.cmpn(f) === -1;
    }, i.prototype.lt = function(f) {
      return this.cmp(f) === -1;
    }, i.prototype.lten = function(f) {
      return this.cmpn(f) <= 0;
    }, i.prototype.lte = function(f) {
      return this.cmp(f) <= 0;
    }, i.prototype.eqn = function(f) {
      return this.cmpn(f) === 0;
    }, i.prototype.eq = function(f) {
      return this.cmp(f) === 0;
    }, i.red = function(f) {
      return new v2(f);
    }, i.prototype.toRed = function(f) {
      return r(!this.red, "Already a number in reduction context"), r(this.negative === 0, "red works only with positives"), f.convertTo(this)._forceRed(f);
    }, i.prototype.fromRed = function() {
      return r(this.red, "fromRed works only with numbers in reduction context"), this.red.convertFrom(this);
    }, i.prototype._forceRed = function(f) {
      return this.red = f, this;
    }, i.prototype.forceRed = function(f) {
      return r(!this.red, "Already a number in reduction context"), this._forceRed(f);
    }, i.prototype.redAdd = function(f) {
      return r(this.red, "redAdd works only with red numbers"), this.red.add(this, f);
    }, i.prototype.redIAdd = function(f) {
      return r(this.red, "redIAdd works only with red numbers"), this.red.iadd(this, f);
    }, i.prototype.redSub = function(f) {
      return r(this.red, "redSub works only with red numbers"), this.red.sub(this, f);
    }, i.prototype.redISub = function(f) {
      return r(this.red, "redISub works only with red numbers"), this.red.isub(this, f);
    }, i.prototype.redShl = function(f) {
      return r(this.red, "redShl works only with red numbers"), this.red.shl(this, f);
    }, i.prototype.redMul = function(f) {
      return r(this.red, "redMul works only with red numbers"), this.red._verify2(this, f), this.red.mul(this, f);
    }, i.prototype.redIMul = function(f) {
      return r(this.red, "redMul works only with red numbers"), this.red._verify2(this, f), this.red.imul(this, f);
    }, i.prototype.redSqr = function() {
      return r(this.red, "redSqr works only with red numbers"), this.red._verify1(this), this.red.sqr(this);
    }, i.prototype.redISqr = function() {
      return r(this.red, "redISqr works only with red numbers"), this.red._verify1(this), this.red.isqr(this);
    }, i.prototype.redSqrt = function() {
      return r(this.red, "redSqrt works only with red numbers"), this.red._verify1(this), this.red.sqrt(this);
    }, i.prototype.redInvm = function() {
      return r(this.red, "redInvm works only with red numbers"), this.red._verify1(this), this.red.invm(this);
    }, i.prototype.redNeg = function() {
      return r(this.red, "redNeg works only with red numbers"), this.red._verify1(this), this.red.neg(this);
    }, i.prototype.redPow = function(f) {
      return r(this.red && !f.red, "redPow(normalNum)"), this.red._verify1(this), this.red.pow(this, f);
    };
    var ke = { k256: null, p224: null, p192: null, p25519: null };
    function Me(c5, f) {
      this.name = c5, this.p = new i(f, 16), this.n = this.p.bitLength(), this.k = new i(1).iushln(this.n).isub(this.p), this.tmp = this._tmp();
    }
    Me.prototype._tmp = function() {
      var f = new i(null);
      return f.words = new Array(Math.ceil(this.n / 13)), f;
    }, Me.prototype.ireduce = function(f) {
      var a = f, u;
      do
        this.split(a, this.tmp), a = this.imulK(a), a = a.iadd(this.tmp), u = a.bitLength();
      while (u > this.n);
      var l = u < this.n ? -1 : a.ucmp(this.p);
      return l === 0 ? (a.words[0] = 0, a.length = 1) : l > 0 ? a.isub(this.p) : a.strip !== void 0 ? a.strip() : a._strip(), a;
    }, Me.prototype.split = function(f, a) {
      f.iushrn(this.n, 0, a);
    }, Me.prototype.imulK = function(f) {
      return f.imul(this.k);
    };
    function Ce3() {
      Me.call(this, "k256", "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f");
    }
    n(Ce3, Me), Ce3.prototype.split = function(f, a) {
      for (var u = 4194303, l = Math.min(f.length, 9), d4 = 0; d4 < l; d4++)
        a.words[d4] = f.words[d4];
      if (a.length = l, f.length <= 9) {
        f.words[0] = 0, f.length = 1;
        return;
      }
      var h = f.words[9];
      for (a.words[a.length++] = h & u, d4 = 10; d4 < f.length; d4++) {
        var b2 = f.words[d4] | 0;
        f.words[d4 - 10] = (b2 & u) << 4 | h >>> 22, h = b2;
      }
      h >>>= 22, f.words[d4 - 10] = h, h === 0 && f.length > 10 ? f.length -= 10 : f.length -= 9;
    }, Ce3.prototype.imulK = function(f) {
      f.words[f.length] = 0, f.words[f.length + 1] = 0, f.length += 2;
      for (var a = 0, u = 0; u < f.length; u++) {
        var l = f.words[u] | 0;
        a += l * 977, f.words[u] = a & 67108863, a = l * 64 + (a / 67108864 | 0);
      }
      return f.words[f.length - 1] === 0 && (f.length--, f.words[f.length - 1] === 0 && f.length--), f;
    };
    function Ee2() {
      Me.call(this, "p224", "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001");
    }
    n(Ee2, Me);
    function Ne3() {
      Me.call(this, "p192", "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff");
    }
    n(Ne3, Me);
    function S3() {
      Me.call(this, "25519", "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed");
    }
    n(S3, Me), S3.prototype.imulK = function(f) {
      for (var a = 0, u = 0; u < f.length; u++) {
        var l = (f.words[u] | 0) * 19 + a, d4 = l & 67108863;
        l >>>= 26, f.words[u] = d4, a = l;
      }
      return a !== 0 && (f.words[f.length++] = a), f;
    }, i._prime = function(f) {
      if (ke[f])
        return ke[f];
      var a;
      if (f === "k256")
        a = new Ce3();
      else if (f === "p224")
        a = new Ee2();
      else if (f === "p192")
        a = new Ne3();
      else if (f === "p25519")
        a = new S3();
      else
        throw new Error("Unknown prime " + f);
      return ke[f] = a, a;
    };
    function v2(c5) {
      if (typeof c5 == "string") {
        var f = i._prime(c5);
        this.m = f.p, this.prime = f;
      } else
        r(c5.gtn(1), "modulus must be greater than 1"), this.m = c5, this.prime = null;
    }
    v2.prototype._verify1 = function(f) {
      r(f.negative === 0, "red works only with positives"), r(f.red, "red works only with red numbers");
    }, v2.prototype._verify2 = function(f, a) {
      r((f.negative | a.negative) === 0, "red works only with positives"), r(f.red && f.red === a.red, "red works only with red numbers");
    }, v2.prototype.imod = function(f) {
      return this.prime ? this.prime.ireduce(f)._forceRed(this) : (x(f, f.umod(this.m)._forceRed(this)), f);
    }, v2.prototype.neg = function(f) {
      return f.isZero() ? f.clone() : this.m.sub(f)._forceRed(this);
    }, v2.prototype.add = function(f, a) {
      this._verify2(f, a);
      var u = f.add(a);
      return u.cmp(this.m) >= 0 && u.isub(this.m), u._forceRed(this);
    }, v2.prototype.iadd = function(f, a) {
      this._verify2(f, a);
      var u = f.iadd(a);
      return u.cmp(this.m) >= 0 && u.isub(this.m), u;
    }, v2.prototype.sub = function(f, a) {
      this._verify2(f, a);
      var u = f.sub(a);
      return u.cmpn(0) < 0 && u.iadd(this.m), u._forceRed(this);
    }, v2.prototype.isub = function(f, a) {
      this._verify2(f, a);
      var u = f.isub(a);
      return u.cmpn(0) < 0 && u.iadd(this.m), u;
    }, v2.prototype.shl = function(f, a) {
      return this._verify1(f), this.imod(f.ushln(a));
    }, v2.prototype.imul = function(f, a) {
      return this._verify2(f, a), this.imod(f.imul(a));
    }, v2.prototype.mul = function(f, a) {
      return this._verify2(f, a), this.imod(f.mul(a));
    }, v2.prototype.isqr = function(f) {
      return this.imul(f, f.clone());
    }, v2.prototype.sqr = function(f) {
      return this.mul(f, f);
    }, v2.prototype.sqrt = function(f) {
      if (f.isZero())
        return f.clone();
      var a = this.m.andln(3);
      if (r(a % 2 === 1), a === 3) {
        var u = this.m.add(new i(1)).iushrn(2);
        return this.pow(f, u);
      }
      for (var l = this.m.subn(1), d4 = 0; !l.isZero() && l.andln(1) === 0; )
        d4++, l.iushrn(1);
      r(!l.isZero());
      var h = new i(1).toRed(this), b2 = h.redNeg(), m3 = this.m.subn(1).iushrn(1), s = this.m.bitLength();
      for (s = new i(2 * s * s).toRed(this); this.pow(s, m3).cmp(b2) !== 0; )
        s.redIAdd(b2);
      for (var g2 = this.pow(s, l), q = this.pow(f, l.addn(1).iushrn(1)), R3 = this.pow(f, l), B3 = d4; R3.cmp(h) !== 0; ) {
        for (var P2 = R3, T4 = 0; P2.cmp(h) !== 0; T4++)
          P2 = P2.redSqr();
        r(T4 < B3);
        var N4 = this.pow(g2, new i(1).iushln(B3 - T4 - 1));
        q = q.redMul(N4), g2 = N4.redSqr(), R3 = R3.redMul(g2), B3 = T4;
      }
      return q;
    }, v2.prototype.invm = function(f) {
      var a = f._invmp(this.m);
      return a.negative !== 0 ? (a.negative = 0, this.imod(a).redNeg()) : this.imod(a);
    }, v2.prototype.pow = function(f, a) {
      if (a.isZero())
        return new i(1).toRed(this);
      if (a.cmpn(1) === 0)
        return f.clone();
      var u = 4, l = new Array(1 << u);
      l[0] = new i(1).toRed(this), l[1] = f;
      for (var d4 = 2; d4 < l.length; d4++)
        l[d4] = this.mul(l[d4 - 1], f);
      var h = l[0], b2 = 0, m3 = 0, s = a.bitLength() % 26;
      for (s === 0 && (s = 26), d4 = a.length - 1; d4 >= 0; d4--) {
        for (var g2 = a.words[d4], q = s - 1; q >= 0; q--) {
          var R3 = g2 >> q & 1;
          if (h !== l[0] && (h = this.sqr(h)), R3 === 0 && b2 === 0) {
            m3 = 0;
            continue;
          }
          b2 <<= 1, b2 |= R3, m3++, !(m3 !== u && (d4 !== 0 || q !== 0)) && (h = this.mul(h, l[b2]), m3 = 0, b2 = 0);
        }
        s = 26;
      }
      return h;
    }, v2.prototype.convertTo = function(f) {
      var a = f.umod(this.m);
      return a === f ? a.clone() : a;
    }, v2.prototype.convertFrom = function(f) {
      var a = f.clone();
      return a.red = null, a;
    }, i.mont = function(f) {
      return new _2(f);
    };
    function _2(c5) {
      v2.call(this, c5), this.shift = this.m.bitLength(), this.shift % 26 !== 0 && (this.shift += 26 - this.shift % 26), this.r = new i(1).iushln(this.shift), this.r2 = this.imod(this.r.sqr()), this.rinv = this.r._invmp(this.m), this.minv = this.rinv.mul(this.r).isubn(1).div(this.m), this.minv = this.minv.umod(this.r), this.minv = this.r.sub(this.minv);
    }
    n(_2, v2), _2.prototype.convertTo = function(f) {
      return this.imod(f.ushln(this.shift));
    }, _2.prototype.convertFrom = function(f) {
      var a = this.imod(f.mul(this.rinv));
      return a.red = null, a;
    }, _2.prototype.imul = function(f, a) {
      if (f.isZero() || a.isZero())
        return f.words[0] = 0, f.length = 1, f;
      var u = f.imul(a), l = u.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), d4 = u.isub(l).iushrn(this.shift), h = d4;
      return d4.cmp(this.m) >= 0 ? h = d4.isub(this.m) : d4.cmpn(0) < 0 && (h = d4.iadd(this.m)), h._forceRed(this);
    }, _2.prototype.mul = function(f, a) {
      if (f.isZero() || a.isZero())
        return new i(0)._forceRed(this);
      var u = f.mul(a), l = u.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), d4 = u.isub(l).iushrn(this.shift), h = d4;
      return d4.cmp(this.m) >= 0 ? h = d4.isub(this.m) : d4.cmpn(0) < 0 && (h = d4.iadd(this.m)), h._forceRed(this);
    }, _2.prototype.invm = function(f) {
      var a = this.imod(f._invmp(this.m).mul(this.r2));
      return a._forceRed(this);
    };
  })(typeof hs == "undefined" || hs, Oc);
});
var aa2 = k4((Wm, zc) => {
  "use strict";
  var na = export_default, tf = na.Buffer, wt = {}, xt2;
  for (xt2 in na)
    !na.hasOwnProperty(xt2) || xt2 === "SlowBuffer" || xt2 === "Buffer" || (wt[xt2] = na[xt2]);
  var rf = wt.Buffer = {};
  for (xt2 in tf)
    !tf.hasOwnProperty(xt2) || xt2 === "allocUnsafe" || xt2 === "allocUnsafeSlow" || (rf[xt2] = tf[xt2]);
  wt.Buffer.prototype = tf.prototype;
  (!rf.from || rf.from === Uint8Array.from) && (rf.from = function(t, e, r) {
    if (typeof t == "number")
      throw new TypeError('The "value" argument must not be of type number. Received type ' + typeof t);
    if (t && typeof t.length == "undefined")
      throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof t);
    return tf(t, e, r);
  });
  rf.alloc || (rf.alloc = function(t, e, r) {
    if (typeof t != "number")
      throw new TypeError('The "size" argument must be of type number. Received type ' + typeof t);
    if (t < 0 || t >= 2 * (1 << 30))
      throw new RangeError('The value "' + t + '" is invalid for option "size"');
    var n = tf(t);
    return !e || e.length === 0 ? n.fill(0) : typeof r == "string" ? n.fill(e, r) : n.fill(e), n;
  });
  if (!wt.kStringMaxLength)
    try {
      wt.kStringMaxLength = node_process_default.binding("buffer").kStringMaxLength;
    } catch {
    }
  wt.constants || (wt.constants = { MAX_LENGTH: wt.kMaxLength }, wt.kStringMaxLength && (wt.constants.MAX_STRING_LENGTH = wt.kStringMaxLength));
  zc.exports = wt;
});
var sa2 = k4((Uc) => {
  "use strict";
  var f4 = qe2();
  function Mt(t) {
    this._reporterState = { obj: null, path: [], options: t || {}, errors: [] };
  }
  Uc.Reporter = Mt;
  Mt.prototype.isError = function(e) {
    return e instanceof ff;
  };
  Mt.prototype.save = function() {
    let e = this._reporterState;
    return { obj: e.obj, pathLen: e.path.length };
  };
  Mt.prototype.restore = function(e) {
    let r = this._reporterState;
    r.obj = e.obj, r.path = r.path.slice(0, e.pathLen);
  };
  Mt.prototype.enterKey = function(e) {
    return this._reporterState.path.push(e);
  };
  Mt.prototype.exitKey = function(e) {
    let r = this._reporterState;
    r.path = r.path.slice(0, e - 1);
  };
  Mt.prototype.leaveKey = function(e, r, n) {
    let i = this._reporterState;
    this.exitKey(e), i.obj !== null && (i.obj[r] = n);
  };
  Mt.prototype.path = function() {
    return this._reporterState.path.join("/");
  };
  Mt.prototype.enterObject = function() {
    let e = this._reporterState, r = e.obj;
    return e.obj = {}, r;
  };
  Mt.prototype.leaveObject = function(e) {
    let r = this._reporterState, n = r.obj;
    return r.obj = e, n;
  };
  Mt.prototype.error = function(e) {
    let r, n = this._reporterState, i = e instanceof ff;
    if (i ? r = e : r = new ff(n.path.map(function(o2) {
      return "[" + JSON.stringify(o2) + "]";
    }).join(""), e.message || e, e.stack), !n.options.partial)
      throw r;
    return i || n.errors.push(r), r;
  };
  Mt.prototype.wrapResult = function(e) {
    let r = this._reporterState;
    return r.options.partial ? { result: this.isError(e) ? null : e, errors: r.errors } : e;
  };
  function ff(t, e) {
    this.path = t, this.rethrow(e);
  }
  f4(ff, Error);
  ff.prototype.rethrow = function(e) {
    if (this.message = e + " at: " + (this.path || "(shallow)"), Error.captureStackTrace && Error.captureStackTrace(this, ff), !this.stack)
      try {
        throw new Error(this.message);
      } catch (r) {
        this.stack = r.stack;
      }
    return this;
  };
});
var sf2 = k4((ds) => {
  "use strict";
  var n4 = qe2(), oa = sa2().Reporter, nf = aa2().Buffer;
  function St(t, e) {
    if (oa.call(this, e), !nf.isBuffer(t)) {
      this.error("Input not Buffer");
      return;
    }
    this.base = t, this.offset = 0, this.length = t.length;
  }
  n4(St, oa);
  ds.DecoderBuffer = St;
  St.isDecoderBuffer = function(e) {
    return e instanceof St ? true : typeof e == "object" && nf.isBuffer(e.base) && e.constructor.name === "DecoderBuffer" && typeof e.offset == "number" && typeof e.length == "number" && typeof e.save == "function" && typeof e.restore == "function" && typeof e.isEmpty == "function" && typeof e.readUInt8 == "function" && typeof e.skip == "function" && typeof e.raw == "function";
  };
  St.prototype.save = function() {
    return { offset: this.offset, reporter: oa.prototype.save.call(this) };
  };
  St.prototype.restore = function(e) {
    let r = new St(this.base);
    return r.offset = e.offset, r.length = this.offset, this.offset = e.offset, oa.prototype.restore.call(this, e.reporter), r;
  };
  St.prototype.isEmpty = function() {
    return this.offset === this.length;
  };
  St.prototype.readUInt8 = function(e) {
    return this.offset + 1 <= this.length ? this.base.readUInt8(this.offset++, true) : this.error(e || "DecoderBuffer overrun");
  };
  St.prototype.skip = function(e, r) {
    if (!(this.offset + e <= this.length))
      return this.error(r || "DecoderBuffer overrun");
    let n = new St(this.base);
    return n._reporterState = this._reporterState, n.offset = this.offset, n.length = this.offset + e, this.offset += e, n;
  };
  St.prototype.raw = function(e) {
    return this.base.slice(e ? e.offset : this.offset, this.length);
  };
  function af(t, e) {
    if (Array.isArray(t))
      this.length = 0, this.value = t.map(function(r) {
        return af.isEncoderBuffer(r) || (r = new af(r, e)), this.length += r.length, r;
      }, this);
    else if (typeof t == "number") {
      if (!(0 <= t && t <= 255))
        return e.error("non-byte EncoderBuffer value");
      this.value = t, this.length = 1;
    } else if (typeof t == "string")
      this.value = t, this.length = nf.byteLength(t);
    else if (nf.isBuffer(t))
      this.value = t, this.length = t.length;
    else
      return e.error("Unsupported type: " + typeof t);
  }
  ds.EncoderBuffer = af;
  af.isEncoderBuffer = function(e) {
    return e instanceof af ? true : typeof e == "object" && e.constructor.name === "EncoderBuffer" && typeof e.length == "number" && typeof e.join == "function";
  };
  af.prototype.join = function(e, r) {
    return e || (e = nf.alloc(this.length)), r || (r = 0), this.length === 0 || (Array.isArray(this.value) ? this.value.forEach(function(n) {
      n.join(e, r), r += n.length;
    }) : (typeof this.value == "number" ? e[r] = this.value : typeof this.value == "string" ? e.write(this.value, r) : nf.isBuffer(this.value) && this.value.copy(e, r), r += this.length)), e;
  };
});
var ha2 = k4((Gm, Fc) => {
  "use strict";
  var a4 = sa2().Reporter, s4 = sf2().EncoderBuffer, o4 = sf2().DecoderBuffer, it2 = ot3(), Hc = ["seq", "seqof", "set", "setof", "objid", "bool", "gentime", "utctime", "null_", "enum", "int", "objDesc", "bitstr", "bmpstr", "charstr", "genstr", "graphstr", "ia5str", "iso646str", "numstr", "octstr", "printstr", "t61str", "unistr", "utf8str", "videostr"], h4 = ["key", "obj", "use", "optional", "explicit", "implicit", "def", "choice", "any", "contains"].concat(Hc), u4 = ["_peekTag", "_decodeTag", "_use", "_decodeStr", "_decodeObjid", "_decodeTime", "_decodeNull", "_decodeInt", "_decodeBool", "_decodeList", "_encodeComposite", "_encodeStr", "_encodeObjid", "_encodeTime", "_encodeNull", "_encodeInt", "_encodeBool"];
  function De4(t, e, r) {
    let n = {};
    this._baseState = n, n.name = r, n.enc = t, n.parent = e || null, n.children = null, n.tag = null, n.args = null, n.reverseArgs = null, n.choice = null, n.optional = false, n.any = false, n.obj = false, n.use = null, n.useDecoder = null, n.key = null, n.default = null, n.explicit = null, n.implicit = null, n.contains = null, n.parent || (n.children = [], this._wrap());
  }
  Fc.exports = De4;
  var d4 = ["enc", "parent", "children", "tag", "args", "reverseArgs", "choice", "optional", "any", "obj", "use", "alteredUse", "key", "default", "explicit", "implicit", "contains"];
  De4.prototype.clone = function() {
    let e = this._baseState, r = {};
    d4.forEach(function(i) {
      r[i] = e[i];
    });
    let n = new this.constructor(r.parent);
    return n._baseState = r, n;
  };
  De4.prototype._wrap = function() {
    let e = this._baseState;
    h4.forEach(function(r) {
      this[r] = function() {
        let i = new this.constructor(this);
        return e.children.push(i), i[r].apply(i, arguments);
      };
    }, this);
  };
  De4.prototype._init = function(e) {
    let r = this._baseState;
    it2(r.parent === null), e.call(this), r.children = r.children.filter(function(n) {
      return n._baseState.parent === this;
    }, this), it2.equal(r.children.length, 1, "Root node can have only one child");
  };
  De4.prototype._useArgs = function(e) {
    let r = this._baseState, n = e.filter(function(i) {
      return i instanceof this.constructor;
    }, this);
    e = e.filter(function(i) {
      return !(i instanceof this.constructor);
    }, this), n.length !== 0 && (it2(r.children === null), r.children = n, n.forEach(function(i) {
      i._baseState.parent = this;
    }, this)), e.length !== 0 && (it2(r.args === null), r.args = e, r.reverseArgs = e.map(function(i) {
      if (typeof i != "object" || i.constructor !== Object)
        return i;
      let o2 = {};
      return Object.keys(i).forEach(function(p3) {
        p3 == (p3 | 0) && (p3 |= 0);
        let y4 = i[p3];
        o2[y4] = p3;
      }), o2;
    }));
  };
  u4.forEach(function(t) {
    De4.prototype[t] = function() {
      let r = this._baseState;
      throw new Error(t + " not implemented for encoding: " + r.enc);
    };
  });
  Hc.forEach(function(t) {
    De4.prototype[t] = function() {
      let r = this._baseState, n = Array.prototype.slice.call(arguments);
      return it2(r.tag === null), r.tag = t, this._useArgs(n), this;
    };
  });
  De4.prototype.use = function(e) {
    it2(e);
    let r = this._baseState;
    return it2(r.use === null), r.use = e, this;
  };
  De4.prototype.optional = function() {
    let e = this._baseState;
    return e.optional = true, this;
  };
  De4.prototype.def = function(e) {
    let r = this._baseState;
    return it2(r.default === null), r.default = e, r.optional = true, this;
  };
  De4.prototype.explicit = function(e) {
    let r = this._baseState;
    return it2(r.explicit === null && r.implicit === null), r.explicit = e, this;
  };
  De4.prototype.implicit = function(e) {
    let r = this._baseState;
    return it2(r.explicit === null && r.implicit === null), r.implicit = e, this;
  };
  De4.prototype.obj = function() {
    let e = this._baseState, r = Array.prototype.slice.call(arguments);
    return e.obj = true, r.length !== 0 && this._useArgs(r), this;
  };
  De4.prototype.key = function(e) {
    let r = this._baseState;
    return it2(r.key === null), r.key = e, this;
  };
  De4.prototype.any = function() {
    let e = this._baseState;
    return e.any = true, this;
  };
  De4.prototype.choice = function(e) {
    let r = this._baseState;
    return it2(r.choice === null), r.choice = e, this._useArgs(Object.keys(e).map(function(n) {
      return e[n];
    })), this;
  };
  De4.prototype.contains = function(e) {
    let r = this._baseState;
    return it2(r.use === null), r.contains = e, this;
  };
  De4.prototype._decode = function(e, r) {
    let n = this._baseState;
    if (n.parent === null)
      return e.wrapResult(n.children[0]._decode(e, r));
    let i = n.default, o2 = true, p3 = null;
    if (n.key !== null && (p3 = e.enterKey(n.key)), n.optional) {
      let w2 = null;
      if (n.explicit !== null ? w2 = n.explicit : n.implicit !== null ? w2 = n.implicit : n.tag !== null && (w2 = n.tag), w2 === null && !n.any) {
        let x = e.save();
        try {
          n.choice === null ? this._decodeGeneric(n.tag, e, r) : this._decodeChoice(e, r), o2 = true;
        } catch {
          o2 = false;
        }
        e.restore(x);
      } else if (o2 = this._peekTag(e, w2, n.any), e.isError(o2))
        return o2;
    }
    let y4;
    if (n.obj && o2 && (y4 = e.enterObject()), o2) {
      if (n.explicit !== null) {
        let x = this._decodeTag(e, n.explicit);
        if (e.isError(x))
          return x;
        e = x;
      }
      let w2 = e.offset;
      if (n.use === null && n.choice === null) {
        let x;
        n.any && (x = e.save());
        let M4 = this._decodeTag(e, n.implicit !== null ? n.implicit : n.tag, n.any);
        if (e.isError(M4))
          return M4;
        n.any ? i = e.raw(x) : e = M4;
      }
      if (r && r.track && n.tag !== null && r.track(e.path(), w2, e.length, "tagged"), r && r.track && n.tag !== null && r.track(e.path(), e.offset, e.length, "content"), n.any || (n.choice === null ? i = this._decodeGeneric(n.tag, e, r) : i = this._decodeChoice(e, r)), e.isError(i))
        return i;
      if (!n.any && n.choice === null && n.children !== null && n.children.forEach(function(M4) {
        M4._decode(e, r);
      }), n.contains && (n.tag === "octstr" || n.tag === "bitstr")) {
        let x = new o4(i);
        i = this._getUse(n.contains, e._reporterState.obj)._decode(x, r);
      }
    }
    return n.obj && o2 && (i = e.leaveObject(y4)), n.key !== null && (i !== null || o2 === true) ? e.leaveKey(p3, n.key, i) : p3 !== null && e.exitKey(p3), i;
  };
  De4.prototype._decodeGeneric = function(e, r, n) {
    let i = this._baseState;
    return e === "seq" || e === "set" ? null : e === "seqof" || e === "setof" ? this._decodeList(r, e, i.args[0], n) : /str$/.test(e) ? this._decodeStr(r, e, n) : e === "objid" && i.args ? this._decodeObjid(r, i.args[0], i.args[1], n) : e === "objid" ? this._decodeObjid(r, null, null, n) : e === "gentime" || e === "utctime" ? this._decodeTime(r, e, n) : e === "null_" ? this._decodeNull(r, n) : e === "bool" ? this._decodeBool(r, n) : e === "objDesc" ? this._decodeStr(r, e, n) : e === "int" || e === "enum" ? this._decodeInt(r, i.args && i.args[0], n) : i.use !== null ? this._getUse(i.use, r._reporterState.obj)._decode(r, n) : r.error("unknown tag: " + e);
  };
  De4.prototype._getUse = function(e, r) {
    let n = this._baseState;
    return n.useDecoder = this._use(e, r), it2(n.useDecoder._baseState.parent === null), n.useDecoder = n.useDecoder._baseState.children[0], n.implicit !== n.useDecoder._baseState.implicit && (n.useDecoder = n.useDecoder.clone(), n.useDecoder._baseState.implicit = n.implicit), n.useDecoder;
  };
  De4.prototype._decodeChoice = function(e, r) {
    let n = this._baseState, i = null, o2 = false;
    return Object.keys(n.choice).some(function(p3) {
      let y4 = e.save(), w2 = n.choice[p3];
      try {
        let x = w2._decode(e, r);
        if (e.isError(x))
          return false;
        i = { type: p3, value: x }, o2 = true;
      } catch {
        return e.restore(y4), false;
      }
      return true;
    }, this), o2 ? i : e.error("Choice not matched");
  };
  De4.prototype._createEncoderBuffer = function(e) {
    return new s4(e, this.reporter);
  };
  De4.prototype._encode = function(e, r, n) {
    let i = this._baseState;
    if (i.default !== null && i.default === e)
      return;
    let o2 = this._encodeValue(e, r, n);
    if (o2 !== void 0 && !this._skipDefault(o2, r, n))
      return o2;
  };
  De4.prototype._encodeValue = function(e, r, n) {
    let i = this._baseState;
    if (i.parent === null)
      return i.children[0]._encode(e, r || new a4());
    let o2 = null;
    if (this.reporter = r, i.optional && e === void 0)
      if (i.default !== null)
        e = i.default;
      else
        return;
    let p3 = null, y4 = false;
    if (i.any)
      o2 = this._createEncoderBuffer(e);
    else if (i.choice)
      o2 = this._encodeChoice(e, r);
    else if (i.contains)
      p3 = this._getUse(i.contains, n)._encode(e, r), y4 = true;
    else if (i.children)
      p3 = i.children.map(function(w2) {
        if (w2._baseState.tag === "null_")
          return w2._encode(null, r, e);
        if (w2._baseState.key === null)
          return r.error("Child should have a key");
        let x = r.enterKey(w2._baseState.key);
        if (typeof e != "object")
          return r.error("Child expected, but input is not object");
        let M4 = w2._encode(e[w2._baseState.key], r, e);
        return r.leaveKey(x), M4;
      }, this).filter(function(w2) {
        return w2;
      }), p3 = this._createEncoderBuffer(p3);
    else if (i.tag === "seqof" || i.tag === "setof") {
      if (!(i.args && i.args.length === 1))
        return r.error("Too many args for : " + i.tag);
      if (!Array.isArray(e))
        return r.error("seqof/setof, but data is not Array");
      let w2 = this.clone();
      w2._baseState.implicit = null, p3 = this._createEncoderBuffer(e.map(function(x) {
        let M4 = this._baseState;
        return this._getUse(M4.args[0], e)._encode(x, r);
      }, w2));
    } else
      i.use !== null ? o2 = this._getUse(i.use, n)._encode(e, r) : (p3 = this._encodePrimitive(i.tag, e), y4 = true);
    if (!i.any && i.choice === null) {
      let w2 = i.implicit !== null ? i.implicit : i.tag, x = i.implicit === null ? "universal" : "context";
      w2 === null ? i.use === null && r.error("Tag could be omitted only for .use()") : i.use === null && (o2 = this._encodeComposite(w2, y4, x, p3));
    }
    return i.explicit !== null && (o2 = this._encodeComposite(i.explicit, false, "context", o2)), o2;
  };
  De4.prototype._encodeChoice = function(e, r) {
    let n = this._baseState, i = n.choice[e.type];
    return i || it2(false, e.type + " not found in " + JSON.stringify(Object.keys(n.choice))), i._encode(e.value, r);
  };
  De4.prototype._encodePrimitive = function(e, r) {
    let n = this._baseState;
    if (/str$/.test(e))
      return this._encodeStr(r, e);
    if (e === "objid" && n.args)
      return this._encodeObjid(r, n.reverseArgs[0], n.args[1]);
    if (e === "objid")
      return this._encodeObjid(r, null, null);
    if (e === "gentime" || e === "utctime")
      return this._encodeTime(r, e);
    if (e === "null_")
      return this._encodeNull();
    if (e === "int" || e === "enum")
      return this._encodeInt(r, n.args && n.reverseArgs[0]);
    if (e === "bool")
      return this._encodeBool(r);
    if (e === "objDesc")
      return this._encodeStr(r, e);
    throw new Error("Unsupported tag: " + e);
  };
  De4.prototype._isNumstr = function(e) {
    return /^[0-9 ]*$/.test(e);
  };
  De4.prototype._isPrintstr = function(e) {
    return /^[A-Za-z0-9 '()+,-./:=?]*$/.test(e);
  };
});
var ua2 = k4((qi) => {
  "use strict";
  function Kc(t) {
    let e = {};
    return Object.keys(t).forEach(function(r) {
      (r | 0) == r && (r = r | 0);
      let n = t[r];
      e[n] = r;
    }), e;
  }
  qi.tagClass = { 0: "universal", 1: "application", 2: "context", 3: "private" };
  qi.tagClassByName = Kc(qi.tagClass);
  qi.tag = { 0: "end", 1: "bool", 2: "int", 3: "bitstr", 4: "octstr", 5: "null_", 6: "objid", 7: "objDesc", 8: "external", 9: "real", 10: "enum", 11: "embed", 12: "utf8str", 13: "relativeOid", 16: "seq", 17: "set", 18: "numstr", 19: "printstr", 20: "t61str", 21: "videostr", 22: "ia5str", 23: "utctime", 24: "gentime", 25: "graphstr", 26: "iso646str", 27: "genstr", 28: "unistr", 29: "charstr", 30: "bmpstr" };
  qi.tagByName = Kc(qi.tag);
});
var ls2 = k4((Ym, Vc) => {
  "use strict";
  var c42 = qe2(), Sr = aa2().Buffer, jc = ha2(), cs = ua2();
  function Wc(t) {
    this.enc = "der", this.name = t.name, this.entity = t, this.tree = new Xt(), this.tree._init(t.body);
  }
  Vc.exports = Wc;
  Wc.prototype.encode = function(e, r) {
    return this.tree._encode(e, r).join();
  };
  function Xt(t) {
    jc.call(this, "der", t);
  }
  c42(Xt, jc);
  Xt.prototype._encodeComposite = function(e, r, n, i) {
    let o2 = l4(e, r, n, this.reporter);
    if (i.length < 128) {
      let w2 = Sr.alloc(2);
      return w2[0] = o2, w2[1] = i.length, this._createEncoderBuffer([w2, i]);
    }
    let p3 = 1;
    for (let w2 = i.length; w2 >= 256; w2 >>= 8)
      p3++;
    let y4 = Sr.alloc(1 + 1 + p3);
    y4[0] = o2, y4[1] = 128 | p3;
    for (let w2 = 1 + p3, x = i.length; x > 0; w2--, x >>= 8)
      y4[w2] = x & 255;
    return this._createEncoderBuffer([y4, i]);
  };
  Xt.prototype._encodeStr = function(e, r) {
    if (r === "bitstr")
      return this._createEncoderBuffer([e.unused | 0, e.data]);
    if (r === "bmpstr") {
      let n = Sr.alloc(e.length * 2);
      for (let i = 0; i < e.length; i++)
        n.writeUInt16BE(e.charCodeAt(i), i * 2);
      return this._createEncoderBuffer(n);
    } else
      return r === "numstr" ? this._isNumstr(e) ? this._createEncoderBuffer(e) : this.reporter.error("Encoding of string type: numstr supports only digits and space") : r === "printstr" ? this._isPrintstr(e) ? this._createEncoderBuffer(e) : this.reporter.error("Encoding of string type: printstr supports only latin upper and lower case letters, digits, space, apostrophe, left and rigth parenthesis, plus sign, comma, hyphen, dot, slash, colon, equal sign, question mark") : /str$/.test(r) ? this._createEncoderBuffer(e) : r === "objDesc" ? this._createEncoderBuffer(e) : this.reporter.error("Encoding of string type: " + r + " unsupported");
  };
  Xt.prototype._encodeObjid = function(e, r, n) {
    if (typeof e == "string") {
      if (!r)
        return this.reporter.error("string objid given, but no values map found");
      if (!r.hasOwnProperty(e))
        return this.reporter.error("objid not found in values map");
      e = r[e].split(/[\s.]+/g);
      for (let y4 = 0; y4 < e.length; y4++)
        e[y4] |= 0;
    } else if (Array.isArray(e)) {
      e = e.slice();
      for (let y4 = 0; y4 < e.length; y4++)
        e[y4] |= 0;
    }
    if (!Array.isArray(e))
      return this.reporter.error("objid() should be either array or string, got: " + JSON.stringify(e));
    if (!n) {
      if (e[1] >= 40)
        return this.reporter.error("Second objid identifier OOB");
      e.splice(0, 2, e[0] * 40 + e[1]);
    }
    let i = 0;
    for (let y4 = 0; y4 < e.length; y4++) {
      let w2 = e[y4];
      for (i++; w2 >= 128; w2 >>= 7)
        i++;
    }
    let o2 = Sr.alloc(i), p3 = o2.length - 1;
    for (let y4 = e.length - 1; y4 >= 0; y4--) {
      let w2 = e[y4];
      for (o2[p3--] = w2 & 127; (w2 >>= 7) > 0; )
        o2[p3--] = 128 | w2 & 127;
    }
    return this._createEncoderBuffer(o2);
  };
  function Et2(t) {
    return t < 10 ? "0" + t : t;
  }
  Xt.prototype._encodeTime = function(e, r) {
    let n, i = new Date(e);
    return r === "gentime" ? n = [Et2(i.getUTCFullYear()), Et2(i.getUTCMonth() + 1), Et2(i.getUTCDate()), Et2(i.getUTCHours()), Et2(i.getUTCMinutes()), Et2(i.getUTCSeconds()), "Z"].join("") : r === "utctime" ? n = [Et2(i.getUTCFullYear() % 100), Et2(i.getUTCMonth() + 1), Et2(i.getUTCDate()), Et2(i.getUTCHours()), Et2(i.getUTCMinutes()), Et2(i.getUTCSeconds()), "Z"].join("") : this.reporter.error("Encoding " + r + " time is not supported yet"), this._encodeStr(n, "octstr");
  };
  Xt.prototype._encodeNull = function() {
    return this._createEncoderBuffer("");
  };
  Xt.prototype._encodeInt = function(e, r) {
    if (typeof e == "string") {
      if (!r)
        return this.reporter.error("String int or enum given, but no values map");
      if (!r.hasOwnProperty(e))
        return this.reporter.error("Values map doesn't contain: " + JSON.stringify(e));
      e = r[e];
    }
    if (typeof e != "number" && !Sr.isBuffer(e)) {
      let o2 = e.toArray();
      !e.sign && o2[0] & 128 && o2.unshift(0), e = Sr.from(o2);
    }
    if (Sr.isBuffer(e)) {
      let o2 = e.length;
      e.length === 0 && o2++;
      let p3 = Sr.alloc(o2);
      return e.copy(p3), e.length === 0 && (p3[0] = 0), this._createEncoderBuffer(p3);
    }
    if (e < 128)
      return this._createEncoderBuffer(e);
    if (e < 256)
      return this._createEncoderBuffer([0, e]);
    let n = 1;
    for (let o2 = e; o2 >= 256; o2 >>= 8)
      n++;
    let i = new Array(n);
    for (let o2 = i.length - 1; o2 >= 0; o2--)
      i[o2] = e & 255, e >>= 8;
    return i[0] & 128 && i.unshift(0), this._createEncoderBuffer(Sr.from(i));
  };
  Xt.prototype._encodeBool = function(e) {
    return this._createEncoderBuffer(e ? 255 : 0);
  };
  Xt.prototype._use = function(e, r) {
    return typeof e == "function" && (e = e(r)), e._getEncoder("der").tree;
  };
  Xt.prototype._skipDefault = function(e, r, n) {
    let i = this._baseState, o2;
    if (i.default === null)
      return false;
    let p3 = e.join();
    if (i.defaultBuffer === void 0 && (i.defaultBuffer = this._encodeValue(i.default, r, n).join()), p3.length !== i.defaultBuffer.length)
      return false;
    for (o2 = 0; o2 < p3.length; o2++)
      if (p3[o2] !== i.defaultBuffer[o2])
        return false;
    return true;
  };
  function l4(t, e, r, n) {
    let i;
    if (t === "seqof" ? t = "seq" : t === "setof" && (t = "set"), cs.tagByName.hasOwnProperty(t))
      i = cs.tagByName[t];
    else if (typeof t == "number" && (t | 0) === t)
      i = t;
    else
      return n.error("Unknown tag: " + t);
    return i >= 31 ? n.error("Multi-octet tag encoding unsupported") : (e || (i |= 32), i |= cs.tagClassByName[r || "universal"] << 6, i);
  }
});
var Gc2 = k4((Jm, Zc) => {
  "use strict";
  var v4 = qe2(), vs = ls2();
  function ps(t) {
    vs.call(this, t), this.enc = "pem";
  }
  v4(ps, vs);
  Zc.exports = ps;
  ps.prototype.encode = function(e, r) {
    let i = vs.prototype.encode.call(this, e).toString("base64"), o2 = ["-----BEGIN " + r.label + "-----"];
    for (let p3 = 0; p3 < i.length; p3 += 64)
      o2.push(i.slice(p3, p3 + 64));
    return o2.push("-----END " + r.label + "-----"), o2.join(`
`);
  };
});
var bs2 = k4((Yc) => {
  "use strict";
  var Xc = Yc;
  Xc.der = ls2();
  Xc.pem = Gc2();
});
var gs2 = k4((Qm, rl) => {
  "use strict";
  var p4 = qe2(), b4 = Fe2(), Jc = sf2().DecoderBuffer, Qc = ha2(), $c = ua2();
  function el(t) {
    this.enc = "der", this.name = t.name, this.entity = t, this.tree = new ut4(), this.tree._init(t.body);
  }
  rl.exports = el;
  el.prototype.decode = function(e, r) {
    return Jc.isDecoderBuffer(e) || (e = new Jc(e, r)), this.tree._decode(e, r);
  };
  function ut4(t) {
    Qc.call(this, "der", t);
  }
  p4(ut4, Qc);
  ut4.prototype._peekTag = function(e, r, n) {
    if (e.isEmpty())
      return false;
    let i = e.save(), o2 = ms(e, 'Failed to peek tag: "' + r + '"');
    return e.isError(o2) ? o2 : (e.restore(i), o2.tag === r || o2.tagStr === r || o2.tagStr + "of" === r || n);
  };
  ut4.prototype._decodeTag = function(e, r, n) {
    let i = ms(e, 'Failed to decode tag of "' + r + '"');
    if (e.isError(i))
      return i;
    let o2 = tl(e, i.primitive, 'Failed to get length of "' + r + '"');
    if (e.isError(o2))
      return o2;
    if (!n && i.tag !== r && i.tagStr !== r && i.tagStr + "of" !== r)
      return e.error('Failed to match tag: "' + r + '"');
    if (i.primitive || o2 !== null)
      return e.skip(o2, 'Failed to match body of: "' + r + '"');
    let p3 = e.save(), y4 = this._skipUntilEnd(e, 'Failed to skip indefinite length body: "' + this.tag + '"');
    return e.isError(y4) ? y4 : (o2 = e.offset - p3.offset, e.restore(p3), e.skip(o2, 'Failed to match body of: "' + r + '"'));
  };
  ut4.prototype._skipUntilEnd = function(e, r) {
    for (; ; ) {
      let n = ms(e, r);
      if (e.isError(n))
        return n;
      let i = tl(e, n.primitive, r);
      if (e.isError(i))
        return i;
      let o2;
      if (n.primitive || i !== null ? o2 = e.skip(i) : o2 = this._skipUntilEnd(e, r), e.isError(o2))
        return o2;
      if (n.tagStr === "end")
        break;
    }
  };
  ut4.prototype._decodeList = function(e, r, n, i) {
    let o2 = [];
    for (; !e.isEmpty(); ) {
      let p3 = this._peekTag(e, "end");
      if (e.isError(p3))
        return p3;
      let y4 = n.decode(e, "der", i);
      if (e.isError(y4) && p3)
        break;
      o2.push(y4);
    }
    return o2;
  };
  ut4.prototype._decodeStr = function(e, r) {
    if (r === "bitstr") {
      let n = e.readUInt8();
      return e.isError(n) ? n : { unused: n, data: e.raw() };
    } else if (r === "bmpstr") {
      let n = e.raw();
      if (n.length % 2 === 1)
        return e.error("Decoding of string type: bmpstr length mismatch");
      let i = "";
      for (let o2 = 0; o2 < n.length / 2; o2++)
        i += String.fromCharCode(n.readUInt16BE(o2 * 2));
      return i;
    } else if (r === "numstr") {
      let n = e.raw().toString("ascii");
      return this._isNumstr(n) ? n : e.error("Decoding of string type: numstr unsupported characters");
    } else {
      if (r === "octstr")
        return e.raw();
      if (r === "objDesc")
        return e.raw();
      if (r === "printstr") {
        let n = e.raw().toString("ascii");
        return this._isPrintstr(n) ? n : e.error("Decoding of string type: printstr unsupported characters");
      } else
        return /str$/.test(r) ? e.raw().toString() : e.error("Decoding of string type: " + r + " unsupported");
    }
  };
  ut4.prototype._decodeObjid = function(e, r, n) {
    let i, o2 = [], p3 = 0, y4 = 0;
    for (; !e.isEmpty(); )
      y4 = e.readUInt8(), p3 <<= 7, p3 |= y4 & 127, (y4 & 128) === 0 && (o2.push(p3), p3 = 0);
    y4 & 128 && o2.push(p3);
    let w2 = o2[0] / 40 | 0, x = o2[0] % 40;
    if (n ? i = o2 : i = [w2, x].concat(o2.slice(1)), r) {
      let M4 = r[i.join(" ")];
      M4 === void 0 && (M4 = r[i.join(".")]), M4 !== void 0 && (i = M4);
    }
    return i;
  };
  ut4.prototype._decodeTime = function(e, r) {
    let n = e.raw().toString(), i, o2, p3, y4, w2, x;
    if (r === "gentime")
      i = n.slice(0, 4) | 0, o2 = n.slice(4, 6) | 0, p3 = n.slice(6, 8) | 0, y4 = n.slice(8, 10) | 0, w2 = n.slice(10, 12) | 0, x = n.slice(12, 14) | 0;
    else if (r === "utctime")
      i = n.slice(0, 2) | 0, o2 = n.slice(2, 4) | 0, p3 = n.slice(4, 6) | 0, y4 = n.slice(6, 8) | 0, w2 = n.slice(8, 10) | 0, x = n.slice(10, 12) | 0, i < 70 ? i = 2e3 + i : i = 1900 + i;
    else
      return e.error("Decoding " + r + " time is not supported yet");
    return Date.UTC(i, o2 - 1, p3, y4, w2, x, 0);
  };
  ut4.prototype._decodeNull = function() {
    return null;
  };
  ut4.prototype._decodeBool = function(e) {
    let r = e.readUInt8();
    return e.isError(r) ? r : r !== 0;
  };
  ut4.prototype._decodeInt = function(e, r) {
    let n = e.raw(), i = new b4(n);
    return r && (i = r[i.toString(10)] || i), i;
  };
  ut4.prototype._use = function(e, r) {
    return typeof e == "function" && (e = e(r)), e._getDecoder("der").tree;
  };
  function ms(t, e) {
    let r = t.readUInt8(e);
    if (t.isError(r))
      return r;
    let n = $c.tagClass[r >> 6], i = (r & 32) === 0;
    if ((r & 31) === 31) {
      let p3 = r;
      for (r = 0; (p3 & 128) === 128; ) {
        if (p3 = t.readUInt8(e), t.isError(p3))
          return p3;
        r <<= 7, r |= p3 & 127;
      }
    } else
      r &= 31;
    let o2 = $c.tag[r];
    return { cls: n, primitive: i, tag: r, tagStr: o2 };
  }
  function tl(t, e, r) {
    let n = t.readUInt8(r);
    if (t.isError(n))
      return n;
    if (!e && n === 128)
      return null;
    if ((n & 128) === 0)
      return n;
    let i = n & 127;
    if (i > 4)
      return t.error("length octect is too long");
    n = 0;
    for (let o2 = 0; o2 < i; o2++) {
      n <<= 8;
      let p3 = t.readUInt8(r);
      if (t.isError(p3))
        return p3;
      n |= p3;
    }
    return n;
  }
});
var fl2 = k4((e7, il) => {
  "use strict";
  var m4 = qe2(), g4 = aa2().Buffer, ys = gs2();
  function _s(t) {
    ys.call(this, t), this.enc = "pem";
  }
  m4(_s, ys);
  il.exports = _s;
  _s.prototype.decode = function(e, r) {
    let n = e.toString().split(/[\r\n]+/g), i = r.label.toUpperCase(), o2 = /^-----(BEGIN|END) ([^-]+)-----$/, p3 = -1, y4 = -1;
    for (let M4 = 0; M4 < n.length; M4++) {
      let E2 = n[M4].match(o2);
      if (E2 !== null && E2[2] === i)
        if (p3 === -1) {
          if (E2[1] !== "BEGIN")
            break;
          p3 = M4;
        } else {
          if (E2[1] !== "END")
            break;
          y4 = M4;
          break;
        }
    }
    if (p3 === -1 || y4 === -1)
      throw new Error("PEM section not found for: " + i);
    let w2 = n.slice(p3 + 1, y4).join("");
    w2.replace(/[^a-z0-9+/=]+/gi, "");
    let x = g4.from(w2, "base64");
    return ys.prototype.decode.call(this, x, r);
  };
});
var ws2 = k4((al) => {
  "use strict";
  var nl = al;
  nl.der = gs2();
  nl.pem = fl2();
});
var ol2 = k4((sl) => {
  "use strict";
  var y4 = bs2(), _4 = ws2(), w4 = qe2(), x4 = sl;
  x4.define = function(e, r) {
    return new of(e, r);
  };
  function of(t, e) {
    this.name = t, this.body = e, this.decoders = {}, this.encoders = {};
  }
  of.prototype._createNamed = function(e) {
    let r = this.name;
    function n(i) {
      this._initNamed(i, r);
    }
    return w4(n, e), n.prototype._initNamed = function(o2, p3) {
      e.call(this, o2, p3);
    }, new n(this);
  };
  of.prototype._getDecoder = function(e) {
    return e = e || "der", this.decoders.hasOwnProperty(e) || (this.decoders[e] = this._createNamed(_4[e])), this.decoders[e];
  };
  of.prototype.decode = function(e, r, n) {
    return this._getDecoder(r).decode(e, n);
  };
  of.prototype._getEncoder = function(e) {
    return e = e || "der", this.encoders.hasOwnProperty(e) || (this.encoders[e] = this._createNamed(y4[e])), this.encoders[e];
  };
  of.prototype.encode = function(e, r, n) {
    return this._getEncoder(r).encode(e, n);
  };
});
var ul2 = k4((hl) => {
  "use strict";
  var da = hl;
  da.Reporter = sa2().Reporter;
  da.DecoderBuffer = sf2().DecoderBuffer;
  da.EncoderBuffer = sf2().EncoderBuffer;
  da.Node = ha2();
});
var ll2 = k4((cl) => {
  "use strict";
  var dl = cl;
  dl._reverse = function(e) {
    let r = {};
    return Object.keys(e).forEach(function(n) {
      (n | 0) == n && (n = n | 0);
      let i = e[n];
      r[i] = n;
    }), r;
  };
  dl.der = ua2();
});
var xs2 = k4((vl) => {
  "use strict";
  var hf = vl;
  hf.bignum = Fe2();
  hf.define = ol2().define;
  hf.base = ul2();
  hf.constants = ll2();
  hf.decoders = ws2();
  hf.encoders = bs2();
});
var gl2 = k4((a7, ml) => {
  "use strict";
  var Yt = xs2(), pl = Yt.define("Time", function() {
    this.choice({ utcTime: this.utctime(), generalTime: this.gentime() });
  }), M4 = Yt.define("AttributeTypeValue", function() {
    this.seq().obj(this.key("type").objid(), this.key("value").any());
  }), Ms = Yt.define("AlgorithmIdentifier", function() {
    this.seq().obj(this.key("algorithm").objid(), this.key("parameters").optional(), this.key("curve").objid().optional());
  }), S4 = Yt.define("SubjectPublicKeyInfo", function() {
    this.seq().obj(this.key("algorithm").use(Ms), this.key("subjectPublicKey").bitstr());
  }), E4 = Yt.define("RelativeDistinguishedName", function() {
    this.setof(M4);
  }), A4 = Yt.define("RDNSequence", function() {
    this.seqof(E4);
  }), bl = Yt.define("Name", function() {
    this.choice({ rdnSequence: this.use(A4) });
  }), q4 = Yt.define("Validity", function() {
    this.seq().obj(this.key("notBefore").use(pl), this.key("notAfter").use(pl));
  }), B4 = Yt.define("Extension", function() {
    this.seq().obj(this.key("extnID").objid(), this.key("critical").bool().def(false), this.key("extnValue").octstr());
  }), R4 = Yt.define("TBSCertificate", function() {
    this.seq().obj(this.key("version").explicit(0).int().optional(), this.key("serialNumber").int(), this.key("signature").use(Ms), this.key("issuer").use(bl), this.key("validity").use(q4), this.key("subject").use(bl), this.key("subjectPublicKeyInfo").use(S4), this.key("issuerUniqueID").implicit(1).bitstr().optional(), this.key("subjectUniqueID").implicit(2).bitstr().optional(), this.key("extensions").explicit(3).seqof(B4).optional());
  }), I4 = Yt.define("X509Certificate", function() {
    this.seq().obj(this.key("tbsCertificate").use(R4), this.key("signatureAlgorithm").use(Ms), this.key("signatureValue").bitstr());
  });
  ml.exports = I4;
});
var _l2 = k4(($t) => {
  "use strict";
  var Jt = xs2();
  $t.certificate = gl2();
  var k42 = Jt.define("RSAPrivateKey", function() {
    this.seq().obj(this.key("version").int(), this.key("modulus").int(), this.key("publicExponent").int(), this.key("privateExponent").int(), this.key("prime1").int(), this.key("prime2").int(), this.key("exponent1").int(), this.key("exponent2").int(), this.key("coefficient").int());
  });
  $t.RSAPrivateKey = k42;
  var D42 = Jt.define("RSAPublicKey", function() {
    this.seq().obj(this.key("modulus").int(), this.key("publicExponent").int());
  });
  $t.RSAPublicKey = D42;
  var P4 = Jt.define("SubjectPublicKeyInfo", function() {
    this.seq().obj(this.key("algorithm").use(yl), this.key("subjectPublicKey").bitstr());
  });
  $t.PublicKey = P4;
  var yl = Jt.define("AlgorithmIdentifier", function() {
    this.seq().obj(this.key("algorithm").objid(), this.key("none").null_().optional(), this.key("curve").objid().optional(), this.key("params").seq().obj(this.key("p").int(), this.key("q").int(), this.key("g").int()).optional());
  }), T4 = Jt.define("PrivateKeyInfo", function() {
    this.seq().obj(this.key("version").int(), this.key("algorithm").use(yl), this.key("subjectPrivateKey").octstr());
  });
  $t.PrivateKey = T4;
  var C4 = Jt.define("EncryptedPrivateKeyInfo", function() {
    this.seq().obj(this.key("algorithm").seq().obj(this.key("id").objid(), this.key("decrypt").seq().obj(this.key("kde").seq().obj(this.key("id").objid(), this.key("kdeparams").seq().obj(this.key("salt").octstr(), this.key("iters").int())), this.key("cipher").seq().obj(this.key("algo").objid(), this.key("iv").octstr()))), this.key("subjectPrivateKey").octstr());
  });
  $t.EncryptedPrivateKey = C4;
  var N4 = Jt.define("DSAPrivateKey", function() {
    this.seq().obj(this.key("version").int(), this.key("p").int(), this.key("q").int(), this.key("g").int(), this.key("pub_key").int(), this.key("priv_key").int());
  });
  $t.DSAPrivateKey = N4;
  $t.DSAparam = Jt.define("DSAparam", function() {
    this.int();
  });
  var L4 = Jt.define("ECPrivateKey", function() {
    this.seq().obj(this.key("version").int(), this.key("privateKey").octstr(), this.key("parameters").optional().explicit(0).use(O4), this.key("publicKey").optional().explicit(1).bitstr());
  });
  $t.ECPrivateKey = L4;
  var O4 = Jt.define("ECParameters", function() {
    this.choice({ namedCurve: this.objid() });
  });
  $t.signature = Jt.define("signature", function() {
    this.seq().obj(this.key("r").int(), this.key("s").int());
  });
});
var wl2 = k4((o7, z4) => {
  z4.exports = { "2.16.840.1.101.3.4.1.1": "aes-128-ecb", "2.16.840.1.101.3.4.1.2": "aes-128-cbc", "2.16.840.1.101.3.4.1.3": "aes-128-ofb", "2.16.840.1.101.3.4.1.4": "aes-128-cfb", "2.16.840.1.101.3.4.1.21": "aes-192-ecb", "2.16.840.1.101.3.4.1.22": "aes-192-cbc", "2.16.840.1.101.3.4.1.23": "aes-192-ofb", "2.16.840.1.101.3.4.1.24": "aes-192-cfb", "2.16.840.1.101.3.4.1.41": "aes-256-ecb", "2.16.840.1.101.3.4.1.42": "aes-256-cbc", "2.16.840.1.101.3.4.1.43": "aes-256-ofb", "2.16.840.1.101.3.4.1.44": "aes-256-cfb" };
});
var Ml2 = k4((h7, xl) => {
  var U4 = /Proc-Type: 4,ENCRYPTED[\n\r]+DEK-Info: AES-((?:128)|(?:192)|(?:256))-CBC,([0-9A-H]+)[\n\r]+([0-9A-z\n\r+/=]+)[\n\r]+/m, H4 = /^-----BEGIN ((?:.*? KEY)|CERTIFICATE)-----/m, F4 = /^-----BEGIN ((?:.*? KEY)|CERTIFICATE)-----([0-9A-z\n\r+/=]+)-----END \1-----$/m, K4 = Pf2(), j4 = Ln2(), ca = Ae2().Buffer;
  xl.exports = function(t, e) {
    var r = t.toString(), n = r.match(U4), i;
    if (n) {
      var p3 = "aes" + n[1], y4 = ca.from(n[2], "hex"), w2 = ca.from(n[3].replace(/[\r\n]/g, ""), "base64"), x = K4(e, y4.slice(0, 8), parseInt(n[1], 10)).key, M4 = [], E2 = j4.createDecipheriv(p3, x, y4);
      M4.push(E2.update(w2)), M4.push(E2.final()), i = ca.concat(M4);
    } else {
      var o2 = r.match(F4);
      i = ca.from(o2[2].replace(/[\r\n]/g, ""), "base64");
    }
    var A4 = r.match(H4)[1];
    return { tag: A4, data: i };
  };
});
var Hf2 = k4((u7, El) => {
  var st2 = _l2(), W4 = wl2(), V4 = Ml2(), Z42 = Ln2(), G4 = d02(), Ss = Ae2().Buffer;
  El.exports = Sl;
  function Sl(t) {
    var e;
    typeof t == "object" && !Ss.isBuffer(t) && (e = t.passphrase, t = t.key), typeof t == "string" && (t = Ss.from(t));
    var r = V4(t, e), n = r.tag, i = r.data, o2, p3;
    switch (n) {
      case "CERTIFICATE":
        p3 = st2.certificate.decode(i, "der").tbsCertificate.subjectPublicKeyInfo;
      case "PUBLIC KEY":
        switch (p3 || (p3 = st2.PublicKey.decode(i, "der")), o2 = p3.algorithm.algorithm.join("."), o2) {
          case "1.2.840.113549.1.1.1":
            return st2.RSAPublicKey.decode(p3.subjectPublicKey.data, "der");
          case "1.2.840.10045.2.1":
            return p3.subjectPrivateKey = p3.subjectPublicKey, { type: "ec", data: p3 };
          case "1.2.840.10040.4.1":
            return p3.algorithm.params.pub_key = st2.DSAparam.decode(p3.subjectPublicKey.data, "der"), { type: "dsa", data: p3.algorithm.params };
          default:
            throw new Error("unknown key id " + o2);
        }
      case "ENCRYPTED PRIVATE KEY":
        i = st2.EncryptedPrivateKey.decode(i, "der"), i = X42(i, e);
      case "PRIVATE KEY":
        switch (p3 = st2.PrivateKey.decode(i, "der"), o2 = p3.algorithm.algorithm.join("."), o2) {
          case "1.2.840.113549.1.1.1":
            return st2.RSAPrivateKey.decode(p3.subjectPrivateKey, "der");
          case "1.2.840.10045.2.1":
            return { curve: p3.algorithm.curve, privateKey: st2.ECPrivateKey.decode(p3.subjectPrivateKey, "der").privateKey };
          case "1.2.840.10040.4.1":
            return p3.algorithm.params.priv_key = st2.DSAparam.decode(p3.subjectPrivateKey, "der"), { type: "dsa", params: p3.algorithm.params };
          default:
            throw new Error("unknown key id " + o2);
        }
      case "RSA PUBLIC KEY":
        return st2.RSAPublicKey.decode(i, "der");
      case "RSA PRIVATE KEY":
        return st2.RSAPrivateKey.decode(i, "der");
      case "DSA PRIVATE KEY":
        return { type: "dsa", params: st2.DSAPrivateKey.decode(i, "der") };
      case "EC PRIVATE KEY":
        return i = st2.ECPrivateKey.decode(i, "der"), { curve: i.parameters.value, privateKey: i.privateKey };
      default:
        throw new Error("unknown key type " + n);
    }
  }
  Sl.signature = st2.signature;
  function X42(t, e) {
    var r = t.algorithm.decrypt.kde.kdeparams.salt, n = parseInt(t.algorithm.decrypt.kde.kdeparams.iters.toString(), 10), i = W4[t.algorithm.decrypt.cipher.algo.join(".")], o2 = t.algorithm.decrypt.cipher.iv, p3 = t.subjectPrivateKey, y4 = parseInt(i.split("-")[1], 10) / 8, w2 = G4.pbkdf2Sync(e, r, n, y4, "sha1"), x = Z42.createDecipheriv(i, w2, o2), M4 = [];
    return M4.push(x.update(p3)), M4.push(x.final()), Ss.concat(M4);
  }
});
var Es2 = k4((d7, Y4) => {
  Y4.exports = { "1.3.132.0.10": "secp256k1", "1.3.132.0.33": "p224", "1.2.840.10045.3.1.1": "p192", "1.2.840.10045.3.1.7": "p256", "1.3.132.0.34": "p384", "1.3.132.0.35": "p521" };
});
var Bl2 = k4((c7, va) => {
  var rt2 = Ae2().Buffer, Bi = t02(), J4 = Hn2(), $4 = fa2().ec, la = us2(), Q4 = Hf2(), e8 = Es2();
  function t8(t, e, r, n, i) {
    var o2 = Q4(e);
    if (o2.curve) {
      if (n !== "ecdsa" && n !== "ecdsa/rsa")
        throw new Error("wrong private key type");
      return r8(t, o2);
    } else if (o2.type === "dsa") {
      if (n !== "dsa")
        throw new Error("wrong private key type");
      return i8(t, o2, r);
    } else if (n !== "rsa" && n !== "ecdsa/rsa")
      throw new Error("wrong private key type");
    t = rt2.concat([i, t]);
    for (var p3 = o2.modulus.byteLength(), y4 = [0, 1]; t.length + y4.length + 1 < p3; )
      y4.push(255);
    y4.push(0);
    for (var w2 = -1; ++w2 < t.length; )
      y4.push(t[w2]);
    var x = J4(y4, o2);
    return x;
  }
  function r8(t, e) {
    var r = e8[e.curve.join(".")];
    if (!r)
      throw new Error("unknown curve " + e.curve.join("."));
    var n = new $4(r), i = n.keyFromPrivate(e.privateKey), o2 = i.sign(t);
    return rt2.from(o2.toDER());
  }
  function i8(t, e, r) {
    for (var n = e.params.priv_key, i = e.params.p, o2 = e.params.q, p3 = e.params.g, y4 = new la(0), w2, x = As(t, o2).mod(o2), M4 = false, E2 = Al(n, o2, t, r); M4 === false; )
      w2 = ql(o2, E2, r), y4 = a8(p3, w2, i, o2), M4 = w2.invm(o2).imul(x.add(n.mul(y4))).mod(o2), M4.cmpn(0) === 0 && (M4 = false, y4 = new la(0));
    return f8(y4, M4);
  }
  function f8(t, e) {
    t = t.toArray(), e = e.toArray(), t[0] & 128 && (t = [0].concat(t)), e[0] & 128 && (e = [0].concat(e));
    var r = t.length + e.length + 4, n = [48, r, 2, t.length];
    return n = n.concat(t, [2, e.length], e), rt2.from(n);
  }
  function Al(t, e, r, n) {
    if (t = rt2.from(t.toArray()), t.length < e.byteLength()) {
      var i = rt2.alloc(e.byteLength() - t.length);
      t = rt2.concat([i, t]);
    }
    var o2 = r.length, p3 = n8(r, e), y4 = rt2.alloc(o2);
    y4.fill(1);
    var w2 = rt2.alloc(o2);
    return w2 = Bi(n, w2).update(y4).update(rt2.from([0])).update(t).update(p3).digest(), y4 = Bi(n, w2).update(y4).digest(), w2 = Bi(n, w2).update(y4).update(rt2.from([1])).update(t).update(p3).digest(), y4 = Bi(n, w2).update(y4).digest(), { k: w2, v: y4 };
  }
  function As(t, e) {
    var r = new la(t), n = (t.length << 3) - e.bitLength();
    return n > 0 && r.ishrn(n), r;
  }
  function n8(t, e) {
    t = As(t, e), t = t.mod(e);
    var r = rt2.from(t.toArray());
    if (r.length < e.byteLength()) {
      var n = rt2.alloc(e.byteLength() - r.length);
      r = rt2.concat([n, r]);
    }
    return r;
  }
  function ql(t, e, r) {
    var n, i;
    do {
      for (n = rt2.alloc(0); n.length * 8 < t.bitLength(); )
        e.v = Bi(r, e.k).update(e.v).digest(), n = rt2.concat([n, e.v]);
      i = As(n, t), e.k = Bi(r, e.k).update(e.v).update(rt2.from([0])).digest(), e.v = Bi(r, e.k).update(e.v).digest();
    } while (i.cmp(t) !== -1);
    return i;
  }
  function a8(t, e, r, n) {
    return t.toRed(la.mont(r)).redPow(e).fromRed().mod(n);
  }
  va.exports = t8;
  va.exports.getKey = Al;
  va.exports.makeKey = ql;
});
var Dl2 = k4((l7, kl) => {
  var qs = Ae2().Buffer, Ff = us2(), s8 = fa2().ec, Il = Hf2(), o8 = Es2();
  function h8(t, e, r, n, i) {
    var o2 = Il(r);
    if (o2.type === "ec") {
      if (n !== "ecdsa" && n !== "ecdsa/rsa")
        throw new Error("wrong public key type");
      return u8(t, e, o2);
    } else if (o2.type === "dsa") {
      if (n !== "dsa")
        throw new Error("wrong public key type");
      return d8(t, e, o2);
    } else if (n !== "rsa" && n !== "ecdsa/rsa")
      throw new Error("wrong public key type");
    e = qs.concat([i, e]);
    for (var p3 = o2.modulus.byteLength(), y4 = [1], w2 = 0; e.length + y4.length + 2 < p3; )
      y4.push(255), w2++;
    y4.push(0);
    for (var x = -1; ++x < e.length; )
      y4.push(e[x]);
    y4 = qs.from(y4);
    var M4 = Ff.mont(o2.modulus);
    t = new Ff(t).toRed(M4), t = t.redPow(new Ff(o2.publicExponent)), t = qs.from(t.fromRed().toArray());
    var E2 = w2 < 8 ? 1 : 0;
    for (p3 = Math.min(t.length, y4.length), t.length !== y4.length && (E2 = 1), x = -1; ++x < p3; )
      E2 |= t[x] ^ y4[x];
    return E2 === 0;
  }
  function u8(t, e, r) {
    var n = o8[r.data.algorithm.curve.join(".")];
    if (!n)
      throw new Error("unknown curve " + r.data.algorithm.curve.join("."));
    var i = new s8(n), o2 = r.data.subjectPrivateKey.data;
    return i.verify(e, t, o2);
  }
  function d8(t, e, r) {
    var n = r.data.p, i = r.data.q, o2 = r.data.g, p3 = r.data.pub_key, y4 = Il.signature.decode(t, "der"), w2 = y4.s, x = y4.r;
    Rl(w2, i), Rl(x, i);
    var M4 = Ff.mont(n), E2 = w2.invm(i), A4 = o2.toRed(M4).redPow(new Ff(e).mul(E2).mod(i)).fromRed().mul(p3.toRed(M4).redPow(x.mul(E2).mod(i)).fromRed()).mod(n).mod(i);
    return A4.cmp(x) === 0;
  }
  function Rl(t, e) {
    if (t.cmpn(0) <= 0)
      throw new Error("invalid sig");
    if (t.cmp(e) >= e)
      throw new Error("invalid sig");
  }
  kl.exports = h8;
});
var Ol2 = k4((v7, Ll) => {
  var pa = Ae2().Buffer, Cl = Ni2(), ba = Za2(), Nl = qe2(), c8 = Bl2(), l8 = Dl2(), Ri = r02();
  Object.keys(Ri).forEach(function(t) {
    Ri[t].id = pa.from(Ri[t].id, "hex"), Ri[t.toLowerCase()] = Ri[t];
  });
  function Kf(t) {
    ba.Writable.call(this);
    var e = Ri[t];
    if (!e)
      throw new Error("Unknown message digest");
    this._hashType = e.hash, this._hash = Cl(e.hash), this._tag = e.id, this._signType = e.sign;
  }
  Nl(Kf, ba.Writable);
  Kf.prototype._write = function(e, r, n) {
    this._hash.update(e), n();
  };
  Kf.prototype.update = function(e, r) {
    return typeof e == "string" && (e = pa.from(e, r)), this._hash.update(e), this;
  };
  Kf.prototype.sign = function(e, r) {
    this.end();
    var n = this._hash.digest(), i = c8(n, e, this._hashType, this._signType, this._tag);
    return r ? i.toString(r) : i;
  };
  function jf(t) {
    ba.Writable.call(this);
    var e = Ri[t];
    if (!e)
      throw new Error("Unknown message digest");
    this._hash = Cl(e.hash), this._tag = e.id, this._signType = e.sign;
  }
  Nl(jf, ba.Writable);
  jf.prototype._write = function(e, r, n) {
    this._hash.update(e), n();
  };
  jf.prototype.update = function(e, r) {
    return typeof e == "string" && (e = pa.from(e, r)), this._hash.update(e), this;
  };
  jf.prototype.verify = function(e, r, n) {
    typeof r == "string" && (r = pa.from(r, n)), this.end();
    var i = this._hash.digest();
    return l8(r, i, e, this._signType, this._tag);
  };
  function Pl(t) {
    return new Kf(t);
  }
  function Tl(t) {
    return new jf(t);
  }
  Ll.exports = { Sign: Pl, Verify: Tl, createSign: Pl, createVerify: Tl };
});
var Ul2 = k4((p7, zl) => {
  var v8 = fa2(), p8 = Fe2();
  zl.exports = function(e) {
    return new Ii(e);
  };
  var dt = { secp256k1: { name: "secp256k1", byteLength: 32 }, secp224r1: { name: "p224", byteLength: 28 }, prime256v1: { name: "p256", byteLength: 32 }, prime192v1: { name: "p192", byteLength: 24 }, ed25519: { name: "ed25519", byteLength: 32 }, secp384r1: { name: "p384", byteLength: 48 }, secp521r1: { name: "p521", byteLength: 66 } };
  dt.p224 = dt.secp224r1;
  dt.p256 = dt.secp256r1 = dt.prime256v1;
  dt.p192 = dt.secp192r1 = dt.prime192v1;
  dt.p384 = dt.secp384r1;
  dt.p521 = dt.secp521r1;
  function Ii(t) {
    this.curveType = dt[t], this.curveType || (this.curveType = { name: t }), this.curve = new v8.ec(this.curveType.name), this.keys = void 0;
  }
  Ii.prototype.generateKeys = function(t, e) {
    return this.keys = this.curve.genKeyPair(), this.getPublicKey(t, e);
  };
  Ii.prototype.computeSecret = function(t, e, r) {
    e = e || "utf8", ut.isBuffer(t) || (t = new ut(t, e));
    var n = this.curve.keyFromPublic(t).getPublic(), i = n.mul(this.keys.getPrivate()).getX();
    return Bs(i, r, this.curveType.byteLength);
  };
  Ii.prototype.getPublicKey = function(t, e) {
    var r = this.keys.getPublic(e === "compressed", true);
    return e === "hybrid" && (r[r.length - 1] % 2 ? r[0] = 7 : r[0] = 6), Bs(r, t);
  };
  Ii.prototype.getPrivateKey = function(t) {
    return Bs(this.keys.getPrivate(), t);
  };
  Ii.prototype.setPublicKey = function(t, e) {
    return e = e || "utf8", ut.isBuffer(t) || (t = new ut(t, e)), this.keys._importPublic(t), this;
  };
  Ii.prototype.setPrivateKey = function(t, e) {
    e = e || "utf8", ut.isBuffer(t) || (t = new ut(t, e));
    var r = new p8(t);
    return r = r.toString(16), this.keys = this.curve.genKeyPair(), this.keys._importPrivate(r), this;
  };
  function Bs(t, e, r) {
    Array.isArray(t) || (t = t.toArray());
    var n = new ut(t);
    if (r && n.length < r) {
      var i = new ut(r - n.length);
      i.fill(0), n = ut.concat([i, n]);
    }
    return e ? n.toString(e) : n;
  }
});
var Is2 = k4((b7, Hl) => {
  var b8 = Ni2(), Rs = Ae2().Buffer;
  Hl.exports = function(t, e) {
    for (var r = Rs.alloc(0), n = 0, i; r.length < e; )
      i = m8(n++), r = Rs.concat([r, b8("sha1").update(t).update(i).digest()]);
    return r.slice(0, e);
  };
  function m8(t) {
    var e = Rs.allocUnsafe(4);
    return e.writeUInt32BE(t, 0), e;
  }
});
var ks2 = k4((m7, Fl) => {
  Fl.exports = function(e, r) {
    for (var n = e.length, i = -1; ++i < n; )
      e[i] ^= r[i];
    return e;
  };
});
var Ds2 = k4((g7, jl) => {
  var Kl = Fe2(), g8 = Ae2().Buffer;
  function y8(t, e) {
    return g8.from(t.toRed(Kl.mont(e.modulus)).redPow(new Kl(e.publicExponent)).fromRed().toArray());
  }
  jl.exports = y8;
});
var Gl2 = k4((y7, Zl) => {
  var _8 = Hf2(), Ps = fi2(), w8 = Ni2(), Wl = Is2(), Vl = ks2(), Ts = Fe2(), x8 = Ds2(), M8 = Hn2(), Qt = Ae2().Buffer;
  Zl.exports = function(e, r, n) {
    var i;
    e.padding ? i = e.padding : n ? i = 1 : i = 4;
    var o2 = _8(e), p3;
    if (i === 4)
      p3 = S8(o2, r);
    else if (i === 1)
      p3 = E8(o2, r, n);
    else if (i === 3) {
      if (p3 = new Ts(r), p3.cmp(o2.modulus) >= 0)
        throw new Error("data too long for modulus");
    } else
      throw new Error("unknown padding");
    return n ? M8(p3, o2) : x8(p3, o2);
  };
  function S8(t, e) {
    var r = t.modulus.byteLength(), n = e.length, i = w8("sha1").update(Qt.alloc(0)).digest(), o2 = i.length, p3 = 2 * o2;
    if (n > r - p3 - 2)
      throw new Error("message too long");
    var y4 = Qt.alloc(r - n - p3 - 2), w2 = r - o2 - 1, x = Ps(o2), M4 = Vl(Qt.concat([i, y4, Qt.alloc(1, 1), e], w2), Wl(x, w2)), E2 = Vl(x, Wl(M4, o2));
    return new Ts(Qt.concat([Qt.alloc(1), E2, M4], r));
  }
  function E8(t, e, r) {
    var n = e.length, i = t.modulus.byteLength();
    if (n > i - 11)
      throw new Error("message too long");
    var o2;
    return r ? o2 = Qt.alloc(i - n - 3, 255) : o2 = A8(i - n - 3), new Ts(Qt.concat([Qt.from([0, r ? 1 : 2]), o2, Qt.alloc(1), e], i));
  }
  function A8(t) {
    for (var e = Qt.allocUnsafe(t), r = 0, n = Ps(t * 2), i = 0, o2; r < t; )
      i === n.length && (n = Ps(t * 2), i = 0), o2 = n[i++], o2 && (e[r++] = o2);
    return e;
  }
});
var Ql2 = k4((_7, $l) => {
  var q8 = Hf2(), Xl = Is2(), Yl = ks2(), Jl = Fe2(), B8 = Hn2(), R8 = Ni2(), I8 = Ds2(), Wf = Ae2().Buffer;
  $l.exports = function(e, r, n) {
    var i;
    e.padding ? i = e.padding : n ? i = 1 : i = 4;
    var o2 = q8(e), p3 = o2.modulus.byteLength();
    if (r.length > p3 || new Jl(r).cmp(o2.modulus) >= 0)
      throw new Error("decryption error");
    var y4;
    n ? y4 = I8(new Jl(r), o2) : y4 = B8(r, o2);
    var w2 = Wf.alloc(p3 - y4.length);
    if (y4 = Wf.concat([w2, y4], p3), i === 4)
      return k8(o2, y4);
    if (i === 1)
      return D8(o2, y4, n);
    if (i === 3)
      return y4;
    throw new Error("unknown padding");
  };
  function k8(t, e) {
    var r = t.modulus.byteLength(), n = R8("sha1").update(Wf.alloc(0)).digest(), i = n.length;
    if (e[0] !== 0)
      throw new Error("decryption error");
    var o2 = e.slice(1, i + 1), p3 = e.slice(i + 1), y4 = Yl(o2, Xl(p3, i)), w2 = Yl(p3, Xl(y4, r - i - 1));
    if (P8(n, w2.slice(0, i)))
      throw new Error("decryption error");
    for (var x = i; w2[x] === 0; )
      x++;
    if (w2[x++] !== 1)
      throw new Error("decryption error");
    return w2.slice(x);
  }
  function D8(t, e, r) {
    for (var n = e.slice(0, 2), i = 2, o2 = 0; e[i++] !== 0; )
      if (i >= e.length) {
        o2++;
        break;
      }
    var p3 = e.slice(2, i - 1);
    if ((n.toString("hex") !== "0002" && !r || n.toString("hex") !== "0001" && r) && o2++, p3.length < 8 && o2++, o2)
      throw new Error("decryption error");
    return e.slice(i);
  }
  function P8(t, e) {
    t = Wf.from(t), e = Wf.from(e);
    var r = 0, n = t.length;
    t.length !== e.length && (r++, n = Math.min(t.length, e.length));
    for (var i = -1; ++i < n; )
      r += t[i] ^ e[i];
    return r;
  }
});
var e12 = k4((ki2) => {
  ki2.publicEncrypt = Gl2();
  ki2.privateDecrypt = Ql2();
  ki2.privateEncrypt = function(e, r) {
    return ki2.publicEncrypt(e, r, true);
  };
  ki2.publicDecrypt = function(e, r) {
    return ki2.privateDecrypt(e, r, true);
  };
});
var u12 = k4((Vf) => {
  "use strict";
  function t1() {
    throw new Error(`secure random number generation not supported by this browser
use chrome, FireFox or Internet Explorer 11`);
  }
  var i1 = Ae2(), r1 = fi2(), f1 = i1.Buffer, n1 = i1.kMaxLength, Cs = __global$4.crypto || __global$4.msCrypto, a1 = Math.pow(2, 32) - 1;
  function s1(t, e) {
    if (typeof t != "number" || t !== t)
      throw new TypeError("offset must be a number");
    if (t > a1 || t < 0)
      throw new TypeError("offset must be a uint32");
    if (t > n1 || t > e)
      throw new RangeError("offset out of range");
  }
  function o1(t, e, r) {
    if (typeof t != "number" || t !== t)
      throw new TypeError("size must be a number");
    if (t > a1 || t < 0)
      throw new TypeError("size must be a uint32");
    if (t + e > r || t > n1)
      throw new RangeError("buffer too small");
  }
  Cs && Cs.getRandomValues || !node_process_default.browser ? (Vf.randomFill = T8, Vf.randomFillSync = C8) : (Vf.randomFill = t1, Vf.randomFillSync = t1);
  function T8(t, e, r, n) {
    if (!f1.isBuffer(t) && !(t instanceof __global$4.Uint8Array))
      throw new TypeError('"buf" argument must be a Buffer or Uint8Array');
    if (typeof e == "function")
      n = e, e = 0, r = t.length;
    else if (typeof r == "function")
      n = r, r = t.length - e;
    else if (typeof n != "function")
      throw new TypeError('"cb" argument must be a function');
    return s1(e, t.length), o1(r, e, t.length), h1(t, e, r, n);
  }
  function h1(t, e, r, n) {
    if (node_process_default.browser) {
      var i = t.buffer, o2 = new Uint8Array(i, e, r);
      if (Cs.getRandomValues(o2), n) {
        node_process_default.nextTick(function() {
          n(null, t);
        });
        return;
      }
      return t;
    }
    if (n) {
      r1(r, function(y4, w2) {
        if (y4)
          return n(y4);
        w2.copy(t, e), n(null, t);
      });
      return;
    }
    var p3 = r1(r);
    return p3.copy(t, e), t;
  }
  function C8(t, e, r) {
    if (typeof e == "undefined" && (e = 0), !f1.isBuffer(t) && !(t instanceof __global$4.Uint8Array))
      throw new TypeError('"buf" argument must be a Buffer or Uint8Array');
    return s1(e, t.length), r === void 0 && (r = t.length - e), o1(r, e, t.length), h1(t, e, r);
  }
});
var Ns2 = k4((Se2) => {
  "use strict";
  Se2.randomBytes = Se2.rng = Se2.pseudoRandomBytes = Se2.prng = fi2();
  Se2.createHash = Se2.Hash = Ni2();
  Se2.createHmac = Se2.Hmac = t02();
  var N8 = Bh2(), L82 = Object.keys(N8), O82 = ["sha1", "sha224", "sha256", "sha384", "sha512", "md5", "rmd160"].concat(L82);
  Se2.getHashes = function() {
    return O82;
  };
  var d1 = d02();
  Se2.pbkdf2 = d1.pbkdf2;
  Se2.pbkdf2Sync = d1.pbkdf2Sync;
  var ur2 = Yu2();
  Se2.Cipher = ur2.Cipher;
  Se2.createCipher = ur2.createCipher;
  Se2.Cipheriv = ur2.Cipheriv;
  Se2.createCipheriv = ur2.createCipheriv;
  Se2.Decipher = ur2.Decipher;
  Se2.createDecipher = ur2.createDecipher;
  Se2.Decipheriv = ur2.Decipheriv;
  Se2.createDecipheriv = ur2.createDecipheriv;
  Se2.getCiphers = ur2.getCiphers;
  Se2.listCiphers = ur2.listCiphers;
  var Zf = hd2();
  Se2.DiffieHellmanGroup = Zf.DiffieHellmanGroup;
  Se2.createDiffieHellmanGroup = Zf.createDiffieHellmanGroup;
  Se2.getDiffieHellman = Zf.getDiffieHellman;
  Se2.createDiffieHellman = Zf.createDiffieHellman;
  Se2.DiffieHellman = Zf.DiffieHellman;
  var ma = Ol2();
  Se2.createSign = ma.createSign;
  Se2.Sign = ma.Sign;
  Se2.createVerify = ma.createVerify;
  Se2.Verify = ma.Verify;
  Se2.createECDH = Ul2();
  var ga = e12();
  Se2.publicEncrypt = ga.publicEncrypt;
  Se2.privateEncrypt = ga.privateEncrypt;
  Se2.publicDecrypt = ga.publicDecrypt;
  Se2.privateDecrypt = ga.privateDecrypt;
  var c1 = u12();
  Se2.randomFill = c1.randomFill;
  Se2.randomFillSync = c1.randomFillSync;
  Se2.createCredentials = function() {
    throw new Error(["sorry, createCredentials is not implemented yet", "we accept pull requests", "https://github.com/crypto-browserify/crypto-browserify"].join(`
`));
  };
  Se2.constants = { DH_CHECK_P_NOT_SAFE_PRIME: 2, DH_CHECK_P_NOT_PRIME: 1, DH_UNABLE_TO_CHECK_GENERATOR: 4, DH_NOT_SUITABLE_GENERATOR: 8, NPN_ENABLED: 1, ALPN_ENABLED: 1, RSA_PKCS1_PADDING: 1, RSA_SSLV23_PADDING: 2, RSA_NO_PADDING: 3, RSA_PKCS1_OAEP_PADDING: 4, RSA_X931_PADDING: 5, RSA_PKCS1_PSS_PADDING: 6, POINT_CONVERSION_COMPRESSED: 2, POINT_CONVERSION_UNCOMPRESSED: 4, POINT_CONVERSION_HYBRID: 6 };
});
var p12 = Os2(Ns2());
var b12 = Os2(Ns2());
var { randomBytes: S72, rng: E72, pseudoRandomBytes: A72, prng: q72, createHash: B72, Hash: R72, createHmac: I72, Hmac: k72, getHashes: D72, pbkdf2: P72, pbkdf2Sync: T72, Cipher: C72, createCipher: N72, Cipheriv: L72, createCipheriv: O72, Decipher: z72, createDecipher: U72, Decipheriv: H72, createDecipheriv: F72, getCiphers: K72, listCiphers: j72, DiffieHellmanGroup: W72, createDiffieHellmanGroup: V72, getDiffieHellman: Z72, createDiffieHellman: G72, DiffieHellman: X72, createSign: Y72, Sign: J72, createVerify: $72, Verify: Q72, createECDH: e92, publicEncrypt: t92, privateEncrypt: r92, publicDecrypt: i92, privateDecrypt: f92, randomFill: n92, randomFillSync: a92, createCredentials: s92, constants: o9 } = b12;
var { default: z8, ...U8 } = b12;
var l12;
var v12;
var h9 = (v12 = (l12 = p12.default) != null ? l12 : z8) != null ? v12 : U8;

// deno:https://esm.sh/v86/jws@4.0.0/es2019/jws.bundle.js
var Je = Object.create;
var W3 = Object.defineProperty;
var Ce2 = Object.getOwnPropertyDescriptor;
var je = Object.getOwnPropertyNames;
var Fe3 = Object.getPrototypeOf;
var Ue2 = Object.prototype.hasOwnProperty;
var c4 = ((e) => typeof require != "undefined" ? require : typeof Proxy != "undefined" ? new Proxy(e, { get: (r, t) => (typeof require != "undefined" ? require : r)[t] }) : e)(function(e) {
  if (typeof require != "undefined")
    return require.apply(this, arguments);
  throw new Error('Dynamic require of "' + e + '" is not supported');
});
var p2 = (e, r) => () => (r || e((r = { exports: {} }).exports, r), r.exports);
var $e = (e, r, t, n) => {
  if (r && typeof r == "object" || typeof r == "function")
    for (let a of je(r))
      !Ue2.call(e, a) && a !== t && W3(e, a, { get: () => r[a], enumerable: !(n = Ce2(r, a)) || n.enumerable });
  return e;
};
var Z4 = (e, r, t) => (t = e != null ? Je(Fe3(e)) : {}, $e(r || !e || !e.__esModule ? W3(t, "default", { value: e, enumerable: true }) : t, e));
var b = p2((N4, X5) => {
  var I3 = export_default, v2 = I3.Buffer;
  function Q3(e, r) {
    for (var t in e)
      r[t] = e[t];
  }
  v2.from && v2.alloc && v2.allocUnsafe && v2.allocUnsafeSlow ? X5.exports = I3 : (Q3(I3, N4), N4.Buffer = g2);
  function g2(e, r, t) {
    return v2(e, r, t);
  }
  g2.prototype = Object.create(v2.prototype);
  Q3(v2, g2);
  g2.from = function(e, r, t) {
    if (typeof e == "number")
      throw new TypeError("Argument must not be a number");
    return v2(e, r, t);
  };
  g2.alloc = function(e, r, t) {
    if (typeof e != "number")
      throw new TypeError("Argument must be a number");
    var n = v2(e);
    return r !== void 0 ? typeof t == "string" ? n.fill(r, t) : n.fill(r) : n.fill(0), n;
  };
  g2.allocUnsafe = function(e) {
    if (typeof e != "number")
      throw new TypeError("Argument must be a number");
    return v2(e);
  };
  g2.allocUnsafeSlow = function(e) {
    if (typeof e != "number")
      throw new TypeError("Argument must be a number");
    return I3.SlowBuffer(e);
  };
});
var G3 = p2((Dr, Y4) => {
  var T4 = b().Buffer, We = Ki, Ze2 = Qo;
  function P2(e) {
    if (this.buffer = null, this.writable = true, this.readable = true, !e)
      return this.buffer = T4.alloc(0), this;
    if (typeof e.pipe == "function")
      return this.buffer = T4.alloc(0), e.pipe(this), this;
    if (e.length || typeof e == "object")
      return this.buffer = e, this.writable = false, node_process_default.nextTick(function() {
        this.emit("end", e), this.readable = false, this.emit("close");
      }.bind(this)), this;
    throw new TypeError("Unexpected data type (" + typeof e + ")");
  }
  Ze2.inherits(P2, We);
  P2.prototype.write = function(r) {
    this.buffer = T4.concat([this.buffer, T4.from(r)]), this.emit("data", r);
  };
  P2.prototype.end = function(r) {
    r && this.write(r), this.emit("end", r), this.emit("close"), this.writable = false, this.readable = false;
  };
  Y4.exports = P2;
});
var k5 = p2((Or2, z) => {
  "use strict";
  var B3 = export_default.Buffer, K4 = export_default.SlowBuffer;
  z.exports = x;
  function x(e, r) {
    if (!B3.isBuffer(e) || !B3.isBuffer(r) || e.length !== r.length)
      return false;
    for (var t = 0, n = 0; n < e.length; n++)
      t |= e[n] ^ r[n];
    return t === 0;
  }
  x.install = function() {
    B3.prototype.equal = K4.prototype.equal = function(r) {
      return x(this, r);
    };
  };
  var Qe2 = B3.prototype.equal, Xe2 = K4.prototype.equal;
  x.restore = function() {
    B3.prototype.equal = Qe2, K4.prototype.equal = Xe2;
  };
});
var re = p2((Hr, ee2) => {
  "use strict";
  function M4(e) {
    var r = (e / 8 | 0) + (e % 8 === 0 ? 0 : 1);
    return r;
  }
  var Ye2 = { ES256: M4(256), ES384: M4(384), ES512: M4(521) };
  function ze(e) {
    var r = Ye2[e];
    if (r)
      return r;
    throw new Error('Unknown algorithm "' + e + '"');
  }
  ee2.exports = ze;
});
var ue = p2((Nr2, oe) => {
  "use strict";
  var R3 = b().Buffer, ne = re(), L4 = 128, ie = 0, ke = 32, er = 16, rr = 2, ae2 = er | ke | ie << 6, V3 = rr | ie << 6;
  function tr(e) {
    return e.replace(/=/g, "").replace(/\+/g, "-").replace(/\//g, "_");
  }
  function fe(e) {
    if (R3.isBuffer(e))
      return e;
    if (typeof e == "string")
      return R3.from(e, "base64");
    throw new TypeError("ECDSA signature must be a Base64 string or a Buffer");
  }
  function nr(e, r) {
    e = fe(e);
    var t = ne(r), n = t + 1, a = e.length, i = 0;
    if (e[i++] !== ae2)
      throw new Error('Could not find expected "seq"');
    var u = e[i++];
    if (u === (L4 | 1) && (u = e[i++]), a - i < u)
      throw new Error('"seq" specified length of "' + u + '", only "' + (a - i) + '" remaining');
    if (e[i++] !== V3)
      throw new Error('Could not find expected "int" for "r"');
    var s = e[i++];
    if (a - i - 2 < s)
      throw new Error('"r" specified length of "' + s + '", only "' + (a - i - 2) + '" available');
    if (n < s)
      throw new Error('"r" specified length of "' + s + '", max of "' + n + '" is acceptable');
    var m3 = i;
    if (i += s, e[i++] !== V3)
      throw new Error('Could not find expected "int" for "s"');
    var l = e[i++];
    if (a - i !== l)
      throw new Error('"s" specified length of "' + l + '", expected "' + (a - i) + '"');
    if (n < l)
      throw new Error('"s" specified length of "' + l + '", max of "' + n + '" is acceptable');
    var o2 = i;
    if (i += l, i !== a)
      throw new Error('Expected to consume entire buffer, but "' + (a - i) + '" bytes remain');
    var f = t - s, H3 = t - l, S3 = R3.allocUnsafe(f + s + H3 + l);
    for (i = 0; i < f; ++i)
      S3[i] = 0;
    e.copy(S3, i, m3 + Math.max(-f, 0), m3 + s), i = t;
    for (var Me = i; i < Me + H3; ++i)
      S3[i] = 0;
    return e.copy(S3, i, o2 + Math.max(-H3, 0), o2 + l), S3 = S3.toString("base64"), S3 = tr(S3), S3;
  }
  function te(e, r, t) {
    for (var n = 0; r + n < t && e[r + n] === 0; )
      ++n;
    var a = e[r + n] >= L4;
    return a && --n, n;
  }
  function ir2(e, r) {
    e = fe(e);
    var t = ne(r), n = e.length;
    if (n !== t * 2)
      throw new TypeError('"' + r + '" signatures must be "' + t * 2 + '" bytes, saw "' + n + '"');
    var a = te(e, 0, t), i = te(e, t, e.length), u = t - a, s = t - i, m3 = 1 + 1 + u + 1 + 1 + s, l = m3 < L4, o2 = R3.allocUnsafe((l ? 2 : 3) + m3), f = 0;
    return o2[f++] = ae2, l ? o2[f++] = m3 : (o2[f++] = L4 | 1, o2[f++] = m3 & 255), o2[f++] = V3, o2[f++] = u, a < 0 ? (o2[f++] = 0, f += e.copy(o2, f, 0, t)) : f += e.copy(o2, f, a, t), o2[f++] = V3, o2[f++] = s, i < 0 ? (o2[f++] = 0, e.copy(o2, f, t)) : e.copy(o2, f, t + i), o2;
  }
  oe.exports = { derToJose: nr, joseToDer: ir2 };
});
var j = p2((Gr2, ye) => {
  var ar = k5(), E2 = b().Buffer, d4 = h9, ce2 = ue(), se = Qo, fr = `"%s" is not a valid algorithm.
  Supported algorithms are:
  "HS256", "HS384", "HS512", "RS256", "RS384", "RS512", "PS256", "PS384", "PS512", "ES256", "ES384", "ES512" and "none".`, q = "secret must be a string or buffer", w2 = "key must be a string or a buffer", or2 = "key must be a string, a buffer or an object", J3 = typeof d4.createPublicKey == "function";
  J3 && (w2 += " or a KeyObject", q += "or a KeyObject");
  function le2(e) {
    if (!E2.isBuffer(e) && typeof e != "string" && (!J3 || typeof e != "object" || typeof e.type != "string" || typeof e.asymmetricKeyType != "string" || typeof e.export != "function"))
      throw h(w2);
  }
  function he2(e) {
    if (!E2.isBuffer(e) && typeof e != "string" && typeof e != "object")
      throw h(or2);
  }
  function ur2(e) {
    if (!E2.isBuffer(e)) {
      if (typeof e == "string")
        return e;
      if (!J3 || typeof e != "object" || e.type !== "secret" || typeof e.export != "function")
        throw h(q);
    }
  }
  function C(e) {
    return e.replace(/=/g, "").replace(/\+/g, "-").replace(/\//g, "_");
  }
  function pe(e) {
    e = e.toString();
    var r = 4 - e.length % 4;
    if (r !== 4)
      for (var t = 0; t < r; ++t)
        e += "=";
    return e.replace(/\-/g, "+").replace(/_/g, "/");
  }
  function h(e) {
    var r = [].slice.call(arguments, 1), t = se.format.bind(se, e).apply(null, r);
    return new TypeError(t);
  }
  function sr(e) {
    return E2.isBuffer(e) || typeof e == "string";
  }
  function _2(e) {
    return sr(e) || (e = JSON.stringify(e)), e;
  }
  function ve2(e) {
    return function(t, n) {
      ur2(n), t = _2(t);
      var a = d4.createHmac("sha" + e, n), i = (a.update(t), a.digest("base64"));
      return C(i);
    };
  }
  function cr(e) {
    return function(t, n, a) {
      var i = ve2(e)(t, a);
      return ar(E2.from(n), E2.from(i));
    };
  }
  function de4(e) {
    return function(t, n) {
      he2(n), t = _2(t);
      var a = d4.createSign("RSA-SHA" + e), i = (a.update(t), a.sign(n, "base64"));
      return C(i);
    };
  }
  function Se2(e) {
    return function(t, n, a) {
      le2(a), t = _2(t), n = pe(n);
      var i = d4.createVerify("RSA-SHA" + e);
      return i.update(t), i.verify(a, n, "base64");
    };
  }
  function lr(e) {
    return function(t, n) {
      he2(n), t = _2(t);
      var a = d4.createSign("RSA-SHA" + e), i = (a.update(t), a.sign({ key: n, padding: d4.constants.RSA_PKCS1_PSS_PADDING, saltLength: d4.constants.RSA_PSS_SALTLEN_DIGEST }, "base64"));
      return C(i);
    };
  }
  function hr(e) {
    return function(t, n, a) {
      le2(a), t = _2(t), n = pe(n);
      var i = d4.createVerify("RSA-SHA" + e);
      return i.update(t), i.verify({ key: a, padding: d4.constants.RSA_PKCS1_PSS_PADDING, saltLength: d4.constants.RSA_PSS_SALTLEN_DIGEST }, n, "base64");
    };
  }
  function pr2(e) {
    var r = de4(e);
    return function() {
      var n = r.apply(null, arguments);
      return n = ce2.derToJose(n, "ES" + e), n;
    };
  }
  function vr5(e) {
    var r = Se2(e);
    return function(n, a, i) {
      a = ce2.joseToDer(a, "ES" + e).toString("base64");
      var u = r(n, a, i);
      return u;
    };
  }
  function dr2() {
    return function() {
      return "";
    };
  }
  function Sr() {
    return function(r, t) {
      return t === "";
    };
  }
  ye.exports = function(r) {
    var t = { hs: ve2, rs: de4, ps: lr, es: pr2, none: dr2 }, n = { hs: cr, rs: Se2, ps: hr, es: vr5, none: Sr }, a = r.match(/^(RS|PS|ES|HS)(256|384|512)$|^(none)$/);
    if (!a)
      throw h(fr, r);
    var i = (a[1] || a[3]).toLowerCase(), u = a[2];
    return { sign: t[i](u), verify: n[i](u) };
  };
});
var F3 = p2((Kr, me) => {
  var yr2 = export_default.Buffer;
  me.exports = function(r) {
    return typeof r == "string" ? r : typeof r == "number" || yr2.isBuffer(r) ? r.toString() : JSON.stringify(r);
  };
});
var Be = p2((Mr, Ae3) => {
  var mr = b().Buffer, ge2 = G3(), gr2 = j(), br = Ki, be = F3(), U2 = Qo;
  function we2(e, r) {
    return mr.from(e, r).toString("base64").replace(/=/g, "").replace(/\+/g, "-").replace(/\//g, "_");
  }
  function wr2(e, r, t) {
    t = t || "utf8";
    var n = we2(be(e), "binary"), a = we2(be(r), t);
    return U2.format("%s.%s", n, a);
  }
  function Ee2(e) {
    var r = e.header, t = e.payload, n = e.secret || e.privateKey, a = e.encoding, i = gr2(r.alg), u = wr2(r, t, a), s = i.sign(u, n);
    return U2.format("%s.%s", u, s);
  }
  function D6(e) {
    var r = e.secret || e.privateKey || e.key, t = new ge2(r);
    this.readable = true, this.header = e.header, this.encoding = e.encoding, this.secret = this.privateKey = this.key = t, this.payload = new ge2(e.payload), this.secret.once("close", function() {
      !this.payload.writable && this.readable && this.sign();
    }.bind(this)), this.payload.once("close", function() {
      !this.secret.writable && this.readable && this.sign();
    }.bind(this));
  }
  U2.inherits(D6, br);
  D6.prototype.sign = function() {
    try {
      var r = Ee2({ header: this.header, payload: this.payload.buffer, secret: this.secret.buffer, encoding: this.encoding });
      return this.emit("done", r), this.emit("data", r), this.emit("end"), this.readable = false, r;
    } catch (t) {
      this.readable = false, this.emit("error", t), this.emit("close");
    }
  };
  D6.sign = Ee2;
  Ae3.exports = D6;
});
var De3 = p2((Jr, Ve2) => {
  var _e2 = b().Buffer, qe3 = G3(), Er3 = j(), Ar = Ki, Ie = F3(), Br2 = Qo, qr2 = /^[a-zA-Z0-9\-_]+?\.[a-zA-Z0-9\-_]+?\.([a-zA-Z0-9\-_]+)?$/;
  function _r2(e) {
    return Object.prototype.toString.call(e) === "[object Object]";
  }
  function Ir2(e) {
    if (_r2(e))
      return e;
    try {
      return JSON.parse(e);
    } catch {
      return;
    }
  }
  function Te(e) {
    var r = e.split(".", 1)[0];
    return Ir2(_e2.from(r, "base64").toString("binary"));
  }
  function Tr2(e) {
    return e.split(".", 2).join(".");
  }
  function Pe(e) {
    return e.split(".")[2];
  }
  function Pr2(e, r) {
    r = r || "utf8";
    var t = e.split(".")[1];
    return _e2.from(t, "base64").toString(r);
  }
  function xe3(e) {
    return qr2.test(e) && !!Te(e);
  }
  function Re(e, r, t) {
    if (!r) {
      var n = new Error("Missing algorithm parameter for jws.verify");
      throw n.code = "MISSING_ALGORITHM", n;
    }
    e = Ie(e);
    var a = Pe(e), i = Tr2(e), u = Er3(r);
    return u.verify(i, a, t);
  }
  function Le(e, r) {
    if (r = r || {}, e = Ie(e), !xe3(e))
      return null;
    var t = Te(e);
    if (!t)
      return null;
    var n = Pr2(e);
    return (t.typ === "JWT" || r.json) && (n = JSON.parse(n, r.encoding)), { header: t, payload: n, signature: Pe(e) };
  }
  function A4(e) {
    e = e || {};
    var r = e.secret || e.publicKey || e.key, t = new qe3(r);
    this.readable = true, this.algorithm = e.algorithm, this.encoding = e.encoding, this.secret = this.publicKey = this.key = t, this.signature = new qe3(e.signature), this.secret.once("close", function() {
      !this.signature.writable && this.readable && this.verify();
    }.bind(this)), this.signature.once("close", function() {
      !this.secret.writable && this.readable && this.verify();
    }.bind(this));
  }
  Br2.inherits(A4, Ar);
  A4.prototype.verify = function() {
    try {
      var r = Re(this.signature.buffer, this.algorithm, this.key.buffer), t = Le(this.signature.buffer, this.encoding);
      return this.emit("done", r, t), this.emit("data", r), this.emit("end"), this.readable = false, r;
    } catch (n) {
      this.readable = false, this.emit("error", n), this.emit("close");
    }
  };
  A4.decode = Le;
  A4.isValid = xe3;
  A4.verify = Re;
  Ve2.exports = A4;
});
var $3 = p2((y4) => {
  var Oe = Be(), O = De3(), xr2 = ["HS256", "HS384", "HS512", "RS256", "RS384", "RS512", "PS256", "PS384", "PS512", "ES256", "ES384", "ES512"];
  y4.ALGORITHMS = xr2;
  y4.sign = Oe.sign;
  y4.verify = O.verify;
  y4.decode = O.decode;
  y4.isValid = O.isValid;
  y4.createSign = function(r) {
    return new Oe(r);
  };
  y4.createVerify = function(r) {
    return new O(r);
  };
});
var Ge = Z4($3());
var Ke5 = Z4($3());
var { ALGORITHMS: jr2, sign: Fr2, verify: Ur, decode: $r2, isValid: Wr, createSign: Zr, createVerify: Qr } = Ke5;
var { default: Rr, ...Lr2 } = Ke5;
var He;
var Ne2;
var Xr = (Ne2 = (He = Ge.default) != null ? He : Rr) != null ? Ne2 : Lr2;

// deno:https://esm.sh/v86/asn1.js@5.4.1/es2020/asn1.bundle.js
var Or = Object.create;
var Ve = Object.defineProperty;
var Ur2 = Object.getOwnPropertyDescriptor;
var Ir = Object.getOwnPropertyNames;
var Cr = Object.getPrototypeOf;
var Lr3 = Object.prototype.hasOwnProperty;
var Xe = ((d4) => typeof require != "undefined" ? require : typeof Proxy != "undefined" ? new Proxy(d4, { get: (r, n) => (typeof require != "undefined" ? require : r)[n] }) : d4)(function(d4) {
  if (typeof require != "undefined")
    return require.apply(this, arguments);
  throw new Error('Dynamic require of "' + d4 + '" is not supported');
});
var ct3 = (d4, r) => () => (r || d4((r = { exports: {} }).exports, r), r.exports);
var Zr2 = (d4, r, n, a) => {
  if (r && typeof r == "object" || typeof r == "function")
    for (let o2 of Ir(r))
      !Lr3.call(d4, o2) && o2 !== n && Ve(d4, o2, { get: () => r[o2], enumerable: !(a = Ur2(r, o2)) || a.enumerable });
  return d4;
};
var Ye = (d4, r, n) => (n = d4 != null ? Or(Cr(d4)) : {}, Zr2(r || !d4 || !d4.__esModule ? Ve(n, "default", { value: d4, enumerable: true }) : n, d4));
var de3 = ct3((We, ce2) => {
  (function(d4, r) {
    "use strict";
    function n(c5, t) {
      if (!c5)
        throw new Error(t || "Assertion failed");
    }
    function a(c5, t) {
      c5.super_ = t;
      var i = function() {
      };
      i.prototype = t.prototype, c5.prototype = new i(), c5.prototype.constructor = c5;
    }
    function o2(c5, t, i) {
      if (o2.isBN(c5))
        return c5;
      this.negative = 0, this.words = null, this.length = 0, this.red = null, c5 !== null && ((t === "le" || t === "be") && (i = t, t = 10), this._init(c5 || 0, t || 10, i || "be"));
    }
    typeof d4 == "object" ? d4.exports = o2 : r.BN = o2, o2.BN = o2, o2.wordSize = 26;
    var m3;
    try {
      typeof window < "u" && typeof window.Buffer < "u" ? m3 = window.Buffer : m3 = export_default.Buffer;
    } catch {
    }
    o2.isBN = function(t) {
      return t instanceof o2 ? true : t !== null && typeof t == "object" && t.constructor.wordSize === o2.wordSize && Array.isArray(t.words);
    }, o2.max = function(t, i) {
      return t.cmp(i) > 0 ? t : i;
    }, o2.min = function(t, i) {
      return t.cmp(i) < 0 ? t : i;
    }, o2.prototype._init = function(t, i, s) {
      if (typeof t == "number")
        return this._initNumber(t, i, s);
      if (typeof t == "object")
        return this._initArray(t, i, s);
      i === "hex" && (i = 16), n(i === (i | 0) && i >= 2 && i <= 36), t = t.toString().replace(/\s+/g, "");
      var f = 0;
      t[0] === "-" && (f++, this.negative = 1), f < t.length && (i === 16 ? this._parseHex(t, f, s) : (this._parseBase(t, i, f), s === "le" && this._initArray(this.toArray(), i, s)));
    }, o2.prototype._initNumber = function(t, i, s) {
      t < 0 && (this.negative = 1, t = -t), t < 67108864 ? (this.words = [t & 67108863], this.length = 1) : t < 4503599627370496 ? (this.words = [t & 67108863, t / 67108864 & 67108863], this.length = 2) : (n(t < 9007199254740992), this.words = [t & 67108863, t / 67108864 & 67108863, 1], this.length = 3), s === "le" && this._initArray(this.toArray(), i, s);
    }, o2.prototype._initArray = function(t, i, s) {
      if (n(typeof t.length == "number"), t.length <= 0)
        return this.words = [0], this.length = 1, this;
      this.length = Math.ceil(t.length / 3), this.words = new Array(this.length);
      for (var f = 0; f < this.length; f++)
        this.words[f] = 0;
      var u, p3, v2 = 0;
      if (s === "be")
        for (f = t.length - 1, u = 0; f >= 0; f -= 3)
          p3 = t[f] | t[f - 1] << 8 | t[f - 2] << 16, this.words[u] |= p3 << v2 & 67108863, this.words[u + 1] = p3 >>> 26 - v2 & 67108863, v2 += 24, v2 >= 26 && (v2 -= 26, u++);
      else if (s === "le")
        for (f = 0, u = 0; f < t.length; f += 3)
          p3 = t[f] | t[f + 1] << 8 | t[f + 2] << 16, this.words[u] |= p3 << v2 & 67108863, this.words[u + 1] = p3 >>> 26 - v2 & 67108863, v2 += 24, v2 >= 26 && (v2 -= 26, u++);
      return this.strip();
    };
    function g2(c5, t) {
      var i = c5.charCodeAt(t);
      return i >= 65 && i <= 70 ? i - 55 : i >= 97 && i <= 102 ? i - 87 : i - 48 & 15;
    }
    function _2(c5, t, i) {
      var s = g2(c5, i);
      return i - 1 >= t && (s |= g2(c5, i - 1) << 4), s;
    }
    o2.prototype._parseHex = function(t, i, s) {
      this.length = Math.ceil((t.length - i) / 6), this.words = new Array(this.length);
      for (var f = 0; f < this.length; f++)
        this.words[f] = 0;
      var u = 0, p3 = 0, v2;
      if (s === "be")
        for (f = t.length - 1; f >= i; f -= 2)
          v2 = _2(t, i, f) << u, this.words[p3] |= v2 & 67108863, u >= 18 ? (u -= 18, p3 += 1, this.words[p3] |= v2 >>> 26) : u += 8;
      else {
        var h = t.length - i;
        for (f = h % 2 === 0 ? i + 1 : i; f < t.length; f += 2)
          v2 = _2(t, i, f) << u, this.words[p3] |= v2 & 67108863, u >= 18 ? (u -= 18, p3 += 1, this.words[p3] |= v2 >>> 26) : u += 8;
      }
      this.strip();
    };
    function x(c5, t, i, s) {
      for (var f = 0, u = Math.min(c5.length, i), p3 = t; p3 < u; p3++) {
        var v2 = c5.charCodeAt(p3) - 48;
        f *= s, v2 >= 49 ? f += v2 - 49 + 10 : v2 >= 17 ? f += v2 - 17 + 10 : f += v2;
      }
      return f;
    }
    o2.prototype._parseBase = function(t, i, s) {
      this.words = [0], this.length = 1;
      for (var f = 0, u = 1; u <= 67108863; u *= i)
        f++;
      f--, u = u / i | 0;
      for (var p3 = t.length - s, v2 = p3 % f, h = Math.min(p3, p3 - v2) + s, e = 0, l = s; l < h; l += f)
        e = x(t, l, l + f, i), this.imuln(u), this.words[0] + e < 67108864 ? this.words[0] += e : this._iaddn(e);
      if (v2 !== 0) {
        var y4 = 1;
        for (e = x(t, l, t.length, i), l = 0; l < v2; l++)
          y4 *= i;
        this.imuln(y4), this.words[0] + e < 67108864 ? this.words[0] += e : this._iaddn(e);
      }
      this.strip();
    }, o2.prototype.copy = function(t) {
      t.words = new Array(this.length);
      for (var i = 0; i < this.length; i++)
        t.words[i] = this.words[i];
      t.length = this.length, t.negative = this.negative, t.red = this.red;
    }, o2.prototype.clone = function() {
      var t = new o2(null);
      return this.copy(t), t;
    }, o2.prototype._expand = function(t) {
      for (; this.length < t; )
        this.words[this.length++] = 0;
      return this;
    }, o2.prototype.strip = function() {
      for (; this.length > 1 && this.words[this.length - 1] === 0; )
        this.length--;
      return this._normSign();
    }, o2.prototype._normSign = function() {
      return this.length === 1 && this.words[0] === 0 && (this.negative = 0), this;
    }, o2.prototype.inspect = function() {
      return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
    };
    var S3 = ["", "0", "00", "000", "0000", "00000", "000000", "0000000", "00000000", "000000000", "0000000000", "00000000000", "000000000000", "0000000000000", "00000000000000", "000000000000000", "0000000000000000", "00000000000000000", "000000000000000000", "0000000000000000000", "00000000000000000000", "000000000000000000000", "0000000000000000000000", "00000000000000000000000", "000000000000000000000000", "0000000000000000000000000"], T4 = [0, 0, 25, 16, 12, 11, 10, 9, 8, 8, 7, 7, 7, 7, 6, 6, 6, 6, 6, 6, 6, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5], qt2 = [0, 0, 33554432, 43046721, 16777216, 48828125, 60466176, 40353607, 16777216, 43046721, 1e7, 19487171, 35831808, 62748517, 7529536, 11390625, 16777216, 24137569, 34012224, 47045881, 64e6, 4084101, 5153632, 6436343, 7962624, 9765625, 11881376, 14348907, 17210368, 20511149, 243e5, 28629151, 33554432, 39135393, 45435424, 52521875, 60466176];
    o2.prototype.toString = function(t, i) {
      t = t || 10, i = i | 0 || 1;
      var s;
      if (t === 16 || t === "hex") {
        s = "";
        for (var f = 0, u = 0, p3 = 0; p3 < this.length; p3++) {
          var v2 = this.words[p3], h = ((v2 << f | u) & 16777215).toString(16);
          u = v2 >>> 24 - f & 16777215, u !== 0 || p3 !== this.length - 1 ? s = S3[6 - h.length] + h + s : s = h + s, f += 2, f >= 26 && (f -= 26, p3--);
        }
        for (u !== 0 && (s = u.toString(16) + s); s.length % i !== 0; )
          s = "0" + s;
        return this.negative !== 0 && (s = "-" + s), s;
      }
      if (t === (t | 0) && t >= 2 && t <= 36) {
        var e = T4[t], l = qt2[t];
        s = "";
        var y4 = this.clone();
        for (y4.negative = 0; !y4.isZero(); ) {
          var M4 = y4.modn(l).toString(t);
          y4 = y4.idivn(l), y4.isZero() ? s = M4 + s : s = S3[e - M4.length] + M4 + s;
        }
        for (this.isZero() && (s = "0" + s); s.length % i !== 0; )
          s = "0" + s;
        return this.negative !== 0 && (s = "-" + s), s;
      }
      n(false, "Base should be between 2 and 36");
    }, o2.prototype.toNumber = function() {
      var t = this.words[0];
      return this.length === 2 ? t += this.words[1] * 67108864 : this.length === 3 && this.words[2] === 1 ? t += 4503599627370496 + this.words[1] * 67108864 : this.length > 2 && n(false, "Number can only safely store up to 53 bits"), this.negative !== 0 ? -t : t;
    }, o2.prototype.toJSON = function() {
      return this.toString(16);
    }, o2.prototype.toBuffer = function(t, i) {
      return n(typeof m3 < "u"), this.toArrayLike(m3, t, i);
    }, o2.prototype.toArray = function(t, i) {
      return this.toArrayLike(Array, t, i);
    }, o2.prototype.toArrayLike = function(t, i, s) {
      var f = this.byteLength(), u = s || Math.max(1, f);
      n(f <= u, "byte array longer than desired length"), n(u > 0, "Requested array length <= 0"), this.strip();
      var p3 = i === "le", v2 = new t(u), h, e, l = this.clone();
      if (p3) {
        for (e = 0; !l.isZero(); e++)
          h = l.andln(255), l.iushrn(8), v2[e] = h;
        for (; e < u; e++)
          v2[e] = 0;
      } else {
        for (e = 0; e < u - f; e++)
          v2[e] = 0;
        for (e = 0; !l.isZero(); e++)
          h = l.andln(255), l.iushrn(8), v2[u - e - 1] = h;
      }
      return v2;
    }, Math.clz32 ? o2.prototype._countBits = function(t) {
      return 32 - Math.clz32(t);
    } : o2.prototype._countBits = function(t) {
      var i = t, s = 0;
      return i >= 4096 && (s += 13, i >>>= 13), i >= 64 && (s += 7, i >>>= 7), i >= 8 && (s += 4, i >>>= 4), i >= 2 && (s += 2, i >>>= 2), s + i;
    }, o2.prototype._zeroBits = function(t) {
      if (t === 0)
        return 26;
      var i = t, s = 0;
      return (i & 8191) === 0 && (s += 13, i >>>= 13), (i & 127) === 0 && (s += 7, i >>>= 7), (i & 15) === 0 && (s += 4, i >>>= 4), (i & 3) === 0 && (s += 2, i >>>= 2), (i & 1) === 0 && s++, s;
    }, o2.prototype.bitLength = function() {
      var t = this.words[this.length - 1], i = this._countBits(t);
      return (this.length - 1) * 26 + i;
    };
    function jr3(c5) {
      for (var t = new Array(c5.bitLength()), i = 0; i < t.length; i++) {
        var s = i / 26 | 0, f = i % 26;
        t[i] = (c5.words[s] & 1 << f) >>> f;
      }
      return t;
    }
    o2.prototype.zeroBits = function() {
      if (this.isZero())
        return 0;
      for (var t = 0, i = 0; i < this.length; i++) {
        var s = this._zeroBits(this.words[i]);
        if (t += s, s !== 26)
          break;
      }
      return t;
    }, o2.prototype.byteLength = function() {
      return Math.ceil(this.bitLength() / 8);
    }, o2.prototype.toTwos = function(t) {
      return this.negative !== 0 ? this.abs().inotn(t).iaddn(1) : this.clone();
    }, o2.prototype.fromTwos = function(t) {
      return this.testn(t - 1) ? this.notn(t).iaddn(1).ineg() : this.clone();
    }, o2.prototype.isNeg = function() {
      return this.negative !== 0;
    }, o2.prototype.neg = function() {
      return this.clone().ineg();
    }, o2.prototype.ineg = function() {
      return this.isZero() || (this.negative ^= 1), this;
    }, o2.prototype.iuor = function(t) {
      for (; this.length < t.length; )
        this.words[this.length++] = 0;
      for (var i = 0; i < t.length; i++)
        this.words[i] = this.words[i] | t.words[i];
      return this.strip();
    }, o2.prototype.ior = function(t) {
      return n((this.negative | t.negative) === 0), this.iuor(t);
    }, o2.prototype.or = function(t) {
      return this.length > t.length ? this.clone().ior(t) : t.clone().ior(this);
    }, o2.prototype.uor = function(t) {
      return this.length > t.length ? this.clone().iuor(t) : t.clone().iuor(this);
    }, o2.prototype.iuand = function(t) {
      var i;
      this.length > t.length ? i = t : i = this;
      for (var s = 0; s < i.length; s++)
        this.words[s] = this.words[s] & t.words[s];
      return this.length = i.length, this.strip();
    }, o2.prototype.iand = function(t) {
      return n((this.negative | t.negative) === 0), this.iuand(t);
    }, o2.prototype.and = function(t) {
      return this.length > t.length ? this.clone().iand(t) : t.clone().iand(this);
    }, o2.prototype.uand = function(t) {
      return this.length > t.length ? this.clone().iuand(t) : t.clone().iuand(this);
    }, o2.prototype.iuxor = function(t) {
      var i, s;
      this.length > t.length ? (i = this, s = t) : (i = t, s = this);
      for (var f = 0; f < s.length; f++)
        this.words[f] = i.words[f] ^ s.words[f];
      if (this !== i)
        for (; f < i.length; f++)
          this.words[f] = i.words[f];
      return this.length = i.length, this.strip();
    }, o2.prototype.ixor = function(t) {
      return n((this.negative | t.negative) === 0), this.iuxor(t);
    }, o2.prototype.xor = function(t) {
      return this.length > t.length ? this.clone().ixor(t) : t.clone().ixor(this);
    }, o2.prototype.uxor = function(t) {
      return this.length > t.length ? this.clone().iuxor(t) : t.clone().iuxor(this);
    }, o2.prototype.inotn = function(t) {
      n(typeof t == "number" && t >= 0);
      var i = Math.ceil(t / 26) | 0, s = t % 26;
      this._expand(i), s > 0 && i--;
      for (var f = 0; f < i; f++)
        this.words[f] = ~this.words[f] & 67108863;
      return s > 0 && (this.words[f] = ~this.words[f] & 67108863 >> 26 - s), this.strip();
    }, o2.prototype.notn = function(t) {
      return this.clone().inotn(t);
    }, o2.prototype.setn = function(t, i) {
      n(typeof t == "number" && t >= 0);
      var s = t / 26 | 0, f = t % 26;
      return this._expand(s + 1), i ? this.words[s] = this.words[s] | 1 << f : this.words[s] = this.words[s] & ~(1 << f), this.strip();
    }, o2.prototype.iadd = function(t) {
      var i;
      if (this.negative !== 0 && t.negative === 0)
        return this.negative = 0, i = this.isub(t), this.negative ^= 1, this._normSign();
      if (this.negative === 0 && t.negative !== 0)
        return t.negative = 0, i = this.isub(t), t.negative = 1, i._normSign();
      var s, f;
      this.length > t.length ? (s = this, f = t) : (s = t, f = this);
      for (var u = 0, p3 = 0; p3 < f.length; p3++)
        i = (s.words[p3] | 0) + (f.words[p3] | 0) + u, this.words[p3] = i & 67108863, u = i >>> 26;
      for (; u !== 0 && p3 < s.length; p3++)
        i = (s.words[p3] | 0) + u, this.words[p3] = i & 67108863, u = i >>> 26;
      if (this.length = s.length, u !== 0)
        this.words[this.length] = u, this.length++;
      else if (s !== this)
        for (; p3 < s.length; p3++)
          this.words[p3] = s.words[p3];
      return this;
    }, o2.prototype.add = function(t) {
      var i;
      return t.negative !== 0 && this.negative === 0 ? (t.negative = 0, i = this.sub(t), t.negative ^= 1, i) : t.negative === 0 && this.negative !== 0 ? (this.negative = 0, i = t.sub(this), this.negative = 1, i) : this.length > t.length ? this.clone().iadd(t) : t.clone().iadd(this);
    }, o2.prototype.isub = function(t) {
      if (t.negative !== 0) {
        t.negative = 0;
        var i = this.iadd(t);
        return t.negative = 1, i._normSign();
      } else if (this.negative !== 0)
        return this.negative = 0, this.iadd(t), this.negative = 1, this._normSign();
      var s = this.cmp(t);
      if (s === 0)
        return this.negative = 0, this.length = 1, this.words[0] = 0, this;
      var f, u;
      s > 0 ? (f = this, u = t) : (f = t, u = this);
      for (var p3 = 0, v2 = 0; v2 < u.length; v2++)
        i = (f.words[v2] | 0) - (u.words[v2] | 0) + p3, p3 = i >> 26, this.words[v2] = i & 67108863;
      for (; p3 !== 0 && v2 < f.length; v2++)
        i = (f.words[v2] | 0) + p3, p3 = i >> 26, this.words[v2] = i & 67108863;
      if (p3 === 0 && v2 < f.length && f !== this)
        for (; v2 < f.length; v2++)
          this.words[v2] = f.words[v2];
      return this.length = Math.max(this.length, v2), f !== this && (this.negative = 1), this.strip();
    }, o2.prototype.sub = function(t) {
      return this.clone().isub(t);
    };
    function ke(c5, t, i) {
      i.negative = t.negative ^ c5.negative;
      var s = c5.length + t.length | 0;
      i.length = s, s = s - 1 | 0;
      var f = c5.words[0] | 0, u = t.words[0] | 0, p3 = f * u, v2 = p3 & 67108863, h = p3 / 67108864 | 0;
      i.words[0] = v2;
      for (var e = 1; e < s; e++) {
        for (var l = h >>> 26, y4 = h & 67108863, M4 = Math.min(e, t.length - 1), w2 = Math.max(0, e - c5.length + 1); w2 <= M4; w2++) {
          var b2 = e - w2 | 0;
          f = c5.words[b2] | 0, u = t.words[w2] | 0, p3 = f * u + y4, l += p3 / 67108864 | 0, y4 = p3 & 67108863;
        }
        i.words[e] = y4 | 0, h = l | 0;
      }
      return h !== 0 ? i.words[e] = h | 0 : i.length--, i.strip();
    }
    var qe3 = function(t, i, s) {
      var f = t.words, u = i.words, p3 = s.words, v2 = 0, h, e, l, y4 = f[0] | 0, M4 = y4 & 8191, w2 = y4 >>> 13, b2 = f[1] | 0, E2 = b2 & 8191, k6 = b2 >>> 13, St = f[2] | 0, q = St & 8191, A4 = St >>> 13, Ne3 = f[3] | 0, N4 = Ne3 & 8191, j2 = Ne3 >>> 13, je2 = f[4] | 0, R3 = je2 & 8191, O = je2 >>> 13, Re = f[5] | 0, U2 = Re & 8191, I3 = Re >>> 13, Oe = f[6] | 0, C = Oe & 8191, L4 = Oe >>> 13, Ue3 = f[7] | 0, Z5 = Ue3 & 8191, P2 = Ue3 >>> 13, Ie = f[8] | 0, K4 = Ie & 8191, z = Ie >>> 13, Ce3 = f[9] | 0, F4 = Ce3 & 8191, G4 = Ce3 >>> 13, Le = u[0] | 0, $4 = Le & 8191, H3 = Le >>> 13, Ze2 = u[1] | 0, J3 = Ze2 & 8191, V3 = Ze2 >>> 13, Pe = u[2] | 0, X5 = Pe & 8191, Y4 = Pe >>> 13, Ke6 = u[3] | 0, W4 = Ke6 & 8191, Q3 = Ke6 >>> 13, ze = u[4] | 0, tt = ze & 8191, et = ze >>> 13, Fe4 = u[5] | 0, rt2 = Fe4 & 8191, it2 = Fe4 >>> 13, Ge2 = u[6] | 0, nt = Ge2 & 8191, ot4 = Ge2 >>> 13, $e2 = u[7] | 0, st2 = $e2 & 8191, ft4 = $e2 >>> 13, He2 = u[8] | 0, ht4 = He2 & 8191, lt3 = He2 >>> 13, Je2 = u[9] | 0, at2 = Je2 & 8191, ut4 = Je2 >>> 13;
      s.negative = t.negative ^ i.negative, s.length = 19, h = Math.imul(M4, $4), e = Math.imul(M4, H3), e = e + Math.imul(w2, $4) | 0, l = Math.imul(w2, H3);
      var Ht = (v2 + h | 0) + ((e & 8191) << 13) | 0;
      v2 = (l + (e >>> 13) | 0) + (Ht >>> 26) | 0, Ht &= 67108863, h = Math.imul(E2, $4), e = Math.imul(E2, H3), e = e + Math.imul(k6, $4) | 0, l = Math.imul(k6, H3), h = h + Math.imul(M4, J3) | 0, e = e + Math.imul(M4, V3) | 0, e = e + Math.imul(w2, J3) | 0, l = l + Math.imul(w2, V3) | 0;
      var Jt = (v2 + h | 0) + ((e & 8191) << 13) | 0;
      v2 = (l + (e >>> 13) | 0) + (Jt >>> 26) | 0, Jt &= 67108863, h = Math.imul(q, $4), e = Math.imul(q, H3), e = e + Math.imul(A4, $4) | 0, l = Math.imul(A4, H3), h = h + Math.imul(E2, J3) | 0, e = e + Math.imul(E2, V3) | 0, e = e + Math.imul(k6, J3) | 0, l = l + Math.imul(k6, V3) | 0, h = h + Math.imul(M4, X5) | 0, e = e + Math.imul(M4, Y4) | 0, e = e + Math.imul(w2, X5) | 0, l = l + Math.imul(w2, Y4) | 0;
      var Vt3 = (v2 + h | 0) + ((e & 8191) << 13) | 0;
      v2 = (l + (e >>> 13) | 0) + (Vt3 >>> 26) | 0, Vt3 &= 67108863, h = Math.imul(N4, $4), e = Math.imul(N4, H3), e = e + Math.imul(j2, $4) | 0, l = Math.imul(j2, H3), h = h + Math.imul(q, J3) | 0, e = e + Math.imul(q, V3) | 0, e = e + Math.imul(A4, J3) | 0, l = l + Math.imul(A4, V3) | 0, h = h + Math.imul(E2, X5) | 0, e = e + Math.imul(E2, Y4) | 0, e = e + Math.imul(k6, X5) | 0, l = l + Math.imul(k6, Y4) | 0, h = h + Math.imul(M4, W4) | 0, e = e + Math.imul(M4, Q3) | 0, e = e + Math.imul(w2, W4) | 0, l = l + Math.imul(w2, Q3) | 0;
      var Xt = (v2 + h | 0) + ((e & 8191) << 13) | 0;
      v2 = (l + (e >>> 13) | 0) + (Xt >>> 26) | 0, Xt &= 67108863, h = Math.imul(R3, $4), e = Math.imul(R3, H3), e = e + Math.imul(O, $4) | 0, l = Math.imul(O, H3), h = h + Math.imul(N4, J3) | 0, e = e + Math.imul(N4, V3) | 0, e = e + Math.imul(j2, J3) | 0, l = l + Math.imul(j2, V3) | 0, h = h + Math.imul(q, X5) | 0, e = e + Math.imul(q, Y4) | 0, e = e + Math.imul(A4, X5) | 0, l = l + Math.imul(A4, Y4) | 0, h = h + Math.imul(E2, W4) | 0, e = e + Math.imul(E2, Q3) | 0, e = e + Math.imul(k6, W4) | 0, l = l + Math.imul(k6, Q3) | 0, h = h + Math.imul(M4, tt) | 0, e = e + Math.imul(M4, et) | 0, e = e + Math.imul(w2, tt) | 0, l = l + Math.imul(w2, et) | 0;
      var Yt = (v2 + h | 0) + ((e & 8191) << 13) | 0;
      v2 = (l + (e >>> 13) | 0) + (Yt >>> 26) | 0, Yt &= 67108863, h = Math.imul(U2, $4), e = Math.imul(U2, H3), e = e + Math.imul(I3, $4) | 0, l = Math.imul(I3, H3), h = h + Math.imul(R3, J3) | 0, e = e + Math.imul(R3, V3) | 0, e = e + Math.imul(O, J3) | 0, l = l + Math.imul(O, V3) | 0, h = h + Math.imul(N4, X5) | 0, e = e + Math.imul(N4, Y4) | 0, e = e + Math.imul(j2, X5) | 0, l = l + Math.imul(j2, Y4) | 0, h = h + Math.imul(q, W4) | 0, e = e + Math.imul(q, Q3) | 0, e = e + Math.imul(A4, W4) | 0, l = l + Math.imul(A4, Q3) | 0, h = h + Math.imul(E2, tt) | 0, e = e + Math.imul(E2, et) | 0, e = e + Math.imul(k6, tt) | 0, l = l + Math.imul(k6, et) | 0, h = h + Math.imul(M4, rt2) | 0, e = e + Math.imul(M4, it2) | 0, e = e + Math.imul(w2, rt2) | 0, l = l + Math.imul(w2, it2) | 0;
      var Wt2 = (v2 + h | 0) + ((e & 8191) << 13) | 0;
      v2 = (l + (e >>> 13) | 0) + (Wt2 >>> 26) | 0, Wt2 &= 67108863, h = Math.imul(C, $4), e = Math.imul(C, H3), e = e + Math.imul(L4, $4) | 0, l = Math.imul(L4, H3), h = h + Math.imul(U2, J3) | 0, e = e + Math.imul(U2, V3) | 0, e = e + Math.imul(I3, J3) | 0, l = l + Math.imul(I3, V3) | 0, h = h + Math.imul(R3, X5) | 0, e = e + Math.imul(R3, Y4) | 0, e = e + Math.imul(O, X5) | 0, l = l + Math.imul(O, Y4) | 0, h = h + Math.imul(N4, W4) | 0, e = e + Math.imul(N4, Q3) | 0, e = e + Math.imul(j2, W4) | 0, l = l + Math.imul(j2, Q3) | 0, h = h + Math.imul(q, tt) | 0, e = e + Math.imul(q, et) | 0, e = e + Math.imul(A4, tt) | 0, l = l + Math.imul(A4, et) | 0, h = h + Math.imul(E2, rt2) | 0, e = e + Math.imul(E2, it2) | 0, e = e + Math.imul(k6, rt2) | 0, l = l + Math.imul(k6, it2) | 0, h = h + Math.imul(M4, nt) | 0, e = e + Math.imul(M4, ot4) | 0, e = e + Math.imul(w2, nt) | 0, l = l + Math.imul(w2, ot4) | 0;
      var Qt = (v2 + h | 0) + ((e & 8191) << 13) | 0;
      v2 = (l + (e >>> 13) | 0) + (Qt >>> 26) | 0, Qt &= 67108863, h = Math.imul(Z5, $4), e = Math.imul(Z5, H3), e = e + Math.imul(P2, $4) | 0, l = Math.imul(P2, H3), h = h + Math.imul(C, J3) | 0, e = e + Math.imul(C, V3) | 0, e = e + Math.imul(L4, J3) | 0, l = l + Math.imul(L4, V3) | 0, h = h + Math.imul(U2, X5) | 0, e = e + Math.imul(U2, Y4) | 0, e = e + Math.imul(I3, X5) | 0, l = l + Math.imul(I3, Y4) | 0, h = h + Math.imul(R3, W4) | 0, e = e + Math.imul(R3, Q3) | 0, e = e + Math.imul(O, W4) | 0, l = l + Math.imul(O, Q3) | 0, h = h + Math.imul(N4, tt) | 0, e = e + Math.imul(N4, et) | 0, e = e + Math.imul(j2, tt) | 0, l = l + Math.imul(j2, et) | 0, h = h + Math.imul(q, rt2) | 0, e = e + Math.imul(q, it2) | 0, e = e + Math.imul(A4, rt2) | 0, l = l + Math.imul(A4, it2) | 0, h = h + Math.imul(E2, nt) | 0, e = e + Math.imul(E2, ot4) | 0, e = e + Math.imul(k6, nt) | 0, l = l + Math.imul(k6, ot4) | 0, h = h + Math.imul(M4, st2) | 0, e = e + Math.imul(M4, ft4) | 0, e = e + Math.imul(w2, st2) | 0, l = l + Math.imul(w2, ft4) | 0;
      var te = (v2 + h | 0) + ((e & 8191) << 13) | 0;
      v2 = (l + (e >>> 13) | 0) + (te >>> 26) | 0, te &= 67108863, h = Math.imul(K4, $4), e = Math.imul(K4, H3), e = e + Math.imul(z, $4) | 0, l = Math.imul(z, H3), h = h + Math.imul(Z5, J3) | 0, e = e + Math.imul(Z5, V3) | 0, e = e + Math.imul(P2, J3) | 0, l = l + Math.imul(P2, V3) | 0, h = h + Math.imul(C, X5) | 0, e = e + Math.imul(C, Y4) | 0, e = e + Math.imul(L4, X5) | 0, l = l + Math.imul(L4, Y4) | 0, h = h + Math.imul(U2, W4) | 0, e = e + Math.imul(U2, Q3) | 0, e = e + Math.imul(I3, W4) | 0, l = l + Math.imul(I3, Q3) | 0, h = h + Math.imul(R3, tt) | 0, e = e + Math.imul(R3, et) | 0, e = e + Math.imul(O, tt) | 0, l = l + Math.imul(O, et) | 0, h = h + Math.imul(N4, rt2) | 0, e = e + Math.imul(N4, it2) | 0, e = e + Math.imul(j2, rt2) | 0, l = l + Math.imul(j2, it2) | 0, h = h + Math.imul(q, nt) | 0, e = e + Math.imul(q, ot4) | 0, e = e + Math.imul(A4, nt) | 0, l = l + Math.imul(A4, ot4) | 0, h = h + Math.imul(E2, st2) | 0, e = e + Math.imul(E2, ft4) | 0, e = e + Math.imul(k6, st2) | 0, l = l + Math.imul(k6, ft4) | 0, h = h + Math.imul(M4, ht4) | 0, e = e + Math.imul(M4, lt3) | 0, e = e + Math.imul(w2, ht4) | 0, l = l + Math.imul(w2, lt3) | 0;
      var ee2 = (v2 + h | 0) + ((e & 8191) << 13) | 0;
      v2 = (l + (e >>> 13) | 0) + (ee2 >>> 26) | 0, ee2 &= 67108863, h = Math.imul(F4, $4), e = Math.imul(F4, H3), e = e + Math.imul(G4, $4) | 0, l = Math.imul(G4, H3), h = h + Math.imul(K4, J3) | 0, e = e + Math.imul(K4, V3) | 0, e = e + Math.imul(z, J3) | 0, l = l + Math.imul(z, V3) | 0, h = h + Math.imul(Z5, X5) | 0, e = e + Math.imul(Z5, Y4) | 0, e = e + Math.imul(P2, X5) | 0, l = l + Math.imul(P2, Y4) | 0, h = h + Math.imul(C, W4) | 0, e = e + Math.imul(C, Q3) | 0, e = e + Math.imul(L4, W4) | 0, l = l + Math.imul(L4, Q3) | 0, h = h + Math.imul(U2, tt) | 0, e = e + Math.imul(U2, et) | 0, e = e + Math.imul(I3, tt) | 0, l = l + Math.imul(I3, et) | 0, h = h + Math.imul(R3, rt2) | 0, e = e + Math.imul(R3, it2) | 0, e = e + Math.imul(O, rt2) | 0, l = l + Math.imul(O, it2) | 0, h = h + Math.imul(N4, nt) | 0, e = e + Math.imul(N4, ot4) | 0, e = e + Math.imul(j2, nt) | 0, l = l + Math.imul(j2, ot4) | 0, h = h + Math.imul(q, st2) | 0, e = e + Math.imul(q, ft4) | 0, e = e + Math.imul(A4, st2) | 0, l = l + Math.imul(A4, ft4) | 0, h = h + Math.imul(E2, ht4) | 0, e = e + Math.imul(E2, lt3) | 0, e = e + Math.imul(k6, ht4) | 0, l = l + Math.imul(k6, lt3) | 0, h = h + Math.imul(M4, at2) | 0, e = e + Math.imul(M4, ut4) | 0, e = e + Math.imul(w2, at2) | 0, l = l + Math.imul(w2, ut4) | 0;
      var re2 = (v2 + h | 0) + ((e & 8191) << 13) | 0;
      v2 = (l + (e >>> 13) | 0) + (re2 >>> 26) | 0, re2 &= 67108863, h = Math.imul(F4, J3), e = Math.imul(F4, V3), e = e + Math.imul(G4, J3) | 0, l = Math.imul(G4, V3), h = h + Math.imul(K4, X5) | 0, e = e + Math.imul(K4, Y4) | 0, e = e + Math.imul(z, X5) | 0, l = l + Math.imul(z, Y4) | 0, h = h + Math.imul(Z5, W4) | 0, e = e + Math.imul(Z5, Q3) | 0, e = e + Math.imul(P2, W4) | 0, l = l + Math.imul(P2, Q3) | 0, h = h + Math.imul(C, tt) | 0, e = e + Math.imul(C, et) | 0, e = e + Math.imul(L4, tt) | 0, l = l + Math.imul(L4, et) | 0, h = h + Math.imul(U2, rt2) | 0, e = e + Math.imul(U2, it2) | 0, e = e + Math.imul(I3, rt2) | 0, l = l + Math.imul(I3, it2) | 0, h = h + Math.imul(R3, nt) | 0, e = e + Math.imul(R3, ot4) | 0, e = e + Math.imul(O, nt) | 0, l = l + Math.imul(O, ot4) | 0, h = h + Math.imul(N4, st2) | 0, e = e + Math.imul(N4, ft4) | 0, e = e + Math.imul(j2, st2) | 0, l = l + Math.imul(j2, ft4) | 0, h = h + Math.imul(q, ht4) | 0, e = e + Math.imul(q, lt3) | 0, e = e + Math.imul(A4, ht4) | 0, l = l + Math.imul(A4, lt3) | 0, h = h + Math.imul(E2, at2) | 0, e = e + Math.imul(E2, ut4) | 0, e = e + Math.imul(k6, at2) | 0, l = l + Math.imul(k6, ut4) | 0;
      var ie = (v2 + h | 0) + ((e & 8191) << 13) | 0;
      v2 = (l + (e >>> 13) | 0) + (ie >>> 26) | 0, ie &= 67108863, h = Math.imul(F4, X5), e = Math.imul(F4, Y4), e = e + Math.imul(G4, X5) | 0, l = Math.imul(G4, Y4), h = h + Math.imul(K4, W4) | 0, e = e + Math.imul(K4, Q3) | 0, e = e + Math.imul(z, W4) | 0, l = l + Math.imul(z, Q3) | 0, h = h + Math.imul(Z5, tt) | 0, e = e + Math.imul(Z5, et) | 0, e = e + Math.imul(P2, tt) | 0, l = l + Math.imul(P2, et) | 0, h = h + Math.imul(C, rt2) | 0, e = e + Math.imul(C, it2) | 0, e = e + Math.imul(L4, rt2) | 0, l = l + Math.imul(L4, it2) | 0, h = h + Math.imul(U2, nt) | 0, e = e + Math.imul(U2, ot4) | 0, e = e + Math.imul(I3, nt) | 0, l = l + Math.imul(I3, ot4) | 0, h = h + Math.imul(R3, st2) | 0, e = e + Math.imul(R3, ft4) | 0, e = e + Math.imul(O, st2) | 0, l = l + Math.imul(O, ft4) | 0, h = h + Math.imul(N4, ht4) | 0, e = e + Math.imul(N4, lt3) | 0, e = e + Math.imul(j2, ht4) | 0, l = l + Math.imul(j2, lt3) | 0, h = h + Math.imul(q, at2) | 0, e = e + Math.imul(q, ut4) | 0, e = e + Math.imul(A4, at2) | 0, l = l + Math.imul(A4, ut4) | 0;
      var ne = (v2 + h | 0) + ((e & 8191) << 13) | 0;
      v2 = (l + (e >>> 13) | 0) + (ne >>> 26) | 0, ne &= 67108863, h = Math.imul(F4, W4), e = Math.imul(F4, Q3), e = e + Math.imul(G4, W4) | 0, l = Math.imul(G4, Q3), h = h + Math.imul(K4, tt) | 0, e = e + Math.imul(K4, et) | 0, e = e + Math.imul(z, tt) | 0, l = l + Math.imul(z, et) | 0, h = h + Math.imul(Z5, rt2) | 0, e = e + Math.imul(Z5, it2) | 0, e = e + Math.imul(P2, rt2) | 0, l = l + Math.imul(P2, it2) | 0, h = h + Math.imul(C, nt) | 0, e = e + Math.imul(C, ot4) | 0, e = e + Math.imul(L4, nt) | 0, l = l + Math.imul(L4, ot4) | 0, h = h + Math.imul(U2, st2) | 0, e = e + Math.imul(U2, ft4) | 0, e = e + Math.imul(I3, st2) | 0, l = l + Math.imul(I3, ft4) | 0, h = h + Math.imul(R3, ht4) | 0, e = e + Math.imul(R3, lt3) | 0, e = e + Math.imul(O, ht4) | 0, l = l + Math.imul(O, lt3) | 0, h = h + Math.imul(N4, at2) | 0, e = e + Math.imul(N4, ut4) | 0, e = e + Math.imul(j2, at2) | 0, l = l + Math.imul(j2, ut4) | 0;
      var oe = (v2 + h | 0) + ((e & 8191) << 13) | 0;
      v2 = (l + (e >>> 13) | 0) + (oe >>> 26) | 0, oe &= 67108863, h = Math.imul(F4, tt), e = Math.imul(F4, et), e = e + Math.imul(G4, tt) | 0, l = Math.imul(G4, et), h = h + Math.imul(K4, rt2) | 0, e = e + Math.imul(K4, it2) | 0, e = e + Math.imul(z, rt2) | 0, l = l + Math.imul(z, it2) | 0, h = h + Math.imul(Z5, nt) | 0, e = e + Math.imul(Z5, ot4) | 0, e = e + Math.imul(P2, nt) | 0, l = l + Math.imul(P2, ot4) | 0, h = h + Math.imul(C, st2) | 0, e = e + Math.imul(C, ft4) | 0, e = e + Math.imul(L4, st2) | 0, l = l + Math.imul(L4, ft4) | 0, h = h + Math.imul(U2, ht4) | 0, e = e + Math.imul(U2, lt3) | 0, e = e + Math.imul(I3, ht4) | 0, l = l + Math.imul(I3, lt3) | 0, h = h + Math.imul(R3, at2) | 0, e = e + Math.imul(R3, ut4) | 0, e = e + Math.imul(O, at2) | 0, l = l + Math.imul(O, ut4) | 0;
      var se = (v2 + h | 0) + ((e & 8191) << 13) | 0;
      v2 = (l + (e >>> 13) | 0) + (se >>> 26) | 0, se &= 67108863, h = Math.imul(F4, rt2), e = Math.imul(F4, it2), e = e + Math.imul(G4, rt2) | 0, l = Math.imul(G4, it2), h = h + Math.imul(K4, nt) | 0, e = e + Math.imul(K4, ot4) | 0, e = e + Math.imul(z, nt) | 0, l = l + Math.imul(z, ot4) | 0, h = h + Math.imul(Z5, st2) | 0, e = e + Math.imul(Z5, ft4) | 0, e = e + Math.imul(P2, st2) | 0, l = l + Math.imul(P2, ft4) | 0, h = h + Math.imul(C, ht4) | 0, e = e + Math.imul(C, lt3) | 0, e = e + Math.imul(L4, ht4) | 0, l = l + Math.imul(L4, lt3) | 0, h = h + Math.imul(U2, at2) | 0, e = e + Math.imul(U2, ut4) | 0, e = e + Math.imul(I3, at2) | 0, l = l + Math.imul(I3, ut4) | 0;
      var fe = (v2 + h | 0) + ((e & 8191) << 13) | 0;
      v2 = (l + (e >>> 13) | 0) + (fe >>> 26) | 0, fe &= 67108863, h = Math.imul(F4, nt), e = Math.imul(F4, ot4), e = e + Math.imul(G4, nt) | 0, l = Math.imul(G4, ot4), h = h + Math.imul(K4, st2) | 0, e = e + Math.imul(K4, ft4) | 0, e = e + Math.imul(z, st2) | 0, l = l + Math.imul(z, ft4) | 0, h = h + Math.imul(Z5, ht4) | 0, e = e + Math.imul(Z5, lt3) | 0, e = e + Math.imul(P2, ht4) | 0, l = l + Math.imul(P2, lt3) | 0, h = h + Math.imul(C, at2) | 0, e = e + Math.imul(C, ut4) | 0, e = e + Math.imul(L4, at2) | 0, l = l + Math.imul(L4, ut4) | 0;
      var he2 = (v2 + h | 0) + ((e & 8191) << 13) | 0;
      v2 = (l + (e >>> 13) | 0) + (he2 >>> 26) | 0, he2 &= 67108863, h = Math.imul(F4, st2), e = Math.imul(F4, ft4), e = e + Math.imul(G4, st2) | 0, l = Math.imul(G4, ft4), h = h + Math.imul(K4, ht4) | 0, e = e + Math.imul(K4, lt3) | 0, e = e + Math.imul(z, ht4) | 0, l = l + Math.imul(z, lt3) | 0, h = h + Math.imul(Z5, at2) | 0, e = e + Math.imul(Z5, ut4) | 0, e = e + Math.imul(P2, at2) | 0, l = l + Math.imul(P2, ut4) | 0;
      var le2 = (v2 + h | 0) + ((e & 8191) << 13) | 0;
      v2 = (l + (e >>> 13) | 0) + (le2 >>> 26) | 0, le2 &= 67108863, h = Math.imul(F4, ht4), e = Math.imul(F4, lt3), e = e + Math.imul(G4, ht4) | 0, l = Math.imul(G4, lt3), h = h + Math.imul(K4, at2) | 0, e = e + Math.imul(K4, ut4) | 0, e = e + Math.imul(z, at2) | 0, l = l + Math.imul(z, ut4) | 0;
      var ae2 = (v2 + h | 0) + ((e & 8191) << 13) | 0;
      v2 = (l + (e >>> 13) | 0) + (ae2 >>> 26) | 0, ae2 &= 67108863, h = Math.imul(F4, at2), e = Math.imul(F4, ut4), e = e + Math.imul(G4, at2) | 0, l = Math.imul(G4, ut4);
      var ue2 = (v2 + h | 0) + ((e & 8191) << 13) | 0;
      return v2 = (l + (e >>> 13) | 0) + (ue2 >>> 26) | 0, ue2 &= 67108863, p3[0] = Ht, p3[1] = Jt, p3[2] = Vt3, p3[3] = Xt, p3[4] = Yt, p3[5] = Wt2, p3[6] = Qt, p3[7] = te, p3[8] = ee2, p3[9] = re2, p3[10] = ie, p3[11] = ne, p3[12] = oe, p3[13] = se, p3[14] = fe, p3[15] = he2, p3[16] = le2, p3[17] = ae2, p3[18] = ue2, v2 !== 0 && (p3[19] = v2, s.length++), s;
    };
    Math.imul || (qe3 = ke);
    function Rr2(c5, t, i) {
      i.negative = t.negative ^ c5.negative, i.length = c5.length + t.length;
      for (var s = 0, f = 0, u = 0; u < i.length - 1; u++) {
        var p3 = f;
        f = 0;
        for (var v2 = s & 67108863, h = Math.min(u, t.length - 1), e = Math.max(0, u - c5.length + 1); e <= h; e++) {
          var l = u - e, y4 = c5.words[l] | 0, M4 = t.words[e] | 0, w2 = y4 * M4, b2 = w2 & 67108863;
          p3 = p3 + (w2 / 67108864 | 0) | 0, b2 = b2 + v2 | 0, v2 = b2 & 67108863, p3 = p3 + (b2 >>> 26) | 0, f += p3 >>> 26, p3 &= 67108863;
        }
        i.words[u] = v2, s = p3, p3 = f;
      }
      return s !== 0 ? i.words[u] = s : i.length--, i.strip();
    }
    function Ae3(c5, t, i) {
      var s = new _t();
      return s.mulp(c5, t, i);
    }
    o2.prototype.mulTo = function(t, i) {
      var s, f = this.length + t.length;
      return this.length === 10 && t.length === 10 ? s = qe3(this, t, i) : f < 63 ? s = ke(this, t, i) : f < 1024 ? s = Rr2(this, t, i) : s = Ae3(this, t, i), s;
    };
    function _t(c5, t) {
      this.x = c5, this.y = t;
    }
    _t.prototype.makeRBT = function(t) {
      for (var i = new Array(t), s = o2.prototype._countBits(t) - 1, f = 0; f < t; f++)
        i[f] = this.revBin(f, s, t);
      return i;
    }, _t.prototype.revBin = function(t, i, s) {
      if (t === 0 || t === s - 1)
        return t;
      for (var f = 0, u = 0; u < i; u++)
        f |= (t & 1) << i - u - 1, t >>= 1;
      return f;
    }, _t.prototype.permute = function(t, i, s, f, u, p3) {
      for (var v2 = 0; v2 < p3; v2++)
        f[v2] = i[t[v2]], u[v2] = s[t[v2]];
    }, _t.prototype.transform = function(t, i, s, f, u, p3) {
      this.permute(p3, t, i, s, f, u);
      for (var v2 = 1; v2 < u; v2 <<= 1)
        for (var h = v2 << 1, e = Math.cos(2 * Math.PI / h), l = Math.sin(2 * Math.PI / h), y4 = 0; y4 < u; y4 += h)
          for (var M4 = e, w2 = l, b2 = 0; b2 < v2; b2++) {
            var E2 = s[y4 + b2], k6 = f[y4 + b2], St = s[y4 + b2 + v2], q = f[y4 + b2 + v2], A4 = M4 * St - w2 * q;
            q = M4 * q + w2 * St, St = A4, s[y4 + b2] = E2 + St, f[y4 + b2] = k6 + q, s[y4 + b2 + v2] = E2 - St, f[y4 + b2 + v2] = k6 - q, b2 !== h && (A4 = e * M4 - l * w2, w2 = e * w2 + l * M4, M4 = A4);
          }
    }, _t.prototype.guessLen13b = function(t, i) {
      var s = Math.max(i, t) | 1, f = s & 1, u = 0;
      for (s = s / 2 | 0; s; s = s >>> 1)
        u++;
      return 1 << u + 1 + f;
    }, _t.prototype.conjugate = function(t, i, s) {
      if (!(s <= 1))
        for (var f = 0; f < s / 2; f++) {
          var u = t[f];
          t[f] = t[s - f - 1], t[s - f - 1] = u, u = i[f], i[f] = -i[s - f - 1], i[s - f - 1] = -u;
        }
    }, _t.prototype.normalize13b = function(t, i) {
      for (var s = 0, f = 0; f < i / 2; f++) {
        var u = Math.round(t[2 * f + 1] / i) * 8192 + Math.round(t[2 * f] / i) + s;
        t[f] = u & 67108863, u < 67108864 ? s = 0 : s = u / 67108864 | 0;
      }
      return t;
    }, _t.prototype.convert13b = function(t, i, s, f) {
      for (var u = 0, p3 = 0; p3 < i; p3++)
        u = u + (t[p3] | 0), s[2 * p3] = u & 8191, u = u >>> 13, s[2 * p3 + 1] = u & 8191, u = u >>> 13;
      for (p3 = 2 * i; p3 < f; ++p3)
        s[p3] = 0;
      n(u === 0), n((u & -8192) === 0);
    }, _t.prototype.stub = function(t) {
      for (var i = new Array(t), s = 0; s < t; s++)
        i[s] = 0;
      return i;
    }, _t.prototype.mulp = function(t, i, s) {
      var f = 2 * this.guessLen13b(t.length, i.length), u = this.makeRBT(f), p3 = this.stub(f), v2 = new Array(f), h = new Array(f), e = new Array(f), l = new Array(f), y4 = new Array(f), M4 = new Array(f), w2 = s.words;
      w2.length = f, this.convert13b(t.words, t.length, v2, f), this.convert13b(i.words, i.length, l, f), this.transform(v2, p3, h, e, f, u), this.transform(l, p3, y4, M4, f, u);
      for (var b2 = 0; b2 < f; b2++) {
        var E2 = h[b2] * y4[b2] - e[b2] * M4[b2];
        e[b2] = h[b2] * M4[b2] + e[b2] * y4[b2], h[b2] = E2;
      }
      return this.conjugate(h, e, f), this.transform(h, e, w2, p3, f, u), this.conjugate(w2, p3, f), this.normalize13b(w2, f), s.negative = t.negative ^ i.negative, s.length = t.length + i.length, s.strip();
    }, o2.prototype.mul = function(t) {
      var i = new o2(null);
      return i.words = new Array(this.length + t.length), this.mulTo(t, i);
    }, o2.prototype.mulf = function(t) {
      var i = new o2(null);
      return i.words = new Array(this.length + t.length), Ae3(this, t, i);
    }, o2.prototype.imul = function(t) {
      return this.clone().mulTo(t, this);
    }, o2.prototype.imuln = function(t) {
      n(typeof t == "number"), n(t < 67108864);
      for (var i = 0, s = 0; s < this.length; s++) {
        var f = (this.words[s] | 0) * t, u = (f & 67108863) + (i & 67108863);
        i >>= 26, i += f / 67108864 | 0, i += u >>> 26, this.words[s] = u & 67108863;
      }
      return i !== 0 && (this.words[s] = i, this.length++), this;
    }, o2.prototype.muln = function(t) {
      return this.clone().imuln(t);
    }, o2.prototype.sqr = function() {
      return this.mul(this);
    }, o2.prototype.isqr = function() {
      return this.imul(this.clone());
    }, o2.prototype.pow = function(t) {
      var i = jr3(t);
      if (i.length === 0)
        return new o2(1);
      for (var s = this, f = 0; f < i.length && i[f] === 0; f++, s = s.sqr())
        ;
      if (++f < i.length)
        for (var u = s.sqr(); f < i.length; f++, u = u.sqr())
          i[f] !== 0 && (s = s.mul(u));
      return s;
    }, o2.prototype.iushln = function(t) {
      n(typeof t == "number" && t >= 0);
      var i = t % 26, s = (t - i) / 26, f = 67108863 >>> 26 - i << 26 - i, u;
      if (i !== 0) {
        var p3 = 0;
        for (u = 0; u < this.length; u++) {
          var v2 = this.words[u] & f, h = (this.words[u] | 0) - v2 << i;
          this.words[u] = h | p3, p3 = v2 >>> 26 - i;
        }
        p3 && (this.words[u] = p3, this.length++);
      }
      if (s !== 0) {
        for (u = this.length - 1; u >= 0; u--)
          this.words[u + s] = this.words[u];
        for (u = 0; u < s; u++)
          this.words[u] = 0;
        this.length += s;
      }
      return this.strip();
    }, o2.prototype.ishln = function(t) {
      return n(this.negative === 0), this.iushln(t);
    }, o2.prototype.iushrn = function(t, i, s) {
      n(typeof t == "number" && t >= 0);
      var f;
      i ? f = (i - i % 26) / 26 : f = 0;
      var u = t % 26, p3 = Math.min((t - u) / 26, this.length), v2 = 67108863 ^ 67108863 >>> u << u, h = s;
      if (f -= p3, f = Math.max(0, f), h) {
        for (var e = 0; e < p3; e++)
          h.words[e] = this.words[e];
        h.length = p3;
      }
      if (p3 !== 0)
        if (this.length > p3)
          for (this.length -= p3, e = 0; e < this.length; e++)
            this.words[e] = this.words[e + p3];
        else
          this.words[0] = 0, this.length = 1;
      var l = 0;
      for (e = this.length - 1; e >= 0 && (l !== 0 || e >= f); e--) {
        var y4 = this.words[e] | 0;
        this.words[e] = l << 26 - u | y4 >>> u, l = y4 & v2;
      }
      return h && l !== 0 && (h.words[h.length++] = l), this.length === 0 && (this.words[0] = 0, this.length = 1), this.strip();
    }, o2.prototype.ishrn = function(t, i, s) {
      return n(this.negative === 0), this.iushrn(t, i, s);
    }, o2.prototype.shln = function(t) {
      return this.clone().ishln(t);
    }, o2.prototype.ushln = function(t) {
      return this.clone().iushln(t);
    }, o2.prototype.shrn = function(t) {
      return this.clone().ishrn(t);
    }, o2.prototype.ushrn = function(t) {
      return this.clone().iushrn(t);
    }, o2.prototype.testn = function(t) {
      n(typeof t == "number" && t >= 0);
      var i = t % 26, s = (t - i) / 26, f = 1 << i;
      if (this.length <= s)
        return false;
      var u = this.words[s];
      return !!(u & f);
    }, o2.prototype.imaskn = function(t) {
      n(typeof t == "number" && t >= 0);
      var i = t % 26, s = (t - i) / 26;
      if (n(this.negative === 0, "imaskn works only with positive numbers"), this.length <= s)
        return this;
      if (i !== 0 && s++, this.length = Math.min(s, this.length), i !== 0) {
        var f = 67108863 ^ 67108863 >>> i << i;
        this.words[this.length - 1] &= f;
      }
      return this.strip();
    }, o2.prototype.maskn = function(t) {
      return this.clone().imaskn(t);
    }, o2.prototype.iaddn = function(t) {
      return n(typeof t == "number"), n(t < 67108864), t < 0 ? this.isubn(-t) : this.negative !== 0 ? this.length === 1 && (this.words[0] | 0) < t ? (this.words[0] = t - (this.words[0] | 0), this.negative = 0, this) : (this.negative = 0, this.isubn(t), this.negative = 1, this) : this._iaddn(t);
    }, o2.prototype._iaddn = function(t) {
      this.words[0] += t;
      for (var i = 0; i < this.length && this.words[i] >= 67108864; i++)
        this.words[i] -= 67108864, i === this.length - 1 ? this.words[i + 1] = 1 : this.words[i + 1]++;
      return this.length = Math.max(this.length, i + 1), this;
    }, o2.prototype.isubn = function(t) {
      if (n(typeof t == "number"), n(t < 67108864), t < 0)
        return this.iaddn(-t);
      if (this.negative !== 0)
        return this.negative = 0, this.iaddn(t), this.negative = 1, this;
      if (this.words[0] -= t, this.length === 1 && this.words[0] < 0)
        this.words[0] = -this.words[0], this.negative = 1;
      else
        for (var i = 0; i < this.length && this.words[i] < 0; i++)
          this.words[i] += 67108864, this.words[i + 1] -= 1;
      return this.strip();
    }, o2.prototype.addn = function(t) {
      return this.clone().iaddn(t);
    }, o2.prototype.subn = function(t) {
      return this.clone().isubn(t);
    }, o2.prototype.iabs = function() {
      return this.negative = 0, this;
    }, o2.prototype.abs = function() {
      return this.clone().iabs();
    }, o2.prototype._ishlnsubmul = function(t, i, s) {
      var f = t.length + s, u;
      this._expand(f);
      var p3, v2 = 0;
      for (u = 0; u < t.length; u++) {
        p3 = (this.words[u + s] | 0) + v2;
        var h = (t.words[u] | 0) * i;
        p3 -= h & 67108863, v2 = (p3 >> 26) - (h / 67108864 | 0), this.words[u + s] = p3 & 67108863;
      }
      for (; u < this.length - s; u++)
        p3 = (this.words[u + s] | 0) + v2, v2 = p3 >> 26, this.words[u + s] = p3 & 67108863;
      if (v2 === 0)
        return this.strip();
      for (n(v2 === -1), v2 = 0, u = 0; u < this.length; u++)
        p3 = -(this.words[u] | 0) + v2, v2 = p3 >> 26, this.words[u] = p3 & 67108863;
      return this.negative = 1, this.strip();
    }, o2.prototype._wordDiv = function(t, i) {
      var s = this.length - t.length, f = this.clone(), u = t, p3 = u.words[u.length - 1] | 0, v2 = this._countBits(p3);
      s = 26 - v2, s !== 0 && (u = u.ushln(s), f.iushln(s), p3 = u.words[u.length - 1] | 0);
      var h = f.length - u.length, e;
      if (i !== "mod") {
        e = new o2(null), e.length = h + 1, e.words = new Array(e.length);
        for (var l = 0; l < e.length; l++)
          e.words[l] = 0;
      }
      var y4 = f.clone()._ishlnsubmul(u, 1, h);
      y4.negative === 0 && (f = y4, e && (e.words[h] = 1));
      for (var M4 = h - 1; M4 >= 0; M4--) {
        var w2 = (f.words[u.length + M4] | 0) * 67108864 + (f.words[u.length + M4 - 1] | 0);
        for (w2 = Math.min(w2 / p3 | 0, 67108863), f._ishlnsubmul(u, w2, M4); f.negative !== 0; )
          w2--, f.negative = 0, f._ishlnsubmul(u, 1, M4), f.isZero() || (f.negative ^= 1);
        e && (e.words[M4] = w2);
      }
      return e && e.strip(), f.strip(), i !== "div" && s !== 0 && f.iushrn(s), { div: e || null, mod: f };
    }, o2.prototype.divmod = function(t, i, s) {
      if (n(!t.isZero()), this.isZero())
        return { div: new o2(0), mod: new o2(0) };
      var f, u, p3;
      return this.negative !== 0 && t.negative === 0 ? (p3 = this.neg().divmod(t, i), i !== "mod" && (f = p3.div.neg()), i !== "div" && (u = p3.mod.neg(), s && u.negative !== 0 && u.iadd(t)), { div: f, mod: u }) : this.negative === 0 && t.negative !== 0 ? (p3 = this.divmod(t.neg(), i), i !== "mod" && (f = p3.div.neg()), { div: f, mod: p3.mod }) : (this.negative & t.negative) !== 0 ? (p3 = this.neg().divmod(t.neg(), i), i !== "div" && (u = p3.mod.neg(), s && u.negative !== 0 && u.isub(t)), { div: p3.div, mod: u }) : t.length > this.length || this.cmp(t) < 0 ? { div: new o2(0), mod: this } : t.length === 1 ? i === "div" ? { div: this.divn(t.words[0]), mod: null } : i === "mod" ? { div: null, mod: new o2(this.modn(t.words[0])) } : { div: this.divn(t.words[0]), mod: new o2(this.modn(t.words[0])) } : this._wordDiv(t, i);
    }, o2.prototype.div = function(t) {
      return this.divmod(t, "div", false).div;
    }, o2.prototype.mod = function(t) {
      return this.divmod(t, "mod", false).mod;
    }, o2.prototype.umod = function(t) {
      return this.divmod(t, "mod", true).mod;
    }, o2.prototype.divRound = function(t) {
      var i = this.divmod(t);
      if (i.mod.isZero())
        return i.div;
      var s = i.div.negative !== 0 ? i.mod.isub(t) : i.mod, f = t.ushrn(1), u = t.andln(1), p3 = s.cmp(f);
      return p3 < 0 || u === 1 && p3 === 0 ? i.div : i.div.negative !== 0 ? i.div.isubn(1) : i.div.iaddn(1);
    }, o2.prototype.modn = function(t) {
      n(t <= 67108863);
      for (var i = (1 << 26) % t, s = 0, f = this.length - 1; f >= 0; f--)
        s = (i * s + (this.words[f] | 0)) % t;
      return s;
    }, o2.prototype.idivn = function(t) {
      n(t <= 67108863);
      for (var i = 0, s = this.length - 1; s >= 0; s--) {
        var f = (this.words[s] | 0) + i * 67108864;
        this.words[s] = f / t | 0, i = f % t;
      }
      return this.strip();
    }, o2.prototype.divn = function(t) {
      return this.clone().idivn(t);
    }, o2.prototype.egcd = function(t) {
      n(t.negative === 0), n(!t.isZero());
      var i = this, s = t.clone();
      i.negative !== 0 ? i = i.umod(t) : i = i.clone();
      for (var f = new o2(1), u = new o2(0), p3 = new o2(0), v2 = new o2(1), h = 0; i.isEven() && s.isEven(); )
        i.iushrn(1), s.iushrn(1), ++h;
      for (var e = s.clone(), l = i.clone(); !i.isZero(); ) {
        for (var y4 = 0, M4 = 1; (i.words[0] & M4) === 0 && y4 < 26; ++y4, M4 <<= 1)
          ;
        if (y4 > 0)
          for (i.iushrn(y4); y4-- > 0; )
            (f.isOdd() || u.isOdd()) && (f.iadd(e), u.isub(l)), f.iushrn(1), u.iushrn(1);
        for (var w2 = 0, b2 = 1; (s.words[0] & b2) === 0 && w2 < 26; ++w2, b2 <<= 1)
          ;
        if (w2 > 0)
          for (s.iushrn(w2); w2-- > 0; )
            (p3.isOdd() || v2.isOdd()) && (p3.iadd(e), v2.isub(l)), p3.iushrn(1), v2.iushrn(1);
        i.cmp(s) >= 0 ? (i.isub(s), f.isub(p3), u.isub(v2)) : (s.isub(i), p3.isub(f), v2.isub(u));
      }
      return { a: p3, b: v2, gcd: s.iushln(h) };
    }, o2.prototype._invmp = function(t) {
      n(t.negative === 0), n(!t.isZero());
      var i = this, s = t.clone();
      i.negative !== 0 ? i = i.umod(t) : i = i.clone();
      for (var f = new o2(1), u = new o2(0), p3 = s.clone(); i.cmpn(1) > 0 && s.cmpn(1) > 0; ) {
        for (var v2 = 0, h = 1; (i.words[0] & h) === 0 && v2 < 26; ++v2, h <<= 1)
          ;
        if (v2 > 0)
          for (i.iushrn(v2); v2-- > 0; )
            f.isOdd() && f.iadd(p3), f.iushrn(1);
        for (var e = 0, l = 1; (s.words[0] & l) === 0 && e < 26; ++e, l <<= 1)
          ;
        if (e > 0)
          for (s.iushrn(e); e-- > 0; )
            u.isOdd() && u.iadd(p3), u.iushrn(1);
        i.cmp(s) >= 0 ? (i.isub(s), f.isub(u)) : (s.isub(i), u.isub(f));
      }
      var y4;
      return i.cmpn(1) === 0 ? y4 = f : y4 = u, y4.cmpn(0) < 0 && y4.iadd(t), y4;
    }, o2.prototype.gcd = function(t) {
      if (this.isZero())
        return t.abs();
      if (t.isZero())
        return this.abs();
      var i = this.clone(), s = t.clone();
      i.negative = 0, s.negative = 0;
      for (var f = 0; i.isEven() && s.isEven(); f++)
        i.iushrn(1), s.iushrn(1);
      do {
        for (; i.isEven(); )
          i.iushrn(1);
        for (; s.isEven(); )
          s.iushrn(1);
        var u = i.cmp(s);
        if (u < 0) {
          var p3 = i;
          i = s, s = p3;
        } else if (u === 0 || s.cmpn(1) === 0)
          break;
        i.isub(s);
      } while (true);
      return s.iushln(f);
    }, o2.prototype.invm = function(t) {
      return this.egcd(t).a.umod(t);
    }, o2.prototype.isEven = function() {
      return (this.words[0] & 1) === 0;
    }, o2.prototype.isOdd = function() {
      return (this.words[0] & 1) === 1;
    }, o2.prototype.andln = function(t) {
      return this.words[0] & t;
    }, o2.prototype.bincn = function(t) {
      n(typeof t == "number");
      var i = t % 26, s = (t - i) / 26, f = 1 << i;
      if (this.length <= s)
        return this._expand(s + 1), this.words[s] |= f, this;
      for (var u = f, p3 = s; u !== 0 && p3 < this.length; p3++) {
        var v2 = this.words[p3] | 0;
        v2 += u, u = v2 >>> 26, v2 &= 67108863, this.words[p3] = v2;
      }
      return u !== 0 && (this.words[p3] = u, this.length++), this;
    }, o2.prototype.isZero = function() {
      return this.length === 1 && this.words[0] === 0;
    }, o2.prototype.cmpn = function(t) {
      var i = t < 0;
      if (this.negative !== 0 && !i)
        return -1;
      if (this.negative === 0 && i)
        return 1;
      this.strip();
      var s;
      if (this.length > 1)
        s = 1;
      else {
        i && (t = -t), n(t <= 67108863, "Number is too big");
        var f = this.words[0] | 0;
        s = f === t ? 0 : f < t ? -1 : 1;
      }
      return this.negative !== 0 ? -s | 0 : s;
    }, o2.prototype.cmp = function(t) {
      if (this.negative !== 0 && t.negative === 0)
        return -1;
      if (this.negative === 0 && t.negative !== 0)
        return 1;
      var i = this.ucmp(t);
      return this.negative !== 0 ? -i | 0 : i;
    }, o2.prototype.ucmp = function(t) {
      if (this.length > t.length)
        return 1;
      if (this.length < t.length)
        return -1;
      for (var i = 0, s = this.length - 1; s >= 0; s--) {
        var f = this.words[s] | 0, u = t.words[s] | 0;
        if (f !== u) {
          f < u ? i = -1 : f > u && (i = 1);
          break;
        }
      }
      return i;
    }, o2.prototype.gtn = function(t) {
      return this.cmpn(t) === 1;
    }, o2.prototype.gt = function(t) {
      return this.cmp(t) === 1;
    }, o2.prototype.gten = function(t) {
      return this.cmpn(t) >= 0;
    }, o2.prototype.gte = function(t) {
      return this.cmp(t) >= 0;
    }, o2.prototype.ltn = function(t) {
      return this.cmpn(t) === -1;
    }, o2.prototype.lt = function(t) {
      return this.cmp(t) === -1;
    }, o2.prototype.lten = function(t) {
      return this.cmpn(t) <= 0;
    }, o2.prototype.lte = function(t) {
      return this.cmp(t) <= 0;
    }, o2.prototype.eqn = function(t) {
      return this.cmpn(t) === 0;
    }, o2.prototype.eq = function(t) {
      return this.cmp(t) === 0;
    }, o2.red = function(t) {
      return new D6(t);
    }, o2.prototype.toRed = function(t) {
      return n(!this.red, "Already a number in reduction context"), n(this.negative === 0, "red works only with positives"), t.convertTo(this)._forceRed(t);
    }, o2.prototype.fromRed = function() {
      return n(this.red, "fromRed works only with numbers in reduction context"), this.red.convertFrom(this);
    }, o2.prototype._forceRed = function(t) {
      return this.red = t, this;
    }, o2.prototype.forceRed = function(t) {
      return n(!this.red, "Already a number in reduction context"), this._forceRed(t);
    }, o2.prototype.redAdd = function(t) {
      return n(this.red, "redAdd works only with red numbers"), this.red.add(this, t);
    }, o2.prototype.redIAdd = function(t) {
      return n(this.red, "redIAdd works only with red numbers"), this.red.iadd(this, t);
    }, o2.prototype.redSub = function(t) {
      return n(this.red, "redSub works only with red numbers"), this.red.sub(this, t);
    }, o2.prototype.redISub = function(t) {
      return n(this.red, "redISub works only with red numbers"), this.red.isub(this, t);
    }, o2.prototype.redShl = function(t) {
      return n(this.red, "redShl works only with red numbers"), this.red.shl(this, t);
    }, o2.prototype.redMul = function(t) {
      return n(this.red, "redMul works only with red numbers"), this.red._verify2(this, t), this.red.mul(this, t);
    }, o2.prototype.redIMul = function(t) {
      return n(this.red, "redMul works only with red numbers"), this.red._verify2(this, t), this.red.imul(this, t);
    }, o2.prototype.redSqr = function() {
      return n(this.red, "redSqr works only with red numbers"), this.red._verify1(this), this.red.sqr(this);
    }, o2.prototype.redISqr = function() {
      return n(this.red, "redISqr works only with red numbers"), this.red._verify1(this), this.red.isqr(this);
    }, o2.prototype.redSqrt = function() {
      return n(this.red, "redSqrt works only with red numbers"), this.red._verify1(this), this.red.sqrt(this);
    }, o2.prototype.redInvm = function() {
      return n(this.red, "redInvm works only with red numbers"), this.red._verify1(this), this.red.invm(this);
    }, o2.prototype.redNeg = function() {
      return n(this.red, "redNeg works only with red numbers"), this.red._verify1(this), this.red.neg(this);
    }, o2.prototype.redPow = function(t) {
      return n(this.red && !t.red, "redPow(normalNum)"), this.red._verify1(this), this.red.pow(this, t);
    };
    var Gt = { k256: null, p224: null, p192: null, p25519: null };
    function vt(c5, t) {
      this.name = c5, this.p = new o2(t, 16), this.n = this.p.bitLength(), this.k = new o2(1).iushln(this.n).isub(this.p), this.tmp = this._tmp();
    }
    vt.prototype._tmp = function() {
      var t = new o2(null);
      return t.words = new Array(Math.ceil(this.n / 13)), t;
    }, vt.prototype.ireduce = function(t) {
      var i = t, s;
      do
        this.split(i, this.tmp), i = this.imulK(i), i = i.iadd(this.tmp), s = i.bitLength();
      while (s > this.n);
      var f = s < this.n ? -1 : i.ucmp(this.p);
      return f === 0 ? (i.words[0] = 0, i.length = 1) : f > 0 ? i.isub(this.p) : i.strip !== void 0 ? i.strip() : i._strip(), i;
    }, vt.prototype.split = function(t, i) {
      t.iushrn(this.n, 0, i);
    }, vt.prototype.imulK = function(t) {
      return t.imul(this.k);
    };
    function It2() {
      vt.call(this, "k256", "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f");
    }
    a(It2, vt), It2.prototype.split = function(t, i) {
      for (var s = 4194303, f = Math.min(t.length, 9), u = 0; u < f; u++)
        i.words[u] = t.words[u];
      if (i.length = f, t.length <= 9) {
        t.words[0] = 0, t.length = 1;
        return;
      }
      var p3 = t.words[9];
      for (i.words[i.length++] = p3 & s, u = 10; u < t.length; u++) {
        var v2 = t.words[u] | 0;
        t.words[u - 10] = (v2 & s) << 4 | p3 >>> 22, p3 = v2;
      }
      p3 >>>= 22, t.words[u - 10] = p3, p3 === 0 && t.length > 10 ? t.length -= 10 : t.length -= 9;
    }, It2.prototype.imulK = function(t) {
      t.words[t.length] = 0, t.words[t.length + 1] = 0, t.length += 2;
      for (var i = 0, s = 0; s < t.length; s++) {
        var f = t.words[s] | 0;
        i += f * 977, t.words[s] = i & 67108863, i = f * 64 + (i / 67108864 | 0);
      }
      return t.words[t.length - 1] === 0 && (t.length--, t.words[t.length - 1] === 0 && t.length--), t;
    };
    function Te() {
      vt.call(this, "p224", "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001");
    }
    a(Te, vt);
    function De4() {
      vt.call(this, "p192", "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff");
    }
    a(De4, vt);
    function $t() {
      vt.call(this, "25519", "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed");
    }
    a($t, vt), $t.prototype.imulK = function(t) {
      for (var i = 0, s = 0; s < t.length; s++) {
        var f = (t.words[s] | 0) * 19 + i, u = f & 67108863;
        f >>>= 26, t.words[s] = u, i = f;
      }
      return i !== 0 && (t.words[t.length++] = i), t;
    }, o2._prime = function(t) {
      if (Gt[t])
        return Gt[t];
      var i;
      if (t === "k256")
        i = new It2();
      else if (t === "p224")
        i = new Te();
      else if (t === "p192")
        i = new De4();
      else if (t === "p25519")
        i = new $t();
      else
        throw new Error("Unknown prime " + t);
      return Gt[t] = i, i;
    };
    function D6(c5) {
      if (typeof c5 == "string") {
        var t = o2._prime(c5);
        this.m = t.p, this.prime = t;
      } else
        n(c5.gtn(1), "modulus must be greater than 1"), this.m = c5, this.prime = null;
    }
    D6.prototype._verify1 = function(t) {
      n(t.negative === 0, "red works only with positives"), n(t.red, "red works only with red numbers");
    }, D6.prototype._verify2 = function(t, i) {
      n((t.negative | i.negative) === 0, "red works only with positives"), n(t.red && t.red === i.red, "red works only with red numbers");
    }, D6.prototype.imod = function(t) {
      return this.prime ? this.prime.ireduce(t)._forceRed(this) : t.umod(this.m)._forceRed(this);
    }, D6.prototype.neg = function(t) {
      return t.isZero() ? t.clone() : this.m.sub(t)._forceRed(this);
    }, D6.prototype.add = function(t, i) {
      this._verify2(t, i);
      var s = t.add(i);
      return s.cmp(this.m) >= 0 && s.isub(this.m), s._forceRed(this);
    }, D6.prototype.iadd = function(t, i) {
      this._verify2(t, i);
      var s = t.iadd(i);
      return s.cmp(this.m) >= 0 && s.isub(this.m), s;
    }, D6.prototype.sub = function(t, i) {
      this._verify2(t, i);
      var s = t.sub(i);
      return s.cmpn(0) < 0 && s.iadd(this.m), s._forceRed(this);
    }, D6.prototype.isub = function(t, i) {
      this._verify2(t, i);
      var s = t.isub(i);
      return s.cmpn(0) < 0 && s.iadd(this.m), s;
    }, D6.prototype.shl = function(t, i) {
      return this._verify1(t), this.imod(t.ushln(i));
    }, D6.prototype.imul = function(t, i) {
      return this._verify2(t, i), this.imod(t.imul(i));
    }, D6.prototype.mul = function(t, i) {
      return this._verify2(t, i), this.imod(t.mul(i));
    }, D6.prototype.isqr = function(t) {
      return this.imul(t, t.clone());
    }, D6.prototype.sqr = function(t) {
      return this.mul(t, t);
    }, D6.prototype.sqrt = function(t) {
      if (t.isZero())
        return t.clone();
      var i = this.m.andln(3);
      if (n(i % 2 === 1), i === 3) {
        var s = this.m.add(new o2(1)).iushrn(2);
        return this.pow(t, s);
      }
      for (var f = this.m.subn(1), u = 0; !f.isZero() && f.andln(1) === 0; )
        u++, f.iushrn(1);
      n(!f.isZero());
      var p3 = new o2(1).toRed(this), v2 = p3.redNeg(), h = this.m.subn(1).iushrn(1), e = this.m.bitLength();
      for (e = new o2(2 * e * e).toRed(this); this.pow(e, h).cmp(v2) !== 0; )
        e.redIAdd(v2);
      for (var l = this.pow(e, f), y4 = this.pow(t, f.addn(1).iushrn(1)), M4 = this.pow(t, f), w2 = u; M4.cmp(p3) !== 0; ) {
        for (var b2 = M4, E2 = 0; b2.cmp(p3) !== 0; E2++)
          b2 = b2.redSqr();
        n(E2 < w2);
        var k6 = this.pow(l, new o2(1).iushln(w2 - E2 - 1));
        y4 = y4.redMul(k6), l = k6.redSqr(), M4 = M4.redMul(l), w2 = E2;
      }
      return y4;
    }, D6.prototype.invm = function(t) {
      var i = t._invmp(this.m);
      return i.negative !== 0 ? (i.negative = 0, this.imod(i).redNeg()) : this.imod(i);
    }, D6.prototype.pow = function(t, i) {
      if (i.isZero())
        return new o2(1).toRed(this);
      if (i.cmpn(1) === 0)
        return t.clone();
      var s = 4, f = new Array(1 << s);
      f[0] = new o2(1).toRed(this), f[1] = t;
      for (var u = 2; u < f.length; u++)
        f[u] = this.mul(f[u - 1], t);
      var p3 = f[0], v2 = 0, h = 0, e = i.bitLength() % 26;
      for (e === 0 && (e = 26), u = i.length - 1; u >= 0; u--) {
        for (var l = i.words[u], y4 = e - 1; y4 >= 0; y4--) {
          var M4 = l >> y4 & 1;
          if (p3 !== f[0] && (p3 = this.sqr(p3)), M4 === 0 && v2 === 0) {
            h = 0;
            continue;
          }
          v2 <<= 1, v2 |= M4, h++, !(h !== s && (u !== 0 || y4 !== 0)) && (p3 = this.mul(p3, f[v2]), h = 0, v2 = 0);
        }
        e = 26;
      }
      return p3;
    }, D6.prototype.convertTo = function(t) {
      var i = t.umod(this.m);
      return i === t ? i.clone() : i;
    }, D6.prototype.convertFrom = function(t) {
      var i = t.clone();
      return i.red = null, i;
    }, o2.mont = function(t) {
      return new Bt(t);
    };
    function Bt(c5) {
      D6.call(this, c5), this.shift = this.m.bitLength(), this.shift % 26 !== 0 && (this.shift += 26 - this.shift % 26), this.r = new o2(1).iushln(this.shift), this.r2 = this.imod(this.r.sqr()), this.rinv = this.r._invmp(this.m), this.minv = this.rinv.mul(this.r).isubn(1).div(this.m), this.minv = this.minv.umod(this.r), this.minv = this.r.sub(this.minv);
    }
    a(Bt, D6), Bt.prototype.convertTo = function(t) {
      return this.imod(t.ushln(this.shift));
    }, Bt.prototype.convertFrom = function(t) {
      var i = this.imod(t.mul(this.rinv));
      return i.red = null, i;
    }, Bt.prototype.imul = function(t, i) {
      if (t.isZero() || i.isZero())
        return t.words[0] = 0, t.length = 1, t;
      var s = t.imul(i), f = s.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), u = s.isub(f).iushrn(this.shift), p3 = u;
      return u.cmp(this.m) >= 0 ? p3 = u.isub(this.m) : u.cmpn(0) < 0 && (p3 = u.iadd(this.m)), p3._forceRed(this);
    }, Bt.prototype.mul = function(t, i) {
      if (t.isZero() || i.isZero())
        return new o2(0)._forceRed(this);
      var s = t.mul(i), f = s.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), u = s.isub(f).iushrn(this.shift), p3 = u;
      return u.cmp(this.m) >= 0 ? p3 = u.isub(this.m) : u.cmpn(0) < 0 && (p3 = u.iadd(this.m)), p3._forceRed(this);
    }, Bt.prototype.invm = function(t) {
      var i = this.imod(t._invmp(this.m).mul(this.r2));
      return i._forceRed(this);
    };
  })(typeof ce2 > "u" || ce2, We);
});
var Et = ct3((ai3, pe) => {
  typeof Object.create == "function" ? pe.exports = function(r, n) {
    n && (r.super_ = n, r.prototype = Object.create(n.prototype, { constructor: { value: r, enumerable: false, writable: true, configurable: true } }));
  } : pe.exports = function(r, n) {
    if (n) {
      r.super_ = n;
      var a = function() {
      };
      a.prototype = n.prototype, r.prototype = new a(), r.prototype.constructor = r;
    }
  };
});
var Lt = ct3((ui, Qe2) => {
  "use strict";
  var Ct2 = export_default, At2 = Ct2.Buffer, mt = {}, gt2;
  for (gt2 in Ct2)
    !Ct2.hasOwnProperty(gt2) || gt2 === "SlowBuffer" || gt2 === "Buffer" || (mt[gt2] = Ct2[gt2]);
  var Tt2 = mt.Buffer = {};
  for (gt2 in At2)
    !At2.hasOwnProperty(gt2) || gt2 === "allocUnsafe" || gt2 === "allocUnsafeSlow" || (Tt2[gt2] = At2[gt2]);
  mt.Buffer.prototype = At2.prototype;
  (!Tt2.from || Tt2.from === Uint8Array.from) && (Tt2.from = function(d4, r, n) {
    if (typeof d4 == "number")
      throw new TypeError('The "value" argument must not be of type number. Received type ' + typeof d4);
    if (d4 && typeof d4.length > "u")
      throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof d4);
    return At2(d4, r, n);
  });
  Tt2.alloc || (Tt2.alloc = function(d4, r, n) {
    if (typeof d4 != "number")
      throw new TypeError('The "size" argument must be of type number. Received type ' + typeof d4);
    if (d4 < 0 || d4 >= 2 * (1 << 30))
      throw new RangeError('The value "' + d4 + '" is invalid for option "size"');
    var a = At2(d4);
    return !r || r.length === 0 ? a.fill(0) : typeof n == "string" ? a.fill(r, n) : a.fill(r), a;
  });
  if (!mt.kStringMaxLength)
    try {
      mt.kStringMaxLength = node_process_default.binding("buffer").kStringMaxLength;
    } catch {
    }
  mt.constants || (mt.constants = { MAX_LENGTH: mt.kMaxLength }, mt.kStringMaxLength && (mt.constants.MAX_STRING_LENGTH = mt.kStringMaxLength));
  Qe2.exports = mt;
});
var Zt = ct3((tr) => {
  "use strict";
  var Pr2 = Et();
  function yt2(d4) {
    this._reporterState = { obj: null, path: [], options: d4 || {}, errors: [] };
  }
  tr.Reporter = yt2;
  yt2.prototype.isError = function(r) {
    return r instanceof Dt;
  };
  yt2.prototype.save = function() {
    let r = this._reporterState;
    return { obj: r.obj, pathLen: r.path.length };
  };
  yt2.prototype.restore = function(r) {
    let n = this._reporterState;
    n.obj = r.obj, n.path = n.path.slice(0, r.pathLen);
  };
  yt2.prototype.enterKey = function(r) {
    return this._reporterState.path.push(r);
  };
  yt2.prototype.exitKey = function(r) {
    let n = this._reporterState;
    n.path = n.path.slice(0, r - 1);
  };
  yt2.prototype.leaveKey = function(r, n, a) {
    let o2 = this._reporterState;
    this.exitKey(r), o2.obj !== null && (o2.obj[n] = a);
  };
  yt2.prototype.path = function() {
    return this._reporterState.path.join("/");
  };
  yt2.prototype.enterObject = function() {
    let r = this._reporterState, n = r.obj;
    return r.obj = {}, n;
  };
  yt2.prototype.leaveObject = function(r) {
    let n = this._reporterState, a = n.obj;
    return n.obj = r, a;
  };
  yt2.prototype.error = function(r) {
    let n, a = this._reporterState, o2 = r instanceof Dt;
    if (o2 ? n = r : n = new Dt(a.path.map(function(m3) {
      return "[" + JSON.stringify(m3) + "]";
    }).join(""), r.message || r, r.stack), !a.options.partial)
      throw n;
    return o2 || a.errors.push(n), n;
  };
  yt2.prototype.wrapResult = function(r) {
    let n = this._reporterState;
    return n.options.partial ? { result: this.isError(r) ? null : r, errors: n.errors } : r;
  };
  function Dt(d4, r) {
    this.path = d4, this.rethrow(r);
  }
  Pr2(Dt, Error);
  Dt.prototype.rethrow = function(r) {
    if (this.message = r + " at: " + (this.path || "(shallow)"), Error.captureStackTrace && Error.captureStackTrace(this, Dt), !this.stack)
      try {
        throw new Error(this.message);
      } catch (n) {
        this.stack = n.stack;
      }
    return this;
  };
});
var Rt = ct3((ve2) => {
  "use strict";
  var Kr = Et(), Pt2 = Zt().Reporter, Nt2 = Lt().Buffer;
  function Mt(d4, r) {
    if (Pt2.call(this, r), !Nt2.isBuffer(d4)) {
      this.error("Input not Buffer");
      return;
    }
    this.base = d4, this.offset = 0, this.length = d4.length;
  }
  Kr(Mt, Pt2);
  ve2.DecoderBuffer = Mt;
  Mt.isDecoderBuffer = function(r) {
    return r instanceof Mt ? true : typeof r == "object" && Nt2.isBuffer(r.base) && r.constructor.name === "DecoderBuffer" && typeof r.offset == "number" && typeof r.length == "number" && typeof r.save == "function" && typeof r.restore == "function" && typeof r.isEmpty == "function" && typeof r.readUInt8 == "function" && typeof r.skip == "function" && typeof r.raw == "function";
  };
  Mt.prototype.save = function() {
    return { offset: this.offset, reporter: Pt2.prototype.save.call(this) };
  };
  Mt.prototype.restore = function(r) {
    let n = new Mt(this.base);
    return n.offset = r.offset, n.length = this.offset, this.offset = r.offset, Pt2.prototype.restore.call(this, r.reporter), n;
  };
  Mt.prototype.isEmpty = function() {
    return this.offset === this.length;
  };
  Mt.prototype.readUInt8 = function(r) {
    return this.offset + 1 <= this.length ? this.base.readUInt8(this.offset++, true) : this.error(r || "DecoderBuffer overrun");
  };
  Mt.prototype.skip = function(r, n) {
    if (!(this.offset + r <= this.length))
      return this.error(n || "DecoderBuffer overrun");
    let a = new Mt(this.base);
    return a._reporterState = this._reporterState, a.offset = this.offset, a.length = this.offset + r, this.offset += r, a;
  };
  Mt.prototype.raw = function(r) {
    return this.base.slice(r ? r.offset : this.offset, this.length);
  };
  function jt2(d4, r) {
    if (Array.isArray(d4))
      this.length = 0, this.value = d4.map(function(n) {
        return jt2.isEncoderBuffer(n) || (n = new jt2(n, r)), this.length += n.length, n;
      }, this);
    else if (typeof d4 == "number") {
      if (!(0 <= d4 && d4 <= 255))
        return r.error("non-byte EncoderBuffer value");
      this.value = d4, this.length = 1;
    } else if (typeof d4 == "string")
      this.value = d4, this.length = Nt2.byteLength(d4);
    else if (Nt2.isBuffer(d4))
      this.value = d4, this.length = d4.length;
    else
      return r.error("Unsupported type: " + typeof d4);
  }
  ve2.EncoderBuffer = jt2;
  jt2.isEncoderBuffer = function(r) {
    return r instanceof jt2 ? true : typeof r == "object" && r.constructor.name === "EncoderBuffer" && typeof r.length == "number" && typeof r.join == "function";
  };
  jt2.prototype.join = function(r, n) {
    return r || (r = Nt2.alloc(this.length)), n || (n = 0), this.length === 0 || (Array.isArray(this.value) ? this.value.forEach(function(a) {
      a.join(r, n), n += a.length;
    }) : (typeof this.value == "number" ? r[n] = this.value : typeof this.value == "string" ? r.write(this.value, n) : Nt2.isBuffer(this.value) && this.value.copy(r, n), n += this.length)), r;
  };
});
var ir = ct3((pi, rr) => {
  rr.exports = er;
  function er(d4, r) {
    if (!d4)
      throw new Error(r || "Assertion failed");
  }
  er.equal = function(r, n, a) {
    if (r != n)
      throw new Error(a || "Assertion failed: " + r + " != " + n);
  };
});
var Kt = ct3((vi, or2) => {
  "use strict";
  var zr = Zt().Reporter, Fr3 = Rt().EncoderBuffer, Gr2 = Rt().DecoderBuffer, dt = ir(), nr = ["seq", "seqof", "set", "setof", "objid", "bool", "gentime", "utctime", "null_", "enum", "int", "objDesc", "bitstr", "bmpstr", "charstr", "genstr", "graphstr", "ia5str", "iso646str", "numstr", "octstr", "printstr", "t61str", "unistr", "utf8str", "videostr"], $r3 = ["key", "obj", "use", "optional", "explicit", "implicit", "def", "choice", "any", "contains"].concat(nr), Hr = ["_peekTag", "_decodeTag", "_use", "_decodeStr", "_decodeObjid", "_decodeTime", "_decodeNull", "_decodeInt", "_decodeBool", "_decodeList", "_encodeComposite", "_encodeStr", "_encodeObjid", "_encodeTime", "_encodeNull", "_encodeInt", "_encodeBool"];
  function B3(d4, r, n) {
    let a = {};
    this._baseState = a, a.name = n, a.enc = d4, a.parent = r || null, a.children = null, a.tag = null, a.args = null, a.reverseArgs = null, a.choice = null, a.optional = false, a.any = false, a.obj = false, a.use = null, a.useDecoder = null, a.key = null, a.default = null, a.explicit = null, a.implicit = null, a.contains = null, a.parent || (a.children = [], this._wrap());
  }
  or2.exports = B3;
  var Jr = ["enc", "parent", "children", "tag", "args", "reverseArgs", "choice", "optional", "any", "obj", "use", "alteredUse", "key", "default", "explicit", "implicit", "contains"];
  B3.prototype.clone = function() {
    let r = this._baseState, n = {};
    Jr.forEach(function(o2) {
      n[o2] = r[o2];
    });
    let a = new this.constructor(n.parent);
    return a._baseState = n, a;
  };
  B3.prototype._wrap = function() {
    let r = this._baseState;
    $r3.forEach(function(n) {
      this[n] = function() {
        let o2 = new this.constructor(this);
        return r.children.push(o2), o2[n].apply(o2, arguments);
      };
    }, this);
  };
  B3.prototype._init = function(r) {
    let n = this._baseState;
    dt(n.parent === null), r.call(this), n.children = n.children.filter(function(a) {
      return a._baseState.parent === this;
    }, this), dt.equal(n.children.length, 1, "Root node can have only one child");
  };
  B3.prototype._useArgs = function(r) {
    let n = this._baseState, a = r.filter(function(o2) {
      return o2 instanceof this.constructor;
    }, this);
    r = r.filter(function(o2) {
      return !(o2 instanceof this.constructor);
    }, this), a.length !== 0 && (dt(n.children === null), n.children = a, a.forEach(function(o2) {
      o2._baseState.parent = this;
    }, this)), r.length !== 0 && (dt(n.args === null), n.args = r, n.reverseArgs = r.map(function(o2) {
      if (typeof o2 != "object" || o2.constructor !== Object)
        return o2;
      let m3 = {};
      return Object.keys(o2).forEach(function(g2) {
        g2 == (g2 | 0) && (g2 |= 0);
        let _2 = o2[g2];
        m3[_2] = g2;
      }), m3;
    }));
  };
  Hr.forEach(function(d4) {
    B3.prototype[d4] = function() {
      let n = this._baseState;
      throw new Error(d4 + " not implemented for encoding: " + n.enc);
    };
  });
  nr.forEach(function(d4) {
    B3.prototype[d4] = function() {
      let n = this._baseState, a = Array.prototype.slice.call(arguments);
      return dt(n.tag === null), n.tag = d4, this._useArgs(a), this;
    };
  });
  B3.prototype.use = function(r) {
    dt(r);
    let n = this._baseState;
    return dt(n.use === null), n.use = r, this;
  };
  B3.prototype.optional = function() {
    let r = this._baseState;
    return r.optional = true, this;
  };
  B3.prototype.def = function(r) {
    let n = this._baseState;
    return dt(n.default === null), n.default = r, n.optional = true, this;
  };
  B3.prototype.explicit = function(r) {
    let n = this._baseState;
    return dt(n.explicit === null && n.implicit === null), n.explicit = r, this;
  };
  B3.prototype.implicit = function(r) {
    let n = this._baseState;
    return dt(n.explicit === null && n.implicit === null), n.implicit = r, this;
  };
  B3.prototype.obj = function() {
    let r = this._baseState, n = Array.prototype.slice.call(arguments);
    return r.obj = true, n.length !== 0 && this._useArgs(n), this;
  };
  B3.prototype.key = function(r) {
    let n = this._baseState;
    return dt(n.key === null), n.key = r, this;
  };
  B3.prototype.any = function() {
    let r = this._baseState;
    return r.any = true, this;
  };
  B3.prototype.choice = function(r) {
    let n = this._baseState;
    return dt(n.choice === null), n.choice = r, this._useArgs(Object.keys(r).map(function(a) {
      return r[a];
    })), this;
  };
  B3.prototype.contains = function(r) {
    let n = this._baseState;
    return dt(n.use === null), n.contains = r, this;
  };
  B3.prototype._decode = function(r, n) {
    let a = this._baseState;
    if (a.parent === null)
      return r.wrapResult(a.children[0]._decode(r, n));
    let o2 = a.default, m3 = true, g2 = null;
    if (a.key !== null && (g2 = r.enterKey(a.key)), a.optional) {
      let x = null;
      if (a.explicit !== null ? x = a.explicit : a.implicit !== null ? x = a.implicit : a.tag !== null && (x = a.tag), x === null && !a.any) {
        let S3 = r.save();
        try {
          a.choice === null ? this._decodeGeneric(a.tag, r, n) : this._decodeChoice(r, n), m3 = true;
        } catch {
          m3 = false;
        }
        r.restore(S3);
      } else if (m3 = this._peekTag(r, x, a.any), r.isError(m3))
        return m3;
    }
    let _2;
    if (a.obj && m3 && (_2 = r.enterObject()), m3) {
      if (a.explicit !== null) {
        let S3 = this._decodeTag(r, a.explicit);
        if (r.isError(S3))
          return S3;
        r = S3;
      }
      let x = r.offset;
      if (a.use === null && a.choice === null) {
        let S3;
        a.any && (S3 = r.save());
        let T4 = this._decodeTag(r, a.implicit !== null ? a.implicit : a.tag, a.any);
        if (r.isError(T4))
          return T4;
        a.any ? o2 = r.raw(S3) : r = T4;
      }
      if (n && n.track && a.tag !== null && n.track(r.path(), x, r.length, "tagged"), n && n.track && a.tag !== null && n.track(r.path(), r.offset, r.length, "content"), a.any || (a.choice === null ? o2 = this._decodeGeneric(a.tag, r, n) : o2 = this._decodeChoice(r, n)), r.isError(o2))
        return o2;
      if (!a.any && a.choice === null && a.children !== null && a.children.forEach(function(T4) {
        T4._decode(r, n);
      }), a.contains && (a.tag === "octstr" || a.tag === "bitstr")) {
        let S3 = new Gr2(o2);
        o2 = this._getUse(a.contains, r._reporterState.obj)._decode(S3, n);
      }
    }
    return a.obj && m3 && (o2 = r.leaveObject(_2)), a.key !== null && (o2 !== null || m3 === true) ? r.leaveKey(g2, a.key, o2) : g2 !== null && r.exitKey(g2), o2;
  };
  B3.prototype._decodeGeneric = function(r, n, a) {
    let o2 = this._baseState;
    return r === "seq" || r === "set" ? null : r === "seqof" || r === "setof" ? this._decodeList(n, r, o2.args[0], a) : /str$/.test(r) ? this._decodeStr(n, r, a) : r === "objid" && o2.args ? this._decodeObjid(n, o2.args[0], o2.args[1], a) : r === "objid" ? this._decodeObjid(n, null, null, a) : r === "gentime" || r === "utctime" ? this._decodeTime(n, r, a) : r === "null_" ? this._decodeNull(n, a) : r === "bool" ? this._decodeBool(n, a) : r === "objDesc" ? this._decodeStr(n, r, a) : r === "int" || r === "enum" ? this._decodeInt(n, o2.args && o2.args[0], a) : o2.use !== null ? this._getUse(o2.use, n._reporterState.obj)._decode(n, a) : n.error("unknown tag: " + r);
  };
  B3.prototype._getUse = function(r, n) {
    let a = this._baseState;
    return a.useDecoder = this._use(r, n), dt(a.useDecoder._baseState.parent === null), a.useDecoder = a.useDecoder._baseState.children[0], a.implicit !== a.useDecoder._baseState.implicit && (a.useDecoder = a.useDecoder.clone(), a.useDecoder._baseState.implicit = a.implicit), a.useDecoder;
  };
  B3.prototype._decodeChoice = function(r, n) {
    let a = this._baseState, o2 = null, m3 = false;
    return Object.keys(a.choice).some(function(g2) {
      let _2 = r.save(), x = a.choice[g2];
      try {
        let S3 = x._decode(r, n);
        if (r.isError(S3))
          return false;
        o2 = { type: g2, value: S3 }, m3 = true;
      } catch {
        return r.restore(_2), false;
      }
      return true;
    }, this), m3 ? o2 : r.error("Choice not matched");
  };
  B3.prototype._createEncoderBuffer = function(r) {
    return new Fr3(r, this.reporter);
  };
  B3.prototype._encode = function(r, n, a) {
    let o2 = this._baseState;
    if (o2.default !== null && o2.default === r)
      return;
    let m3 = this._encodeValue(r, n, a);
    if (m3 !== void 0 && !this._skipDefault(m3, n, a))
      return m3;
  };
  B3.prototype._encodeValue = function(r, n, a) {
    let o2 = this._baseState;
    if (o2.parent === null)
      return o2.children[0]._encode(r, n || new zr());
    let m3 = null;
    if (this.reporter = n, o2.optional && r === void 0)
      if (o2.default !== null)
        r = o2.default;
      else
        return;
    let g2 = null, _2 = false;
    if (o2.any)
      m3 = this._createEncoderBuffer(r);
    else if (o2.choice)
      m3 = this._encodeChoice(r, n);
    else if (o2.contains)
      g2 = this._getUse(o2.contains, a)._encode(r, n), _2 = true;
    else if (o2.children)
      g2 = o2.children.map(function(x) {
        if (x._baseState.tag === "null_")
          return x._encode(null, n, r);
        if (x._baseState.key === null)
          return n.error("Child should have a key");
        let S3 = n.enterKey(x._baseState.key);
        if (typeof r != "object")
          return n.error("Child expected, but input is not object");
        let T4 = x._encode(r[x._baseState.key], n, r);
        return n.leaveKey(S3), T4;
      }, this).filter(function(x) {
        return x;
      }), g2 = this._createEncoderBuffer(g2);
    else if (o2.tag === "seqof" || o2.tag === "setof") {
      if (!(o2.args && o2.args.length === 1))
        return n.error("Too many args for : " + o2.tag);
      if (!Array.isArray(r))
        return n.error("seqof/setof, but data is not Array");
      let x = this.clone();
      x._baseState.implicit = null, g2 = this._createEncoderBuffer(r.map(function(S3) {
        let T4 = this._baseState;
        return this._getUse(T4.args[0], r)._encode(S3, n);
      }, x));
    } else
      o2.use !== null ? m3 = this._getUse(o2.use, a)._encode(r, n) : (g2 = this._encodePrimitive(o2.tag, r), _2 = true);
    if (!o2.any && o2.choice === null) {
      let x = o2.implicit !== null ? o2.implicit : o2.tag, S3 = o2.implicit === null ? "universal" : "context";
      x === null ? o2.use === null && n.error("Tag could be omitted only for .use()") : o2.use === null && (m3 = this._encodeComposite(x, _2, S3, g2));
    }
    return o2.explicit !== null && (m3 = this._encodeComposite(o2.explicit, false, "context", m3)), m3;
  };
  B3.prototype._encodeChoice = function(r, n) {
    let a = this._baseState, o2 = a.choice[r.type];
    return o2 || dt(false, r.type + " not found in " + JSON.stringify(Object.keys(a.choice))), o2._encode(r.value, n);
  };
  B3.prototype._encodePrimitive = function(r, n) {
    let a = this._baseState;
    if (/str$/.test(r))
      return this._encodeStr(n, r);
    if (r === "objid" && a.args)
      return this._encodeObjid(n, a.reverseArgs[0], a.args[1]);
    if (r === "objid")
      return this._encodeObjid(n, null, null);
    if (r === "gentime" || r === "utctime")
      return this._encodeTime(n, r);
    if (r === "null_")
      return this._encodeNull();
    if (r === "int" || r === "enum")
      return this._encodeInt(n, a.args && a.reverseArgs[0]);
    if (r === "bool")
      return this._encodeBool(n);
    if (r === "objDesc")
      return this._encodeStr(n, r);
    throw new Error("Unsupported tag: " + r);
  };
  B3.prototype._isNumstr = function(r) {
    return /^[0-9 ]*$/.test(r);
  };
  B3.prototype._isPrintstr = function(r) {
    return /^[A-Za-z0-9 '()+,-./:=?]*$/.test(r);
  };
});
var zt = ct3((kt2) => {
  "use strict";
  function sr(d4) {
    let r = {};
    return Object.keys(d4).forEach(function(n) {
      (n | 0) == n && (n = n | 0);
      let a = d4[n];
      r[a] = n;
    }), r;
  }
  kt2.tagClass = { 0: "universal", 1: "application", 2: "context", 3: "private" };
  kt2.tagClassByName = sr(kt2.tagClass);
  kt2.tag = { 0: "end", 1: "bool", 2: "int", 3: "bitstr", 4: "octstr", 5: "null_", 6: "objid", 7: "objDesc", 8: "external", 9: "real", 10: "enum", 11: "embed", 12: "utf8str", 13: "relativeOid", 16: "seq", 17: "set", 18: "numstr", 19: "printstr", 20: "t61str", 21: "videostr", 22: "ia5str", 23: "utctime", 24: "gentime", 25: "graphstr", 26: "iso646str", 27: "genstr", 28: "unistr", 29: "charstr", 30: "bmpstr" };
  kt2.tagByName = sr(kt2.tag);
});
var ge = ct3((gi, lr) => {
  "use strict";
  var Vr2 = Et(), bt = Lt().Buffer, fr = Kt(), me = zt();
  function hr(d4) {
    this.enc = "der", this.name = d4.name, this.entity = d4, this.tree = new xt2(), this.tree._init(d4.body);
  }
  lr.exports = hr;
  hr.prototype.encode = function(r, n) {
    return this.tree._encode(r, n).join();
  };
  function xt2(d4) {
    fr.call(this, "der", d4);
  }
  Vr2(xt2, fr);
  xt2.prototype._encodeComposite = function(r, n, a, o2) {
    let m3 = Xr2(r, n, a, this.reporter);
    if (o2.length < 128) {
      let x = bt.alloc(2);
      return x[0] = m3, x[1] = o2.length, this._createEncoderBuffer([x, o2]);
    }
    let g2 = 1;
    for (let x = o2.length; x >= 256; x >>= 8)
      g2++;
    let _2 = bt.alloc(1 + 1 + g2);
    _2[0] = m3, _2[1] = 128 | g2;
    for (let x = 1 + g2, S3 = o2.length; S3 > 0; x--, S3 >>= 8)
      _2[x] = S3 & 255;
    return this._createEncoderBuffer([_2, o2]);
  };
  xt2.prototype._encodeStr = function(r, n) {
    if (n === "bitstr")
      return this._createEncoderBuffer([r.unused | 0, r.data]);
    if (n === "bmpstr") {
      let a = bt.alloc(r.length * 2);
      for (let o2 = 0; o2 < r.length; o2++)
        a.writeUInt16BE(r.charCodeAt(o2), o2 * 2);
      return this._createEncoderBuffer(a);
    } else
      return n === "numstr" ? this._isNumstr(r) ? this._createEncoderBuffer(r) : this.reporter.error("Encoding of string type: numstr supports only digits and space") : n === "printstr" ? this._isPrintstr(r) ? this._createEncoderBuffer(r) : this.reporter.error("Encoding of string type: printstr supports only latin upper and lower case letters, digits, space, apostrophe, left and rigth parenthesis, plus sign, comma, hyphen, dot, slash, colon, equal sign, question mark") : /str$/.test(n) ? this._createEncoderBuffer(r) : n === "objDesc" ? this._createEncoderBuffer(r) : this.reporter.error("Encoding of string type: " + n + " unsupported");
  };
  xt2.prototype._encodeObjid = function(r, n, a) {
    if (typeof r == "string") {
      if (!n)
        return this.reporter.error("string objid given, but no values map found");
      if (!n.hasOwnProperty(r))
        return this.reporter.error("objid not found in values map");
      r = n[r].split(/[\s.]+/g);
      for (let _2 = 0; _2 < r.length; _2++)
        r[_2] |= 0;
    } else if (Array.isArray(r)) {
      r = r.slice();
      for (let _2 = 0; _2 < r.length; _2++)
        r[_2] |= 0;
    }
    if (!Array.isArray(r))
      return this.reporter.error("objid() should be either array or string, got: " + JSON.stringify(r));
    if (!a) {
      if (r[1] >= 40)
        return this.reporter.error("Second objid identifier OOB");
      r.splice(0, 2, r[0] * 40 + r[1]);
    }
    let o2 = 0;
    for (let _2 = 0; _2 < r.length; _2++) {
      let x = r[_2];
      for (o2++; x >= 128; x >>= 7)
        o2++;
    }
    let m3 = bt.alloc(o2), g2 = m3.length - 1;
    for (let _2 = r.length - 1; _2 >= 0; _2--) {
      let x = r[_2];
      for (m3[g2--] = x & 127; (x >>= 7) > 0; )
        m3[g2--] = 128 | x & 127;
    }
    return this._createEncoderBuffer(m3);
  };
  function wt(d4) {
    return d4 < 10 ? "0" + d4 : d4;
  }
  xt2.prototype._encodeTime = function(r, n) {
    let a, o2 = new Date(r);
    return n === "gentime" ? a = [wt(o2.getUTCFullYear()), wt(o2.getUTCMonth() + 1), wt(o2.getUTCDate()), wt(o2.getUTCHours()), wt(o2.getUTCMinutes()), wt(o2.getUTCSeconds()), "Z"].join("") : n === "utctime" ? a = [wt(o2.getUTCFullYear() % 100), wt(o2.getUTCMonth() + 1), wt(o2.getUTCDate()), wt(o2.getUTCHours()), wt(o2.getUTCMinutes()), wt(o2.getUTCSeconds()), "Z"].join("") : this.reporter.error("Encoding " + n + " time is not supported yet"), this._encodeStr(a, "octstr");
  };
  xt2.prototype._encodeNull = function() {
    return this._createEncoderBuffer("");
  };
  xt2.prototype._encodeInt = function(r, n) {
    if (typeof r == "string") {
      if (!n)
        return this.reporter.error("String int or enum given, but no values map");
      if (!n.hasOwnProperty(r))
        return this.reporter.error("Values map doesn't contain: " + JSON.stringify(r));
      r = n[r];
    }
    if (typeof r != "number" && !bt.isBuffer(r)) {
      let m3 = r.toArray();
      !r.sign && m3[0] & 128 && m3.unshift(0), r = bt.from(m3);
    }
    if (bt.isBuffer(r)) {
      let m3 = r.length;
      r.length === 0 && m3++;
      let g2 = bt.alloc(m3);
      return r.copy(g2), r.length === 0 && (g2[0] = 0), this._createEncoderBuffer(g2);
    }
    if (r < 128)
      return this._createEncoderBuffer(r);
    if (r < 256)
      return this._createEncoderBuffer([0, r]);
    let a = 1;
    for (let m3 = r; m3 >= 256; m3 >>= 8)
      a++;
    let o2 = new Array(a);
    for (let m3 = o2.length - 1; m3 >= 0; m3--)
      o2[m3] = r & 255, r >>= 8;
    return o2[0] & 128 && o2.unshift(0), this._createEncoderBuffer(bt.from(o2));
  };
  xt2.prototype._encodeBool = function(r) {
    return this._createEncoderBuffer(r ? 255 : 0);
  };
  xt2.prototype._use = function(r, n) {
    return typeof r == "function" && (r = r(n)), r._getEncoder("der").tree;
  };
  xt2.prototype._skipDefault = function(r, n, a) {
    let o2 = this._baseState, m3;
    if (o2.default === null)
      return false;
    let g2 = r.join();
    if (o2.defaultBuffer === void 0 && (o2.defaultBuffer = this._encodeValue(o2.default, n, a).join()), g2.length !== o2.defaultBuffer.length)
      return false;
    for (m3 = 0; m3 < g2.length; m3++)
      if (g2[m3] !== o2.defaultBuffer[m3])
        return false;
    return true;
  };
  function Xr2(d4, r, n, a) {
    let o2;
    if (d4 === "seqof" ? d4 = "seq" : d4 === "setof" && (d4 = "set"), me.tagByName.hasOwnProperty(d4))
      o2 = me.tagByName[d4];
    else if (typeof d4 == "number" && (d4 | 0) === d4)
      o2 = d4;
    else
      return a.error("Unknown tag: " + d4);
    return o2 >= 31 ? a.error("Multi-octet tag encoding unsupported") : (r || (o2 |= 32), o2 |= me.tagClassByName[n || "universal"] << 6, o2);
  }
});
var ur = ct3((yi, ar) => {
  "use strict";
  var Yr2 = Et(), ye = ge();
  function Me(d4) {
    ye.call(this, d4), this.enc = "pem";
  }
  Yr2(Me, ye);
  ar.exports = Me;
  Me.prototype.encode = function(r, n) {
    let o2 = ye.prototype.encode.call(this, r).toString("base64"), m3 = ["-----BEGIN " + n.label + "-----"];
    for (let g2 = 0; g2 < o2.length; g2 += 64)
      m3.push(o2.slice(g2, g2 + 64));
    return m3.push("-----END " + n.label + "-----"), m3.join(`
`);
  };
});
var we = ct3((dr2) => {
  "use strict";
  var cr = dr2;
  cr.der = ge();
  cr.pem = ur();
});
var xe2 = ct3((wi, Mr) => {
  "use strict";
  var Wr2 = Et(), Qr2 = de3(), pr2 = Rt().DecoderBuffer, mr = Kt(), vr5 = zt();
  function gr2(d4) {
    this.enc = "der", this.name = d4.name, this.entity = d4, this.tree = new pt2(), this.tree._init(d4.body);
  }
  Mr.exports = gr2;
  gr2.prototype.decode = function(r, n) {
    return pr2.isDecoderBuffer(r) || (r = new pr2(r, n)), this.tree._decode(r, n);
  };
  function pt2(d4) {
    mr.call(this, "der", d4);
  }
  Wr2(pt2, mr);
  pt2.prototype._peekTag = function(r, n, a) {
    if (r.isEmpty())
      return false;
    let o2 = r.save(), m3 = _e2(r, 'Failed to peek tag: "' + n + '"');
    return r.isError(m3) ? m3 : (r.restore(o2), m3.tag === n || m3.tagStr === n || m3.tagStr + "of" === n || a);
  };
  pt2.prototype._decodeTag = function(r, n, a) {
    let o2 = _e2(r, 'Failed to decode tag of "' + n + '"');
    if (r.isError(o2))
      return o2;
    let m3 = yr2(r, o2.primitive, 'Failed to get length of "' + n + '"');
    if (r.isError(m3))
      return m3;
    if (!a && o2.tag !== n && o2.tagStr !== n && o2.tagStr + "of" !== n)
      return r.error('Failed to match tag: "' + n + '"');
    if (o2.primitive || m3 !== null)
      return r.skip(m3, 'Failed to match body of: "' + n + '"');
    let g2 = r.save(), _2 = this._skipUntilEnd(r, 'Failed to skip indefinite length body: "' + this.tag + '"');
    return r.isError(_2) ? _2 : (m3 = r.offset - g2.offset, r.restore(g2), r.skip(m3, 'Failed to match body of: "' + n + '"'));
  };
  pt2.prototype._skipUntilEnd = function(r, n) {
    for (; ; ) {
      let a = _e2(r, n);
      if (r.isError(a))
        return a;
      let o2 = yr2(r, a.primitive, n);
      if (r.isError(o2))
        return o2;
      let m3;
      if (a.primitive || o2 !== null ? m3 = r.skip(o2) : m3 = this._skipUntilEnd(r, n), r.isError(m3))
        return m3;
      if (a.tagStr === "end")
        break;
    }
  };
  pt2.prototype._decodeList = function(r, n, a, o2) {
    let m3 = [];
    for (; !r.isEmpty(); ) {
      let g2 = this._peekTag(r, "end");
      if (r.isError(g2))
        return g2;
      let _2 = a.decode(r, "der", o2);
      if (r.isError(_2) && g2)
        break;
      m3.push(_2);
    }
    return m3;
  };
  pt2.prototype._decodeStr = function(r, n) {
    if (n === "bitstr") {
      let a = r.readUInt8();
      return r.isError(a) ? a : { unused: a, data: r.raw() };
    } else if (n === "bmpstr") {
      let a = r.raw();
      if (a.length % 2 === 1)
        return r.error("Decoding of string type: bmpstr length mismatch");
      let o2 = "";
      for (let m3 = 0; m3 < a.length / 2; m3++)
        o2 += String.fromCharCode(a.readUInt16BE(m3 * 2));
      return o2;
    } else if (n === "numstr") {
      let a = r.raw().toString("ascii");
      return this._isNumstr(a) ? a : r.error("Decoding of string type: numstr unsupported characters");
    } else {
      if (n === "octstr")
        return r.raw();
      if (n === "objDesc")
        return r.raw();
      if (n === "printstr") {
        let a = r.raw().toString("ascii");
        return this._isPrintstr(a) ? a : r.error("Decoding of string type: printstr unsupported characters");
      } else
        return /str$/.test(n) ? r.raw().toString() : r.error("Decoding of string type: " + n + " unsupported");
    }
  };
  pt2.prototype._decodeObjid = function(r, n, a) {
    let o2, m3 = [], g2 = 0, _2 = 0;
    for (; !r.isEmpty(); )
      _2 = r.readUInt8(), g2 <<= 7, g2 |= _2 & 127, (_2 & 128) === 0 && (m3.push(g2), g2 = 0);
    _2 & 128 && m3.push(g2);
    let x = m3[0] / 40 | 0, S3 = m3[0] % 40;
    if (a ? o2 = m3 : o2 = [x, S3].concat(m3.slice(1)), n) {
      let T4 = n[o2.join(" ")];
      T4 === void 0 && (T4 = n[o2.join(".")]), T4 !== void 0 && (o2 = T4);
    }
    return o2;
  };
  pt2.prototype._decodeTime = function(r, n) {
    let a = r.raw().toString(), o2, m3, g2, _2, x, S3;
    if (n === "gentime")
      o2 = a.slice(0, 4) | 0, m3 = a.slice(4, 6) | 0, g2 = a.slice(6, 8) | 0, _2 = a.slice(8, 10) | 0, x = a.slice(10, 12) | 0, S3 = a.slice(12, 14) | 0;
    else if (n === "utctime")
      o2 = a.slice(0, 2) | 0, m3 = a.slice(2, 4) | 0, g2 = a.slice(4, 6) | 0, _2 = a.slice(6, 8) | 0, x = a.slice(8, 10) | 0, S3 = a.slice(10, 12) | 0, o2 < 70 ? o2 = 2e3 + o2 : o2 = 1900 + o2;
    else
      return r.error("Decoding " + n + " time is not supported yet");
    return Date.UTC(o2, m3 - 1, g2, _2, x, S3, 0);
  };
  pt2.prototype._decodeNull = function() {
    return null;
  };
  pt2.prototype._decodeBool = function(r) {
    let n = r.readUInt8();
    return r.isError(n) ? n : n !== 0;
  };
  pt2.prototype._decodeInt = function(r, n) {
    let a = r.raw(), o2 = new Qr2(a);
    return n && (o2 = n[o2.toString(10)] || o2), o2;
  };
  pt2.prototype._use = function(r, n) {
    return typeof r == "function" && (r = r(n)), r._getDecoder("der").tree;
  };
  function _e2(d4, r) {
    let n = d4.readUInt8(r);
    if (d4.isError(n))
      return n;
    let a = vr5.tagClass[n >> 6], o2 = (n & 32) === 0;
    if ((n & 31) === 31) {
      let g2 = n;
      for (n = 0; (g2 & 128) === 128; ) {
        if (g2 = d4.readUInt8(r), d4.isError(g2))
          return g2;
        n <<= 7, n |= g2 & 127;
      }
    } else
      n &= 31;
    let m3 = vr5.tag[n];
    return { cls: a, primitive: o2, tag: n, tagStr: m3 };
  }
  function yr2(d4, r, n) {
    let a = d4.readUInt8(n);
    if (d4.isError(a))
      return a;
    if (!r && a === 128)
      return null;
    if ((a & 128) === 0)
      return a;
    let o2 = a & 127;
    if (o2 > 4)
      return d4.error("length octect is too long");
    a = 0;
    for (let m3 = 0; m3 < o2; m3++) {
      a <<= 8;
      let g2 = d4.readUInt8(n);
      if (d4.isError(g2))
        return g2;
      a |= g2;
    }
    return a;
  }
});
var _r = ct3((_i, wr2) => {
  "use strict";
  var ti = Et(), ei = Lt().Buffer, be = xe2();
  function Se2(d4) {
    be.call(this, d4), this.enc = "pem";
  }
  ti(Se2, be);
  wr2.exports = Se2;
  Se2.prototype.decode = function(r, n) {
    let a = r.toString().split(/[\r\n]+/g), o2 = n.label.toUpperCase(), m3 = /^-----(BEGIN|END) ([^-]+)-----$/, g2 = -1, _2 = -1;
    for (let T4 = 0; T4 < a.length; T4++) {
      let qt2 = a[T4].match(m3);
      if (qt2 !== null && qt2[2] === o2)
        if (g2 === -1) {
          if (qt2[1] !== "BEGIN")
            break;
          g2 = T4;
        } else {
          if (qt2[1] !== "END")
            break;
          _2 = T4;
          break;
        }
    }
    if (g2 === -1 || _2 === -1)
      throw new Error("PEM section not found for: " + o2);
    let x = a.slice(g2 + 1, _2).join("");
    x.replace(/[^a-z0-9+/=]+/gi, "");
    let S3 = ei.from(x, "base64");
    return be.prototype.decode.call(this, S3, n);
  };
});
var Ee = ct3((br) => {
  "use strict";
  var xr2 = br;
  xr2.der = xe2();
  xr2.pem = _r();
});
var Er2 = ct3((Sr) => {
  "use strict";
  var ri = we(), ii = Ee(), ni3 = Et(), oi = Sr;
  oi.define = function(r, n) {
    return new Ot(r, n);
  };
  function Ot(d4, r) {
    this.name = d4, this.body = r, this.decoders = {}, this.encoders = {};
  }
  Ot.prototype._createNamed = function(r) {
    let n = this.name;
    function a(o2) {
      this._initNamed(o2, n);
    }
    return ni3(a, r), a.prototype._initNamed = function(m3, g2) {
      r.call(this, m3, g2);
    }, new a(this);
  };
  Ot.prototype._getDecoder = function(r) {
    return r = r || "der", this.decoders.hasOwnProperty(r) || (this.decoders[r] = this._createNamed(ii[r])), this.decoders[r];
  };
  Ot.prototype.decode = function(r, n, a) {
    return this._getDecoder(n).decode(r, a);
  };
  Ot.prototype._getEncoder = function(r) {
    return r = r || "der", this.encoders.hasOwnProperty(r) || (this.encoders[r] = this._createNamed(ri[r])), this.encoders[r];
  };
  Ot.prototype.encode = function(r, n, a) {
    return this._getEncoder(n).encode(r, a);
  };
});
var kr = ct3((Br2) => {
  "use strict";
  var Ft = Br2;
  Ft.Reporter = Zt().Reporter;
  Ft.DecoderBuffer = Rt().DecoderBuffer;
  Ft.EncoderBuffer = Rt().EncoderBuffer;
  Ft.Node = Kt();
});
var Tr = ct3((Ar) => {
  "use strict";
  var qr2 = Ar;
  qr2._reverse = function(r) {
    let n = {};
    return Object.keys(r).forEach(function(a) {
      (a | 0) == a && (a = a | 0);
      let o2 = r[a];
      n[o2] = a;
    }), n;
  };
  qr2.der = zt();
});
var Be2 = ct3((Dr) => {
  "use strict";
  var Ut = Dr;
  Ut.bignum = de3();
  Ut.define = Er2().define;
  Ut.base = kr();
  Ut.constants = Tr();
  Ut.decoders = Ee();
  Ut.encoders = we();
});
var Nr = Ye(Be2());
var si = Ye(Be2());
var { default: fi3, ...hi } = si;
var ki = Nr.default ?? fi3 ?? hi;

// deno:https://cdn.skypack.dev/-/urlsafe-base64@v1.0.0-BTpQCswrPNOGPq5vM1FQ/dist=es2019,mode=imports/optimized/urlsafe-base64.js
var global$1 = typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {};
var lookup = [];
var revLookup = [];
var Arr = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
var inited = false;
function init3() {
  inited = true;
  var code2 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
  for (var i = 0, len = code2.length; i < len; ++i) {
    lookup[i] = code2[i];
    revLookup[code2.charCodeAt(i)] = i;
  }
  revLookup["-".charCodeAt(0)] = 62;
  revLookup["_".charCodeAt(0)] = 63;
}
function toByteArray(b64) {
  if (!inited) {
    init3();
  }
  var i, j2, l, tmp, placeHolders, arr;
  var len = b64.length;
  if (len % 4 > 0) {
    throw new Error("Invalid string. Length must be a multiple of 4");
  }
  placeHolders = b64[len - 2] === "=" ? 2 : b64[len - 1] === "=" ? 1 : 0;
  arr = new Arr(len * 3 / 4 - placeHolders);
  l = placeHolders > 0 ? len - 4 : len;
  var L4 = 0;
  for (i = 0, j2 = 0; i < l; i += 4, j2 += 3) {
    tmp = revLookup[b64.charCodeAt(i)] << 18 | revLookup[b64.charCodeAt(i + 1)] << 12 | revLookup[b64.charCodeAt(i + 2)] << 6 | revLookup[b64.charCodeAt(i + 3)];
    arr[L4++] = tmp >> 16 & 255;
    arr[L4++] = tmp >> 8 & 255;
    arr[L4++] = tmp & 255;
  }
  if (placeHolders === 2) {
    tmp = revLookup[b64.charCodeAt(i)] << 2 | revLookup[b64.charCodeAt(i + 1)] >> 4;
    arr[L4++] = tmp & 255;
  } else if (placeHolders === 1) {
    tmp = revLookup[b64.charCodeAt(i)] << 10 | revLookup[b64.charCodeAt(i + 1)] << 4 | revLookup[b64.charCodeAt(i + 2)] >> 2;
    arr[L4++] = tmp >> 8 & 255;
    arr[L4++] = tmp & 255;
  }
  return arr;
}
function tripletToBase64(num) {
  return lookup[num >> 18 & 63] + lookup[num >> 12 & 63] + lookup[num >> 6 & 63] + lookup[num & 63];
}
function encodeChunk(uint8, start, end) {
  var tmp;
  var output = [];
  for (var i = start; i < end; i += 3) {
    tmp = (uint8[i] << 16) + (uint8[i + 1] << 8) + uint8[i + 2];
    output.push(tripletToBase64(tmp));
  }
  return output.join("");
}
function fromByteArray(uint8) {
  if (!inited) {
    init3();
  }
  var tmp;
  var len = uint8.length;
  var extraBytes = len % 3;
  var output = "";
  var parts = [];
  var maxChunkLength = 16383;
  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
    parts.push(encodeChunk(uint8, i, i + maxChunkLength > len2 ? len2 : i + maxChunkLength));
  }
  if (extraBytes === 1) {
    tmp = uint8[len - 1];
    output += lookup[tmp >> 2];
    output += lookup[tmp << 4 & 63];
    output += "==";
  } else if (extraBytes === 2) {
    tmp = (uint8[len - 2] << 8) + uint8[len - 1];
    output += lookup[tmp >> 10];
    output += lookup[tmp >> 4 & 63];
    output += lookup[tmp << 2 & 63];
    output += "=";
  }
  parts.push(output);
  return parts.join("");
}
function read(buffer, offset, isLE, mLen, nBytes) {
  var e, m3;
  var eLen = nBytes * 8 - mLen - 1;
  var eMax = (1 << eLen) - 1;
  var eBias = eMax >> 1;
  var nBits = -7;
  var i = isLE ? nBytes - 1 : 0;
  var d4 = isLE ? -1 : 1;
  var s = buffer[offset + i];
  i += d4;
  e = s & (1 << -nBits) - 1;
  s >>= -nBits;
  nBits += eLen;
  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d4, nBits -= 8) {
  }
  m3 = e & (1 << -nBits) - 1;
  e >>= -nBits;
  nBits += mLen;
  for (; nBits > 0; m3 = m3 * 256 + buffer[offset + i], i += d4, nBits -= 8) {
  }
  if (e === 0) {
    e = 1 - eBias;
  } else if (e === eMax) {
    return m3 ? NaN : (s ? -1 : 1) * Infinity;
  } else {
    m3 = m3 + Math.pow(2, mLen);
    e = e - eBias;
  }
  return (s ? -1 : 1) * m3 * Math.pow(2, e - mLen);
}
function write4(buffer, value, offset, isLE, mLen, nBytes) {
  var e, m3, c5;
  var eLen = nBytes * 8 - mLen - 1;
  var eMax = (1 << eLen) - 1;
  var eBias = eMax >> 1;
  var rt2 = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
  var i = isLE ? 0 : nBytes - 1;
  var d4 = isLE ? 1 : -1;
  var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
  value = Math.abs(value);
  if (isNaN(value) || value === Infinity) {
    m3 = isNaN(value) ? 1 : 0;
    e = eMax;
  } else {
    e = Math.floor(Math.log(value) / Math.LN2);
    if (value * (c5 = Math.pow(2, -e)) < 1) {
      e--;
      c5 *= 2;
    }
    if (e + eBias >= 1) {
      value += rt2 / c5;
    } else {
      value += rt2 * Math.pow(2, 1 - eBias);
    }
    if (value * c5 >= 2) {
      e++;
      c5 /= 2;
    }
    if (e + eBias >= eMax) {
      m3 = 0;
      e = eMax;
    } else if (e + eBias >= 1) {
      m3 = (value * c5 - 1) * Math.pow(2, mLen);
      e = e + eBias;
    } else {
      m3 = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
      e = 0;
    }
  }
  for (; mLen >= 8; buffer[offset + i] = m3 & 255, i += d4, m3 /= 256, mLen -= 8) {
  }
  e = e << mLen | m3;
  eLen += mLen;
  for (; eLen > 0; buffer[offset + i] = e & 255, i += d4, e /= 256, eLen -= 8) {
  }
  buffer[offset + i - d4] |= s * 128;
}
var toString5 = {}.toString;
var isArray3 = Array.isArray || function(arr) {
  return toString5.call(arr) == "[object Array]";
};
var INSPECT_MAX_BYTES4 = 50;
Buffer7.TYPED_ARRAY_SUPPORT = global$1.TYPED_ARRAY_SUPPORT !== void 0 ? global$1.TYPED_ARRAY_SUPPORT : true;
function kMaxLength4() {
  return Buffer7.TYPED_ARRAY_SUPPORT ? 2147483647 : 1073741823;
}
function createBuffer4(that, length) {
  if (kMaxLength4() < length) {
    throw new RangeError("Invalid typed array length");
  }
  if (Buffer7.TYPED_ARRAY_SUPPORT) {
    that = new Uint8Array(length);
    that.__proto__ = Buffer7.prototype;
  } else {
    if (that === null) {
      that = new Buffer7(length);
    }
    that.length = length;
  }
  return that;
}
function Buffer7(arg, encodingOrOffset, length) {
  if (!Buffer7.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer7)) {
    return new Buffer7(arg, encodingOrOffset, length);
  }
  if (typeof arg === "number") {
    if (typeof encodingOrOffset === "string") {
      throw new Error("If encoding is specified then the first argument must be a string");
    }
    return allocUnsafe4(this, arg);
  }
  return from4(this, arg, encodingOrOffset, length);
}
Buffer7.poolSize = 8192;
Buffer7._augment = function(arr) {
  arr.__proto__ = Buffer7.prototype;
  return arr;
};
function from4(that, value, encodingOrOffset, length) {
  if (typeof value === "number") {
    throw new TypeError('"value" argument must not be a number');
  }
  if (typeof ArrayBuffer !== "undefined" && value instanceof ArrayBuffer) {
    return fromArrayBuffer4(that, value, encodingOrOffset, length);
  }
  if (typeof value === "string") {
    return fromString4(that, value, encodingOrOffset);
  }
  return fromObject4(that, value);
}
Buffer7.from = function(value, encodingOrOffset, length) {
  return from4(null, value, encodingOrOffset, length);
};
if (Buffer7.TYPED_ARRAY_SUPPORT) {
  Buffer7.prototype.__proto__ = Uint8Array.prototype;
  Buffer7.__proto__ = Uint8Array;
}
function assertSize5(size) {
  if (typeof size !== "number") {
    throw new TypeError('"size" argument must be a number');
  } else if (size < 0) {
    throw new RangeError('"size" argument must not be negative');
  }
}
function alloc4(that, size, fill22, encoding) {
  assertSize5(size);
  if (size <= 0) {
    return createBuffer4(that, size);
  }
  if (fill22 !== void 0) {
    return typeof encoding === "string" ? createBuffer4(that, size).fill(fill22, encoding) : createBuffer4(that, size).fill(fill22);
  }
  return createBuffer4(that, size);
}
Buffer7.alloc = function(size, fill22, encoding) {
  return alloc4(null, size, fill22, encoding);
};
function allocUnsafe4(that, size) {
  assertSize5(size);
  that = createBuffer4(that, size < 0 ? 0 : checked4(size) | 0);
  if (!Buffer7.TYPED_ARRAY_SUPPORT) {
    for (var i = 0; i < size; ++i) {
      that[i] = 0;
    }
  }
  return that;
}
Buffer7.allocUnsafe = function(size) {
  return allocUnsafe4(null, size);
};
Buffer7.allocUnsafeSlow = function(size) {
  return allocUnsafe4(null, size);
};
function fromString4(that, string, encoding) {
  if (typeof encoding !== "string" || encoding === "") {
    encoding = "utf8";
  }
  if (!Buffer7.isEncoding(encoding)) {
    throw new TypeError('"encoding" must be a valid string encoding');
  }
  var length = byteLength5(string, encoding) | 0;
  that = createBuffer4(that, length);
  var actual = that.write(string, encoding);
  if (actual !== length) {
    that = that.slice(0, actual);
  }
  return that;
}
function fromArrayLike4(that, array) {
  var length = array.length < 0 ? 0 : checked4(array.length) | 0;
  that = createBuffer4(that, length);
  for (var i = 0; i < length; i += 1) {
    that[i] = array[i] & 255;
  }
  return that;
}
function fromArrayBuffer4(that, array, byteOffset, length) {
  array.byteLength;
  if (byteOffset < 0 || array.byteLength < byteOffset) {
    throw new RangeError("'offset' is out of bounds");
  }
  if (array.byteLength < byteOffset + (length || 0)) {
    throw new RangeError("'length' is out of bounds");
  }
  if (byteOffset === void 0 && length === void 0) {
    array = new Uint8Array(array);
  } else if (length === void 0) {
    array = new Uint8Array(array, byteOffset);
  } else {
    array = new Uint8Array(array, byteOffset, length);
  }
  if (Buffer7.TYPED_ARRAY_SUPPORT) {
    that = array;
    that.__proto__ = Buffer7.prototype;
  } else {
    that = fromArrayLike4(that, array);
  }
  return that;
}
function fromObject4(that, obj2) {
  if (internalIsBuffer(obj2)) {
    var len = checked4(obj2.length) | 0;
    that = createBuffer4(that, len);
    if (that.length === 0) {
      return that;
    }
    obj2.copy(that, 0, 0, len);
    return that;
  }
  if (obj2) {
    if (typeof ArrayBuffer !== "undefined" && obj2.buffer instanceof ArrayBuffer || "length" in obj2) {
      if (typeof obj2.length !== "number" || isnan(obj2.length)) {
        return createBuffer4(that, 0);
      }
      return fromArrayLike4(that, obj2);
    }
    if (obj2.type === "Buffer" && isArray3(obj2.data)) {
      return fromArrayLike4(that, obj2.data);
    }
  }
  throw new TypeError("First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.");
}
function checked4(length) {
  if (length >= kMaxLength4()) {
    throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + kMaxLength4().toString(16) + " bytes");
  }
  return length | 0;
}
Buffer7.isBuffer = isBuffer6;
function internalIsBuffer(b2) {
  return !!(b2 != null && b2._isBuffer);
}
Buffer7.compare = function compare8(a, b2) {
  if (!internalIsBuffer(a) || !internalIsBuffer(b2)) {
    throw new TypeError("Arguments must be Buffers");
  }
  if (a === b2)
    return 0;
  var x = a.length;
  var y4 = b2.length;
  for (var i = 0, len = Math.min(x, y4); i < len; ++i) {
    if (a[i] !== b2[i]) {
      x = a[i];
      y4 = b2[i];
      break;
    }
  }
  if (x < y4)
    return -1;
  if (y4 < x)
    return 1;
  return 0;
};
Buffer7.isEncoding = function isEncoding4(encoding) {
  switch (String(encoding).toLowerCase()) {
    case "hex":
    case "utf8":
    case "utf-8":
    case "ascii":
    case "latin1":
    case "binary":
    case "base64":
    case "ucs2":
    case "ucs-2":
    case "utf16le":
    case "utf-16le":
      return true;
    default:
      return false;
  }
};
Buffer7.concat = function concat6(list, length) {
  if (!isArray3(list)) {
    throw new TypeError('"list" argument must be an Array of Buffers');
  }
  if (list.length === 0) {
    return Buffer7.alloc(0);
  }
  var i;
  if (length === void 0) {
    length = 0;
    for (i = 0; i < list.length; ++i) {
      length += list[i].length;
    }
  }
  var buffer = Buffer7.allocUnsafe(length);
  var pos = 0;
  for (i = 0; i < list.length; ++i) {
    var buf = list[i];
    if (!internalIsBuffer(buf)) {
      throw new TypeError('"list" argument must be an Array of Buffers');
    }
    buf.copy(buffer, pos);
    pos += buf.length;
  }
  return buffer;
};
function byteLength5(string, encoding) {
  if (internalIsBuffer(string)) {
    return string.length;
  }
  if (typeof ArrayBuffer !== "undefined" && typeof ArrayBuffer.isView === "function" && (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {
    return string.byteLength;
  }
  if (typeof string !== "string") {
    string = "" + string;
  }
  var len = string.length;
  if (len === 0)
    return 0;
  var loweredCase = false;
  for (; ; ) {
    switch (encoding) {
      case "ascii":
      case "latin1":
      case "binary":
        return len;
      case "utf8":
      case "utf-8":
      case void 0:
        return utf8ToBytes4(string).length;
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return len * 2;
      case "hex":
        return len >>> 1;
      case "base64":
        return base64ToBytes4(string).length;
      default:
        if (loweredCase)
          return utf8ToBytes4(string).length;
        encoding = ("" + encoding).toLowerCase();
        loweredCase = true;
    }
  }
}
Buffer7.byteLength = byteLength5;
function slowToString(encoding, start, end) {
  var loweredCase = false;
  if (start === void 0 || start < 0) {
    start = 0;
  }
  if (start > this.length) {
    return "";
  }
  if (end === void 0 || end > this.length) {
    end = this.length;
  }
  if (end <= 0) {
    return "";
  }
  end >>>= 0;
  start >>>= 0;
  if (end <= start) {
    return "";
  }
  if (!encoding)
    encoding = "utf8";
  while (true) {
    switch (encoding) {
      case "hex":
        return hexSlice6(this, start, end);
      case "utf8":
      case "utf-8":
        return utf8Slice4(this, start, end);
      case "ascii":
        return asciiSlice4(this, start, end);
      case "latin1":
      case "binary":
        return latin1Slice4(this, start, end);
      case "base64":
        return base64Slice4(this, start, end);
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return utf16leSlice(this, start, end);
      default:
        if (loweredCase)
          throw new TypeError("Unknown encoding: " + encoding);
        encoding = (encoding + "").toLowerCase();
        loweredCase = true;
    }
  }
}
Buffer7.prototype._isBuffer = true;
function swap4(b2, n, m3) {
  var i = b2[n];
  b2[n] = b2[m3];
  b2[m3] = i;
}
Buffer7.prototype.swap16 = function swap164() {
  var len = this.length;
  if (len % 2 !== 0) {
    throw new RangeError("Buffer size must be a multiple of 16-bits");
  }
  for (var i = 0; i < len; i += 2) {
    swap4(this, i, i + 1);
  }
  return this;
};
Buffer7.prototype.swap32 = function swap324() {
  var len = this.length;
  if (len % 4 !== 0) {
    throw new RangeError("Buffer size must be a multiple of 32-bits");
  }
  for (var i = 0; i < len; i += 4) {
    swap4(this, i, i + 3);
    swap4(this, i + 1, i + 2);
  }
  return this;
};
Buffer7.prototype.swap64 = function swap644() {
  var len = this.length;
  if (len % 8 !== 0) {
    throw new RangeError("Buffer size must be a multiple of 64-bits");
  }
  for (var i = 0; i < len; i += 8) {
    swap4(this, i, i + 7);
    swap4(this, i + 1, i + 6);
    swap4(this, i + 2, i + 5);
    swap4(this, i + 3, i + 4);
  }
  return this;
};
Buffer7.prototype.toString = function toString22() {
  var length = this.length | 0;
  if (length === 0)
    return "";
  if (arguments.length === 0)
    return utf8Slice4(this, 0, length);
  return slowToString.apply(this, arguments);
};
Buffer7.prototype.equals = function equals7(b2) {
  if (!internalIsBuffer(b2))
    throw new TypeError("Argument must be a Buffer");
  if (this === b2)
    return true;
  return Buffer7.compare(this, b2) === 0;
};
Buffer7.prototype.inspect = function inspect7() {
  var str = "";
  var max2 = INSPECT_MAX_BYTES4;
  if (this.length > 0) {
    str = this.toString("hex", 0, max2).match(/.{2}/g).join(" ");
    if (this.length > max2)
      str += " ... ";
  }
  return "<Buffer " + str + ">";
};
Buffer7.prototype.compare = function compare22(target, start, end, thisStart, thisEnd) {
  if (!internalIsBuffer(target)) {
    throw new TypeError("Argument must be a Buffer");
  }
  if (start === void 0) {
    start = 0;
  }
  if (end === void 0) {
    end = target ? target.length : 0;
  }
  if (thisStart === void 0) {
    thisStart = 0;
  }
  if (thisEnd === void 0) {
    thisEnd = this.length;
  }
  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
    throw new RangeError("out of range index");
  }
  if (thisStart >= thisEnd && start >= end) {
    return 0;
  }
  if (thisStart >= thisEnd) {
    return -1;
  }
  if (start >= end) {
    return 1;
  }
  start >>>= 0;
  end >>>= 0;
  thisStart >>>= 0;
  thisEnd >>>= 0;
  if (this === target)
    return 0;
  var x = thisEnd - thisStart;
  var y4 = end - start;
  var len = Math.min(x, y4);
  var thisCopy = this.slice(thisStart, thisEnd);
  var targetCopy = target.slice(start, end);
  for (var i = 0; i < len; ++i) {
    if (thisCopy[i] !== targetCopy[i]) {
      x = thisCopy[i];
      y4 = targetCopy[i];
      break;
    }
  }
  if (x < y4)
    return -1;
  if (y4 < x)
    return 1;
  return 0;
};
function bidirectionalIndexOf4(buffer, val, byteOffset, encoding, dir) {
  if (buffer.length === 0)
    return -1;
  if (typeof byteOffset === "string") {
    encoding = byteOffset;
    byteOffset = 0;
  } else if (byteOffset > 2147483647) {
    byteOffset = 2147483647;
  } else if (byteOffset < -2147483648) {
    byteOffset = -2147483648;
  }
  byteOffset = +byteOffset;
  if (isNaN(byteOffset)) {
    byteOffset = dir ? 0 : buffer.length - 1;
  }
  if (byteOffset < 0)
    byteOffset = buffer.length + byteOffset;
  if (byteOffset >= buffer.length) {
    if (dir)
      return -1;
    else
      byteOffset = buffer.length - 1;
  } else if (byteOffset < 0) {
    if (dir)
      byteOffset = 0;
    else
      return -1;
  }
  if (typeof val === "string") {
    val = Buffer7.from(val, encoding);
  }
  if (internalIsBuffer(val)) {
    if (val.length === 0) {
      return -1;
    }
    return arrayIndexOf(buffer, val, byteOffset, encoding, dir);
  } else if (typeof val === "number") {
    val = val & 255;
    if (Buffer7.TYPED_ARRAY_SUPPORT && typeof Uint8Array.prototype.indexOf === "function") {
      if (dir) {
        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset);
      } else {
        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset);
      }
    }
    return arrayIndexOf(buffer, [val], byteOffset, encoding, dir);
  }
  throw new TypeError("val must be string, number or Buffer");
}
function arrayIndexOf(arr, val, byteOffset, encoding, dir) {
  var indexSize = 1;
  var arrLength = arr.length;
  var valLength = val.length;
  if (encoding !== void 0) {
    encoding = String(encoding).toLowerCase();
    if (encoding === "ucs2" || encoding === "ucs-2" || encoding === "utf16le" || encoding === "utf-16le") {
      if (arr.length < 2 || val.length < 2) {
        return -1;
      }
      indexSize = 2;
      arrLength /= 2;
      valLength /= 2;
      byteOffset /= 2;
    }
  }
  function read2(buf, i2) {
    if (indexSize === 1) {
      return buf[i2];
    } else {
      return buf.readUInt16BE(i2 * indexSize);
    }
  }
  var i;
  if (dir) {
    var foundIndex = -1;
    for (i = byteOffset; i < arrLength; i++) {
      if (read2(arr, i) === read2(val, foundIndex === -1 ? 0 : i - foundIndex)) {
        if (foundIndex === -1)
          foundIndex = i;
        if (i - foundIndex + 1 === valLength)
          return foundIndex * indexSize;
      } else {
        if (foundIndex !== -1)
          i -= i - foundIndex;
        foundIndex = -1;
      }
    }
  } else {
    if (byteOffset + valLength > arrLength)
      byteOffset = arrLength - valLength;
    for (i = byteOffset; i >= 0; i--) {
      var found = true;
      for (var j2 = 0; j2 < valLength; j2++) {
        if (read2(arr, i + j2) !== read2(val, j2)) {
          found = false;
          break;
        }
      }
      if (found)
        return i;
    }
  }
  return -1;
}
Buffer7.prototype.includes = function includes4(val, byteOffset, encoding) {
  return this.indexOf(val, byteOffset, encoding) !== -1;
};
Buffer7.prototype.indexOf = function indexOf4(val, byteOffset, encoding) {
  return bidirectionalIndexOf4(this, val, byteOffset, encoding, true);
};
Buffer7.prototype.lastIndexOf = function lastIndexOf4(val, byteOffset, encoding) {
  return bidirectionalIndexOf4(this, val, byteOffset, encoding, false);
};
function hexWrite4(buf, string, offset, length) {
  offset = Number(offset) || 0;
  var remaining = buf.length - offset;
  if (!length) {
    length = remaining;
  } else {
    length = Number(length);
    if (length > remaining) {
      length = remaining;
    }
  }
  var strLen = string.length;
  if (strLen % 2 !== 0)
    throw new TypeError("Invalid hex string");
  if (length > strLen / 2) {
    length = strLen / 2;
  }
  for (var i = 0; i < length; ++i) {
    var parsed = parseInt(string.substr(i * 2, 2), 16);
    if (isNaN(parsed))
      return i;
    buf[offset + i] = parsed;
  }
  return i;
}
function utf8Write5(buf, string, offset, length) {
  return blitBuffer4(utf8ToBytes4(string, buf.length - offset), buf, offset, length);
}
function asciiWrite4(buf, string, offset, length) {
  return blitBuffer4(asciiToBytes4(string), buf, offset, length);
}
function latin1Write4(buf, string, offset, length) {
  return asciiWrite4(buf, string, offset, length);
}
function base64Write4(buf, string, offset, length) {
  return blitBuffer4(base64ToBytes4(string), buf, offset, length);
}
function ucs2Write4(buf, string, offset, length) {
  return blitBuffer4(utf16leToBytes4(string, buf.length - offset), buf, offset, length);
}
Buffer7.prototype.write = function write22(string, offset, length, encoding) {
  if (offset === void 0) {
    encoding = "utf8";
    length = this.length;
    offset = 0;
  } else if (length === void 0 && typeof offset === "string") {
    encoding = offset;
    length = this.length;
    offset = 0;
  } else if (isFinite(offset)) {
    offset = offset | 0;
    if (isFinite(length)) {
      length = length | 0;
      if (encoding === void 0)
        encoding = "utf8";
    } else {
      encoding = length;
      length = void 0;
    }
  } else {
    throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");
  }
  var remaining = this.length - offset;
  if (length === void 0 || length > remaining)
    length = remaining;
  if (string.length > 0 && (length < 0 || offset < 0) || offset > this.length) {
    throw new RangeError("Attempt to write outside buffer bounds");
  }
  if (!encoding)
    encoding = "utf8";
  var loweredCase = false;
  for (; ; ) {
    switch (encoding) {
      case "hex":
        return hexWrite4(this, string, offset, length);
      case "utf8":
      case "utf-8":
        return utf8Write5(this, string, offset, length);
      case "ascii":
        return asciiWrite4(this, string, offset, length);
      case "latin1":
      case "binary":
        return latin1Write4(this, string, offset, length);
      case "base64":
        return base64Write4(this, string, offset, length);
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return ucs2Write4(this, string, offset, length);
      default:
        if (loweredCase)
          throw new TypeError("Unknown encoding: " + encoding);
        encoding = ("" + encoding).toLowerCase();
        loweredCase = true;
    }
  }
};
Buffer7.prototype.toJSON = function toJSON5() {
  return {
    type: "Buffer",
    data: Array.prototype.slice.call(this._arr || this, 0)
  };
};
function base64Slice4(buf, start, end) {
  if (start === 0 && end === buf.length) {
    return fromByteArray(buf);
  } else {
    return fromByteArray(buf.slice(start, end));
  }
}
function utf8Slice4(buf, start, end) {
  end = Math.min(buf.length, end);
  var res = [];
  var i = start;
  while (i < end) {
    var firstByte = buf[i];
    var codePoint = null;
    var bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;
    if (i + bytesPerSequence <= end) {
      var secondByte, thirdByte, fourthByte, tempCodePoint;
      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 128) {
            codePoint = firstByte;
          }
          break;
        case 2:
          secondByte = buf[i + 1];
          if ((secondByte & 192) === 128) {
            tempCodePoint = (firstByte & 31) << 6 | secondByte & 63;
            if (tempCodePoint > 127) {
              codePoint = tempCodePoint;
            }
          }
          break;
        case 3:
          secondByte = buf[i + 1];
          thirdByte = buf[i + 2];
          if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {
            tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63;
            if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) {
              codePoint = tempCodePoint;
            }
          }
          break;
        case 4:
          secondByte = buf[i + 1];
          thirdByte = buf[i + 2];
          fourthByte = buf[i + 3];
          if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {
            tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63;
            if (tempCodePoint > 65535 && tempCodePoint < 1114112) {
              codePoint = tempCodePoint;
            }
          }
      }
    }
    if (codePoint === null) {
      codePoint = 65533;
      bytesPerSequence = 1;
    } else if (codePoint > 65535) {
      codePoint -= 65536;
      res.push(codePoint >>> 10 & 1023 | 55296);
      codePoint = 56320 | codePoint & 1023;
    }
    res.push(codePoint);
    i += bytesPerSequence;
  }
  return decodeCodePointsArray4(res);
}
var MAX_ARGUMENTS_LENGTH4 = 4096;
function decodeCodePointsArray4(codePoints) {
  var len = codePoints.length;
  if (len <= MAX_ARGUMENTS_LENGTH4) {
    return String.fromCharCode.apply(String, codePoints);
  }
  var res = "";
  var i = 0;
  while (i < len) {
    res += String.fromCharCode.apply(String, codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH4));
  }
  return res;
}
function asciiSlice4(buf, start, end) {
  var ret = "";
  end = Math.min(buf.length, end);
  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i] & 127);
  }
  return ret;
}
function latin1Slice4(buf, start, end) {
  var ret = "";
  end = Math.min(buf.length, end);
  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i]);
  }
  return ret;
}
function hexSlice6(buf, start, end) {
  var len = buf.length;
  if (!start || start < 0)
    start = 0;
  if (!end || end < 0 || end > len)
    end = len;
  var out = "";
  for (var i = start; i < end; ++i) {
    out += toHex(buf[i]);
  }
  return out;
}
function utf16leSlice(buf, start, end) {
  var bytes = buf.slice(start, end);
  var res = "";
  for (var i = 0; i < bytes.length; i += 2) {
    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);
  }
  return res;
}
Buffer7.prototype.slice = function slice4(start, end) {
  var len = this.length;
  start = ~~start;
  end = end === void 0 ? len : ~~end;
  if (start < 0) {
    start += len;
    if (start < 0)
      start = 0;
  } else if (start > len) {
    start = len;
  }
  if (end < 0) {
    end += len;
    if (end < 0)
      end = 0;
  } else if (end > len) {
    end = len;
  }
  if (end < start)
    end = start;
  var newBuf;
  if (Buffer7.TYPED_ARRAY_SUPPORT) {
    newBuf = this.subarray(start, end);
    newBuf.__proto__ = Buffer7.prototype;
  } else {
    var sliceLen = end - start;
    newBuf = new Buffer7(sliceLen, void 0);
    for (var i = 0; i < sliceLen; ++i) {
      newBuf[i] = this[i + start];
    }
  }
  return newBuf;
};
function checkOffset(offset, ext, length) {
  if (offset % 1 !== 0 || offset < 0)
    throw new RangeError("offset is not uint");
  if (offset + ext > length)
    throw new RangeError("Trying to access beyond buffer length");
}
Buffer7.prototype.readUIntLE = function readUIntLE4(offset, byteLength22, noAssert) {
  offset = offset | 0;
  byteLength22 = byteLength22 | 0;
  if (!noAssert)
    checkOffset(offset, byteLength22, this.length);
  var val = this[offset];
  var mul4 = 1;
  var i = 0;
  while (++i < byteLength22 && (mul4 *= 256)) {
    val += this[offset + i] * mul4;
  }
  return val;
};
Buffer7.prototype.readUIntBE = function readUIntBE4(offset, byteLength22, noAssert) {
  offset = offset | 0;
  byteLength22 = byteLength22 | 0;
  if (!noAssert) {
    checkOffset(offset, byteLength22, this.length);
  }
  var val = this[offset + --byteLength22];
  var mul4 = 1;
  while (byteLength22 > 0 && (mul4 *= 256)) {
    val += this[offset + --byteLength22] * mul4;
  }
  return val;
};
Buffer7.prototype.readUInt8 = function readUInt85(offset, noAssert) {
  if (!noAssert)
    checkOffset(offset, 1, this.length);
  return this[offset];
};
Buffer7.prototype.readUInt16LE = function readUInt16LE4(offset, noAssert) {
  if (!noAssert)
    checkOffset(offset, 2, this.length);
  return this[offset] | this[offset + 1] << 8;
};
Buffer7.prototype.readUInt16BE = function readUInt16BE4(offset, noAssert) {
  if (!noAssert)
    checkOffset(offset, 2, this.length);
  return this[offset] << 8 | this[offset + 1];
};
Buffer7.prototype.readUInt32LE = function readUInt32LE4(offset, noAssert) {
  if (!noAssert)
    checkOffset(offset, 4, this.length);
  return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 16777216;
};
Buffer7.prototype.readUInt32BE = function readUInt32BE4(offset, noAssert) {
  if (!noAssert)
    checkOffset(offset, 4, this.length);
  return this[offset] * 16777216 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);
};
Buffer7.prototype.readIntLE = function readIntLE4(offset, byteLength22, noAssert) {
  offset = offset | 0;
  byteLength22 = byteLength22 | 0;
  if (!noAssert)
    checkOffset(offset, byteLength22, this.length);
  var val = this[offset];
  var mul4 = 1;
  var i = 0;
  while (++i < byteLength22 && (mul4 *= 256)) {
    val += this[offset + i] * mul4;
  }
  mul4 *= 128;
  if (val >= mul4)
    val -= Math.pow(2, 8 * byteLength22);
  return val;
};
Buffer7.prototype.readIntBE = function readIntBE4(offset, byteLength22, noAssert) {
  offset = offset | 0;
  byteLength22 = byteLength22 | 0;
  if (!noAssert)
    checkOffset(offset, byteLength22, this.length);
  var i = byteLength22;
  var mul4 = 1;
  var val = this[offset + --i];
  while (i > 0 && (mul4 *= 256)) {
    val += this[offset + --i] * mul4;
  }
  mul4 *= 128;
  if (val >= mul4)
    val -= Math.pow(2, 8 * byteLength22);
  return val;
};
Buffer7.prototype.readInt8 = function readInt84(offset, noAssert) {
  if (!noAssert)
    checkOffset(offset, 1, this.length);
  if (!(this[offset] & 128))
    return this[offset];
  return (255 - this[offset] + 1) * -1;
};
Buffer7.prototype.readInt16LE = function readInt16LE4(offset, noAssert) {
  if (!noAssert)
    checkOffset(offset, 2, this.length);
  var val = this[offset] | this[offset + 1] << 8;
  return val & 32768 ? val | 4294901760 : val;
};
Buffer7.prototype.readInt16BE = function readInt16BE4(offset, noAssert) {
  if (!noAssert)
    checkOffset(offset, 2, this.length);
  var val = this[offset + 1] | this[offset] << 8;
  return val & 32768 ? val | 4294901760 : val;
};
Buffer7.prototype.readInt32LE = function readInt32LE4(offset, noAssert) {
  if (!noAssert)
    checkOffset(offset, 4, this.length);
  return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;
};
Buffer7.prototype.readInt32BE = function readInt32BE4(offset, noAssert) {
  if (!noAssert)
    checkOffset(offset, 4, this.length);
  return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];
};
Buffer7.prototype.readFloatLE = function readFloatLE4(offset, noAssert) {
  if (!noAssert)
    checkOffset(offset, 4, this.length);
  return read(this, offset, true, 23, 4);
};
Buffer7.prototype.readFloatBE = function readFloatBE4(offset, noAssert) {
  if (!noAssert)
    checkOffset(offset, 4, this.length);
  return read(this, offset, false, 23, 4);
};
Buffer7.prototype.readDoubleLE = function readDoubleLE4(offset, noAssert) {
  if (!noAssert)
    checkOffset(offset, 8, this.length);
  return read(this, offset, true, 52, 8);
};
Buffer7.prototype.readDoubleBE = function readDoubleBE4(offset, noAssert) {
  if (!noAssert)
    checkOffset(offset, 8, this.length);
  return read(this, offset, false, 52, 8);
};
function checkInt4(buf, value, offset, ext, max2, min4) {
  if (!internalIsBuffer(buf))
    throw new TypeError('"buffer" argument must be a Buffer instance');
  if (value > max2 || value < min4)
    throw new RangeError('"value" argument is out of bounds');
  if (offset + ext > buf.length)
    throw new RangeError("Index out of range");
}
Buffer7.prototype.writeUIntLE = function writeUIntLE4(value, offset, byteLength22, noAssert) {
  value = +value;
  offset = offset | 0;
  byteLength22 = byteLength22 | 0;
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength22) - 1;
    checkInt4(this, value, offset, byteLength22, maxBytes, 0);
  }
  var mul4 = 1;
  var i = 0;
  this[offset] = value & 255;
  while (++i < byteLength22 && (mul4 *= 256)) {
    this[offset + i] = value / mul4 & 255;
  }
  return offset + byteLength22;
};
Buffer7.prototype.writeUIntBE = function writeUIntBE4(value, offset, byteLength22, noAssert) {
  value = +value;
  offset = offset | 0;
  byteLength22 = byteLength22 | 0;
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength22) - 1;
    checkInt4(this, value, offset, byteLength22, maxBytes, 0);
  }
  var i = byteLength22 - 1;
  var mul4 = 1;
  this[offset + i] = value & 255;
  while (--i >= 0 && (mul4 *= 256)) {
    this[offset + i] = value / mul4 & 255;
  }
  return offset + byteLength22;
};
Buffer7.prototype.writeUInt8 = function writeUInt84(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert)
    checkInt4(this, value, offset, 1, 255, 0);
  if (!Buffer7.TYPED_ARRAY_SUPPORT)
    value = Math.floor(value);
  this[offset] = value & 255;
  return offset + 1;
};
function objectWriteUInt16(buf, value, offset, littleEndian) {
  if (value < 0)
    value = 65535 + value + 1;
  for (var i = 0, j2 = Math.min(buf.length - offset, 2); i < j2; ++i) {
    buf[offset + i] = (value & 255 << 8 * (littleEndian ? i : 1 - i)) >>> (littleEndian ? i : 1 - i) * 8;
  }
}
Buffer7.prototype.writeUInt16LE = function writeUInt16LE4(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert)
    checkInt4(this, value, offset, 2, 65535, 0);
  if (Buffer7.TYPED_ARRAY_SUPPORT) {
    this[offset] = value & 255;
    this[offset + 1] = value >>> 8;
  } else {
    objectWriteUInt16(this, value, offset, true);
  }
  return offset + 2;
};
Buffer7.prototype.writeUInt16BE = function writeUInt16BE4(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert)
    checkInt4(this, value, offset, 2, 65535, 0);
  if (Buffer7.TYPED_ARRAY_SUPPORT) {
    this[offset] = value >>> 8;
    this[offset + 1] = value & 255;
  } else {
    objectWriteUInt16(this, value, offset, false);
  }
  return offset + 2;
};
function objectWriteUInt32(buf, value, offset, littleEndian) {
  if (value < 0)
    value = 4294967295 + value + 1;
  for (var i = 0, j2 = Math.min(buf.length - offset, 4); i < j2; ++i) {
    buf[offset + i] = value >>> (littleEndian ? i : 3 - i) * 8 & 255;
  }
}
Buffer7.prototype.writeUInt32LE = function writeUInt32LE4(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert)
    checkInt4(this, value, offset, 4, 4294967295, 0);
  if (Buffer7.TYPED_ARRAY_SUPPORT) {
    this[offset + 3] = value >>> 24;
    this[offset + 2] = value >>> 16;
    this[offset + 1] = value >>> 8;
    this[offset] = value & 255;
  } else {
    objectWriteUInt32(this, value, offset, true);
  }
  return offset + 4;
};
Buffer7.prototype.writeUInt32BE = function writeUInt32BE4(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert)
    checkInt4(this, value, offset, 4, 4294967295, 0);
  if (Buffer7.TYPED_ARRAY_SUPPORT) {
    this[offset] = value >>> 24;
    this[offset + 1] = value >>> 16;
    this[offset + 2] = value >>> 8;
    this[offset + 3] = value & 255;
  } else {
    objectWriteUInt32(this, value, offset, false);
  }
  return offset + 4;
};
Buffer7.prototype.writeIntLE = function writeIntLE4(value, offset, byteLength22, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength22 - 1);
    checkInt4(this, value, offset, byteLength22, limit - 1, -limit);
  }
  var i = 0;
  var mul4 = 1;
  var sub3 = 0;
  this[offset] = value & 255;
  while (++i < byteLength22 && (mul4 *= 256)) {
    if (value < 0 && sub3 === 0 && this[offset + i - 1] !== 0) {
      sub3 = 1;
    }
    this[offset + i] = (value / mul4 >> 0) - sub3 & 255;
  }
  return offset + byteLength22;
};
Buffer7.prototype.writeIntBE = function writeIntBE4(value, offset, byteLength22, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength22 - 1);
    checkInt4(this, value, offset, byteLength22, limit - 1, -limit);
  }
  var i = byteLength22 - 1;
  var mul4 = 1;
  var sub3 = 0;
  this[offset + i] = value & 255;
  while (--i >= 0 && (mul4 *= 256)) {
    if (value < 0 && sub3 === 0 && this[offset + i + 1] !== 0) {
      sub3 = 1;
    }
    this[offset + i] = (value / mul4 >> 0) - sub3 & 255;
  }
  return offset + byteLength22;
};
Buffer7.prototype.writeInt8 = function writeInt84(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert)
    checkInt4(this, value, offset, 1, 127, -128);
  if (!Buffer7.TYPED_ARRAY_SUPPORT)
    value = Math.floor(value);
  if (value < 0)
    value = 255 + value + 1;
  this[offset] = value & 255;
  return offset + 1;
};
Buffer7.prototype.writeInt16LE = function writeInt16LE4(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert)
    checkInt4(this, value, offset, 2, 32767, -32768);
  if (Buffer7.TYPED_ARRAY_SUPPORT) {
    this[offset] = value & 255;
    this[offset + 1] = value >>> 8;
  } else {
    objectWriteUInt16(this, value, offset, true);
  }
  return offset + 2;
};
Buffer7.prototype.writeInt16BE = function writeInt16BE4(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert)
    checkInt4(this, value, offset, 2, 32767, -32768);
  if (Buffer7.TYPED_ARRAY_SUPPORT) {
    this[offset] = value >>> 8;
    this[offset + 1] = value & 255;
  } else {
    objectWriteUInt16(this, value, offset, false);
  }
  return offset + 2;
};
Buffer7.prototype.writeInt32LE = function writeInt32LE4(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert)
    checkInt4(this, value, offset, 4, 2147483647, -2147483648);
  if (Buffer7.TYPED_ARRAY_SUPPORT) {
    this[offset] = value & 255;
    this[offset + 1] = value >>> 8;
    this[offset + 2] = value >>> 16;
    this[offset + 3] = value >>> 24;
  } else {
    objectWriteUInt32(this, value, offset, true);
  }
  return offset + 4;
};
Buffer7.prototype.writeInt32BE = function writeInt32BE4(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert)
    checkInt4(this, value, offset, 4, 2147483647, -2147483648);
  if (value < 0)
    value = 4294967295 + value + 1;
  if (Buffer7.TYPED_ARRAY_SUPPORT) {
    this[offset] = value >>> 24;
    this[offset + 1] = value >>> 16;
    this[offset + 2] = value >>> 8;
    this[offset + 3] = value & 255;
  } else {
    objectWriteUInt32(this, value, offset, false);
  }
  return offset + 4;
};
function checkIEEE754(buf, value, offset, ext, max2, min4) {
  if (offset + ext > buf.length)
    throw new RangeError("Index out of range");
  if (offset < 0)
    throw new RangeError("Index out of range");
}
function writeFloat(buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 4);
  }
  write4(buf, value, offset, littleEndian, 23, 4);
  return offset + 4;
}
Buffer7.prototype.writeFloatLE = function writeFloatLE4(value, offset, noAssert) {
  return writeFloat(this, value, offset, true, noAssert);
};
Buffer7.prototype.writeFloatBE = function writeFloatBE4(value, offset, noAssert) {
  return writeFloat(this, value, offset, false, noAssert);
};
function writeDouble(buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 8);
  }
  write4(buf, value, offset, littleEndian, 52, 8);
  return offset + 8;
}
Buffer7.prototype.writeDoubleLE = function writeDoubleLE4(value, offset, noAssert) {
  return writeDouble(this, value, offset, true, noAssert);
};
Buffer7.prototype.writeDoubleBE = function writeDoubleBE4(value, offset, noAssert) {
  return writeDouble(this, value, offset, false, noAssert);
};
Buffer7.prototype.copy = function copy7(target, targetStart, start, end) {
  if (!start)
    start = 0;
  if (!end && end !== 0)
    end = this.length;
  if (targetStart >= target.length)
    targetStart = target.length;
  if (!targetStart)
    targetStart = 0;
  if (end > 0 && end < start)
    end = start;
  if (end === start)
    return 0;
  if (target.length === 0 || this.length === 0)
    return 0;
  if (targetStart < 0) {
    throw new RangeError("targetStart out of bounds");
  }
  if (start < 0 || start >= this.length)
    throw new RangeError("sourceStart out of bounds");
  if (end < 0)
    throw new RangeError("sourceEnd out of bounds");
  if (end > this.length)
    end = this.length;
  if (target.length - targetStart < end - start) {
    end = target.length - targetStart + start;
  }
  var len = end - start;
  var i;
  if (this === target && start < targetStart && targetStart < end) {
    for (i = len - 1; i >= 0; --i) {
      target[i + targetStart] = this[i + start];
    }
  } else if (len < 1e3 || !Buffer7.TYPED_ARRAY_SUPPORT) {
    for (i = 0; i < len; ++i) {
      target[i + targetStart] = this[i + start];
    }
  } else {
    Uint8Array.prototype.set.call(target, this.subarray(start, start + len), targetStart);
  }
  return len;
};
Buffer7.prototype.fill = function fill4(val, start, end, encoding) {
  if (typeof val === "string") {
    if (typeof start === "string") {
      encoding = start;
      start = 0;
      end = this.length;
    } else if (typeof end === "string") {
      encoding = end;
      end = this.length;
    }
    if (val.length === 1) {
      var code2 = val.charCodeAt(0);
      if (code2 < 256) {
        val = code2;
      }
    }
    if (encoding !== void 0 && typeof encoding !== "string") {
      throw new TypeError("encoding must be a string");
    }
    if (typeof encoding === "string" && !Buffer7.isEncoding(encoding)) {
      throw new TypeError("Unknown encoding: " + encoding);
    }
  } else if (typeof val === "number") {
    val = val & 255;
  }
  if (start < 0 || this.length < start || this.length < end) {
    throw new RangeError("Out of range index");
  }
  if (end <= start) {
    return this;
  }
  start = start >>> 0;
  end = end === void 0 ? this.length : end >>> 0;
  if (!val)
    val = 0;
  var i;
  if (typeof val === "number") {
    for (i = start; i < end; ++i) {
      this[i] = val;
    }
  } else {
    var bytes = internalIsBuffer(val) ? val : utf8ToBytes4(new Buffer7(val, encoding).toString());
    var len = bytes.length;
    for (i = 0; i < end - start; ++i) {
      this[i + start] = bytes[i % len];
    }
  }
  return this;
};
var INVALID_BASE64_RE4 = /[^+\/0-9A-Za-z-_]/g;
function base64clean4(str) {
  str = stringtrim(str).replace(INVALID_BASE64_RE4, "");
  if (str.length < 2)
    return "";
  while (str.length % 4 !== 0) {
    str = str + "=";
  }
  return str;
}
function stringtrim(str) {
  if (str.trim)
    return str.trim();
  return str.replace(/^\s+|\s+$/g, "");
}
function toHex(n) {
  if (n < 16)
    return "0" + n.toString(16);
  return n.toString(16);
}
function utf8ToBytes4(string, units) {
  units = units || Infinity;
  var codePoint;
  var length = string.length;
  var leadSurrogate = null;
  var bytes = [];
  for (var i = 0; i < length; ++i) {
    codePoint = string.charCodeAt(i);
    if (codePoint > 55295 && codePoint < 57344) {
      if (!leadSurrogate) {
        if (codePoint > 56319) {
          if ((units -= 3) > -1)
            bytes.push(239, 191, 189);
          continue;
        } else if (i + 1 === length) {
          if ((units -= 3) > -1)
            bytes.push(239, 191, 189);
          continue;
        }
        leadSurrogate = codePoint;
        continue;
      }
      if (codePoint < 56320) {
        if ((units -= 3) > -1)
          bytes.push(239, 191, 189);
        leadSurrogate = codePoint;
        continue;
      }
      codePoint = (leadSurrogate - 55296 << 10 | codePoint - 56320) + 65536;
    } else if (leadSurrogate) {
      if ((units -= 3) > -1)
        bytes.push(239, 191, 189);
    }
    leadSurrogate = null;
    if (codePoint < 128) {
      if ((units -= 1) < 0)
        break;
      bytes.push(codePoint);
    } else if (codePoint < 2048) {
      if ((units -= 2) < 0)
        break;
      bytes.push(codePoint >> 6 | 192, codePoint & 63 | 128);
    } else if (codePoint < 65536) {
      if ((units -= 3) < 0)
        break;
      bytes.push(codePoint >> 12 | 224, codePoint >> 6 & 63 | 128, codePoint & 63 | 128);
    } else if (codePoint < 1114112) {
      if ((units -= 4) < 0)
        break;
      bytes.push(codePoint >> 18 | 240, codePoint >> 12 & 63 | 128, codePoint >> 6 & 63 | 128, codePoint & 63 | 128);
    } else {
      throw new Error("Invalid code point");
    }
  }
  return bytes;
}
function asciiToBytes4(str) {
  var byteArray = [];
  for (var i = 0; i < str.length; ++i) {
    byteArray.push(str.charCodeAt(i) & 255);
  }
  return byteArray;
}
function utf16leToBytes4(str, units) {
  var c5, hi2, lo3;
  var byteArray = [];
  for (var i = 0; i < str.length; ++i) {
    if ((units -= 2) < 0)
      break;
    c5 = str.charCodeAt(i);
    hi2 = c5 >> 8;
    lo3 = c5 % 256;
    byteArray.push(lo3);
    byteArray.push(hi2);
  }
  return byteArray;
}
function base64ToBytes4(str) {
  return toByteArray(base64clean4(str));
}
function blitBuffer4(src, dst, offset, length) {
  for (var i = 0; i < length; ++i) {
    if (i + offset >= dst.length || i >= src.length)
      break;
    dst[i + offset] = src[i];
  }
  return i;
}
function isnan(val) {
  return val !== val;
}
function isBuffer6(obj2) {
  return obj2 != null && (!!obj2._isBuffer || isFastBuffer(obj2) || isSlowBuffer(obj2));
}
function isFastBuffer(obj2) {
  return !!obj2.constructor && typeof obj2.constructor.isBuffer === "function" && obj2.constructor.isBuffer(obj2);
}
function isSlowBuffer(obj2) {
  return typeof obj2.readFloatLE === "function" && typeof obj2.slice === "function" && isFastBuffer(obj2.slice(0, 0));
}
var version2 = "1.0.0";
var encode15 = function encode22(buffer) {
  return buffer.toString("base64").replace(/\+/g, "-").replace(/\//g, "_").replace(/=+$/, "");
};
var decode12 = function decode22(base64) {
  base64 += Array(5 - base64.length % 4).join("=");
  base64 = base64.replace(/\-/g, "+").replace(/\_/g, "/");
  return new Buffer7(base64, "base64");
};
var validate = function validate2(base64) {
  return /^[A-Za-z0-9\-_]+$/.test(base64);
};
var urlsafeBase64 = {
  version: version2,
  encode: encode15,
  decode: decode12,
  validate
};
var urlsafeBase64$1 = urlsafeBase64;
var decode$1 = urlsafeBase64$1.decode;
var encode$1 = urlsafeBase64$1.encode;
var validate$1 = urlsafeBase64$1.validate;
var version$1 = urlsafeBase64$1.version;

// deno:file:///Users/mcharlton/OtherCode/deno-web-push/src/web-push-constants.ts
var WebPushConstants = {};
var supportedContentEncodings = {
  AES_GCM: "aesgcm",
  AES_128_GCM: "aes128gcm"
};
WebPushConstants.supportedContentEncodings = supportedContentEncodings;
var web_push_constants_default = WebPushConstants;

// deno:file:///Users/mcharlton/OtherCode/deno-web-push/src/vapid-helper.ts
var DEFAULT_EXPIRATION_SECONDS = 12 * 60 * 60;
var MAX_EXPIRATION_SECONDS = 24 * 60 * 60;
var ECPrivateKeyASN = ki.define("ECPrivateKey", function() {
  this.seq().obj(this.key("version").int(), this.key("privateKey").octstr(), this.key("parameters").explicit(0).objid().optional(), this.key("publicKey").explicit(1).bitstr().optional());
});
function toPEM(key2) {
  return ECPrivateKeyASN.encode({
    version: 1,
    privateKey: key2,
    parameters: [1, 2, 840, 10045, 3, 1, 7]
  }, "pem", {
    label: "EC PRIVATE KEY"
  });
}
function generateVAPIDKeys() {
  const curve = crypto_default2.createECDH("prime256v1");
  curve.generateKeys();
  let publicKeyBuffer = curve.getPublicKey();
  let privateKeyBuffer = curve.getPrivateKey();
  if (privateKeyBuffer.length < 32) {
    const padding = Buffer4.alloc(32 - privateKeyBuffer.length);
    padding.fill(0);
    privateKeyBuffer = Buffer4.concat([padding, privateKeyBuffer]);
  }
  if (publicKeyBuffer.length < 65) {
    const padding = Buffer4.alloc(65 - publicKeyBuffer.length);
    padding.fill(0);
    publicKeyBuffer = Buffer4.concat([padding, publicKeyBuffer]);
  }
  return {
    publicKey: encode$1(publicKeyBuffer),
    privateKey: encode$1(privateKeyBuffer)
  };
}
function validateSubject(subject) {
  if (!subject) {
    throw new Error("No subject set in vapidDetails.subject.");
  }
  if (typeof subject !== "string" || subject.length === 0) {
    throw new Error("The subject value must be a string containing a URL or mailto: address. " + subject);
  }
  if (subject.indexOf("mailto:") !== 0) {
    const subjectParseResult = parse9(subject, false, false);
    if (!subjectParseResult.hostname) {
      throw new Error("Vapid subject is not a url or mailto url. " + subject);
    }
  }
}
function validatePublicKey(publicKey) {
  if (!publicKey) {
    throw new Error("No key set vapidDetails.publicKey");
  }
  if (typeof publicKey !== "string") {
    throw new Error("Vapid public key is must be a URL safe Base 64 encoded string.");
  }
  if (!validate$1(publicKey)) {
    throw new Error('Vapid public key must be a URL safe Base 64 (without "=")');
  }
  publicKey = decode$1(publicKey);
  if (publicKey.length !== 65) {
    throw new Error("Vapid public key should be 65 bytes long when decoded.");
  }
}
function validatePrivateKey(privateKey) {
  if (!privateKey) {
    throw new Error("No key set in vapidDetails.privateKey");
  }
  if (typeof privateKey !== "string") {
    throw new Error("Vapid private key must be a URL safe Base 64 encoded string.");
  }
  if (!validate$1(privateKey)) {
    throw new Error('Vapid private key must be a URL safe Base 64 (without "=")');
  }
  privateKey = decode$1(privateKey);
  if (privateKey.length !== 32) {
    throw new Error("Vapid private key should be 32 bytes long when decoded.");
  }
}
function getFutureExpirationTimestamp(numSeconds) {
  const futureExp = new Date();
  futureExp.setSeconds(futureExp.getSeconds() + numSeconds);
  return Math.floor(futureExp.getTime() / 1e3);
}
function validateExpiration(expiration) {
  if (!Number.isInteger(expiration)) {
    throw new Error("`expiration` value must be a number");
  }
  if (expiration < 0) {
    throw new Error("`expiration` must be a positive integer");
  }
  const maxExpirationTimestamp = getFutureExpirationTimestamp(MAX_EXPIRATION_SECONDS);
  if (expiration >= maxExpirationTimestamp) {
    throw new Error("`expiration` value is greater than maximum of 24 hours");
  }
}
function getVapidHeaders(audience, subject, publicKey, privateKey, contentEncoding, expiration) {
  if (!audience) {
    throw new Error("No audience could be generated for VAPID.");
  }
  if (typeof audience !== "string" || audience.length === 0) {
    throw new Error("The audience value must be a string containing the origin of a push service. " + audience);
  }
  const audienceParseResult = parse9(audience, false, false);
  if (!audienceParseResult.hostname) {
    throw new Error("VAPID audience is not a url. " + audience);
  }
  validateSubject(subject);
  validatePublicKey(publicKey);
  validatePrivateKey(privateKey);
  if (expiration) {
    validateExpiration(expiration);
  } else {
    expiration = getFutureExpirationTimestamp(DEFAULT_EXPIRATION_SECONDS);
  }
  const header = {
    typ: "JWT",
    alg: "ES256"
  };
  const jwtPayload = {
    aud: audience,
    exp: expiration,
    sub: subject
  };
  const jwt = Fr2({
    header,
    payload: jwtPayload,
    privateKey: toPEM(privateKey)
  });
  if (contentEncoding === supportedContentEncodings.AES_128_GCM) {
    return {
      Authorization: "vapid t=" + jwt + ", k=" + publicKey
    };
  }
  if (contentEncoding === supportedContentEncodings.AES_GCM) {
    return {
      Authorization: "WebPush " + jwt,
      "Crypto-Key": "p256ecdsa=" + publicKey
    };
  }
  throw new Error("Unsupported encoding type specified.");
}

// deno:file:///Users/mcharlton/OtherCode/deno-web-push/src/ece.ts
var AES_GCM = "aes-128-gcm";
var PAD_SIZE = { aes128gcm: 1, aesgcm: 2 };
var TAG_LENGTH = 16;
var KEY_LENGTH = 16;
var NONCE_LENGTH = 12;
var SHA_256_LENGTH = 32;
var MODE_ENCRYPT = "encrypt";
var MODE_DECRYPT = "decrypt";
var keylog;
keylog = function(m3, k6) {
  return k6;
};
function decode13(b2) {
  if (typeof b2 === "string") {
    return decode$1(b2);
  }
  return b2;
}
function HMAC_hash(key2, input) {
  const hmac = crypto_default2.createHmac("sha256", key2);
  hmac.update(input);
  return hmac.digest();
}
function HKDF_extract(salt, ikm) {
  keylog("salt", salt);
  keylog("ikm", ikm);
  return keylog("extract", HMAC_hash(salt, ikm));
}
function HKDF_expand(prk, info2, l) {
  keylog("prk", prk);
  keylog("info", info2);
  let output = Buffer4.alloc(0);
  let T4 = Buffer4.alloc(0);
  info2 = Buffer4.from(info2, "ascii");
  let counter = 0;
  const cbuf = Buffer4.alloc(1);
  while (output.length < l) {
    cbuf.writeUIntBE(++counter, 0, 1);
    T4 = HMAC_hash(prk, Buffer4.concat([T4, info2, cbuf]));
    output = Buffer4.concat([output, T4]);
  }
  return keylog("expand", output.slice(0, l));
}
function HKDF(salt, ikm, info2, len) {
  return HKDF_expand(HKDF_extract(salt, ikm), info2, len);
}
function info(base3, context) {
  const result = Buffer4.concat([
    Buffer4.from("Content-Encoding: " + base3 + "\0", "ascii"),
    context
  ]);
  keylog("info " + base3, result);
  return result;
}
function lengthPrefix(buffer) {
  const b2 = Buffer4.concat([Buffer4.alloc(2), buffer]);
  b2.writeUIntBE(buffer.length, 0, 2);
  return b2;
}
function extractDH(header, mode) {
  const key2 = header.privateKey;
  let senderPubKey, receiverPubKey;
  if (mode === MODE_ENCRYPT) {
    senderPubKey = key2.getPublicKey();
    receiverPubKey = header.dh;
  } else if (mode === MODE_DECRYPT) {
    senderPubKey = header.dh;
    receiverPubKey = key2.getPublicKey();
  } else {
    throw new Error("Unknown mode only " + MODE_ENCRYPT + " and " + MODE_DECRYPT + " supported");
  }
  return {
    secret: key2.computeSecret(header.dh),
    context: Buffer4.concat([
      Buffer4.from(header.keylabel, "ascii"),
      Buffer4.from([0]),
      lengthPrefix(receiverPubKey),
      lengthPrefix(senderPubKey)
    ])
  };
}
function extractSecretAndContext(header, mode) {
  let result = { secret: null, context: Buffer4.alloc(0) };
  if (header.key) {
    result.secret = header.key;
    if (result.secret !== null && result.secret.length !== KEY_LENGTH) {
      throw new Error("An explicit key must be " + KEY_LENGTH + " bytes");
    }
  } else if (header.dh) {
    result = extractDH(header, mode);
  } else if (header.keyid !== void 0) {
    result.secret = header.keymap[header.keyid];
  }
  if (!result.secret) {
    throw new Error("Unable to determine key");
  }
  keylog("secret", result.secret);
  keylog("context", result.context);
  if (header.authSecret) {
    result.secret = HKDF(header.authSecret, result.secret, info("auth", Buffer4.alloc(0)), SHA_256_LENGTH);
    keylog("authsecret", result.secret);
  }
  return result;
}
function webpushSecret(header, mode) {
  if (!header.authSecret) {
    throw new Error("No authentication secret for webpush");
  }
  keylog("authsecret", header.authSecret);
  let remotePubKey, senderPubKey, receiverPubKey;
  if (mode === MODE_ENCRYPT) {
    senderPubKey = header.privateKey.getPublicKey();
    remotePubKey = receiverPubKey = header.dh;
  } else if (mode === MODE_DECRYPT) {
    remotePubKey = senderPubKey = header.keyid;
    receiverPubKey = header.privateKey.getPublicKey();
  } else {
    throw new Error("Unknown mode only " + MODE_ENCRYPT + " and " + MODE_DECRYPT + " supported");
  }
  keylog("remote pubkey", remotePubKey);
  keylog("sender pubkey", senderPubKey);
  keylog("receiver pubkey", receiverPubKey);
  return keylog("secret dh", HKDF(header.authSecret, header.privateKey.computeSecret(remotePubKey), Buffer4.concat([
    Buffer4.from("WebPush: info\0"),
    receiverPubKey,
    senderPubKey
  ]), SHA_256_LENGTH));
}
function extractSecret(header, mode, keyLookupCallback) {
  if (keyLookupCallback) {
    if (!isFunction3(keyLookupCallback)) {
      throw new Error("Callback is not a function");
    }
  }
  if (header.key) {
    if (header.key.length !== KEY_LENGTH) {
      throw new Error("An explicit key must be " + KEY_LENGTH + " bytes");
    }
    return keylog("secret key", header.key);
  }
  if (!header.privateKey) {
    let key2;
    if (!keyLookupCallback) {
      key2 = header.keymap && header.keymap[header.keyid];
    } else {
      key2 = keyLookupCallback(header.keyid);
    }
    if (!key2) {
      throw new Error('No saved key (keyid: "' + header.keyid + '")');
    }
    return key2;
  }
  return webpushSecret(header, mode);
}
function deriveKeyAndNonce(header, mode, lookupKeyCallback) {
  if (!header.salt) {
    throw new Error("must include a salt parameter for " + header.version);
  }
  let keyInfo;
  let nonceInfo;
  let secret;
  if (header.version === "aesgcm") {
    const s = extractSecretAndContext(header, mode, lookupKeyCallback);
    keyInfo = info("aesgcm", s.context);
    nonceInfo = info("nonce", s.context);
    secret = s.secret;
  } else if (header.version === "aes128gcm") {
    keyInfo = Buffer4.from("Content-Encoding: aes128gcm\0");
    nonceInfo = Buffer4.from("Content-Encoding: nonce\0");
    secret = extractSecret(header, mode, lookupKeyCallback);
  } else {
    throw new Error("Unable to set context for mode " + header.version);
  }
  const prk = HKDF_extract(header.salt, secret);
  const result = {
    key: HKDF_expand(prk, keyInfo, KEY_LENGTH),
    nonce: HKDF_expand(prk, nonceInfo, NONCE_LENGTH)
  };
  keylog("key", result.key);
  keylog("nonce base", result.nonce);
  return result;
}
function parseParams(params) {
  const header = {};
  header.version = params.version || "aes128gcm";
  header.rs = parseInt(params.rs, 10);
  if (isNaN(header.rs)) {
    header.rs = 4096;
  }
  let overhead = PAD_SIZE[header.version];
  if (header.version === "aes128gcm") {
    overhead += TAG_LENGTH;
  }
  if (header.rs <= overhead) {
    throw new Error("The rs parameter has to be greater than " + overhead);
  }
  if (params.salt) {
    header.salt = decode13(params.salt);
    if (header.salt.length !== KEY_LENGTH) {
      throw new Error("The salt parameter must be " + KEY_LENGTH + " bytes");
    }
  }
  header.keyid = params.keyid;
  if (params.key) {
    header.key = decode13(params.key);
  } else {
    header.privateKey = params.privateKey;
    if (!header.privateKey) {
      header.keymap = params.keymap;
    }
    if (header.version !== "aes128gcm") {
      header.keylabel = params.keylabel || "P-256";
    }
    if (params.dh) {
      header.dh = decode13(params.dh);
    }
  }
  if (params.authSecret) {
    header.authSecret = decode13(params.authSecret);
  }
  return header;
}
function generateNonce(base3, counter) {
  const nonce = Buffer4.from(base3);
  const m3 = nonce.readUIntBE(nonce.length - 6, 6);
  const x = ((m3 ^ counter) & 16777215) + ((m3 / 16777216 ^ counter / 16777216) & 16777215) * 16777216;
  nonce.writeUIntBE(x, nonce.length - 6, 6);
  keylog("nonce" + counter, nonce);
  return nonce;
}
function encryptRecord(key2, counter, buffer, pad3, header, last) {
  keylog("encrypt", buffer);
  pad3 = pad3 || 0;
  const nonce = generateNonce(key2.nonce, counter);
  const gcm = crypto_default2.createCipheriv(AES_GCM, key2.key, nonce);
  const ciphertext = [];
  const padSize = PAD_SIZE[header.version];
  const padding = Buffer4.alloc(pad3 + padSize);
  padding.fill(0);
  if (header.version !== "aes128gcm") {
    padding.writeUIntBE(pad3, 0, padSize);
    keylog("padding", padding);
    ciphertext.push(gcm.update(padding));
    ciphertext.push(gcm.update(buffer));
    if (!last && padding.length + buffer.length < header.rs) {
      throw new Error("Unable to pad to record size");
    }
  } else {
    ciphertext.push(gcm.update(buffer));
    padding.writeUIntBE(last ? 2 : 1, 0, 1);
    keylog("padding", padding);
    ciphertext.push(gcm.update(padding));
  }
  gcm.final();
  const tag2 = gcm.getAuthTag();
  if (tag2.length !== TAG_LENGTH) {
    throw new Error("invalid tag generated");
  }
  ciphertext.push(tag2);
  return keylog("encrypted", Buffer4.concat(ciphertext));
}
function writeHeader(header) {
  const ints = Buffer4.alloc(5);
  const keyid = Buffer4.from(header.keyid || []);
  if (keyid.length > 255) {
    throw new Error("keyid is too large");
  }
  ints.writeUIntBE(header.rs, 0, 4);
  ints.writeUIntBE(keyid.length, 4, 1);
  return Buffer4.concat([header.salt, ints, keyid]);
}
function encrypt8(buffer, params, keyLookupCallback) {
  if (!Buffer4.isBuffer(buffer)) {
    throw new Error("buffer argument must be a Buffer");
  }
  const header = parseParams(params);
  if (!header.salt) {
    header.salt = crypto_default2.randomBytes(KEY_LENGTH);
  }
  let result;
  if (header.version === "aes128gcm") {
    if (header.privateKey && !header.keyid) {
      header.keyid = header.privateKey.getPublicKey();
    }
    result = writeHeader(header);
  } else {
    result = Buffer4.alloc(0);
  }
  const key2 = deriveKeyAndNonce(header, MODE_ENCRYPT, keyLookupCallback);
  let start = 0;
  const padSize = PAD_SIZE[header.version];
  let overhead = padSize;
  if (header.version === "aes128gcm") {
    overhead += TAG_LENGTH;
  }
  let pad3 = isNaN(parseInt(params.pad, 10)) ? 0 : parseInt(params.pad, 10);
  let counter = 0;
  let last = false;
  while (!last) {
    let recordPad = Math.min(header.rs - overhead - 1, pad3);
    if (header.version !== "aes128gcm") {
      recordPad = Math.min((1 << padSize * 8) - 1, recordPad);
    }
    if (pad3 > 0 && recordPad === 0) {
      ++recordPad;
    }
    pad3 -= recordPad;
    const end = start + header.rs - overhead - recordPad;
    if (header.version !== "aes128gcm") {
      last = end > buffer.length;
    } else {
      last = end >= buffer.length;
    }
    last = last && pad3 <= 0;
    const block = encryptRecord(key2, counter, buffer.slice(start, end), recordPad, header, last);
    result = Buffer4.concat([result, block]);
    start = end;
    ++counter;
  }
  return result;
}
function isFunction3(object) {
  return typeof object === "function";
}

// deno:file:///Users/mcharlton/OtherCode/deno-web-push/src/encryption-helper.ts
var encrypt9 = function(userPublicKey, userAuth, payload, contentEncoding) {
  if (!userPublicKey) {
    throw new Error("No user public key provided for encryption.");
  }
  if (typeof userPublicKey !== "string") {
    throw new Error("The subscription p256dh value must be a string.");
  }
  if (decode$1(userPublicKey).length !== 65) {
    throw new Error("The subscription p256dh value should be 65 bytes long.");
  }
  if (!userAuth) {
    throw new Error("No user auth provided for encryption.");
  }
  if (typeof userAuth !== "string") {
    throw new Error("The subscription auth key must be a string.");
  }
  if (decode$1(userAuth).length < 16) {
    throw new Error("The subscription auth key should be at least 16 bytes long");
  }
  if (payload instanceof Uint8Array) {
    payload = new Buffer4(payload);
  }
  if (typeof payload !== "string" && !Buffer4.isBuffer(payload)) {
    throw new Error("Payload must be either a string or a Node Buffer.");
  }
  if (typeof payload === "string" || payload instanceof String) {
    payload = Buffer4.from(payload);
  }
  const localCurve = crypto_default2.createECDH("prime256v1");
  const localPublicKey = localCurve.generateKeys();
  const salt = encode$1(crypto_default2.randomBytes(16));
  const cipherText = encrypt8(payload, {
    version: contentEncoding,
    dh: userPublicKey,
    privateKey: localCurve,
    salt,
    authSecret: userAuth
  });
  return {
    localPublicKey,
    salt,
    cipherText
  };
};

// deno:file:///Users/mcharlton/OtherCode/deno-web-push/src/web-push-error.ts
function WebPushError(message, statusCode, headers, body, endpoint) {
  Error.captureStackTrace(this, this.constructor);
  this.name = this.constructor.name;
  this.message = message;
  this.statusCode = statusCode;
  this.headers = headers;
  this.body = body;
  this.endpoint = endpoint;
}
util_default2.inherits(WebPushError, Error);
var web_push_error_default = WebPushError;

// deno:file:///Users/mcharlton/OtherCode/deno-web-push/src/web-push-lib.ts
var DEFAULT_TTL = 2419200;
var gcmAPIKey = "";
var vapidDetails;
function WebPushLib() {
}
WebPushLib.prototype.setGCMAPIKey = function(apiKey) {
  if (apiKey === null) {
    gcmAPIKey = null;
    return;
  }
  if (typeof apiKey === "undefined" || typeof apiKey !== "string" || apiKey.length === 0) {
    throw new Error("The GCM API Key should be a non-empty string or null.");
  }
  gcmAPIKey = apiKey;
};
WebPushLib.prototype.setVapidDetails = function(subject, publicKey, privateKey) {
  if (arguments.length === 1 && arguments[0] === null) {
    vapidDetails = null;
    return;
  }
  validateSubject(subject);
  validatePublicKey(publicKey);
  validatePrivateKey(privateKey);
  vapidDetails = {
    subject,
    publicKey,
    privateKey
  };
};
WebPushLib.prototype.generateRequestDetails = async function(subscription, payload, options) {
  if (!subscription || !subscription.endpoint) {
    throw new Error("You must pass in a subscription with at least an endpoint.");
  }
  if (typeof subscription.endpoint !== "string" || subscription.endpoint.length === 0) {
    throw new Error("The subscription endpoint must be a string with a valid URL.");
  }
  if (payload) {
    if (typeof subscription !== "object" || !subscription.keys || !subscription.keys.p256dh || !subscription.keys.auth) {
      throw new Error("To send a message with a payload, the subscription must have 'auth' and 'p256dh' keys.");
    }
  }
  let currentGCMAPIKey = gcmAPIKey;
  let currentVapidDetails = vapidDetails;
  let timeToLive = DEFAULT_TTL;
  let extraHeaders = {};
  let contentEncoding = web_push_constants_default.supportedContentEncodings.AES_128_GCM;
  let proxy;
  let agent;
  let timeout;
  if (options) {
    const validOptionKeys = [
      "headers",
      "gcmAPIKey",
      "vapidDetails",
      "TTL",
      "contentEncoding",
      "proxy",
      "agent",
      "timeout"
    ];
    const optionKeys = Object.keys(options);
    for (let i = 0; i < optionKeys.length; i += 1) {
      const optionKey = optionKeys[i];
      if (validOptionKeys.indexOf(optionKey) === -1) {
        throw new Error("'" + optionKey + "' is an invalid option. The valid options are ['" + validOptionKeys.join("', '") + "'].");
      }
    }
    if (options.headers) {
      extraHeaders = options.headers;
      let duplicates = Object.keys(extraHeaders).filter(function(header) {
        return typeof options[header] !== "undefined";
      });
      if (duplicates.length > 0) {
        throw new Error("Duplicated headers defined [" + duplicates.join(",") + "]. Please either define the header in thetop level options OR in the 'headers' key.");
      }
    }
    if (options.gcmAPIKey) {
      currentGCMAPIKey = options.gcmAPIKey;
    }
    if (options.vapidDetails !== void 0) {
      currentVapidDetails = options.vapidDetails;
    }
    if (options.TTL !== void 0) {
      timeToLive = Number(options.TTL);
      if (timeToLive < 0) {
        throw new Error("TTL should be a number and should be at least 0");
      }
    }
    if (options.contentEncoding) {
      if (options.contentEncoding === web_push_constants_default.supportedContentEncodings.AES_128_GCM || options.contentEncoding === web_push_constants_default.supportedContentEncodings.AES_GCM) {
        contentEncoding = options.contentEncoding;
      } else {
        throw new Error("Unsupported content encoding specified.");
      }
    }
    if (options.proxy) {
      if (typeof options.proxy === "string" || typeof options.proxy.host === "string") {
        proxy = options.proxy;
      } else {
        console.warn("Attempt to use proxy option, but invalid type it should be a string or proxy options object.");
      }
    }
    if (typeof options.timeout === "number") {
      timeout = options.timeout;
    }
  }
  if (typeof timeToLive === "undefined") {
    timeToLive = DEFAULT_TTL;
  }
  const requestDetails = {
    method: "POST",
    headers: {
      TTL: timeToLive
    }
  };
  Object.keys(extraHeaders).forEach(function(header) {
    requestDetails.headers[header] = extraHeaders[header];
  });
  let requestPayload = null;
  if (payload) {
    const encrypted = encrypt9(subscription.keys.p256dh, subscription.keys.auth, payload, contentEncoding);
    requestDetails.headers["Content-Length"] = encrypted.cipherText.length;
    requestDetails.headers["Content-Type"] = "application/octet-stream";
    if (contentEncoding === web_push_constants_default.supportedContentEncodings.AES_128_GCM) {
      requestDetails.headers["Content-Encoding"] = web_push_constants_default.supportedContentEncodings.AES_128_GCM;
    } else if (contentEncoding === web_push_constants_default.supportedContentEncodings.AES_GCM) {
      requestDetails.headers["Content-Encoding"] = web_push_constants_default.supportedContentEncodings.AES_GCM;
      requestDetails.headers.Encryption = "salt=" + encrypted.salt;
      requestDetails.headers["Crypto-Key"] = "dh=" + encode$1(encrypted.localPublicKey);
    }
    requestPayload = encrypted.cipherText;
  } else {
    requestDetails.headers["Content-Length"] = 0;
  }
  const isGCM = subscription.endpoint.indexOf("https://android.googleapis.com/gcm/send") === 0;
  const isFCM = subscription.endpoint.indexOf("https://fcm.googleapis.com/fcm/send") === 0;
  if (isGCM) {
    if (!currentGCMAPIKey) {
      console.warn("Attempt to send push notification to GCM endpoint, but no GCM key is defined. Please use setGCMApiKey() or add 'gcmAPIKey' as an option.");
    } else {
      requestDetails.headers.Authorization = "key=" + currentGCMAPIKey;
    }
  } else if (currentVapidDetails) {
    const parsedUrl = parse9(subscription.endpoint, false, false);
    const audience = parsedUrl.protocol + "//" + parsedUrl.host;
    const vapidHeaders = getVapidHeaders(audience, currentVapidDetails.subject, currentVapidDetails.publicKey, currentVapidDetails.privateKey, contentEncoding);
    requestDetails.headers.Authorization = vapidHeaders.Authorization;
    if (contentEncoding === web_push_constants_default.supportedContentEncodings.AES_GCM) {
      if (requestDetails.headers["Crypto-Key"]) {
        requestDetails.headers["Crypto-Key"] += ";" + vapidHeaders["Crypto-Key"];
      } else {
        requestDetails.headers["Crypto-Key"] = vapidHeaders["Crypto-Key"];
      }
    }
  } else if (isFCM && currentGCMAPIKey) {
    requestDetails.headers.Authorization = "key=" + currentGCMAPIKey;
  }
  requestDetails.body = requestPayload;
  requestDetails.endpoint = subscription.endpoint;
  if (proxy) {
    requestDetails.proxy = proxy;
  }
  if (agent) {
    requestDetails.agent = agent;
  }
  if (timeout) {
    requestDetails.timeout = timeout;
  }
  return requestDetails;
};
WebPushLib.prototype.sendNotification = async function(subscription, payload, options) {
  let requestDetails;
  try {
    requestDetails = await this.generateRequestDetails(subscription, payload, options);
  } catch (err) {
    return Promise.reject(err);
  }
  return new Promise(async function(resolve7, reject) {
    const httpsOptions = {};
    const urlParts = parse9(requestDetails.endpoint, false, false);
    httpsOptions.hostname = urlParts.hostname;
    httpsOptions.port = urlParts.port;
    httpsOptions.path = urlParts.path;
    httpsOptions.headers = requestDetails.headers;
    httpsOptions.method = requestDetails.method;
    if (requestDetails.timeout) {
      httpsOptions.timeout = requestDetails.timeout;
    }
    if (requestDetails.agent) {
      httpsOptions.agent = requestDetails.agent;
    }
    if (requestDetails.body) {
      httpsOptions.body = requestDetails.body;
    }
    const pushResponse = await fetch(requestDetails.endpoint, httpsOptions).catch((e) => {
      reject(e);
    });
    if (pushResponse.statusCode < 200 || pushResponse.statusCode > 299) {
      reject(new web_push_error_default("Received unexpected response code", pushResponse.statusCode, pushResponse.headers, responseText, requestDetails.endpoint));
    } else {
      const responseText2 = await pushResponse.text();
      resolve7({
        statusCode: pushResponse.statusCode,
        body: responseText2,
        headers: pushResponse.headers
      });
    }
  });
};
var web_push_lib_default = WebPushLib;

// deno:file:///Users/mcharlton/OtherCode/deno-web-push/src/index.ts
var webPush = new web_push_lib_default();
var setGCMAPIKey = webPush.setGCMAPIKey;
var setVapidDetails = webPush.setVapidDetails;
var generateRequestDetails = webPush.generateRequestDetails;
var sendNotification = webPush.sendNotification;
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
 * @license  MIT
 */
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */
/*!
 * urlsafe-base64
 */
/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
/*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
